'use strict';

require('child_process');

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __require = /* @__PURE__ */ ((x2) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x2, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x2)(function(x2) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x2 + '" is not supported');
});
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@actions/core/lib/utils.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toCommandProperties = exports.toCommandValue = void 0;
    function toCommandValue(input) {
      if (input === null || input === void 0) {
        return "";
      } else if (typeof input === "string" || input instanceof String) {
        return input;
      }
      return JSON.stringify(input);
    }
    exports.toCommandValue = toCommandValue;
    function toCommandProperties(annotationProperties) {
      if (!Object.keys(annotationProperties).length) {
        return {};
      }
      return {
        title: annotationProperties.title,
        file: annotationProperties.file,
        line: annotationProperties.startLine,
        endLine: annotationProperties.endLine,
        col: annotationProperties.startColumn,
        endColumn: annotationProperties.endColumn
      };
    }
    exports.toCommandProperties = toCommandProperties;
  }
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS({
  "node_modules/@actions/core/lib/command.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.issue = exports.issueCommand = void 0;
    var os = __importStar(__require("os"));
    var utils_1 = require_utils();
    function issueCommand(command, properties, message) {
      const cmd = new Command(command, properties, message);
      process.stdout.write(cmd.toString() + os.EOL);
    }
    exports.issueCommand = issueCommand;
    function issue(name, message = "") {
      issueCommand(name, {}, message);
    }
    exports.issue = issue;
    var CMD_STRING = "::";
    var Command = class {
      constructor(command, properties, message) {
        if (!command) {
          command = "missing.command";
        }
        this.command = command;
        this.properties = properties;
        this.message = message;
      }
      toString() {
        let cmdStr = CMD_STRING + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          cmdStr += " ";
          let first = true;
          for (const key in this.properties) {
            if (this.properties.hasOwnProperty(key)) {
              const val = this.properties[key];
              if (val) {
                if (first) {
                  first = false;
                } else {
                  cmdStr += ",";
                }
                cmdStr += `${key}=${escapeProperty(val)}`;
              }
            }
          }
        }
        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
        return cmdStr;
      }
    };
    function escapeData(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(s) {
      return (0, utils_1.toCommandValue)(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS({
  "node_modules/@actions/core/lib/file-command.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.prepareKeyValueMessage = exports.issueFileCommand = void 0;
    var crypto = __importStar(__require("crypto"));
    var fs = __importStar(__require("fs"));
    var os = __importStar(__require("os"));
    var utils_1 = require_utils();
    function issueFileCommand(command, message) {
      const filePath = process.env[`GITHUB_${command}`];
      if (!filePath) {
        throw new Error(`Unable to find environment variable for file command ${command}`);
      }
      if (!fs.existsSync(filePath)) {
        throw new Error(`Missing file at path: ${filePath}`);
      }
      fs.appendFileSync(filePath, `${(0, utils_1.toCommandValue)(message)}${os.EOL}`, {
        encoding: "utf8"
      });
    }
    exports.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(key, value) {
      const delimiter = `ghadelimiter_${crypto.randomUUID()}`;
      const convertedValue = (0, utils_1.toCommandValue)(value);
      if (key.includes(delimiter)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${delimiter}"`);
      }
      if (convertedValue.includes(delimiter)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${delimiter}"`);
      }
      return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;
    }
    exports.prepareKeyValueMessage = prepareKeyValueMessage;
  }
});

// node_modules/@actions/http-client/lib/proxy.js
var require_proxy = __commonJS({
  "node_modules/@actions/http-client/lib/proxy.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkBypass = exports.getProxyUrl = void 0;
    function getProxyUrl(reqUrl) {
      const usingSsl = reqUrl.protocol === "https:";
      if (checkBypass(reqUrl)) {
        return void 0;
      }
      const proxyVar = (() => {
        if (usingSsl) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (proxyVar) {
        try {
          return new DecodedURL(proxyVar);
        } catch (_a) {
          if (!proxyVar.startsWith("http://") && !proxyVar.startsWith("https://"))
            return new DecodedURL(`http://${proxyVar}`);
        }
      } else {
        return void 0;
      }
    }
    exports.getProxyUrl = getProxyUrl;
    function checkBypass(reqUrl) {
      if (!reqUrl.hostname) {
        return false;
      }
      const reqHost = reqUrl.hostname;
      if (isLoopbackAddress(reqHost)) {
        return true;
      }
      const noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!noProxy) {
        return false;
      }
      let reqPort;
      if (reqUrl.port) {
        reqPort = Number(reqUrl.port);
      } else if (reqUrl.protocol === "http:") {
        reqPort = 80;
      } else if (reqUrl.protocol === "https:") {
        reqPort = 443;
      }
      const upperReqHosts = [reqUrl.hostname.toUpperCase()];
      if (typeof reqPort === "number") {
        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
      }
      for (const upperNoProxyItem of noProxy.split(",").map((x2) => x2.trim().toUpperCase()).filter((x2) => x2)) {
        if (upperNoProxyItem === "*" || upperReqHosts.some((x2) => x2 === upperNoProxyItem || x2.endsWith(`.${upperNoProxyItem}`) || upperNoProxyItem.startsWith(".") && x2.endsWith(`${upperNoProxyItem}`))) {
          return true;
        }
      }
      return false;
    }
    exports.checkBypass = checkBypass;
    function isLoopbackAddress(host) {
      const hostLower = host.toLowerCase();
      return hostLower === "localhost" || hostLower.startsWith("127.") || hostLower.startsWith("[::1]") || hostLower.startsWith("[0:0:0:0:0:0:0:1]");
    }
    var DecodedURL = class extends URL {
      constructor(url, base2) {
        super(url, base2);
        this._decodedUsername = decodeURIComponent(super.username);
        this._decodedPassword = decodeURIComponent(super.password);
      }
      get username() {
        return this._decodedUsername;
      }
      get password() {
        return this._decodedPassword;
      }
    };
  }
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "node_modules/tunnel/lib/tunnel.js"(exports) {
    __require("net");
    var tls = __require("tls");
    var http = __require("http");
    var https = __require("https");
    var events = __require("events");
    __require("assert");
    var util = __require("util");
    exports.httpOverHttp = httpOverHttp;
    exports.httpsOverHttp = httpsOverHttp;
    exports.httpOverHttps = httpOverHttps;
    exports.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug2("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug2(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug2("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        debug2("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug2(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys = Object.keys(overrides);
          for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
            var k2 = keys[j];
            if (overrides[k2] !== void 0) {
              target[k2] = overrides[k2];
            }
          }
        }
      }
      return target;
    }
    var debug2;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug2 = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug2 = function() {
      };
    }
    exports.debug = debug2;
  }
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "node_modules/tunnel/index.js"(exports, module) {
    module.exports = require_tunnel();
  }
});

// node_modules/undici/lib/core/symbols.js
var require_symbols = __commonJS({
  "node_modules/undici/lib/core/symbols.js"(exports, module) {
    module.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable")
    };
  }
});

// node_modules/undici/lib/core/errors.js
var require_errors = __commonJS({
  "node_modules/undici/lib/core/errors.js"(exports, module) {
    var UndiciError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    };
    var ConnectTimeoutError = class _ConnectTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = message || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    };
    var HeadersTimeoutError = class _HeadersTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = message || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    };
    var HeadersOverflowError = class _HeadersOverflowError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = message || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    };
    var BodyTimeoutError = class _BodyTimeoutError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = message || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    };
    var ResponseStatusCodeError = class _ResponseStatusCodeError extends UndiciError {
      constructor(message, statusCode, headers, body) {
        super(message);
        Error.captureStackTrace(this, _ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = message || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = body;
        this.status = statusCode;
        this.statusCode = statusCode;
        this.headers = headers;
      }
    };
    var InvalidArgumentError = class _InvalidArgumentError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = message || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    };
    var InvalidReturnValueError = class _InvalidReturnValueError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = message || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    };
    var RequestAbortedError = class _RequestAbortedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestAbortedError);
        this.name = "AbortError";
        this.message = message || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    };
    var InformationalError = class _InformationalError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _InformationalError);
        this.name = "InformationalError";
        this.message = message || "Request information";
        this.code = "UND_ERR_INFO";
      }
    };
    var RequestContentLengthMismatchError = class _RequestContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = message || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ResponseContentLengthMismatchError = class _ResponseContentLengthMismatchError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = message || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    };
    var ClientDestroyedError = class _ClientDestroyedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = message || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    };
    var ClientClosedError = class _ClientClosedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ClientClosedError);
        this.name = "ClientClosedError";
        this.message = message || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    };
    var SocketError = class _SocketError extends UndiciError {
      constructor(message, socket) {
        super(message);
        Error.captureStackTrace(this, _SocketError);
        this.name = "SocketError";
        this.message = message || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = socket;
      }
    };
    var NotSupportedError = class _NotSupportedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _NotSupportedError);
        this.name = "NotSupportedError";
        this.message = message || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    };
    var BalancedPoolMissingUpstreamError = class extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = message || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    };
    var HTTPParserError = class _HTTPParserError extends Error {
      constructor(message, code, data) {
        super(message);
        Error.captureStackTrace(this, _HTTPParserError);
        this.name = "HTTPParserError";
        this.code = code ? `HPE_${code}` : void 0;
        this.data = data ? data.toString() : void 0;
      }
    };
    var ResponseExceededMaxSizeError = class _ResponseExceededMaxSizeError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = message || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    };
    var RequestRetryError = class _RequestRetryError extends UndiciError {
      constructor(message, code, { headers, data }) {
        super(message);
        Error.captureStackTrace(this, _RequestRetryError);
        this.name = "RequestRetryError";
        this.message = message || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = code;
        this.data = data;
        this.headers = headers;
      }
    };
    module.exports = {
      HTTPParserError,
      UndiciError,
      HeadersTimeoutError,
      HeadersOverflowError,
      BodyTimeoutError,
      RequestContentLengthMismatchError,
      ConnectTimeoutError,
      ResponseStatusCodeError,
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError,
      ClientDestroyedError,
      ClientClosedError,
      InformationalError,
      SocketError,
      NotSupportedError,
      ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError,
      RequestRetryError
    };
  }
});

// node_modules/undici/lib/core/constants.js
var require_constants = __commonJS({
  "node_modules/undici/lib/core/constants.js"(exports, module) {
    var headerNameLowerCasedRecord = {};
    var wellknownHeaderNames = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection"
    ];
    for (let i = 0; i < wellknownHeaderNames.length; ++i) {
      const key = wellknownHeaderNames[i];
      const lowerCasedKey = key.toLowerCase();
      headerNameLowerCasedRecord[key] = headerNameLowerCasedRecord[lowerCasedKey] = lowerCasedKey;
    }
    Object.setPrototypeOf(headerNameLowerCasedRecord, null);
    module.exports = {
      wellknownHeaderNames,
      headerNameLowerCasedRecord
    };
  }
});

// node_modules/undici/lib/core/util.js
var require_util = __commonJS({
  "node_modules/undici/lib/core/util.js"(exports, module) {
    var assert = __require("assert");
    var { kDestroyed, kBodyUsed } = require_symbols();
    var { IncomingMessage } = __require("http");
    var stream = __require("stream");
    var net = __require("net");
    var { InvalidArgumentError } = require_errors();
    var { Blob: Blob2 } = __require("buffer");
    var nodeUtil = __require("util");
    var { stringify } = __require("querystring");
    var { headerNameLowerCasedRecord } = require_constants();
    var [nodeMajor, nodeMinor] = process.versions.node.split(".").map((v) => Number(v));
    function nop() {
    }
    function isStream(obj) {
      return obj && typeof obj === "object" && typeof obj.pipe === "function" && typeof obj.on === "function";
    }
    function isBlobLike(object) {
      return Blob2 && object instanceof Blob2 || object && typeof object === "object" && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && /^(Blob|File)$/.test(object[Symbol.toStringTag]);
    }
    function buildURL(url, queryParams) {
      if (url.includes("?") || url.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const stringified = stringify(queryParams);
      if (stringified) {
        url += "?" + stringified;
      }
      return url;
    }
    function parseURL(url) {
      if (typeof url === "string") {
        url = new URL(url);
        if (!/^https?:/.test(url.origin || url.protocol)) {
          throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return url;
      }
      if (!url || typeof url !== "object") {
        throw new InvalidArgumentError("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(url.origin || url.protocol)) {
        throw new InvalidArgumentError("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(url instanceof URL)) {
        if (url.port != null && url.port !== "" && !Number.isFinite(parseInt(url.port))) {
          throw new InvalidArgumentError("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (url.path != null && typeof url.path !== "string") {
          throw new InvalidArgumentError("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (url.pathname != null && typeof url.pathname !== "string") {
          throw new InvalidArgumentError("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (url.hostname != null && typeof url.hostname !== "string") {
          throw new InvalidArgumentError("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (url.origin != null && typeof url.origin !== "string") {
          throw new InvalidArgumentError("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const port = url.port != null ? url.port : url.protocol === "https:" ? 443 : 80;
        let origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
        let path = url.path != null ? url.path : `${url.pathname || ""}${url.search || ""}`;
        if (origin.endsWith("/")) {
          origin = origin.substring(0, origin.length - 1);
        }
        if (path && !path.startsWith("/")) {
          path = `/${path}`;
        }
        url = new URL(origin + path);
      }
      return url;
    }
    function parseOrigin(url) {
      url = parseURL(url);
      if (url.pathname !== "/" || url.search || url.hash) {
        throw new InvalidArgumentError("invalid url");
      }
      return url;
    }
    function getHostname(host) {
      if (host[0] === "[") {
        const idx2 = host.indexOf("]");
        assert(idx2 !== -1);
        return host.substring(1, idx2);
      }
      const idx = host.indexOf(":");
      if (idx === -1) return host;
      return host.substring(0, idx);
    }
    function getServerName(host) {
      if (!host) {
        return null;
      }
      assert.strictEqual(typeof host, "string");
      const servername = getHostname(host);
      if (net.isIP(servername)) {
        return "";
      }
      return servername;
    }
    function deepClone(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function isAsyncIterable(obj) {
      return !!(obj != null && typeof obj[Symbol.asyncIterator] === "function");
    }
    function isIterable(obj) {
      return !!(obj != null && (typeof obj[Symbol.iterator] === "function" || typeof obj[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(body) {
      if (body == null) {
        return 0;
      } else if (isStream(body)) {
        const state = body._readableState;
        return state && state.objectMode === false && state.ended === true && Number.isFinite(state.length) ? state.length : null;
      } else if (isBlobLike(body)) {
        return body.size != null ? body.size : null;
      } else if (isBuffer(body)) {
        return body.byteLength;
      }
      return null;
    }
    function isDestroyed(stream2) {
      return !stream2 || !!(stream2.destroyed || stream2[kDestroyed]);
    }
    function isReadableAborted(stream2) {
      const state = stream2 && stream2._readableState;
      return isDestroyed(stream2) && state && !state.endEmitted;
    }
    function destroy(stream2, err) {
      if (stream2 == null || !isStream(stream2) || isDestroyed(stream2)) {
        return;
      }
      if (typeof stream2.destroy === "function") {
        if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
          stream2.socket = null;
        }
        stream2.destroy(err);
      } else if (err) {
        process.nextTick((stream3, err2) => {
          stream3.emit("error", err2);
        }, stream2, err);
      }
      if (stream2.destroyed !== true) {
        stream2[kDestroyed] = true;
      }
    }
    var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
    function parseKeepAliveTimeout(val) {
      const m = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
      return m ? parseInt(m[1], 10) * 1e3 : null;
    }
    function headerNameToString(value) {
      return headerNameLowerCasedRecord[value] || value.toLowerCase();
    }
    function parseHeaders(headers, obj = {}) {
      if (!Array.isArray(headers)) return headers;
      for (let i = 0; i < headers.length; i += 2) {
        const key = headers[i].toString().toLowerCase();
        let val = obj[key];
        if (!val) {
          if (Array.isArray(headers[i + 1])) {
            obj[key] = headers[i + 1].map((x2) => x2.toString("utf8"));
          } else {
            obj[key] = headers[i + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(val)) {
            val = [val];
            obj[key] = val;
          }
          val.push(headers[i + 1].toString("utf8"));
        }
      }
      if ("content-length" in obj && "content-disposition" in obj) {
        obj["content-disposition"] = Buffer.from(obj["content-disposition"]).toString("latin1");
      }
      return obj;
    }
    function parseRawHeaders(headers) {
      const ret = [];
      let hasContentLength = false;
      let contentDispositionIdx = -1;
      for (let n = 0; n < headers.length; n += 2) {
        const key = headers[n + 0].toString();
        const val = headers[n + 1].toString("utf8");
        if (key.length === 14 && (key === "content-length" || key.toLowerCase() === "content-length")) {
          ret.push(key, val);
          hasContentLength = true;
        } else if (key.length === 19 && (key === "content-disposition" || key.toLowerCase() === "content-disposition")) {
          contentDispositionIdx = ret.push(key, val) - 1;
        } else {
          ret.push(key, val);
        }
      }
      if (hasContentLength && contentDispositionIdx !== -1) {
        ret[contentDispositionIdx] = Buffer.from(ret[contentDispositionIdx]).toString("latin1");
      }
      return ret;
    }
    function isBuffer(buffer) {
      return buffer instanceof Uint8Array || Buffer.isBuffer(buffer);
    }
    function validateHandler(handler, method, upgrade) {
      if (!handler || typeof handler !== "object") {
        throw new InvalidArgumentError("handler must be an object");
      }
      if (typeof handler.onConnect !== "function") {
        throw new InvalidArgumentError("invalid onConnect method");
      }
      if (typeof handler.onError !== "function") {
        throw new InvalidArgumentError("invalid onError method");
      }
      if (typeof handler.onBodySent !== "function" && handler.onBodySent !== void 0) {
        throw new InvalidArgumentError("invalid onBodySent method");
      }
      if (upgrade || method === "CONNECT") {
        if (typeof handler.onUpgrade !== "function") {
          throw new InvalidArgumentError("invalid onUpgrade method");
        }
      } else {
        if (typeof handler.onHeaders !== "function") {
          throw new InvalidArgumentError("invalid onHeaders method");
        }
        if (typeof handler.onData !== "function") {
          throw new InvalidArgumentError("invalid onData method");
        }
        if (typeof handler.onComplete !== "function") {
          throw new InvalidArgumentError("invalid onComplete method");
        }
      }
    }
    function isDisturbed(body) {
      return !!(body && (stream.isDisturbed ? stream.isDisturbed(body) || body[kBodyUsed] : body[kBodyUsed] || body.readableDidRead || body._readableState && body._readableState.dataEmitted || isReadableAborted(body)));
    }
    function isErrored(body) {
      return !!(body && (stream.isErrored ? stream.isErrored(body) : /state: 'errored'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function isReadable(body) {
      return !!(body && (stream.isReadable ? stream.isReadable(body) : /state: 'readable'/.test(
        nodeUtil.inspect(body)
      )));
    }
    function getSocketInfo(socket) {
      return {
        localAddress: socket.localAddress,
        localPort: socket.localPort,
        remoteAddress: socket.remoteAddress,
        remotePort: socket.remotePort,
        remoteFamily: socket.remoteFamily,
        timeout: socket.timeout,
        bytesWritten: socket.bytesWritten,
        bytesRead: socket.bytesRead
      };
    }
    async function* convertIterableToBuffer(iterable) {
      for await (const chunk of iterable) {
        yield Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk);
      }
    }
    var ReadableStream;
    function ReadableStreamFrom(iterable) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      if (ReadableStream.from) {
        return ReadableStream.from(convertIterableToBuffer(iterable));
      }
      let iterator;
      return new ReadableStream(
        {
          async start() {
            iterator = iterable[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
              controller.enqueue(new Uint8Array(buf));
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          }
        },
        0
      );
    }
    function isFormDataLike(object) {
      return object && typeof object === "object" && typeof object.append === "function" && typeof object.delete === "function" && typeof object.get === "function" && typeof object.getAll === "function" && typeof object.has === "function" && typeof object.set === "function" && object[Symbol.toStringTag] === "FormData";
    }
    function throwIfAborted(signal) {
      if (!signal) {
        return;
      }
      if (typeof signal.throwIfAborted === "function") {
        signal.throwIfAborted();
      } else {
        if (signal.aborted) {
          const err = new Error("The operation was aborted");
          err.name = "AbortError";
          throw err;
        }
      }
    }
    function addAbortListener(signal, listener) {
      if ("addEventListener" in signal) {
        signal.addEventListener("abort", listener, { once: true });
        return () => signal.removeEventListener("abort", listener);
      }
      signal.addListener("abort", listener);
      return () => signal.removeListener("abort", listener);
    }
    var hasToWellFormed = !!String.prototype.toWellFormed;
    function toUSVString(val) {
      if (hasToWellFormed) {
        return `${val}`.toWellFormed();
      } else if (nodeUtil.toUSVString) {
        return nodeUtil.toUSVString(val);
      }
      return `${val}`;
    }
    function parseRangeHeader(range) {
      if (range == null || range === "") return { start: 0, end: null, size: null };
      const m = range ? range.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return m ? {
        start: parseInt(m[1]),
        end: m[2] ? parseInt(m[2]) : null,
        size: m[3] ? parseInt(m[3]) : null
      } : null;
    }
    var kEnumerableProperty = /* @__PURE__ */ Object.create(null);
    kEnumerableProperty.enumerable = true;
    module.exports = {
      kEnumerableProperty,
      nop,
      isDisturbed,
      isErrored,
      isReadable,
      toUSVString,
      isReadableAborted,
      isBlobLike,
      parseOrigin,
      parseURL,
      getServerName,
      isStream,
      isIterable,
      isAsyncIterable,
      isDestroyed,
      headerNameToString,
      parseRawHeaders,
      parseHeaders,
      parseKeepAliveTimeout,
      destroy,
      bodyLength,
      deepClone,
      ReadableStreamFrom,
      isBuffer,
      validateHandler,
      getSocketInfo,
      isFormDataLike,
      buildURL,
      throwIfAborted,
      addAbortListener,
      parseRangeHeader,
      nodeMajor,
      nodeMinor,
      nodeHasAutoSelectFamily: nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 13,
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
    };
  }
});

// node_modules/undici/lib/timers.js
var require_timers = __commonJS({
  "node_modules/undici/lib/timers.js"(exports, module) {
    var fastNow = Date.now();
    var fastNowTimeout;
    var fastTimers = [];
    function onTimeout() {
      fastNow = Date.now();
      let len = fastTimers.length;
      let idx = 0;
      while (idx < len) {
        const timer = fastTimers[idx];
        if (timer.state === 0) {
          timer.state = fastNow + timer.delay;
        } else if (timer.state > 0 && fastNow >= timer.state) {
          timer.state = -1;
          timer.callback(timer.opaque);
        }
        if (timer.state === -1) {
          timer.state = -2;
          if (idx !== len - 1) {
            fastTimers[idx] = fastTimers.pop();
          } else {
            fastTimers.pop();
          }
          len -= 1;
        } else {
          idx += 1;
        }
      }
      if (fastTimers.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (fastNowTimeout && fastNowTimeout.refresh) {
        fastNowTimeout.refresh();
      } else {
        clearTimeout(fastNowTimeout);
        fastNowTimeout = setTimeout(onTimeout, 1e3);
        if (fastNowTimeout.unref) {
          fastNowTimeout.unref();
        }
      }
    }
    var Timeout = class {
      constructor(callback, delay, opaque) {
        this.callback = callback;
        this.delay = delay;
        this.opaque = opaque;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          fastTimers.push(this);
          if (!fastNowTimeout || fastTimers.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    };
    module.exports = {
      setTimeout(callback, delay, opaque) {
        return delay < 1e3 ? setTimeout(callback, delay, opaque) : new Timeout(callback, delay, opaque);
      },
      clearTimeout(timeout) {
        if (timeout instanceof Timeout) {
          timeout.clear();
        } else {
          clearTimeout(timeout);
        }
      }
    };
  }
});

// node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
    var EventEmitter = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLength);
      for (var i = 0; i < needleLength - 1; ++i) {
        this._occ[needle[i]] = needleLength - 1 - i;
      }
    }
    inherits(SBMH, EventEmitter);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const lastNeedleChar = needle[needleLength - 1];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLength - 1);
          if (ch === lastNeedleChar && this._sbmh_memcmp(data, pos, needleLength - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        if (pos < 0) {
          while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
            ++pos;
          }
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind.copy(
            this._lookbehind,
            0,
            bytesToCutOff,
            this._lookbehind_size - bytesToCutOff
          );
          this._lookbehind_size -= bytesToCutOff;
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos += (pos >= 0) * this._bufpos;
      if (data.indexOf(needle, pos) !== -1) {
        pos = data.indexOf(needle, pos);
        ++this.matches;
        if (pos > 0) {
          this.emit("info", true, data, this._bufpos, pos);
        } else {
          this.emit("info", true);
        }
        return this._bufpos = pos + needleLength;
      } else {
        pos = len - needleLength;
      }
      while (pos < len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos, pos + len - pos),
        needle.subarray(0, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos < len) {
        data.copy(this._lookbehind, 0, pos, pos + (len - pos));
        this._lookbehind_size = len - pos;
      }
      if (pos > 0) {
        this.emit("info", false, data, this._bufpos, pos < len ? pos : len);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module.exports = SBMH;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
    var inherits = __require("util").inherits;
    var ReadableStream = __require("stream").Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    inherits(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module.exports = PartStream;
  }
});

// node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
    module.exports = function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    };
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
    var EventEmitter = __require("events").EventEmitter;
    var inherits = __require("util").inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter.call(this);
      cfg = cfg || {};
      const self2 = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self2.maxed) {
          if (self2.nread + end - start >= self2.maxHeaderSize) {
            end = self2.maxHeaderSize - self2.nread + start;
            self2.nread = self2.maxHeaderSize;
            self2.maxed = true;
          } else {
            self2.nread += end - start;
          }
          self2.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self2._finish();
        }
      });
    }
    inherits(HeaderParser, EventEmitter);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m = RE_HDR.exec(lines[i]);
        h = m[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module.exports = HeaderParser;
  }
});

// node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
    var WritableStream = __require("stream").Writable;
    var inherits = __require("util").inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = function() {
    };
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self2 = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self2._inHeader = false;
        self2._part.emit("header", header);
      });
    }
    inherits(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self2 = this;
          process.nextTick(function() {
            self2.emit("error", new Error("Unexpected end of multipart data"));
            if (self2._part && !self2._ignoreData) {
              const type = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type + " terminated early due to unexpected end of multipart data"));
              self2._part.push(null);
              process.nextTick(function() {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              });
              return;
            }
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self2 = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self2._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self2 = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self2._parts === 0) {
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self2._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self2._parts === 0) {
                if (self2._finished) {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                } else {
                  self2._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module.exports = Dicer;
  }
});

// node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    var decoders = {
      utf8: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      },
      latin1: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      },
      utf16le: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      },
      base64: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      },
      other: (data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports.toString())) {
          try {
            return textDecoders.get(exports).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    module.exports = decodeText;
  }
});

// node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p] === void 0) {
              res[p] = tmp;
            } else {
              res[p][1] = tmp;
            }
            tmp = "";
            ++p;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p] === void 0) {
        if (tmp) {
          res[p] = tmp;
        }
      } else {
        res[p][1] = tmp;
      }
      return res;
    }
    module.exports = parseParams;
  }
});

// node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
    module.exports = function basename(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          // '/'
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    };
  }
});

// node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
    var { Readable } = __require("stream");
    var { inherits } = __require("util");
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self2 = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self2.end();
        }
      }
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self2._needDrain = false;
        if (self2._cb && !self2._pause) {
          const cb = self2._cb;
          self2._cb = void 0;
          cb();
        }
      }).on("part", function onPart(part) {
        if (++self2._nparts > partsLimit) {
          self2.parser.removeListener("part", onPart);
          self2.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self2._pause = false;
              checkFinished();
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self2._pause) {
                return;
              }
              self2._pause = false;
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self2._pause = true;
              }
              file.bytesRead = nsize;
            };
            onEnd = function() {
              curFile = void 0;
              file.push(null);
            };
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            };
            onEnd = function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            };
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self2 = this;
      if (self2.parser.writable) {
        self2.parser.end();
      } else if (!self2._boy._done) {
        process.nextTick(function() {
          self2._boy._done = true;
          self2._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    function FileStream(opts) {
      Readable.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    inherits(FileStream, Readable);
    FileStream.prototype._read = function(n) {
    };
    module.exports = Multipart;
  }
});

// node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p) {
            res += str.substring(p, i);
            p = i;
          }
          this.buffer = "";
          ++p;
        }
      }
      if (p < len && this.buffer === void 0) {
        res += str.substring(p);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module.exports = Decoder;
  }
});

// node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p = 0;
      const len = data.length;
      while (p < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p) {
              this._key += this.decoder.write(data.toString("binary", p, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p) {
              key = this._key += this.decoder.write(data.toString("binary", p, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._key += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p < len) {
              this._key += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        } else {
          idxamp = void 0;
          for (i = p; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p) {
              this._val += this.decoder.write(data.toString("binary", p, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p) {
              this._val += this.decoder.write(data.toString("binary", p, i));
            }
            p = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p < len) {
              this._val += this.decoder.write(data.toString("binary", p));
            }
            p = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module.exports = UrlEncoded;
  }
});

// node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/@fastify/busboy/lib/main.js"(exports, module) {
    var WritableStream = __require("stream").Writable;
    var { inherits } = __require("util");
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    inherits(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module.exports = Busboy;
    module.exports.default = Busboy;
    module.exports.Busboy = Busboy;
    module.exports.Dicer = Dicer;
  }
});

// node_modules/undici/lib/fetch/constants.js
var require_constants2 = __commonJS({
  "node_modules/undici/lib/fetch/constants.js"(exports, module) {
    var { MessageChannel, receiveMessageOnPort } = __require("worker_threads");
    var corsSafeListedMethods = ["GET", "HEAD", "POST"];
    var corsSafeListedMethodsSet = new Set(corsSafeListedMethods);
    var nullBodyStatus = [101, 204, 205, 304];
    var redirectStatus = [301, 302, 303, 307, 308];
    var redirectStatusSet = new Set(redirectStatus);
    var badPorts = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080"
    ];
    var badPortsSet = new Set(badPorts);
    var referrerPolicy = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url"
    ];
    var referrerPolicySet = new Set(referrerPolicy);
    var requestRedirect = ["follow", "manual", "error"];
    var safeMethods = ["GET", "HEAD", "OPTIONS", "TRACE"];
    var safeMethodsSet = new Set(safeMethods);
    var requestMode = ["navigate", "same-origin", "no-cors", "cors"];
    var requestCredentials = ["omit", "same-origin", "include"];
    var requestCache = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached"
    ];
    var requestBodyHeader = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      // See https://github.com/nodejs/undici/issues/2021
      // 'Content-Length' is a forbidden header name, which is typically
      // removed in the Headers implementation. However, undici doesn't
      // filter out headers, so we add it here.
      "content-length"
    ];
    var requestDuplex = [
      "half"
    ];
    var forbiddenMethods = ["CONNECT", "TRACE", "TRACK"];
    var forbiddenMethodsSet = new Set(forbiddenMethods);
    var subresource = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      ""
    ];
    var subresourceSet = new Set(subresource);
    var DOMException2 = globalThis.DOMException ?? (() => {
      try {
        atob("~");
      } catch (err) {
        return Object.getPrototypeOf(err).constructor;
      }
    })();
    var channel;
    var structuredClone = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
    // structuredClone was added in v17.0.0, but fetch supports v16.8
    function structuredClone2(value, options = void 0) {
      if (arguments.length === 0) {
        throw new TypeError("missing argument");
      }
      if (!channel) {
        channel = new MessageChannel();
      }
      channel.port1.unref();
      channel.port2.unref();
      channel.port1.postMessage(value, options?.transfer);
      return receiveMessageOnPort(channel.port2).message;
    };
    module.exports = {
      DOMException: DOMException2,
      structuredClone,
      subresource,
      forbiddenMethods,
      requestBodyHeader,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      redirectStatus,
      corsSafeListedMethods,
      nullBodyStatus,
      safeMethods,
      badPorts,
      requestDuplex,
      subresourceSet,
      badPortsSet,
      redirectStatusSet,
      corsSafeListedMethodsSet,
      safeMethodsSet,
      forbiddenMethodsSet,
      referrerPolicySet
    };
  }
});

// node_modules/undici/lib/fetch/global.js
var require_global = __commonJS({
  "node_modules/undici/lib/fetch/global.js"(exports, module) {
    var globalOrigin = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[globalOrigin];
    }
    function setGlobalOrigin(newOrigin) {
      if (newOrigin === void 0) {
        Object.defineProperty(globalThis, globalOrigin, {
          value: void 0,
          writable: true,
          enumerable: false,
          configurable: false
        });
        return;
      }
      const parsedURL = new URL(newOrigin);
      if (parsedURL.protocol !== "http:" && parsedURL.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${parsedURL.protocol}`);
      }
      Object.defineProperty(globalThis, globalOrigin, {
        value: parsedURL,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    module.exports = {
      getGlobalOrigin,
      setGlobalOrigin
    };
  }
});

// node_modules/undici/lib/fetch/util.js
var require_util2 = __commonJS({
  "node_modules/undici/lib/fetch/util.js"(exports, module) {
    var { redirectStatusSet, referrerPolicySet: referrerPolicyTokens, badPortsSet } = require_constants2();
    var { getGlobalOrigin } = require_global();
    var { performance: performance2 } = __require("perf_hooks");
    var { isBlobLike, toUSVString, ReadableStreamFrom } = require_util();
    var assert = __require("assert");
    var { isUint8Array } = __require("util/types");
    var supportedHashes = [];
    var crypto;
    try {
      crypto = __require("crypto");
      const possibleRelevantHashes = ["sha256", "sha384", "sha512"];
      supportedHashes = crypto.getHashes().filter((hash) => possibleRelevantHashes.includes(hash));
    } catch {
    }
    function responseURL(response) {
      const urlList = response.urlList;
      const length = urlList.length;
      return length === 0 ? null : urlList[length - 1].toString();
    }
    function responseLocationURL(response, requestFragment) {
      if (!redirectStatusSet.has(response.status)) {
        return null;
      }
      let location = response.headersList.get("location");
      if (location !== null && isValidHeaderValue(location)) {
        location = new URL(location, responseURL(response));
      }
      if (location && !location.hash) {
        location.hash = requestFragment;
      }
      return location;
    }
    function requestCurrentURL(request) {
      return request.urlList[request.urlList.length - 1];
    }
    function requestBadPort(request) {
      const url = requestCurrentURL(request);
      if (urlIsHttpHttpsScheme(url) && badPortsSet.has(url.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(object) {
      return object instanceof Error || (object?.constructor?.name === "Error" || object?.constructor?.name === "DOMException");
    }
    function isValidReasonPhrase(statusText) {
      for (let i = 0; i < statusText.length; ++i) {
        const c = statusText.charCodeAt(i);
        if (!(c === 9 || // HTAB
        c >= 32 && c <= 126 || // SP / VCHAR
        c >= 128 && c <= 255)) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(c) {
      switch (c) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return c >= 33 && c <= 126;
      }
    }
    function isValidHTTPToken(characters) {
      if (characters.length === 0) {
        return false;
      }
      for (let i = 0; i < characters.length; ++i) {
        if (!isTokenCharCode(characters.charCodeAt(i))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(potentialValue) {
      return isValidHTTPToken(potentialValue);
    }
    function isValidHeaderValue(potentialValue) {
      if (potentialValue.startsWith("	") || potentialValue.startsWith(" ") || potentialValue.endsWith("	") || potentialValue.endsWith(" ")) {
        return false;
      }
      if (potentialValue.includes("\0") || potentialValue.includes("\r") || potentialValue.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(request, actualResponse) {
      const { headersList } = actualResponse;
      const policyHeader = (headersList.get("referrer-policy") ?? "").split(",");
      let policy = "";
      if (policyHeader.length > 0) {
        for (let i = policyHeader.length; i !== 0; i--) {
          const token = policyHeader[i - 1].trim();
          if (referrerPolicyTokens.has(token)) {
            policy = token;
            break;
          }
        }
      }
      if (policy !== "") {
        request.referrerPolicy = policy;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(httpRequest) {
      let header = null;
      header = httpRequest.mode;
      httpRequest.headersList.set("sec-fetch-mode", header);
    }
    function appendRequestOriginHeader(request) {
      let serializedOrigin = request.origin;
      if (request.responseTainting === "cors" || request.mode === "websocket") {
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      } else if (request.method !== "GET" && request.method !== "HEAD") {
        switch (request.referrerPolicy) {
          case "no-referrer":
            serializedOrigin = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (request.origin && urlHasHttpsScheme(request.origin) && !urlHasHttpsScheme(requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(request, requestCurrentURL(request))) {
              serializedOrigin = null;
            }
            break;
        }
        if (serializedOrigin) {
          request.headersList.append("origin", serializedOrigin);
        }
      }
    }
    function coarsenedSharedCurrentTime(crossOriginIsolatedCapability) {
      return performance2.now();
    }
    function createOpaqueTimingInfo(timingInfo) {
      return {
        startTime: timingInfo.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: timingInfo.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null
      };
    }
    function makePolicyContainer() {
      return {
        referrerPolicy: "strict-origin-when-cross-origin"
      };
    }
    function clonePolicyContainer(policyContainer) {
      return {
        referrerPolicy: policyContainer.referrerPolicy
      };
    }
    function determineRequestsReferrer(request) {
      const policy = request.referrerPolicy;
      assert(policy);
      let referrerSource = null;
      if (request.referrer === "client") {
        const globalOrigin = getGlobalOrigin();
        if (!globalOrigin || globalOrigin.origin === "null") {
          return "no-referrer";
        }
        referrerSource = new URL(globalOrigin);
      } else if (request.referrer instanceof URL) {
        referrerSource = request.referrer;
      }
      let referrerURL = stripURLForReferrer(referrerSource);
      const referrerOrigin = stripURLForReferrer(referrerSource, true);
      if (referrerURL.toString().length > 4096) {
        referrerURL = referrerOrigin;
      }
      const areSameOrigin = sameOrigin(request, referrerURL);
      const isNonPotentiallyTrustWorthy = isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(request.url);
      switch (policy) {
        case "origin":
          return referrerOrigin != null ? referrerOrigin : stripURLForReferrer(referrerSource, true);
        case "unsafe-url":
          return referrerURL;
        case "same-origin":
          return areSameOrigin ? referrerOrigin : "no-referrer";
        case "origin-when-cross-origin":
          return areSameOrigin ? referrerURL : referrerOrigin;
        case "strict-origin-when-cross-origin": {
          const currentURL = requestCurrentURL(request);
          if (sameOrigin(referrerURL, currentURL)) {
            return referrerURL;
          }
          if (isURLPotentiallyTrustworthy(referrerURL) && !isURLPotentiallyTrustworthy(currentURL)) {
            return "no-referrer";
          }
          return referrerOrigin;
        }
        case "strict-origin":
        // eslint-disable-line
        /**
           * 1. If referrerURL is a potentially trustworthy URL and
           * request’s current URL is not a potentially trustworthy URL,
           * then return no referrer.
           * 2. Return referrerOrigin
          */
        case "no-referrer-when-downgrade":
        // eslint-disable-line
        /**
         * 1. If referrerURL is a potentially trustworthy URL and
         * request’s current URL is not a potentially trustworthy URL,
         * then return no referrer.
         * 2. Return referrerOrigin
        */
        default:
          return isNonPotentiallyTrustWorthy ? "no-referrer" : referrerOrigin;
      }
    }
    function stripURLForReferrer(url, originOnly) {
      assert(url instanceof URL);
      if (url.protocol === "file:" || url.protocol === "about:" || url.protocol === "blank:") {
        return "no-referrer";
      }
      url.username = "";
      url.password = "";
      url.hash = "";
      if (originOnly) {
        url.pathname = "";
        url.search = "";
      }
      return url;
    }
    function isURLPotentiallyTrustworthy(url) {
      if (!(url instanceof URL)) {
        return false;
      }
      if (url.href === "about:blank" || url.href === "about:srcdoc") {
        return true;
      }
      if (url.protocol === "data:") return true;
      if (url.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(url.origin);
      function isOriginPotentiallyTrustworthy(origin) {
        if (origin == null || origin === "null") return false;
        const originAsURL = new URL(origin);
        if (originAsURL.protocol === "https:" || originAsURL.protocol === "wss:") {
          return true;
        }
        if (/^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(originAsURL.hostname) || (originAsURL.hostname === "localhost" || originAsURL.hostname.includes("localhost.")) || originAsURL.hostname.endsWith(".localhost")) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(bytes, metadataList) {
      if (crypto === void 0) {
        return true;
      }
      const parsedMetadata = parseMetadata(metadataList);
      if (parsedMetadata === "no metadata") {
        return true;
      }
      if (parsedMetadata.length === 0) {
        return true;
      }
      const strongest = getStrongestMetadata(parsedMetadata);
      const metadata = filterMetadataListByAlgorithm(parsedMetadata, strongest);
      for (const item of metadata) {
        const algorithm = item.algo;
        const expectedValue = item.hash;
        let actualValue = crypto.createHash(algorithm).update(bytes).digest("base64");
        if (actualValue[actualValue.length - 1] === "=") {
          if (actualValue[actualValue.length - 2] === "=") {
            actualValue = actualValue.slice(0, -2);
          } else {
            actualValue = actualValue.slice(0, -1);
          }
        }
        if (compareBase64Mixed(actualValue, expectedValue)) {
          return true;
        }
      }
      return false;
    }
    var parseHashWithOptions = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(metadata) {
      const result = [];
      let empty = true;
      for (const token of metadata.split(" ")) {
        empty = false;
        const parsedToken = parseHashWithOptions.exec(token);
        if (parsedToken === null || parsedToken.groups === void 0 || parsedToken.groups.algo === void 0) {
          continue;
        }
        const algorithm = parsedToken.groups.algo.toLowerCase();
        if (supportedHashes.includes(algorithm)) {
          result.push(parsedToken.groups);
        }
      }
      if (empty === true) {
        return "no metadata";
      }
      return result;
    }
    function getStrongestMetadata(metadataList) {
      let algorithm = metadataList[0].algo;
      if (algorithm[3] === "5") {
        return algorithm;
      }
      for (let i = 1; i < metadataList.length; ++i) {
        const metadata = metadataList[i];
        if (metadata.algo[3] === "5") {
          algorithm = "sha512";
          break;
        } else if (algorithm[3] === "3") {
          continue;
        } else if (metadata.algo[3] === "3") {
          algorithm = "sha384";
        }
      }
      return algorithm;
    }
    function filterMetadataListByAlgorithm(metadataList, algorithm) {
      if (metadataList.length === 1) {
        return metadataList;
      }
      let pos = 0;
      for (let i = 0; i < metadataList.length; ++i) {
        if (metadataList[i].algo === algorithm) {
          metadataList[pos++] = metadataList[i];
        }
      }
      metadataList.length = pos;
      return metadataList;
    }
    function compareBase64Mixed(actualValue, expectedValue) {
      if (actualValue.length !== expectedValue.length) {
        return false;
      }
      for (let i = 0; i < actualValue.length; ++i) {
        if (actualValue[i] !== expectedValue[i]) {
          if (actualValue[i] === "+" && expectedValue[i] === "-" || actualValue[i] === "/" && expectedValue[i] === "_") {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(request) {
    }
    function sameOrigin(A2, B2) {
      if (A2.origin === B2.origin && A2.origin === "null") {
        return true;
      }
      if (A2.protocol === B2.protocol && A2.hostname === B2.hostname && A2.port === B2.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let res;
      let rej;
      const promise = new Promise((resolve, reject) => {
        res = resolve;
        rej = reject;
      });
      return { promise, resolve: res, reject: rej };
    }
    function isAborted(fetchParams) {
      return fetchParams.controller.state === "aborted";
    }
    function isCancelled(fetchParams) {
      return fetchParams.controller.state === "aborted" || fetchParams.controller.state === "terminated";
    }
    var normalizeMethodRecord = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT"
    };
    Object.setPrototypeOf(normalizeMethodRecord, null);
    function normalizeMethod(method) {
      return normalizeMethodRecord[method.toLowerCase()] ?? method;
    }
    function serializeJavascriptValueToJSONString(value) {
      const result = JSON.stringify(value);
      if (result === void 0) {
        throw new TypeError("Value is not JSON serializable");
      }
      assert(typeof result === "string");
      return result;
    }
    var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(iterator, name, kind) {
      const object = {
        index: 0,
        kind,
        target: iterator
      };
      const i = {
        next() {
          if (Object.getPrototypeOf(this) !== i) {
            throw new TypeError(
              `'next' called on an object that does not implement interface ${name} Iterator.`
            );
          }
          const { index, kind: kind2, target } = object;
          const values = target();
          const len = values.length;
          if (index >= len) {
            return { value: void 0, done: true };
          }
          const pair = values[index];
          object.index = index + 1;
          return iteratorResult(pair, kind2);
        },
        // The class string of an iterator prototype object for a given interface is the
        // result of concatenating the identifier of the interface and the string " Iterator".
        [Symbol.toStringTag]: `${name} Iterator`
      };
      Object.setPrototypeOf(i, esIteratorPrototype);
      return Object.setPrototypeOf({}, i);
    }
    function iteratorResult(pair, kind) {
      let result;
      switch (kind) {
        case "key": {
          result = pair[0];
          break;
        }
        case "value": {
          result = pair[1];
          break;
        }
        case "key+value": {
          result = pair;
          break;
        }
      }
      return { value: result, done: false };
    }
    async function fullyReadBody(body, processBody, processBodyError) {
      const successSteps = processBody;
      const errorSteps = processBodyError;
      let reader;
      try {
        reader = body.stream.getReader();
      } catch (e) {
        errorSteps(e);
        return;
      }
      try {
        const result = await readAllBytes(reader);
        successSteps(result);
      } catch (e) {
        errorSteps(e);
      }
    }
    var ReadableStream = globalThis.ReadableStream;
    function isReadableStreamLike(stream) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      return stream instanceof ReadableStream || stream[Symbol.toStringTag] === "ReadableStream" && typeof stream.tee === "function";
    }
    var MAXIMUM_ARGUMENT_LENGTH = 65535;
    function isomorphicDecode(input) {
      if (input.length < MAXIMUM_ARGUMENT_LENGTH) {
        return String.fromCharCode(...input);
      }
      return input.reduce((previous, current) => previous + String.fromCharCode(current), "");
    }
    function readableStreamClose(controller) {
      try {
        controller.close();
      } catch (err) {
        if (!err.message.includes("Controller is already closed")) {
          throw err;
        }
      }
    }
    function isomorphicEncode(input) {
      for (let i = 0; i < input.length; i++) {
        assert(input.charCodeAt(i) <= 255);
      }
      return input;
    }
    async function readAllBytes(reader) {
      const bytes = [];
      let byteLength = 0;
      while (true) {
        const { done, value: chunk } = await reader.read();
        if (done) {
          return Buffer.concat(bytes, byteLength);
        }
        if (!isUint8Array(chunk)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        bytes.push(chunk);
        byteLength += chunk.length;
      }
    }
    function urlIsLocal(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "about:" || protocol === "blob:" || protocol === "data:";
    }
    function urlHasHttpsScheme(url) {
      if (typeof url === "string") {
        return url.startsWith("https:");
      }
      return url.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(url) {
      assert("protocol" in url);
      const protocol = url.protocol;
      return protocol === "http:" || protocol === "https:";
    }
    var hasOwn = Object.hasOwn || ((dict, key) => Object.prototype.hasOwnProperty.call(dict, key));
    module.exports = {
      isAborted,
      isCancelled,
      createDeferredPromise,
      ReadableStreamFrom,
      toUSVString,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime,
      determineRequestsReferrer,
      makePolicyContainer,
      clonePolicyContainer,
      appendFetchMetadata,
      appendRequestOriginHeader,
      TAOCheck,
      corsCheck,
      crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken,
      requestBadPort,
      requestCurrentURL,
      responseURL,
      responseLocationURL,
      isBlobLike,
      isURLPotentiallyTrustworthy,
      isValidReasonPhrase,
      sameOrigin,
      normalizeMethod,
      serializeJavascriptValueToJSONString,
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue,
      hasOwn,
      isErrorLike,
      fullyReadBody,
      bytesMatch,
      isReadableStreamLike,
      readableStreamClose,
      isomorphicEncode,
      isomorphicDecode,
      urlIsLocal,
      urlHasHttpsScheme,
      urlIsHttpHttpsScheme,
      readAllBytes,
      normalizeMethodRecord,
      parseMetadata
    };
  }
});

// node_modules/undici/lib/fetch/symbols.js
var require_symbols2 = __commonJS({
  "node_modules/undici/lib/fetch/symbols.js"(exports, module) {
    module.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm")
    };
  }
});

// node_modules/undici/lib/fetch/webidl.js
var require_webidl = __commonJS({
  "node_modules/undici/lib/fetch/webidl.js"(exports, module) {
    var { types } = __require("util");
    var { hasOwn, toUSVString } = require_util2();
    var webidl = {};
    webidl.converters = {};
    webidl.util = {};
    webidl.errors = {};
    webidl.errors.exception = function(message) {
      return new TypeError(`${message.header}: ${message.message}`);
    };
    webidl.errors.conversionFailed = function(context) {
      const plural = context.types.length === 1 ? "" : " one of";
      const message = `${context.argument} could not be converted to${plural}: ${context.types.join(", ")}.`;
      return webidl.errors.exception({
        header: context.prefix,
        message
      });
    };
    webidl.errors.invalidArgument = function(context) {
      return webidl.errors.exception({
        header: context.prefix,
        message: `"${context.value}" is an invalid ${context.type}.`
      });
    };
    webidl.brandCheck = function(V2, I2, opts = void 0) {
      if (opts?.strict !== false && !(V2 instanceof I2)) {
        throw new TypeError("Illegal invocation");
      } else {
        return V2?.[Symbol.toStringTag] === I2.prototype[Symbol.toStringTag];
      }
    };
    webidl.argumentLengthCheck = function({ length }, min, ctx) {
      if (length < min) {
        throw webidl.errors.exception({
          message: `${min} argument${min !== 1 ? "s" : ""} required, but${length ? " only" : ""} ${length} found.`,
          ...ctx
        });
      }
    };
    webidl.illegalConstructor = function() {
      throw webidl.errors.exception({
        header: "TypeError",
        message: "Illegal constructor"
      });
    };
    webidl.util.Type = function(V2) {
      switch (typeof V2) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (V2 === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    webidl.util.ConvertToInt = function(V2, bitLength, signedness, opts = {}) {
      let upperBound;
      let lowerBound;
      if (bitLength === 64) {
        upperBound = Math.pow(2, 53) - 1;
        if (signedness === "unsigned") {
          lowerBound = 0;
        } else {
          lowerBound = Math.pow(-2, 53) + 1;
        }
      } else if (signedness === "unsigned") {
        lowerBound = 0;
        upperBound = Math.pow(2, bitLength) - 1;
      } else {
        lowerBound = Math.pow(-2, bitLength) - 1;
        upperBound = Math.pow(2, bitLength - 1) - 1;
      }
      let x2 = Number(V2);
      if (x2 === 0) {
        x2 = 0;
      }
      if (opts.enforceRange === true) {
        if (Number.isNaN(x2) || x2 === Number.POSITIVE_INFINITY || x2 === Number.NEGATIVE_INFINITY) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Could not convert ${V2} to an integer.`
          });
        }
        x2 = webidl.util.IntegerPart(x2);
        if (x2 < lowerBound || x2 > upperBound) {
          throw webidl.errors.exception({
            header: "Integer conversion",
            message: `Value must be between ${lowerBound}-${upperBound}, got ${x2}.`
          });
        }
        return x2;
      }
      if (!Number.isNaN(x2) && opts.clamp === true) {
        x2 = Math.min(Math.max(x2, lowerBound), upperBound);
        if (Math.floor(x2) % 2 === 0) {
          x2 = Math.floor(x2);
        } else {
          x2 = Math.ceil(x2);
        }
        return x2;
      }
      if (Number.isNaN(x2) || x2 === 0 && Object.is(0, x2) || x2 === Number.POSITIVE_INFINITY || x2 === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      x2 = webidl.util.IntegerPart(x2);
      x2 = x2 % Math.pow(2, bitLength);
      if (signedness === "signed" && x2 >= Math.pow(2, bitLength) - 1) {
        return x2 - Math.pow(2, bitLength);
      }
      return x2;
    };
    webidl.util.IntegerPart = function(n) {
      const r = Math.floor(Math.abs(n));
      if (n < 0) {
        return -1 * r;
      }
      return r;
    };
    webidl.sequenceConverter = function(converter) {
      return (V2) => {
        if (webidl.util.Type(V2) !== "Object") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: `Value of type ${webidl.util.Type(V2)} is not an Object.`
          });
        }
        const method = V2?.[Symbol.iterator]?.();
        const seq = [];
        if (method === void 0 || typeof method.next !== "function") {
          throw webidl.errors.exception({
            header: "Sequence",
            message: "Object is not an iterator."
          });
        }
        while (true) {
          const { done, value } = method.next();
          if (done) {
            break;
          }
          seq.push(converter(value));
        }
        return seq;
      };
    };
    webidl.recordConverter = function(keyConverter, valueConverter) {
      return (O2) => {
        if (webidl.util.Type(O2) !== "Object") {
          throw webidl.errors.exception({
            header: "Record",
            message: `Value of type ${webidl.util.Type(O2)} is not an Object.`
          });
        }
        const result = {};
        if (!types.isProxy(O2)) {
          const keys2 = Object.keys(O2);
          for (const key of keys2) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O2[key]);
            result[typedKey] = typedValue;
          }
          return result;
        }
        const keys = Reflect.ownKeys(O2);
        for (const key of keys) {
          const desc = Reflect.getOwnPropertyDescriptor(O2, key);
          if (desc?.enumerable) {
            const typedKey = keyConverter(key);
            const typedValue = valueConverter(O2[key]);
            result[typedKey] = typedValue;
          }
        }
        return result;
      };
    };
    webidl.interfaceConverter = function(i) {
      return (V2, opts = {}) => {
        if (opts.strict !== false && !(V2 instanceof i)) {
          throw webidl.errors.exception({
            header: i.name,
            message: `Expected ${V2} to be an instance of ${i.name}.`
          });
        }
        return V2;
      };
    };
    webidl.dictionaryConverter = function(converters) {
      return (dictionary) => {
        const type = webidl.util.Type(dictionary);
        const dict = {};
        if (type === "Null" || type === "Undefined") {
          return dict;
        } else if (type !== "Object") {
          throw webidl.errors.exception({
            header: "Dictionary",
            message: `Expected ${dictionary} to be one of: Null, Undefined, Object.`
          });
        }
        for (const options of converters) {
          const { key, defaultValue, required, converter } = options;
          if (required === true) {
            if (!hasOwn(dictionary, key)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `Missing required key "${key}".`
              });
            }
          }
          let value = dictionary[key];
          const hasDefault = hasOwn(options, "defaultValue");
          if (hasDefault && value !== null) {
            value = value ?? defaultValue;
          }
          if (required || hasDefault || value !== void 0) {
            value = converter(value);
            if (options.allowedValues && !options.allowedValues.includes(value)) {
              throw webidl.errors.exception({
                header: "Dictionary",
                message: `${value} is not an accepted type. Expected one of ${options.allowedValues.join(", ")}.`
              });
            }
            dict[key] = value;
          }
        }
        return dict;
      };
    };
    webidl.nullableConverter = function(converter) {
      return (V2) => {
        if (V2 === null) {
          return V2;
        }
        return converter(V2);
      };
    };
    webidl.converters.DOMString = function(V2, opts = {}) {
      if (V2 === null && opts.legacyNullToEmptyString) {
        return "";
      }
      if (typeof V2 === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(V2);
    };
    webidl.converters.ByteString = function(V2) {
      const x2 = webidl.converters.DOMString(V2);
      for (let index = 0; index < x2.length; index++) {
        if (x2.charCodeAt(index) > 255) {
          throw new TypeError(
            `Cannot convert argument to a ByteString because the character at index ${index} has a value of ${x2.charCodeAt(index)} which is greater than 255.`
          );
        }
      }
      return x2;
    };
    webidl.converters.USVString = toUSVString;
    webidl.converters.boolean = function(V2) {
      const x2 = Boolean(V2);
      return x2;
    };
    webidl.converters.any = function(V2) {
      return V2;
    };
    webidl.converters["long long"] = function(V2) {
      const x2 = webidl.util.ConvertToInt(V2, 64, "signed");
      return x2;
    };
    webidl.converters["unsigned long long"] = function(V2) {
      const x2 = webidl.util.ConvertToInt(V2, 64, "unsigned");
      return x2;
    };
    webidl.converters["unsigned long"] = function(V2) {
      const x2 = webidl.util.ConvertToInt(V2, 32, "unsigned");
      return x2;
    };
    webidl.converters["unsigned short"] = function(V2, opts) {
      const x2 = webidl.util.ConvertToInt(V2, 16, "unsigned", opts);
      return x2;
    };
    webidl.converters.ArrayBuffer = function(V2, opts = {}) {
      if (webidl.util.Type(V2) !== "Object" || !types.isAnyArrayBuffer(V2)) {
        throw webidl.errors.conversionFailed({
          prefix: `${V2}`,
          argument: `${V2}`,
          types: ["ArrayBuffer"]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V2)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V2;
    };
    webidl.converters.TypedArray = function(V2, T2, opts = {}) {
      if (webidl.util.Type(V2) !== "Object" || !types.isTypedArray(V2) || V2.constructor.name !== T2.name) {
        throw webidl.errors.conversionFailed({
          prefix: `${T2.name}`,
          argument: `${V2}`,
          types: [T2.name]
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V2.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V2;
    };
    webidl.converters.DataView = function(V2, opts = {}) {
      if (webidl.util.Type(V2) !== "Object" || !types.isDataView(V2)) {
        throw webidl.errors.exception({
          header: "DataView",
          message: "Object is not a DataView."
        });
      }
      if (opts.allowShared === false && types.isSharedArrayBuffer(V2.buffer)) {
        throw webidl.errors.exception({
          header: "ArrayBuffer",
          message: "SharedArrayBuffer is not allowed."
        });
      }
      return V2;
    };
    webidl.converters.BufferSource = function(V2, opts = {}) {
      if (types.isAnyArrayBuffer(V2)) {
        return webidl.converters.ArrayBuffer(V2, opts);
      }
      if (types.isTypedArray(V2)) {
        return webidl.converters.TypedArray(V2, V2.constructor);
      }
      if (types.isDataView(V2)) {
        return webidl.converters.DataView(V2, opts);
      }
      throw new TypeError(`Could not convert ${V2} to a BufferSource.`);
    };
    webidl.converters["sequence<ByteString>"] = webidl.sequenceConverter(
      webidl.converters.ByteString
    );
    webidl.converters["sequence<sequence<ByteString>>"] = webidl.sequenceConverter(
      webidl.converters["sequence<ByteString>"]
    );
    webidl.converters["record<ByteString, ByteString>"] = webidl.recordConverter(
      webidl.converters.ByteString,
      webidl.converters.ByteString
    );
    module.exports = {
      webidl
    };
  }
});

// node_modules/undici/lib/fetch/dataURL.js
var require_dataURL = __commonJS({
  "node_modules/undici/lib/fetch/dataURL.js"(exports, module) {
    var assert = __require("assert");
    var { atob: atob2 } = __require("buffer");
    var { isomorphicDecode } = require_util2();
    var encoder3 = new TextEncoder();
    var HTTP_TOKEN_CODEPOINTS = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    var HTTP_WHITESPACE_REGEX = /(\u000A|\u000D|\u0009|\u0020)/;
    var HTTP_QUOTED_STRING_TOKENS = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(dataURL) {
      assert(dataURL.protocol === "data:");
      let input = URLSerializer(dataURL, true);
      input = input.slice(5);
      const position = { position: 0 };
      let mimeType = collectASequenceOfCodePointsFast(
        ",",
        input,
        position
      );
      const mimeTypeLength = mimeType.length;
      mimeType = removeASCIIWhitespace(mimeType, true, true);
      if (position.position >= input.length) {
        return "failure";
      }
      position.position++;
      const encodedBody = input.slice(mimeTypeLength + 1);
      let body = stringPercentDecode(encodedBody);
      if (/;(\u0020){0,}base64$/i.test(mimeType)) {
        const stringBody = isomorphicDecode(body);
        body = forgivingBase64(stringBody);
        if (body === "failure") {
          return "failure";
        }
        mimeType = mimeType.slice(0, -6);
        mimeType = mimeType.replace(/(\u0020)+$/, "");
        mimeType = mimeType.slice(0, -1);
      }
      if (mimeType.startsWith(";")) {
        mimeType = "text/plain" + mimeType;
      }
      let mimeTypeRecord = parseMIMEType(mimeType);
      if (mimeTypeRecord === "failure") {
        mimeTypeRecord = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: mimeTypeRecord, body };
    }
    function URLSerializer(url, excludeFragment = false) {
      if (!excludeFragment) {
        return url.href;
      }
      const href = url.href;
      const hashLength = url.hash.length;
      return hashLength === 0 ? href : href.substring(0, href.length - hashLength);
    }
    function collectASequenceOfCodePoints(condition, input, position) {
      let result = "";
      while (position.position < input.length && condition(input[position.position])) {
        result += input[position.position];
        position.position++;
      }
      return result;
    }
    function collectASequenceOfCodePointsFast(char, input, position) {
      const idx = input.indexOf(char, position.position);
      const start = position.position;
      if (idx === -1) {
        position.position = input.length;
        return input.slice(start);
      }
      position.position = idx;
      return input.slice(start, position.position);
    }
    function stringPercentDecode(input) {
      const bytes = encoder3.encode(input);
      return percentDecode(bytes);
    }
    function percentDecode(input) {
      const output = [];
      for (let i = 0; i < input.length; i++) {
        const byte = input[i];
        if (byte !== 37) {
          output.push(byte);
        } else if (byte === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i + 1], input[i + 2]))) {
          output.push(37);
        } else {
          const nextTwoBytes = String.fromCharCode(input[i + 1], input[i + 2]);
          const bytePoint = Number.parseInt(nextTwoBytes, 16);
          output.push(bytePoint);
          i += 2;
        }
      }
      return Uint8Array.from(output);
    }
    function parseMIMEType(input) {
      input = removeHTTPWhitespace(input, true, true);
      const position = { position: 0 };
      const type = collectASequenceOfCodePointsFast(
        "/",
        input,
        position
      );
      if (type.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(type)) {
        return "failure";
      }
      if (position.position > input.length) {
        return "failure";
      }
      position.position++;
      let subtype = collectASequenceOfCodePointsFast(
        ";",
        input,
        position
      );
      subtype = removeHTTPWhitespace(subtype, false, true);
      if (subtype.length === 0 || !HTTP_TOKEN_CODEPOINTS.test(subtype)) {
        return "failure";
      }
      const typeLowercase = type.toLowerCase();
      const subtypeLowercase = subtype.toLowerCase();
      const mimeType = {
        type: typeLowercase,
        subtype: subtypeLowercase,
        /** @type {Map<string, string>} */
        parameters: /* @__PURE__ */ new Map(),
        // https://mimesniff.spec.whatwg.org/#mime-type-essence
        essence: `${typeLowercase}/${subtypeLowercase}`
      };
      while (position.position < input.length) {
        position.position++;
        collectASequenceOfCodePoints(
          // https://fetch.spec.whatwg.org/#http-whitespace
          (char) => HTTP_WHITESPACE_REGEX.test(char),
          input,
          position
        );
        let parameterName = collectASequenceOfCodePoints(
          (char) => char !== ";" && char !== "=",
          input,
          position
        );
        parameterName = parameterName.toLowerCase();
        if (position.position < input.length) {
          if (input[position.position] === ";") {
            continue;
          }
          position.position++;
        }
        if (position.position > input.length) {
          break;
        }
        let parameterValue = null;
        if (input[position.position] === '"') {
          parameterValue = collectAnHTTPQuotedString(input, position, true);
          collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
        } else {
          parameterValue = collectASequenceOfCodePointsFast(
            ";",
            input,
            position
          );
          parameterValue = removeHTTPWhitespace(parameterValue, false, true);
          if (parameterValue.length === 0) {
            continue;
          }
        }
        if (parameterName.length !== 0 && HTTP_TOKEN_CODEPOINTS.test(parameterName) && (parameterValue.length === 0 || HTTP_QUOTED_STRING_TOKENS.test(parameterValue)) && !mimeType.parameters.has(parameterName)) {
          mimeType.parameters.set(parameterName, parameterValue);
        }
      }
      return mimeType;
    }
    function forgivingBase64(data) {
      data = data.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (data.length % 4 === 0) {
        data = data.replace(/=?=$/, "");
      }
      if (data.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(data)) {
        return "failure";
      }
      const binary = atob2(data);
      const bytes = new Uint8Array(binary.length);
      for (let byte = 0; byte < binary.length; byte++) {
        bytes[byte] = binary.charCodeAt(byte);
      }
      return bytes;
    }
    function collectAnHTTPQuotedString(input, position, extractValue) {
      const positionStart = position.position;
      let value = "";
      assert(input[position.position] === '"');
      position.position++;
      while (true) {
        value += collectASequenceOfCodePoints(
          (char) => char !== '"' && char !== "\\",
          input,
          position
        );
        if (position.position >= input.length) {
          break;
        }
        const quoteOrBackslash = input[position.position];
        position.position++;
        if (quoteOrBackslash === "\\") {
          if (position.position >= input.length) {
            value += "\\";
            break;
          }
          value += input[position.position];
          position.position++;
        } else {
          assert(quoteOrBackslash === '"');
          break;
        }
      }
      if (extractValue) {
        return value;
      }
      return input.slice(positionStart, position.position);
    }
    function serializeAMimeType(mimeType) {
      assert(mimeType !== "failure");
      const { parameters, essence } = mimeType;
      let serialization = essence;
      for (let [name, value] of parameters.entries()) {
        serialization += ";";
        serialization += name;
        serialization += "=";
        if (!HTTP_TOKEN_CODEPOINTS.test(value)) {
          value = value.replace(/(\\|")/g, "\\$1");
          value = '"' + value;
          value += '"';
        }
        serialization += value;
      }
      return serialization;
    }
    function isHTTPWhiteSpace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === " ";
    }
    function removeHTTPWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isHTTPWhiteSpace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isHTTPWhiteSpace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    function isASCIIWhitespace(char) {
      return char === "\r" || char === "\n" || char === "	" || char === "\f" || char === " ";
    }
    function removeASCIIWhitespace(str, leading = true, trailing = true) {
      let lead = 0;
      let trail = str.length - 1;
      if (leading) {
        for (; lead < str.length && isASCIIWhitespace(str[lead]); lead++) ;
      }
      if (trailing) {
        for (; trail > 0 && isASCIIWhitespace(str[trail]); trail--) ;
      }
      return str.slice(lead, trail + 1);
    }
    module.exports = {
      dataURLProcessor,
      URLSerializer,
      collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast,
      stringPercentDecode,
      parseMIMEType,
      collectAnHTTPQuotedString,
      serializeAMimeType
    };
  }
});

// node_modules/undici/lib/fetch/file.js
var require_file = __commonJS({
  "node_modules/undici/lib/fetch/file.js"(exports, module) {
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var { types } = __require("util");
    var { kState } = require_symbols2();
    var { isBlobLike } = require_util2();
    var { webidl } = require_webidl();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var { kEnumerableProperty } = require_util();
    var encoder3 = new TextEncoder();
    var File = class _File extends Blob2 {
      constructor(fileBits, fileName, options = {}) {
        webidl.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        fileBits = webidl.converters["sequence<BlobPart>"](fileBits);
        fileName = webidl.converters.USVString(fileName);
        options = webidl.converters.FilePropertyBag(options);
        const n = fileName;
        let t = options.type;
        let d;
        substep: {
          if (t) {
            t = parseMIMEType(t);
            if (t === "failure") {
              t = "";
              break substep;
            }
            t = serializeAMimeType(t).toLowerCase();
          }
          d = options.lastModified;
        }
        super(processBlobParts(fileBits, options), { type: t });
        this[kState] = {
          name: n,
          lastModified: d,
          type: t
        };
      }
      get name() {
        webidl.brandCheck(this, _File);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _File);
        return this[kState].lastModified;
      }
      get type() {
        webidl.brandCheck(this, _File);
        return this[kState].type;
      }
    };
    var FileLike = class _FileLike {
      constructor(blobLike, fileName, options = {}) {
        const n = fileName;
        const t = options.type;
        const d = options.lastModified ?? Date.now();
        this[kState] = {
          blobLike,
          name: n,
          type: t,
          lastModified: d
        };
      }
      stream(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.stream(...args);
      }
      arrayBuffer(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.arrayBuffer(...args);
      }
      slice(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.slice(...args);
      }
      text(...args) {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.text(...args);
      }
      get size() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.size;
      }
      get type() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].blobLike.type;
      }
      get name() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].name;
      }
      get lastModified() {
        webidl.brandCheck(this, _FileLike);
        return this[kState].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    };
    Object.defineProperties(File.prototype, {
      [Symbol.toStringTag]: {
        value: "File",
        configurable: true
      },
      name: kEnumerableProperty,
      lastModified: kEnumerableProperty
    });
    webidl.converters.Blob = webidl.interfaceConverter(Blob2);
    webidl.converters.BlobPart = function(V2, opts) {
      if (webidl.util.Type(V2) === "Object") {
        if (isBlobLike(V2)) {
          return webidl.converters.Blob(V2, { strict: false });
        }
        if (ArrayBuffer.isView(V2) || types.isAnyArrayBuffer(V2)) {
          return webidl.converters.BufferSource(V2, opts);
        }
      }
      return webidl.converters.USVString(V2, opts);
    };
    webidl.converters["sequence<BlobPart>"] = webidl.sequenceConverter(
      webidl.converters.BlobPart
    );
    webidl.converters.FilePropertyBag = webidl.dictionaryConverter([
      {
        key: "lastModified",
        converter: webidl.converters["long long"],
        get defaultValue() {
          return Date.now();
        }
      },
      {
        key: "type",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "endings",
        converter: (value) => {
          value = webidl.converters.DOMString(value);
          value = value.toLowerCase();
          if (value !== "native") {
            value = "transparent";
          }
          return value;
        },
        defaultValue: "transparent"
      }
    ]);
    function processBlobParts(parts, options) {
      const bytes = [];
      for (const element of parts) {
        if (typeof element === "string") {
          let s = element;
          if (options.endings === "native") {
            s = convertLineEndingsNative(s);
          }
          bytes.push(encoder3.encode(s));
        } else if (types.isAnyArrayBuffer(element) || types.isTypedArray(element)) {
          if (!element.buffer) {
            bytes.push(new Uint8Array(element));
          } else {
            bytes.push(
              new Uint8Array(element.buffer, element.byteOffset, element.byteLength)
            );
          }
        } else if (isBlobLike(element)) {
          bytes.push(element);
        }
      }
      return bytes;
    }
    function convertLineEndingsNative(s) {
      let nativeLineEnding = "\n";
      if (process.platform === "win32") {
        nativeLineEnding = "\r\n";
      }
      return s.replace(/\r?\n/g, nativeLineEnding);
    }
    function isFileLike(object) {
      return NativeFile && object instanceof NativeFile || object instanceof File || object && (typeof object.stream === "function" || typeof object.arrayBuffer === "function") && object[Symbol.toStringTag] === "File";
    }
    module.exports = { File, FileLike, isFileLike };
  }
});

// node_modules/undici/lib/fetch/formdata.js
var require_formdata = __commonJS({
  "node_modules/undici/lib/fetch/formdata.js"(exports, module) {
    var { isBlobLike, toUSVString, makeIterator } = require_util2();
    var { kState } = require_symbols2();
    var { File: UndiciFile, FileLike, isFileLike } = require_file();
    var { webidl } = require_webidl();
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var File = NativeFile ?? UndiciFile;
    var FormData = class _FormData {
      constructor(form) {
        if (form !== void 0) {
          throw webidl.errors.conversionFailed({
            prefix: "FormData constructor",
            argument: "Argument 1",
            types: ["undefined"]
          });
        }
        this[kState] = [];
      }
      append(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? webidl.converters.USVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        this[kState].push(entry);
      }
      delete(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        name = webidl.converters.USVString(name);
        this[kState] = this[kState].filter((entry) => entry.name !== name);
      }
      get(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        name = webidl.converters.USVString(name);
        const idx = this[kState].findIndex((entry) => entry.name === name);
        if (idx === -1) {
          return null;
        }
        return this[kState][idx].value;
      }
      getAll(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        name = webidl.converters.USVString(name);
        return this[kState].filter((entry) => entry.name === name).map((entry) => entry.value);
      }
      has(name) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        name = webidl.converters.USVString(name);
        return this[kState].findIndex((entry) => entry.name === name) !== -1;
      }
      set(name, value, filename = void 0) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !isBlobLike(value)) {
          throw new TypeError(
            "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
          );
        }
        name = webidl.converters.USVString(name);
        value = isBlobLike(value) ? webidl.converters.Blob(value, { strict: false }) : webidl.converters.USVString(value);
        filename = arguments.length === 3 ? toUSVString(filename) : void 0;
        const entry = makeEntry(name, value, filename);
        const idx = this[kState].findIndex((entry2) => entry2.name === name);
        if (idx !== -1) {
          this[kState] = [
            ...this[kState].slice(0, idx),
            entry,
            ...this[kState].slice(idx + 1).filter((entry2) => entry2.name !== name)
          ];
        } else {
          this[kState].push(entry);
        }
      }
      entries() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key+value"
        );
      }
      keys() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _FormData);
        return makeIterator(
          () => this[kState].map((pair) => [pair.name, pair.value]),
          "FormData",
          "value"
        );
      }
      /**
       * @param {(value: string, key: string, self: FormData) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _FormData);
        webidl.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
    };
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, {
      [Symbol.toStringTag]: {
        value: "FormData",
        configurable: true
      }
    });
    function makeEntry(name, value, filename) {
      name = Buffer.from(name).toString("utf8");
      if (typeof value === "string") {
        value = Buffer.from(value).toString("utf8");
      } else {
        if (!isFileLike(value)) {
          value = value instanceof Blob2 ? new File([value], "blob", { type: value.type }) : new FileLike(value, "blob", { type: value.type });
        }
        if (filename !== void 0) {
          const options = {
            type: value.type,
            lastModified: value.lastModified
          };
          value = NativeFile && value instanceof NativeFile || value instanceof UndiciFile ? new File([value], filename, options) : new FileLike(value, filename, options);
        }
      }
      return { name, value };
    }
    module.exports = { FormData };
  }
});

// node_modules/undici/lib/fetch/body.js
var require_body = __commonJS({
  "node_modules/undici/lib/fetch/body.js"(exports, module) {
    var Busboy = require_main();
    var util = require_util();
    var {
      ReadableStreamFrom,
      isBlobLike,
      isReadableStreamLike,
      readableStreamClose,
      createDeferredPromise,
      fullyReadBody
    } = require_util2();
    var { FormData } = require_formdata();
    var { kState } = require_symbols2();
    var { webidl } = require_webidl();
    var { DOMException: DOMException2, structuredClone } = require_constants2();
    var { Blob: Blob2, File: NativeFile } = __require("buffer");
    var { kBodyUsed } = require_symbols();
    var assert = __require("assert");
    var { isErrored } = require_util();
    var { isUint8Array, isArrayBuffer } = __require("util/types");
    var { File: UndiciFile } = require_file();
    var { parseMIMEType, serializeAMimeType } = require_dataURL();
    var ReadableStream = globalThis.ReadableStream;
    var File = NativeFile ?? UndiciFile;
    var textEncoder = new TextEncoder();
    var textDecoder = new TextDecoder();
    function extractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      let stream = null;
      if (object instanceof ReadableStream) {
        stream = object;
      } else if (isBlobLike(object)) {
        stream = object.stream();
      } else {
        stream = new ReadableStream({
          async pull(controller) {
            controller.enqueue(
              typeof source === "string" ? textEncoder.encode(source) : source
            );
            queueMicrotask(() => readableStreamClose(controller));
          },
          start() {
          },
          type: void 0
        });
      }
      assert(isReadableStreamLike(stream));
      let action = null;
      let source = null;
      let length = null;
      let type = null;
      if (typeof object === "string") {
        source = object;
        type = "text/plain;charset=UTF-8";
      } else if (object instanceof URLSearchParams) {
        source = object.toString();
        type = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (isArrayBuffer(object)) {
        source = new Uint8Array(object.slice());
      } else if (ArrayBuffer.isView(object)) {
        source = new Uint8Array(object.buffer.slice(object.byteOffset, object.byteOffset + object.byteLength));
      } else if (util.isFormDataLike(object)) {
        const boundary = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
        const prefix = `--${boundary}\r
Content-Disposition: form-data`;
        const escape = (str) => str.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, "\r\n");
        const blobParts = [];
        const rn2 = new Uint8Array([13, 10]);
        length = 0;
        let hasUnknownSizeValue = false;
        for (const [name, value] of object) {
          if (typeof value === "string") {
            const chunk2 = textEncoder.encode(prefix + `; name="${escape(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`);
            blobParts.push(chunk2);
            length += chunk2.byteLength;
          } else {
            const chunk2 = textEncoder.encode(`${prefix}; name="${escape(normalizeLinefeeds(name))}"` + (value.name ? `; filename="${escape(value.name)}"` : "") + `\r
Content-Type: ${value.type || "application/octet-stream"}\r
\r
`);
            blobParts.push(chunk2, value, rn2);
            if (typeof value.size === "number") {
              length += chunk2.byteLength + value.size + rn2.byteLength;
            } else {
              hasUnknownSizeValue = true;
            }
          }
        }
        const chunk = textEncoder.encode(`--${boundary}--`);
        blobParts.push(chunk);
        length += chunk.byteLength;
        if (hasUnknownSizeValue) {
          length = null;
        }
        source = object;
        action = async function* () {
          for (const part of blobParts) {
            if (part.stream) {
              yield* part.stream();
            } else {
              yield part;
            }
          }
        };
        type = "multipart/form-data; boundary=" + boundary;
      } else if (isBlobLike(object)) {
        source = object;
        length = object.size;
        if (object.type) {
          type = object.type;
        }
      } else if (typeof object[Symbol.asyncIterator] === "function") {
        if (keepalive) {
          throw new TypeError("keepalive");
        }
        if (util.isDisturbed(object) || object.locked) {
          throw new TypeError(
            "Response body object should not be disturbed or locked"
          );
        }
        stream = object instanceof ReadableStream ? object : ReadableStreamFrom(object);
      }
      if (typeof source === "string" || util.isBuffer(source)) {
        length = Buffer.byteLength(source);
      }
      if (action != null) {
        let iterator;
        stream = new ReadableStream({
          async start() {
            iterator = action(object)[Symbol.asyncIterator]();
          },
          async pull(controller) {
            const { value, done } = await iterator.next();
            if (done) {
              queueMicrotask(() => {
                controller.close();
              });
            } else {
              if (!isErrored(stream)) {
                controller.enqueue(new Uint8Array(value));
              }
            }
            return controller.desiredSize > 0;
          },
          async cancel(reason) {
            await iterator.return();
          },
          type: void 0
        });
      }
      const body = { stream, source, length };
      return [body, type];
    }
    function safelyExtractBody(object, keepalive = false) {
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      if (object instanceof ReadableStream) {
        assert(!util.isDisturbed(object), "The body has already been consumed.");
        assert(!object.locked, "The stream is locked.");
      }
      return extractBody(object, keepalive);
    }
    function cloneBody(body) {
      const [out1, out2] = body.stream.tee();
      const out2Clone = structuredClone(out2, { transfer: [out2] });
      const [, finalClone] = out2Clone.tee();
      body.stream = out1;
      return {
        stream: finalClone,
        length: body.length,
        source: body.source
      };
    }
    async function* consumeBody(body) {
      if (body) {
        if (isUint8Array(body)) {
          yield body;
        } else {
          const stream = body.stream;
          if (util.isDisturbed(stream)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (stream.locked) {
            throw new TypeError("The stream is locked.");
          }
          stream[kBodyUsed] = true;
          yield* stream;
        }
      }
    }
    function throwIfAborted(state) {
      if (state.aborted) {
        throw new DOMException2("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(instance) {
      const methods = {
        blob() {
          return specConsumeBody(this, (bytes) => {
            let mimeType = bodyMimeType(this);
            if (mimeType === "failure") {
              mimeType = "";
            } else if (mimeType) {
              mimeType = serializeAMimeType(mimeType);
            }
            return new Blob2([bytes], { type: mimeType });
          }, instance);
        },
        arrayBuffer() {
          return specConsumeBody(this, (bytes) => {
            return new Uint8Array(bytes).buffer;
          }, instance);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, instance);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, instance);
        },
        async formData() {
          webidl.brandCheck(this, instance);
          throwIfAborted(this[kState]);
          const contentType = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(contentType)) {
            const headers = {};
            for (const [key, value] of this.headers) headers[key.toLowerCase()] = value;
            const responseFormData = new FormData();
            let busboy;
            try {
              busboy = new Busboy({
                headers,
                preservePath: true
              });
            } catch (err) {
              throw new DOMException2(`${err}`, "AbortError");
            }
            busboy.on("field", (name, value) => {
              responseFormData.append(name, value);
            });
            busboy.on("file", (name, value, filename, encoding, mimeType) => {
              const chunks = [];
              if (encoding === "base64" || encoding.toLowerCase() === "base64") {
                let base64chunk = "";
                value.on("data", (chunk) => {
                  base64chunk += chunk.toString().replace(/[\r\n]/gm, "");
                  const end = base64chunk.length - base64chunk.length % 4;
                  chunks.push(Buffer.from(base64chunk.slice(0, end), "base64"));
                  base64chunk = base64chunk.slice(end);
                });
                value.on("end", () => {
                  chunks.push(Buffer.from(base64chunk, "base64"));
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              } else {
                value.on("data", (chunk) => {
                  chunks.push(chunk);
                });
                value.on("end", () => {
                  responseFormData.append(name, new File(chunks, filename, { type: mimeType }));
                });
              }
            });
            const busboyResolve = new Promise((resolve, reject) => {
              busboy.on("finish", resolve);
              busboy.on("error", (err) => reject(new TypeError(err)));
            });
            if (this.body !== null) for await (const chunk of consumeBody(this[kState].body)) busboy.write(chunk);
            busboy.end();
            await busboyResolve;
            return responseFormData;
          } else if (/application\/x-www-form-urlencoded/.test(contentType)) {
            let entries;
            try {
              let text = "";
              const streamingDecoder = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const chunk of consumeBody(this[kState].body)) {
                if (!isUint8Array(chunk)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                text += streamingDecoder.decode(chunk, { stream: true });
              }
              text += streamingDecoder.decode();
              entries = new URLSearchParams(text);
            } catch (err) {
              throw Object.assign(new TypeError(), { cause: err });
            }
            const formData = new FormData();
            for (const [name, value] of entries) {
              formData.append(name, value);
            }
            return formData;
          } else {
            await Promise.resolve();
            throwIfAborted(this[kState]);
            throw webidl.errors.exception({
              header: `${instance.name}.formData`,
              message: "Could not parse content as FormData."
            });
          }
        }
      };
      return methods;
    }
    function mixinBody(prototype) {
      Object.assign(prototype.prototype, bodyMixinMethods(prototype));
    }
    async function specConsumeBody(object, convertBytesToJSValue, instance) {
      webidl.brandCheck(object, instance);
      throwIfAborted(object[kState]);
      if (bodyUnusable(object[kState].body)) {
        throw new TypeError("Body is unusable");
      }
      const promise = createDeferredPromise();
      const errorSteps = (error) => promise.reject(error);
      const successSteps = (data) => {
        try {
          promise.resolve(convertBytesToJSValue(data));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (object[kState].body == null) {
        successSteps(new Uint8Array());
        return promise.promise;
      }
      await fullyReadBody(object[kState].body, successSteps, errorSteps);
      return promise.promise;
    }
    function bodyUnusable(body) {
      return body != null && (body.stream.locked || util.isDisturbed(body.stream));
    }
    function utf8DecodeBytes(buffer) {
      if (buffer.length === 0) {
        return "";
      }
      if (buffer[0] === 239 && buffer[1] === 187 && buffer[2] === 191) {
        buffer = buffer.subarray(3);
      }
      const output = textDecoder.decode(buffer);
      return output;
    }
    function parseJSONFromBytes(bytes) {
      return JSON.parse(utf8DecodeBytes(bytes));
    }
    function bodyMimeType(object) {
      const { headersList } = object[kState];
      const contentType = headersList.get("content-type");
      if (contentType === null) {
        return "failure";
      }
      return parseMIMEType(contentType);
    }
    module.exports = {
      extractBody,
      safelyExtractBody,
      cloneBody,
      mixinBody
    };
  }
});

// node_modules/undici/lib/core/request.js
var require_request = __commonJS({
  "node_modules/undici/lib/core/request.js"(exports, module) {
    var {
      InvalidArgumentError,
      NotSupportedError
    } = require_errors();
    var assert = __require("assert");
    var { kHTTP2BuildRequest, kHTTP2CopyHeaders, kHTTP1BuildRequest } = require_symbols();
    var util = require_util();
    var tokenRegExp = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    var headerCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
    var invalidPathRegex = /[^\u0021-\u00ff]/;
    var kHandler = Symbol("handler");
    var channels = {};
    var extractBody;
    try {
      const diagnosticsChannel = __require("diagnostics_channel");
      channels.create = diagnosticsChannel.channel("undici:request:create");
      channels.bodySent = diagnosticsChannel.channel("undici:request:bodySent");
      channels.headers = diagnosticsChannel.channel("undici:request:headers");
      channels.trailers = diagnosticsChannel.channel("undici:request:trailers");
      channels.error = diagnosticsChannel.channel("undici:request:error");
    } catch {
      channels.create = { hasSubscribers: false };
      channels.bodySent = { hasSubscribers: false };
      channels.headers = { hasSubscribers: false };
      channels.trailers = { hasSubscribers: false };
      channels.error = { hasSubscribers: false };
    }
    var Request = class _Request {
      constructor(origin, {
        path,
        method,
        body,
        headers,
        query,
        idempotent,
        blocking,
        upgrade,
        headersTimeout,
        bodyTimeout,
        reset,
        throwOnError,
        expectContinue
      }, handler) {
        if (typeof path !== "string") {
          throw new InvalidArgumentError("path must be a string");
        } else if (path[0] !== "/" && !(path.startsWith("http://") || path.startsWith("https://")) && method !== "CONNECT") {
          throw new InvalidArgumentError("path must be an absolute URL or start with a slash");
        } else if (invalidPathRegex.exec(path) !== null) {
          throw new InvalidArgumentError("invalid request path");
        }
        if (typeof method !== "string") {
          throw new InvalidArgumentError("method must be a string");
        } else if (tokenRegExp.exec(method) === null) {
          throw new InvalidArgumentError("invalid request method");
        }
        if (upgrade && typeof upgrade !== "string") {
          throw new InvalidArgumentError("upgrade must be a string");
        }
        if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("invalid headersTimeout");
        }
        if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("invalid bodyTimeout");
        }
        if (reset != null && typeof reset !== "boolean") {
          throw new InvalidArgumentError("invalid reset");
        }
        if (expectContinue != null && typeof expectContinue !== "boolean") {
          throw new InvalidArgumentError("invalid expectContinue");
        }
        this.headersTimeout = headersTimeout;
        this.bodyTimeout = bodyTimeout;
        this.throwOnError = throwOnError === true;
        this.method = method;
        this.abort = null;
        if (body == null) {
          this.body = null;
        } else if (util.isStream(body)) {
          this.body = body;
          const rState = this.body._readableState;
          if (!rState || !rState.autoDestroy) {
            this.endHandler = function autoDestroy() {
              util.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (err) => {
            if (this.abort) {
              this.abort(err);
            } else {
              this.error = err;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (util.isBuffer(body)) {
          this.body = body.byteLength ? body : null;
        } else if (ArrayBuffer.isView(body)) {
          this.body = body.buffer.byteLength ? Buffer.from(body.buffer, body.byteOffset, body.byteLength) : null;
        } else if (body instanceof ArrayBuffer) {
          this.body = body.byteLength ? Buffer.from(body) : null;
        } else if (typeof body === "string") {
          this.body = body.length ? Buffer.from(body) : null;
        } else if (util.isFormDataLike(body) || util.isIterable(body) || util.isBlobLike(body)) {
          this.body = body;
        } else {
          throw new InvalidArgumentError("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = upgrade || null;
        this.path = query ? util.buildURL(path, query) : path;
        this.origin = origin;
        this.idempotent = idempotent == null ? method === "HEAD" || method === "GET" : idempotent;
        this.blocking = blocking == null ? false : blocking;
        this.reset = reset == null ? null : reset;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = expectContinue != null ? expectContinue : false;
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(this, headers[i], headers[i + 1]);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(this, key, headers[key]);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        if (util.isFormDataLike(this.body)) {
          if (util.nodeMajor < 16 || util.nodeMajor === 16 && util.nodeMinor < 8) {
            throw new InvalidArgumentError("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!extractBody) {
            extractBody = require_body().extractBody;
          }
          const [bodyStream, contentType] = extractBody(body);
          if (this.contentType == null) {
            this.contentType = contentType;
            this.headers += `content-type: ${contentType}\r
`;
          }
          this.body = bodyStream.stream;
          this.contentLength = bodyStream.length;
        } else if (util.isBlobLike(body) && this.contentType == null && body.type) {
          this.contentType = body.type;
          this.headers += `content-type: ${body.type}\r
`;
        }
        util.validateHandler(handler, method, upgrade);
        this.servername = util.getServerName(this.host);
        this[kHandler] = handler;
        if (channels.create.hasSubscribers) {
          channels.create.publish({ request: this });
        }
      }
      onBodySent(chunk) {
        if (this[kHandler].onBodySent) {
          try {
            return this[kHandler].onBodySent(chunk);
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onRequestSent() {
        if (channels.bodySent.hasSubscribers) {
          channels.bodySent.publish({ request: this });
        }
        if (this[kHandler].onRequestSent) {
          try {
            return this[kHandler].onRequestSent();
          } catch (err) {
            this.abort(err);
          }
        }
      }
      onConnect(abort) {
        assert(!this.aborted);
        assert(!this.completed);
        if (this.error) {
          abort(this.error);
        } else {
          this.abort = abort;
          return this[kHandler].onConnect(abort);
        }
      }
      onHeaders(statusCode, headers, resume, statusText) {
        assert(!this.aborted);
        assert(!this.completed);
        if (channels.headers.hasSubscribers) {
          channels.headers.publish({ request: this, response: { statusCode, headers, statusText } });
        }
        try {
          return this[kHandler].onHeaders(statusCode, headers, resume, statusText);
        } catch (err) {
          this.abort(err);
        }
      }
      onData(chunk) {
        assert(!this.aborted);
        assert(!this.completed);
        try {
          return this[kHandler].onData(chunk);
        } catch (err) {
          this.abort(err);
          return false;
        }
      }
      onUpgrade(statusCode, headers, socket) {
        assert(!this.aborted);
        assert(!this.completed);
        return this[kHandler].onUpgrade(statusCode, headers, socket);
      }
      onComplete(trailers) {
        this.onFinally();
        assert(!this.aborted);
        this.completed = true;
        if (channels.trailers.hasSubscribers) {
          channels.trailers.publish({ request: this, trailers });
        }
        try {
          return this[kHandler].onComplete(trailers);
        } catch (err) {
          this.onError(err);
        }
      }
      onError(error) {
        this.onFinally();
        if (channels.error.hasSubscribers) {
          channels.error.publish({ request: this, error });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[kHandler].onError(error);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      // TODO: adjust to support H2
      addHeader(key, value) {
        processHeader(this, key, value);
        return this;
      }
      static [kHTTP1BuildRequest](origin, opts, handler) {
        return new _Request(origin, opts, handler);
      }
      static [kHTTP2BuildRequest](origin, opts, handler) {
        const headers = opts.headers;
        opts = { ...opts, headers: null };
        const request = new _Request(origin, opts, handler);
        request.headers = {};
        if (Array.isArray(headers)) {
          if (headers.length % 2 !== 0) {
            throw new InvalidArgumentError("headers array must be even");
          }
          for (let i = 0; i < headers.length; i += 2) {
            processHeader(request, headers[i], headers[i + 1], true);
          }
        } else if (headers && typeof headers === "object") {
          const keys = Object.keys(headers);
          for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            processHeader(request, key, headers[key], true);
          }
        } else if (headers != null) {
          throw new InvalidArgumentError("headers must be an object or an array");
        }
        return request;
      }
      static [kHTTP2CopyHeaders](raw) {
        const rawHeaders = raw.split("\r\n");
        const headers = {};
        for (const header of rawHeaders) {
          const [key, value] = header.split(": ");
          if (value == null || value.length === 0) continue;
          if (headers[key]) headers[key] += `,${value}`;
          else headers[key] = value;
        }
        return headers;
      }
    };
    function processHeaderValue(key, val, skipAppend) {
      if (val && typeof val === "object") {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      val = val != null ? `${val}` : "";
      if (headerCharRegex.exec(val) !== null) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      }
      return skipAppend ? val : `${key}: ${val}\r
`;
    }
    function processHeader(request, key, val, skipAppend = false) {
      if (val && (typeof val === "object" && !Array.isArray(val))) {
        throw new InvalidArgumentError(`invalid ${key} header`);
      } else if (val === void 0) {
        return;
      }
      if (request.host === null && key.length === 4 && key.toLowerCase() === "host") {
        if (headerCharRegex.exec(val) !== null) {
          throw new InvalidArgumentError(`invalid ${key} header`);
        }
        request.host = val;
      } else if (request.contentLength === null && key.length === 14 && key.toLowerCase() === "content-length") {
        request.contentLength = parseInt(val, 10);
        if (!Number.isFinite(request.contentLength)) {
          throw new InvalidArgumentError("invalid content-length header");
        }
      } else if (request.contentType === null && key.length === 12 && key.toLowerCase() === "content-type") {
        request.contentType = val;
        if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
        else request.headers += processHeaderValue(key, val);
      } else if (key.length === 17 && key.toLowerCase() === "transfer-encoding") {
        throw new InvalidArgumentError("invalid transfer-encoding header");
      } else if (key.length === 10 && key.toLowerCase() === "connection") {
        const value = typeof val === "string" ? val.toLowerCase() : null;
        if (value !== "close" && value !== "keep-alive") {
          throw new InvalidArgumentError("invalid connection header");
        } else if (value === "close") {
          request.reset = true;
        }
      } else if (key.length === 10 && key.toLowerCase() === "keep-alive") {
        throw new InvalidArgumentError("invalid keep-alive header");
      } else if (key.length === 7 && key.toLowerCase() === "upgrade") {
        throw new InvalidArgumentError("invalid upgrade header");
      } else if (key.length === 6 && key.toLowerCase() === "expect") {
        throw new NotSupportedError("expect header not supported");
      } else if (tokenRegExp.exec(key) === null) {
        throw new InvalidArgumentError("invalid header key");
      } else {
        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            if (skipAppend) {
              if (request.headers[key]) request.headers[key] += `,${processHeaderValue(key, val[i], skipAppend)}`;
              else request.headers[key] = processHeaderValue(key, val[i], skipAppend);
            } else {
              request.headers += processHeaderValue(key, val[i]);
            }
          }
        } else {
          if (skipAppend) request.headers[key] = processHeaderValue(key, val, skipAppend);
          else request.headers += processHeaderValue(key, val);
        }
      }
    }
    module.exports = Request;
  }
});

// node_modules/undici/lib/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/undici/lib/dispatcher.js"(exports, module) {
    var EventEmitter = __require("events");
    var Dispatcher = class extends EventEmitter {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    };
    module.exports = Dispatcher;
  }
});

// node_modules/undici/lib/dispatcher-base.js
var require_dispatcher_base = __commonJS({
  "node_modules/undici/lib/dispatcher-base.js"(exports, module) {
    var Dispatcher = require_dispatcher();
    var {
      ClientDestroyedError,
      ClientClosedError,
      InvalidArgumentError
    } = require_errors();
    var { kDestroy, kClose, kDispatch, kInterceptors } = require_symbols();
    var kDestroyed = Symbol("destroyed");
    var kClosed = Symbol("closed");
    var kOnDestroyed = Symbol("onDestroyed");
    var kOnClosed = Symbol("onClosed");
    var kInterceptedDispatch = Symbol("Intercepted Dispatch");
    var DispatcherBase = class extends Dispatcher {
      constructor() {
        super();
        this[kDestroyed] = false;
        this[kOnDestroyed] = null;
        this[kClosed] = false;
        this[kOnClosed] = [];
      }
      get destroyed() {
        return this[kDestroyed];
      }
      get closed() {
        return this[kClosed];
      }
      get interceptors() {
        return this[kInterceptors];
      }
      set interceptors(newInterceptors) {
        if (newInterceptors) {
          for (let i = newInterceptors.length - 1; i >= 0; i--) {
            const interceptor = this[kInterceptors][i];
            if (typeof interceptor !== "function") {
              throw new InvalidArgumentError("interceptor must be an function");
            }
          }
        }
        this[kInterceptors] = newInterceptors;
      }
      close(callback) {
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.close((err, data) => {
              return err ? reject(err) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          queueMicrotask(() => callback(new ClientDestroyedError(), null));
          return;
        }
        if (this[kClosed]) {
          if (this[kOnClosed]) {
            this[kOnClosed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        this[kClosed] = true;
        this[kOnClosed].push(callback);
        const onClosed = () => {
          const callbacks = this[kOnClosed];
          this[kOnClosed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kClose]().then(() => this.destroy()).then(() => {
          queueMicrotask(onClosed);
        });
      }
      destroy(err, callback) {
        if (typeof err === "function") {
          callback = err;
          err = null;
        }
        if (callback === void 0) {
          return new Promise((resolve, reject) => {
            this.destroy(err, (err2, data) => {
              return err2 ? (
                /* istanbul ignore next: should never error */
                reject(err2)
              ) : resolve(data);
            });
          });
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        if (this[kDestroyed]) {
          if (this[kOnDestroyed]) {
            this[kOnDestroyed].push(callback);
          } else {
            queueMicrotask(() => callback(null, null));
          }
          return;
        }
        if (!err) {
          err = new ClientDestroyedError();
        }
        this[kDestroyed] = true;
        this[kOnDestroyed] = this[kOnDestroyed] || [];
        this[kOnDestroyed].push(callback);
        const onDestroyed = () => {
          const callbacks = this[kOnDestroyed];
          this[kOnDestroyed] = null;
          for (let i = 0; i < callbacks.length; i++) {
            callbacks[i](null, null);
          }
        };
        this[kDestroy](err).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [kInterceptedDispatch](opts, handler) {
        if (!this[kInterceptors] || this[kInterceptors].length === 0) {
          this[kInterceptedDispatch] = this[kDispatch];
          return this[kDispatch](opts, handler);
        }
        let dispatch = this[kDispatch].bind(this);
        for (let i = this[kInterceptors].length - 1; i >= 0; i--) {
          dispatch = this[kInterceptors][i](dispatch);
        }
        this[kInterceptedDispatch] = dispatch;
        return dispatch(opts, handler);
      }
      dispatch(opts, handler) {
        if (!handler || typeof handler !== "object") {
          throw new InvalidArgumentError("handler must be an object");
        }
        try {
          if (!opts || typeof opts !== "object") {
            throw new InvalidArgumentError("opts must be an object.");
          }
          if (this[kDestroyed] || this[kOnDestroyed]) {
            throw new ClientDestroyedError();
          }
          if (this[kClosed]) {
            throw new ClientClosedError();
          }
          return this[kInterceptedDispatch](opts, handler);
        } catch (err) {
          if (typeof handler.onError !== "function") {
            throw new InvalidArgumentError("invalid onError method");
          }
          handler.onError(err);
          return false;
        }
      }
    };
    module.exports = DispatcherBase;
  }
});

// node_modules/undici/lib/core/connect.js
var require_connect = __commonJS({
  "node_modules/undici/lib/core/connect.js"(exports, module) {
    var net = __require("net");
    var assert = __require("assert");
    var util = require_util();
    var { InvalidArgumentError, ConnectTimeoutError } = require_errors();
    var tls;
    var SessionCache;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      SessionCache = class WeakSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
          this._sessionRegistry = new global.FinalizationRegistry((key) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const ref = this._sessionCache.get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this._sessionCache.delete(key);
            }
          });
        }
        get(sessionKey) {
          const ref = this._sessionCache.get(sessionKey);
          return ref ? ref.deref() : null;
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(sessionKey, new WeakRef(session));
          this._sessionRegistry.register(session, sessionKey);
        }
      };
    } else {
      SessionCache = class SimpleSessionCache {
        constructor(maxCachedSessions) {
          this._maxCachedSessions = maxCachedSessions;
          this._sessionCache = /* @__PURE__ */ new Map();
        }
        get(sessionKey) {
          return this._sessionCache.get(sessionKey);
        }
        set(sessionKey, session) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: oldestKey } = this._sessionCache.keys().next();
            this._sessionCache.delete(oldestKey);
          }
          this._sessionCache.set(sessionKey, session);
        }
      };
    }
    function buildConnector({ allowH2, maxCachedSessions, socketPath, timeout, ...opts }) {
      if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {
        throw new InvalidArgumentError("maxCachedSessions must be a positive integer or zero");
      }
      const options = { path: socketPath, ...opts };
      const sessionCache = new SessionCache(maxCachedSessions == null ? 100 : maxCachedSessions);
      timeout = timeout == null ? 1e4 : timeout;
      allowH2 = allowH2 != null ? allowH2 : false;
      return function connect({ hostname, host, protocol, port, servername, localAddress, httpSocket }, callback) {
        let socket;
        if (protocol === "https:") {
          if (!tls) {
            tls = __require("tls");
          }
          servername = servername || options.servername || util.getServerName(host) || null;
          const sessionKey = servername || hostname;
          const session = sessionCache.get(sessionKey) || null;
          assert(sessionKey);
          socket = tls.connect({
            highWaterMark: 16384,
            // TLS in node can't have bigger HWM anyway...
            ...options,
            servername,
            session,
            localAddress,
            // TODO(HTTP/2): Add support for h2c
            ALPNProtocols: allowH2 ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: httpSocket,
            // upgrade socket connection
            port: port || 443,
            host: hostname
          });
          socket.on("session", function(session2) {
            sessionCache.set(sessionKey, session2);
          });
        } else {
          assert(!httpSocket, "httpSocket can only be sent on TLS update");
          socket = net.connect({
            highWaterMark: 64 * 1024,
            // Same as nodejs fs streams.
            ...options,
            localAddress,
            port: port || 80,
            host: hostname
          });
        }
        if (options.keepAlive == null || options.keepAlive) {
          const keepAliveInitialDelay = options.keepAliveInitialDelay === void 0 ? 6e4 : options.keepAliveInitialDelay;
          socket.setKeepAlive(true, keepAliveInitialDelay);
        }
        const cancelTimeout = setupTimeout(() => onConnectTimeout(socket), timeout);
        socket.setNoDelay(true).once(protocol === "https:" ? "secureConnect" : "connect", function() {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(null, this);
          }
        }).on("error", function(err) {
          cancelTimeout();
          if (callback) {
            const cb = callback;
            callback = null;
            cb(err);
          }
        });
        return socket;
      };
    }
    function setupTimeout(onConnectTimeout2, timeout) {
      if (!timeout) {
        return () => {
        };
      }
      let s1 = null;
      let s2 = null;
      const timeoutId = setTimeout(() => {
        s1 = setImmediate(() => {
          if (process.platform === "win32") {
            s2 = setImmediate(() => onConnectTimeout2());
          } else {
            onConnectTimeout2();
          }
        });
      }, timeout);
      return () => {
        clearTimeout(timeoutId);
        clearImmediate(s1);
        clearImmediate(s2);
      };
    }
    function onConnectTimeout(socket) {
      util.destroy(socket, new ConnectTimeoutError());
    }
    module.exports = buildConnector;
  }
});

// node_modules/undici/lib/llhttp/utils.js
var require_utils2 = __commonJS({
  "node_modules/undici/lib/llhttp/utils.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.enumToMap = void 0;
    function enumToMap(obj) {
      const res = {};
      Object.keys(obj).forEach((key) => {
        const value = obj[key];
        if (typeof value === "number") {
          res[key] = value;
        }
      });
      return res;
    }
    exports.enumToMap = enumToMap;
  }
});

// node_modules/undici/lib/llhttp/constants.js
var require_constants3 = __commonJS({
  "node_modules/undici/lib/llhttp/constants.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SPECIAL_HEADERS = exports.HEADER_STATE = exports.MINOR = exports.MAJOR = exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS = exports.TOKEN = exports.STRICT_TOKEN = exports.HEX = exports.URL_CHAR = exports.STRICT_URL_CHAR = exports.USERINFO_CHARS = exports.MARK = exports.ALPHANUM = exports.NUM = exports.HEX_MAP = exports.NUM_MAP = exports.ALPHA = exports.FINISH = exports.H_METHOD_MAP = exports.METHOD_MAP = exports.METHODS_RTSP = exports.METHODS_ICE = exports.METHODS_HTTP = exports.METHODS = exports.LENIENT_FLAGS = exports.FLAGS = exports.TYPE = exports.ERROR = void 0;
    var utils_1 = require_utils2();
    (function(ERROR2) {
      ERROR2[ERROR2["OK"] = 0] = "OK";
      ERROR2[ERROR2["INTERNAL"] = 1] = "INTERNAL";
      ERROR2[ERROR2["STRICT"] = 2] = "STRICT";
      ERROR2[ERROR2["LF_EXPECTED"] = 3] = "LF_EXPECTED";
      ERROR2[ERROR2["UNEXPECTED_CONTENT_LENGTH"] = 4] = "UNEXPECTED_CONTENT_LENGTH";
      ERROR2[ERROR2["CLOSED_CONNECTION"] = 5] = "CLOSED_CONNECTION";
      ERROR2[ERROR2["INVALID_METHOD"] = 6] = "INVALID_METHOD";
      ERROR2[ERROR2["INVALID_URL"] = 7] = "INVALID_URL";
      ERROR2[ERROR2["INVALID_CONSTANT"] = 8] = "INVALID_CONSTANT";
      ERROR2[ERROR2["INVALID_VERSION"] = 9] = "INVALID_VERSION";
      ERROR2[ERROR2["INVALID_HEADER_TOKEN"] = 10] = "INVALID_HEADER_TOKEN";
      ERROR2[ERROR2["INVALID_CONTENT_LENGTH"] = 11] = "INVALID_CONTENT_LENGTH";
      ERROR2[ERROR2["INVALID_CHUNK_SIZE"] = 12] = "INVALID_CHUNK_SIZE";
      ERROR2[ERROR2["INVALID_STATUS"] = 13] = "INVALID_STATUS";
      ERROR2[ERROR2["INVALID_EOF_STATE"] = 14] = "INVALID_EOF_STATE";
      ERROR2[ERROR2["INVALID_TRANSFER_ENCODING"] = 15] = "INVALID_TRANSFER_ENCODING";
      ERROR2[ERROR2["CB_MESSAGE_BEGIN"] = 16] = "CB_MESSAGE_BEGIN";
      ERROR2[ERROR2["CB_HEADERS_COMPLETE"] = 17] = "CB_HEADERS_COMPLETE";
      ERROR2[ERROR2["CB_MESSAGE_COMPLETE"] = 18] = "CB_MESSAGE_COMPLETE";
      ERROR2[ERROR2["CB_CHUNK_HEADER"] = 19] = "CB_CHUNK_HEADER";
      ERROR2[ERROR2["CB_CHUNK_COMPLETE"] = 20] = "CB_CHUNK_COMPLETE";
      ERROR2[ERROR2["PAUSED"] = 21] = "PAUSED";
      ERROR2[ERROR2["PAUSED_UPGRADE"] = 22] = "PAUSED_UPGRADE";
      ERROR2[ERROR2["PAUSED_H2_UPGRADE"] = 23] = "PAUSED_H2_UPGRADE";
      ERROR2[ERROR2["USER"] = 24] = "USER";
    })(exports.ERROR || (exports.ERROR = {}));
    (function(TYPE2) {
      TYPE2[TYPE2["BOTH"] = 0] = "BOTH";
      TYPE2[TYPE2["REQUEST"] = 1] = "REQUEST";
      TYPE2[TYPE2["RESPONSE"] = 2] = "RESPONSE";
    })(exports.TYPE || (exports.TYPE = {}));
    (function(FLAGS2) {
      FLAGS2[FLAGS2["CONNECTION_KEEP_ALIVE"] = 1] = "CONNECTION_KEEP_ALIVE";
      FLAGS2[FLAGS2["CONNECTION_CLOSE"] = 2] = "CONNECTION_CLOSE";
      FLAGS2[FLAGS2["CONNECTION_UPGRADE"] = 4] = "CONNECTION_UPGRADE";
      FLAGS2[FLAGS2["CHUNKED"] = 8] = "CHUNKED";
      FLAGS2[FLAGS2["UPGRADE"] = 16] = "UPGRADE";
      FLAGS2[FLAGS2["CONTENT_LENGTH"] = 32] = "CONTENT_LENGTH";
      FLAGS2[FLAGS2["SKIPBODY"] = 64] = "SKIPBODY";
      FLAGS2[FLAGS2["TRAILING"] = 128] = "TRAILING";
      FLAGS2[FLAGS2["TRANSFER_ENCODING"] = 512] = "TRANSFER_ENCODING";
    })(exports.FLAGS || (exports.FLAGS = {}));
    (function(LENIENT_FLAGS2) {
      LENIENT_FLAGS2[LENIENT_FLAGS2["HEADERS"] = 1] = "HEADERS";
      LENIENT_FLAGS2[LENIENT_FLAGS2["CHUNKED_LENGTH"] = 2] = "CHUNKED_LENGTH";
      LENIENT_FLAGS2[LENIENT_FLAGS2["KEEP_ALIVE"] = 4] = "KEEP_ALIVE";
    })(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
    var METHODS;
    (function(METHODS2) {
      METHODS2[METHODS2["DELETE"] = 0] = "DELETE";
      METHODS2[METHODS2["GET"] = 1] = "GET";
      METHODS2[METHODS2["HEAD"] = 2] = "HEAD";
      METHODS2[METHODS2["POST"] = 3] = "POST";
      METHODS2[METHODS2["PUT"] = 4] = "PUT";
      METHODS2[METHODS2["CONNECT"] = 5] = "CONNECT";
      METHODS2[METHODS2["OPTIONS"] = 6] = "OPTIONS";
      METHODS2[METHODS2["TRACE"] = 7] = "TRACE";
      METHODS2[METHODS2["COPY"] = 8] = "COPY";
      METHODS2[METHODS2["LOCK"] = 9] = "LOCK";
      METHODS2[METHODS2["MKCOL"] = 10] = "MKCOL";
      METHODS2[METHODS2["MOVE"] = 11] = "MOVE";
      METHODS2[METHODS2["PROPFIND"] = 12] = "PROPFIND";
      METHODS2[METHODS2["PROPPATCH"] = 13] = "PROPPATCH";
      METHODS2[METHODS2["SEARCH"] = 14] = "SEARCH";
      METHODS2[METHODS2["UNLOCK"] = 15] = "UNLOCK";
      METHODS2[METHODS2["BIND"] = 16] = "BIND";
      METHODS2[METHODS2["REBIND"] = 17] = "REBIND";
      METHODS2[METHODS2["UNBIND"] = 18] = "UNBIND";
      METHODS2[METHODS2["ACL"] = 19] = "ACL";
      METHODS2[METHODS2["REPORT"] = 20] = "REPORT";
      METHODS2[METHODS2["MKACTIVITY"] = 21] = "MKACTIVITY";
      METHODS2[METHODS2["CHECKOUT"] = 22] = "CHECKOUT";
      METHODS2[METHODS2["MERGE"] = 23] = "MERGE";
      METHODS2[METHODS2["M-SEARCH"] = 24] = "M-SEARCH";
      METHODS2[METHODS2["NOTIFY"] = 25] = "NOTIFY";
      METHODS2[METHODS2["SUBSCRIBE"] = 26] = "SUBSCRIBE";
      METHODS2[METHODS2["UNSUBSCRIBE"] = 27] = "UNSUBSCRIBE";
      METHODS2[METHODS2["PATCH"] = 28] = "PATCH";
      METHODS2[METHODS2["PURGE"] = 29] = "PURGE";
      METHODS2[METHODS2["MKCALENDAR"] = 30] = "MKCALENDAR";
      METHODS2[METHODS2["LINK"] = 31] = "LINK";
      METHODS2[METHODS2["UNLINK"] = 32] = "UNLINK";
      METHODS2[METHODS2["SOURCE"] = 33] = "SOURCE";
      METHODS2[METHODS2["PRI"] = 34] = "PRI";
      METHODS2[METHODS2["DESCRIBE"] = 35] = "DESCRIBE";
      METHODS2[METHODS2["ANNOUNCE"] = 36] = "ANNOUNCE";
      METHODS2[METHODS2["SETUP"] = 37] = "SETUP";
      METHODS2[METHODS2["PLAY"] = 38] = "PLAY";
      METHODS2[METHODS2["PAUSE"] = 39] = "PAUSE";
      METHODS2[METHODS2["TEARDOWN"] = 40] = "TEARDOWN";
      METHODS2[METHODS2["GET_PARAMETER"] = 41] = "GET_PARAMETER";
      METHODS2[METHODS2["SET_PARAMETER"] = 42] = "SET_PARAMETER";
      METHODS2[METHODS2["REDIRECT"] = 43] = "REDIRECT";
      METHODS2[METHODS2["RECORD"] = 44] = "RECORD";
      METHODS2[METHODS2["FLUSH"] = 45] = "FLUSH";
    })(METHODS = exports.METHODS || (exports.METHODS = {}));
    exports.METHODS_HTTP = [
      METHODS.DELETE,
      METHODS.GET,
      METHODS.HEAD,
      METHODS.POST,
      METHODS.PUT,
      METHODS.CONNECT,
      METHODS.OPTIONS,
      METHODS.TRACE,
      METHODS.COPY,
      METHODS.LOCK,
      METHODS.MKCOL,
      METHODS.MOVE,
      METHODS.PROPFIND,
      METHODS.PROPPATCH,
      METHODS.SEARCH,
      METHODS.UNLOCK,
      METHODS.BIND,
      METHODS.REBIND,
      METHODS.UNBIND,
      METHODS.ACL,
      METHODS.REPORT,
      METHODS.MKACTIVITY,
      METHODS.CHECKOUT,
      METHODS.MERGE,
      METHODS["M-SEARCH"],
      METHODS.NOTIFY,
      METHODS.SUBSCRIBE,
      METHODS.UNSUBSCRIBE,
      METHODS.PATCH,
      METHODS.PURGE,
      METHODS.MKCALENDAR,
      METHODS.LINK,
      METHODS.UNLINK,
      METHODS.PRI,
      // TODO(indutny): should we allow it with HTTP?
      METHODS.SOURCE
    ];
    exports.METHODS_ICE = [
      METHODS.SOURCE
    ];
    exports.METHODS_RTSP = [
      METHODS.OPTIONS,
      METHODS.DESCRIBE,
      METHODS.ANNOUNCE,
      METHODS.SETUP,
      METHODS.PLAY,
      METHODS.PAUSE,
      METHODS.TEARDOWN,
      METHODS.GET_PARAMETER,
      METHODS.SET_PARAMETER,
      METHODS.REDIRECT,
      METHODS.RECORD,
      METHODS.FLUSH,
      // For AirPlay
      METHODS.GET,
      METHODS.POST
    ];
    exports.METHOD_MAP = utils_1.enumToMap(METHODS);
    exports.H_METHOD_MAP = {};
    Object.keys(exports.METHOD_MAP).forEach((key) => {
      if (/^H/.test(key)) {
        exports.H_METHOD_MAP[key] = exports.METHOD_MAP[key];
      }
    });
    (function(FINISH2) {
      FINISH2[FINISH2["SAFE"] = 0] = "SAFE";
      FINISH2[FINISH2["SAFE_WITH_CB"] = 1] = "SAFE_WITH_CB";
      FINISH2[FINISH2["UNSAFE"] = 2] = "UNSAFE";
    })(exports.FINISH || (exports.FINISH = {}));
    exports.ALPHA = [];
    for (let i = "A".charCodeAt(0); i <= "Z".charCodeAt(0); i++) {
      exports.ALPHA.push(String.fromCharCode(i));
      exports.ALPHA.push(String.fromCharCode(i + 32));
    }
    exports.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    };
    exports.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    };
    exports.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ];
    exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
    exports.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    exports.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(exports.ALPHANUM);
    exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let i = 128; i <= 255; i++) {
      exports.URL_CHAR.push(i);
    }
    exports.HEX = exports.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    exports.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(exports.ALPHANUM);
    exports.TOKEN = exports.STRICT_TOKEN.concat([" "]);
    exports.HEADER_CHARS = ["	"];
    for (let i = 32; i <= 255; i++) {
      if (i !== 127) {
        exports.HEADER_CHARS.push(i);
      }
    }
    exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
    exports.MAJOR = exports.NUM_MAP;
    exports.MINOR = exports.MAJOR;
    var HEADER_STATE;
    (function(HEADER_STATE2) {
      HEADER_STATE2[HEADER_STATE2["GENERAL"] = 0] = "GENERAL";
      HEADER_STATE2[HEADER_STATE2["CONNECTION"] = 1] = "CONNECTION";
      HEADER_STATE2[HEADER_STATE2["CONTENT_LENGTH"] = 2] = "CONTENT_LENGTH";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING"] = 3] = "TRANSFER_ENCODING";
      HEADER_STATE2[HEADER_STATE2["UPGRADE"] = 4] = "UPGRADE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_KEEP_ALIVE"] = 5] = "CONNECTION_KEEP_ALIVE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_CLOSE"] = 6] = "CONNECTION_CLOSE";
      HEADER_STATE2[HEADER_STATE2["CONNECTION_UPGRADE"] = 7] = "CONNECTION_UPGRADE";
      HEADER_STATE2[HEADER_STATE2["TRANSFER_ENCODING_CHUNKED"] = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {}));
    exports.SPECIAL_HEADERS = {
      "connection": HEADER_STATE.CONNECTION,
      "content-length": HEADER_STATE.CONTENT_LENGTH,
      "proxy-connection": HEADER_STATE.CONNECTION,
      "transfer-encoding": HEADER_STATE.TRANSFER_ENCODING,
      "upgrade": HEADER_STATE.UPGRADE
    };
  }
});

// node_modules/undici/lib/handler/RedirectHandler.js
var require_RedirectHandler = __commonJS({
  "node_modules/undici/lib/handler/RedirectHandler.js"(exports, module) {
    var util = require_util();
    var { kBodyUsed } = require_symbols();
    var assert = __require("assert");
    var { InvalidArgumentError } = require_errors();
    var EE = __require("events");
    var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
    var kBody = Symbol("body");
    var BodyAsyncIterable = class {
      constructor(body) {
        this[kBody] = body;
        this[kBodyUsed] = false;
      }
      async *[Symbol.asyncIterator]() {
        assert(!this[kBodyUsed], "disturbed");
        this[kBodyUsed] = true;
        yield* this[kBody];
      }
    };
    var RedirectHandler = class {
      constructor(dispatch, maxRedirections, opts, handler) {
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        util.validateHandler(handler, opts.method, opts.upgrade);
        this.dispatch = dispatch;
        this.location = null;
        this.abort = null;
        this.opts = { ...opts, maxRedirections: 0 };
        this.maxRedirections = maxRedirections;
        this.handler = handler;
        this.history = [];
        if (util.isStream(this.opts.body)) {
          if (util.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function() {
              assert(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[kBodyUsed] = false;
            EE.prototype.on.call(this.opts.body, "data", function() {
              this[kBodyUsed] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && util.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(abort) {
        this.abort = abort;
        this.handler.onConnect(abort, { history: this.history });
      }
      onUpgrade(statusCode, headers, socket) {
        this.handler.onUpgrade(statusCode, headers, socket);
      }
      onError(error) {
        this.handler.onError(error);
      }
      onHeaders(statusCode, headers, resume, statusText) {
        this.location = this.history.length >= this.maxRedirections || util.isDisturbed(this.opts.body) ? null : parseLocation(statusCode, headers);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(statusCode, headers, resume, statusText);
        }
        const { origin, pathname, search } = util.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const path = search ? `${pathname}${search}` : pathname;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, statusCode === 303, this.opts.origin !== origin);
        this.opts.path = path;
        this.opts.origin = origin;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (statusCode === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(chunk) {
        if (this.location) ; else {
          return this.handler.onData(chunk);
        }
      }
      onComplete(trailers) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(trailers);
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(chunk);
        }
      }
    };
    function parseLocation(statusCode, headers) {
      if (redirectableStatusCodes.indexOf(statusCode) === -1) {
        return null;
      }
      for (let i = 0; i < headers.length; i += 2) {
        if (headers[i].toString().toLowerCase() === "location") {
          return headers[i + 1];
        }
      }
    }
    function shouldRemoveHeader(header, removeContent, unknownOrigin) {
      if (header.length === 4) {
        return util.headerNameToString(header) === "host";
      }
      if (removeContent && util.headerNameToString(header).startsWith("content-")) {
        return true;
      }
      if (unknownOrigin && (header.length === 13 || header.length === 6 || header.length === 19)) {
        const name = util.headerNameToString(header);
        return name === "authorization" || name === "cookie" || name === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(headers, removeContent, unknownOrigin) {
      const ret = [];
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (!shouldRemoveHeader(headers[i], removeContent, unknownOrigin)) {
            ret.push(headers[i], headers[i + 1]);
          }
        }
      } else if (headers && typeof headers === "object") {
        for (const key of Object.keys(headers)) {
          if (!shouldRemoveHeader(key, removeContent, unknownOrigin)) {
            ret.push(key, headers[key]);
          }
        }
      } else {
        assert(headers == null, "headers must be an object or an array");
      }
      return ret;
    }
    module.exports = RedirectHandler;
  }
});

// node_modules/undici/lib/interceptor/redirectInterceptor.js
var require_redirectInterceptor = __commonJS({
  "node_modules/undici/lib/interceptor/redirectInterceptor.js"(exports, module) {
    var RedirectHandler = require_RedirectHandler();
    function createRedirectInterceptor({ maxRedirections: defaultMaxRedirections }) {
      return (dispatch) => {
        return function Intercept(opts, handler) {
          const { maxRedirections = defaultMaxRedirections } = opts;
          if (!maxRedirections) {
            return dispatch(opts, handler);
          }
          const redirectHandler = new RedirectHandler(dispatch, maxRedirections, opts, handler);
          opts = { ...opts, maxRedirections: 0 };
          return dispatch(opts, redirectHandler);
        };
      };
    }
    module.exports = createRedirectInterceptor;
  }
});

// node_modules/undici/lib/llhttp/llhttp-wasm.js
var require_llhttp_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp-wasm.js"(exports, module) {
    module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  }
});

// node_modules/undici/lib/llhttp/llhttp_simd-wasm.js
var require_llhttp_simd_wasm = __commonJS({
  "node_modules/undici/lib/llhttp/llhttp_simd-wasm.js"(exports, module) {
    module.exports = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  }
});

// node_modules/undici/lib/client.js
var require_client = __commonJS({
  "node_modules/undici/lib/client.js"(exports, module) {
    var assert = __require("assert");
    var net = __require("net");
    var http = __require("http");
    var { pipeline } = __require("stream");
    var util = require_util();
    var timers = require_timers();
    var Request = require_request();
    var DispatcherBase = require_dispatcher_base();
    var {
      RequestContentLengthMismatchError,
      ResponseContentLengthMismatchError,
      InvalidArgumentError,
      RequestAbortedError,
      HeadersTimeoutError,
      HeadersOverflowError,
      SocketError,
      InformationalError,
      BodyTimeoutError,
      HTTPParserError,
      ResponseExceededMaxSizeError,
      ClientDestroyedError
    } = require_errors();
    var buildConnector = require_connect();
    var {
      kUrl,
      kReset,
      kServerName,
      kClient,
      kBusy,
      kParser,
      kConnect,
      kBlocking,
      kResuming,
      kRunning,
      kPending,
      kSize,
      kWriting,
      kQueue,
      kConnected,
      kConnecting,
      kNeedDrain,
      kNoRef,
      kKeepAliveDefaultTimeout,
      kHostHeader,
      kPendingIdx,
      kRunningIdx,
      kError,
      kPipelining,
      kSocket,
      kKeepAliveTimeoutValue,
      kMaxHeadersSize,
      kKeepAliveMaxTimeout,
      kKeepAliveTimeoutThreshold,
      kHeadersTimeout,
      kBodyTimeout,
      kStrictContentLength,
      kConnector,
      kMaxRedirections,
      kMaxRequests,
      kCounter,
      kClose,
      kDestroy,
      kDispatch,
      kInterceptors,
      kLocalAddress,
      kMaxResponseSize,
      kHTTPConnVersion,
      // HTTP2
      kHost,
      kHTTP2Session,
      kHTTP2SessionState,
      kHTTP2BuildRequest,
      kHTTP2CopyHeaders,
      kHTTP1BuildRequest
    } = require_symbols();
    var http2;
    try {
      http2 = __require("http2");
    } catch {
      http2 = { constants: {} };
    }
    var {
      constants: {
        HTTP2_HEADER_AUTHORITY,
        HTTP2_HEADER_METHOD,
        HTTP2_HEADER_PATH,
        HTTP2_HEADER_SCHEME,
        HTTP2_HEADER_CONTENT_LENGTH,
        HTTP2_HEADER_EXPECT,
        HTTP2_HEADER_STATUS
      }
    } = http2;
    var h2ExperimentalWarned = false;
    var FastBuffer = Buffer[Symbol.species];
    var kClosedResolve = Symbol("kClosedResolve");
    var channels = {};
    try {
      const diagnosticsChannel = __require("diagnostics_channel");
      channels.sendHeaders = diagnosticsChannel.channel("undici:client:sendHeaders");
      channels.beforeConnect = diagnosticsChannel.channel("undici:client:beforeConnect");
      channels.connectError = diagnosticsChannel.channel("undici:client:connectError");
      channels.connected = diagnosticsChannel.channel("undici:client:connected");
    } catch {
      channels.sendHeaders = { hasSubscribers: false };
      channels.beforeConnect = { hasSubscribers: false };
      channels.connectError = { hasSubscribers: false };
      channels.connected = { hasSubscribers: false };
    }
    var Client = class extends DispatcherBase {
      /**
       *
       * @param {string|URL} url
       * @param {import('../types/client').Client.Options} options
       */
      constructor(url, {
        interceptors,
        maxHeaderSize,
        headersTimeout,
        socketTimeout,
        requestTimeout,
        connectTimeout,
        bodyTimeout,
        idleTimeout,
        keepAlive,
        keepAliveTimeout,
        maxKeepAliveTimeout,
        keepAliveMaxTimeout,
        keepAliveTimeoutThreshold,
        socketPath,
        pipelining,
        tls,
        strictContentLength,
        maxCachedSessions,
        maxRedirections,
        connect: connect2,
        maxRequestsPerClient,
        localAddress,
        maxResponseSize,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        // h2
        allowH2,
        maxConcurrentStreams
      } = {}) {
        super();
        if (keepAlive !== void 0) {
          throw new InvalidArgumentError("unsupported keepAlive, use pipelining=0 instead");
        }
        if (socketTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (requestTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (idleTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (maxKeepAliveTimeout !== void 0) {
          throw new InvalidArgumentError("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
          throw new InvalidArgumentError("invalid maxHeaderSize");
        }
        if (socketPath != null && typeof socketPath !== "string") {
          throw new InvalidArgumentError("invalid socketPath");
        }
        if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
          throw new InvalidArgumentError("invalid connectTimeout");
        }
        if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveTimeout");
        }
        if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {
          throw new InvalidArgumentError("invalid keepAliveMaxTimeout");
        }
        if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
          throw new InvalidArgumentError("invalid keepAliveTimeoutThreshold");
        }
        if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
          throw new InvalidArgumentError("headersTimeout must be a positive integer or zero");
        }
        if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
          throw new InvalidArgumentError("bodyTimeout must be a positive integer or zero");
        }
        if (connect2 != null && typeof connect2 !== "function" && typeof connect2 !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {
          throw new InvalidArgumentError("maxRequestsPerClient must be a positive number");
        }
        if (localAddress != null && (typeof localAddress !== "string" || net.isIP(localAddress) === 0)) {
          throw new InvalidArgumentError("localAddress must be valid string IP address");
        }
        if (maxResponseSize != null && (!Number.isInteger(maxResponseSize) || maxResponseSize < -1)) {
          throw new InvalidArgumentError("maxResponseSize must be a positive number");
        }
        if (autoSelectFamilyAttemptTimeout != null && (!Number.isInteger(autoSelectFamilyAttemptTimeout) || autoSelectFamilyAttemptTimeout < -1)) {
          throw new InvalidArgumentError("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (allowH2 != null && typeof allowH2 !== "boolean") {
          throw new InvalidArgumentError("allowH2 must be a valid boolean value");
        }
        if (maxConcurrentStreams != null && (typeof maxConcurrentStreams !== "number" || maxConcurrentStreams < 1)) {
          throw new InvalidArgumentError("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof connect2 !== "function") {
          connect2 = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect2
          });
        }
        this[kInterceptors] = interceptors && interceptors.Client && Array.isArray(interceptors.Client) ? interceptors.Client : [createRedirectInterceptor({ maxRedirections })];
        this[kUrl] = util.parseOrigin(url);
        this[kConnector] = connect2;
        this[kSocket] = null;
        this[kPipelining] = pipelining != null ? pipelining : 1;
        this[kMaxHeadersSize] = maxHeaderSize || http.maxHeaderSize;
        this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
        this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
        this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
        this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
        this[kServerName] = null;
        this[kLocalAddress] = localAddress != null ? localAddress : null;
        this[kResuming] = 0;
        this[kNeedDrain] = 0;
        this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}\r
`;
        this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e5;
        this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e5;
        this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
        this[kMaxRedirections] = maxRedirections;
        this[kMaxRequests] = maxRequestsPerClient;
        this[kClosedResolve] = null;
        this[kMaxResponseSize] = maxResponseSize > -1 ? maxResponseSize : -1;
        this[kHTTPConnVersion] = "h1";
        this[kHTTP2Session] = null;
        this[kHTTP2SessionState] = !allowH2 ? null : {
          // streams: null, // Fixed queue of streams - For future support of `push`
          openStreams: 0,
          // Keep track of them to decide wether or not unref the session
          maxConcurrentStreams: maxConcurrentStreams != null ? maxConcurrentStreams : 100
          // Max peerConcurrentStreams for a Node h2 server
        };
        this[kHost] = `${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ""}`;
        this[kQueue] = [];
        this[kRunningIdx] = 0;
        this[kPendingIdx] = 0;
      }
      get pipelining() {
        return this[kPipelining];
      }
      set pipelining(value) {
        this[kPipelining] = value;
        resume(this, true);
      }
      get [kPending]() {
        return this[kQueue].length - this[kPendingIdx];
      }
      get [kRunning]() {
        return this[kPendingIdx] - this[kRunningIdx];
      }
      get [kSize]() {
        return this[kQueue].length - this[kRunningIdx];
      }
      get [kConnected]() {
        return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
      }
      get [kBusy]() {
        const socket = this[kSocket];
        return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;
      }
      /* istanbul ignore: only used for test */
      [kConnect](cb) {
        connect(this);
        this.once("connect", cb);
      }
      [kDispatch](opts, handler) {
        const origin = opts.origin || this[kUrl].origin;
        const request = this[kHTTPConnVersion] === "h2" ? Request[kHTTP2BuildRequest](origin, opts, handler) : Request[kHTTP1BuildRequest](origin, opts, handler);
        this[kQueue].push(request);
        if (this[kResuming]) ; else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {
          this[kResuming] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {
          this[kNeedDrain] = 2;
        }
        return this[kNeedDrain] < 2;
      }
      async [kClose]() {
        return new Promise((resolve) => {
          if (!this[kSize]) {
            resolve(null);
          } else {
            this[kClosedResolve] = resolve;
          }
        });
      }
      async [kDestroy](err) {
        return new Promise((resolve) => {
          const requests = this[kQueue].splice(this[kPendingIdx]);
          for (let i = 0; i < requests.length; i++) {
            const request = requests[i];
            errorRequest(this, request, err);
          }
          const callback = () => {
            if (this[kClosedResolve]) {
              this[kClosedResolve]();
              this[kClosedResolve] = null;
            }
            resolve();
          };
          if (this[kHTTP2Session] != null) {
            util.destroy(this[kHTTP2Session], err);
            this[kHTTP2Session] = null;
            this[kHTTP2SessionState] = null;
          }
          if (!this[kSocket]) {
            queueMicrotask(callback);
          } else {
            util.destroy(this[kSocket].on("close", callback), err);
          }
          resume(this);
        });
      }
    };
    function onHttp2SessionError(err) {
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[kSocket][kError] = err;
      onError(this[kClient], err);
    }
    function onHttp2FrameError(type, code, id) {
      const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
      if (id === 0) {
        this[kSocket][kError] = err;
        onError(this[kClient], err);
      }
    }
    function onHttp2SessionEnd() {
      util.destroy(this, new SocketError("other side closed"));
      util.destroy(this[kSocket], new SocketError("other side closed"));
    }
    function onHTTP2GoAway(code) {
      const client = this[kClient];
      const err = new InformationalError(`HTTP/2: "GOAWAY" frame received with code ${code}`);
      client[kSocket] = null;
      client[kHTTP2Session] = null;
      if (client.destroyed) {
        assert(this[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(this, request, err);
        }
      } else if (client[kRunning] > 0) {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit(
        "disconnect",
        client[kUrl],
        [client],
        err
      );
      resume(client);
    }
    var constants = require_constants3();
    var createRedirectInterceptor = require_redirectInterceptor();
    var EMPTY_BUF = Buffer.alloc(0);
    async function lazyllhttp() {
      const llhttpWasmData = process.env.JEST_WORKER_ID ? require_llhttp_wasm() : void 0;
      let mod;
      try {
        mod = await WebAssembly.compile(Buffer.from(require_llhttp_simd_wasm(), "base64"));
      } catch (e) {
        mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require_llhttp_wasm(), "base64"));
      }
      return await WebAssembly.instantiate(mod, {
        env: {
          /* eslint-disable camelcase */
          wasm_on_url: (p, at2, len) => {
            return 0;
          },
          wasm_on_status: (p, at2, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onStatus(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_begin: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageBegin() || 0;
          },
          wasm_on_header_field: (p, at2, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderField(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_header_value: (p, at2, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onHeaderValue(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;
          },
          wasm_on_body: (p, at2, len) => {
            assert.strictEqual(currentParser.ptr, p);
            const start = at2 - currentBufferPtr + currentBufferRef.byteOffset;
            return currentParser.onBody(new FastBuffer(currentBufferRef.buffer, start, len)) || 0;
          },
          wasm_on_message_complete: (p) => {
            assert.strictEqual(currentParser.ptr, p);
            return currentParser.onMessageComplete() || 0;
          }
          /* eslint-enable camelcase */
        }
      });
    }
    var llhttpInstance = null;
    var llhttpPromise = lazyllhttp();
    llhttpPromise.catch();
    var currentParser = null;
    var currentBufferRef = null;
    var currentBufferSize = 0;
    var currentBufferPtr = null;
    var TIMEOUT_HEADERS = 1;
    var TIMEOUT_BODY = 2;
    var TIMEOUT_IDLE = 3;
    var Parser = class {
      constructor(client, socket, { exports: exports2 }) {
        assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);
        this.llhttp = exports2;
        this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
        this.client = client;
        this.socket = socket;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = client[kMaxHeadersSize];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = client[kMaxResponseSize];
      }
      setTimeout(value, type) {
        this.timeoutType = type;
        if (value !== this.timeoutValue) {
          timers.clearTimeout(this.timeout);
          if (value) {
            this.timeout = timers.setTimeout(onParserTimeout, value, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = value;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_resume(this.ptr);
        assert(this.timeoutType === TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || EMPTY_BUF);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const chunk = this.socket.read();
          if (chunk === null) {
            break;
          }
          this.execute(chunk);
        }
      }
      execute(data) {
        assert(this.ptr != null);
        assert(currentParser == null);
        assert(!this.paused);
        const { socket, llhttp } = this;
        if (data.length > currentBufferSize) {
          if (currentBufferPtr) {
            llhttp.free(currentBufferPtr);
          }
          currentBufferSize = Math.ceil(data.length / 4096) * 4096;
          currentBufferPtr = llhttp.malloc(currentBufferSize);
        }
        new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data);
        try {
          let ret;
          try {
            currentBufferRef = data;
            currentParser = this;
            ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);
          } catch (err) {
            throw err;
          } finally {
            currentParser = null;
            currentBufferRef = null;
          }
          const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
          if (ret === constants.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(data.slice(offset));
          } else if (ret === constants.ERROR.PAUSED) {
            this.paused = true;
            socket.unshift(data.slice(offset));
          } else if (ret !== constants.ERROR.OK) {
            const ptr = llhttp.llhttp_get_error_reason(this.ptr);
            let message = "";
            if (ptr) {
              const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
              message = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(llhttp.memory.buffer, ptr, len).toString() + ")";
            }
            throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));
          }
        } catch (err) {
          util.destroy(socket, err);
        }
      }
      destroy() {
        assert(this.ptr != null);
        assert(currentParser == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        timers.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(buf) {
        this.statusText = buf.toString();
      }
      onMessageBegin() {
        const { socket, client } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
      }
      onHeaderField(buf) {
        const len = this.headers.length;
        if ((len & 1) === 0) {
          this.headers.push(buf);
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        this.trackHeader(buf.length);
      }
      onHeaderValue(buf) {
        let len = this.headers.length;
        if ((len & 1) === 1) {
          this.headers.push(buf);
          len += 1;
        } else {
          this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
        }
        const key = this.headers[len - 2];
        if (key.length === 10 && key.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += buf.toString();
        } else if (key.length === 10 && key.toString().toLowerCase() === "connection") {
          this.connection += buf.toString();
        } else if (key.length === 14 && key.toString().toLowerCase() === "content-length") {
          this.contentLength += buf.toString();
        }
        this.trackHeader(buf.length);
      }
      trackHeader(len) {
        this.headersSize += len;
        if (this.headersSize >= this.headersMaxSize) {
          util.destroy(this.socket, new HeadersOverflowError());
        }
      }
      onUpgrade(head) {
        const { upgrade, client, socket, headers, statusCode } = this;
        assert(upgrade);
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(!socket.destroyed);
        assert(socket === client[kSocket]);
        assert(!this.paused);
        assert(request.upgrade || request.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        socket.unshift(head);
        socket[kParser].destroy();
        socket[kParser] = null;
        socket[kClient] = null;
        socket[kError] = null;
        socket.removeListener("error", onSocketError).removeListener("readable", onSocketReadable).removeListener("end", onSocketEnd).removeListener("close", onSocketClose);
        client[kSocket] = null;
        client[kQueue][client[kRunningIdx]++] = null;
        client.emit("disconnect", client[kUrl], [client], new InformationalError("upgrade"));
        try {
          request.onUpgrade(statusCode, headers, socket);
        } catch (err) {
          util.destroy(socket, err);
        }
        resume(client);
      }
      onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {
        const { client, socket, headers, statusText } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        if (!request) {
          return -1;
        }
        assert(!this.upgrade);
        assert(this.statusCode < 200);
        if (statusCode === 100) {
          util.destroy(socket, new SocketError("bad response", util.getSocketInfo(socket)));
          return -1;
        }
        if (upgrade && !request.upgrade) {
          util.destroy(socket, new SocketError("bad upgrade", util.getSocketInfo(socket)));
          return -1;
        }
        assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
        this.statusCode = statusCode;
        this.shouldKeepAlive = shouldKeepAlive || // Override llhttp value which does not allow keepAlive for HEAD.
        request.method === "HEAD" && !socket[kReset] && this.connection.toLowerCase() === "keep-alive";
        if (this.statusCode >= 200) {
          const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];
          this.setTimeout(bodyTimeout, TIMEOUT_BODY);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (request.method === "CONNECT") {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        if (upgrade) {
          assert(client[kRunning] === 1);
          this.upgrade = true;
          return 2;
        }
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && client[kPipelining]) {
          const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;
          if (keepAliveTimeout != null) {
            const timeout = Math.min(
              keepAliveTimeout - client[kKeepAliveTimeoutThreshold],
              client[kKeepAliveMaxTimeout]
            );
            if (timeout <= 0) {
              socket[kReset] = true;
            } else {
              client[kKeepAliveTimeoutValue] = timeout;
            }
          } else {
            client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];
          }
        } else {
          socket[kReset] = true;
        }
        const pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;
        if (request.aborted) {
          return -1;
        }
        if (request.method === "HEAD") {
          return 1;
        }
        if (statusCode < 200) {
          return 1;
        }
        if (socket[kBlocking]) {
          socket[kBlocking] = false;
          resume(client);
        }
        return pause ? constants.ERROR.PAUSED : 0;
      }
      onBody(buf) {
        const { client, socket, statusCode, maxResponseSize } = this;
        if (socket.destroyed) {
          return -1;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert.strictEqual(this.timeoutType, TIMEOUT_BODY);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        assert(statusCode >= 200);
        if (maxResponseSize > -1 && this.bytesRead + buf.length > maxResponseSize) {
          util.destroy(socket, new ResponseExceededMaxSizeError());
          return -1;
        }
        this.bytesRead += buf.length;
        if (request.onData(buf) === false) {
          return constants.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client, socket, statusCode, upgrade, headers, contentLength, bytesRead, shouldKeepAlive } = this;
        if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
          return -1;
        }
        if (upgrade) {
          return;
        }
        const request = client[kQueue][client[kRunningIdx]];
        assert(request);
        assert(statusCode >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        assert(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (statusCode < 200) {
          return;
        }
        if (request.method !== "HEAD" && contentLength && bytesRead !== parseInt(contentLength, 10)) {
          util.destroy(socket, new ResponseContentLengthMismatchError());
          return -1;
        }
        request.onComplete(headers);
        client[kQueue][client[kRunningIdx]++] = null;
        if (socket[kWriting]) {
          assert.strictEqual(client[kRunning], 0);
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (!shouldKeepAlive) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (socket[kReset] && client[kRunning] === 0) {
          util.destroy(socket, new InformationalError("reset"));
          return constants.ERROR.PAUSED;
        } else if (client[kPipelining] === 1) {
          setImmediate(resume, client);
        } else {
          resume(client);
        }
      }
    };
    function onParserTimeout(parser) {
      const { socket, timeoutType, client } = parser;
      if (timeoutType === TIMEOUT_HEADERS) {
        if (!socket[kWriting] || socket.writableNeedDrain || client[kRunning] > 1) {
          assert(!parser.paused, "cannot be paused while waiting for headers");
          util.destroy(socket, new HeadersTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_BODY) {
        if (!parser.paused) {
          util.destroy(socket, new BodyTimeoutError());
        }
      } else if (timeoutType === TIMEOUT_IDLE) {
        assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);
        util.destroy(socket, new InformationalError("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [kParser]: parser } = this;
      if (parser) {
        parser.readMore();
      }
    }
    function onSocketError(err) {
      const { [kClient]: client, [kParser]: parser } = this;
      assert(err.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (client[kHTTPConnVersion] !== "h2") {
        if (err.code === "ECONNRESET" && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      this[kError] = err;
      onError(this[kClient], err);
    }
    function onError(client, err) {
      if (client[kRunning] === 0 && err.code !== "UND_ERR_INFO" && err.code !== "UND_ERR_SOCKET") {
        assert(client[kPendingIdx] === client[kRunningIdx]);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
        assert(client[kSize] === 0);
      }
    }
    function onSocketEnd() {
      const { [kParser]: parser, [kClient]: client } = this;
      if (client[kHTTPConnVersion] !== "h2") {
        if (parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
          return;
        }
      }
      util.destroy(this, new SocketError("other side closed", util.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [kClient]: client, [kParser]: parser } = this;
      if (client[kHTTPConnVersion] === "h1" && parser) {
        if (!this[kError] && parser.statusCode && !parser.shouldKeepAlive) {
          parser.onMessageComplete();
        }
        this[kParser].destroy();
        this[kParser] = null;
      }
      const err = this[kError] || new SocketError("closed", util.getSocketInfo(this));
      client[kSocket] = null;
      if (client.destroyed) {
        assert(client[kPending] === 0);
        const requests = client[kQueue].splice(client[kRunningIdx]);
        for (let i = 0; i < requests.length; i++) {
          const request = requests[i];
          errorRequest(client, request, err);
        }
      } else if (client[kRunning] > 0 && err.code !== "UND_ERR_INFO") {
        const request = client[kQueue][client[kRunningIdx]];
        client[kQueue][client[kRunningIdx]++] = null;
        errorRequest(client, request, err);
      }
      client[kPendingIdx] = client[kRunningIdx];
      assert(client[kRunning] === 0);
      client.emit("disconnect", client[kUrl], [client], err);
      resume(client);
    }
    async function connect(client) {
      assert(!client[kConnecting]);
      assert(!client[kSocket]);
      let { host, hostname, protocol, port } = client[kUrl];
      if (hostname[0] === "[") {
        const idx = hostname.indexOf("]");
        assert(idx !== -1);
        const ip = hostname.substring(1, idx);
        assert(net.isIP(ip));
        hostname = ip;
      }
      client[kConnecting] = true;
      if (channels.beforeConnect.hasSubscribers) {
        channels.beforeConnect.publish({
          connectParams: {
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          },
          connector: client[kConnector]
        });
      }
      try {
        const socket = await new Promise((resolve, reject) => {
          client[kConnector]({
            host,
            hostname,
            protocol,
            port,
            servername: client[kServerName],
            localAddress: client[kLocalAddress]
          }, (err, socket2) => {
            if (err) {
              reject(err);
            } else {
              resolve(socket2);
            }
          });
        });
        if (client.destroyed) {
          util.destroy(socket.on("error", () => {
          }), new ClientDestroyedError());
          return;
        }
        client[kConnecting] = false;
        assert(socket);
        const isH2 = socket.alpnProtocol === "h2";
        if (isH2) {
          if (!h2ExperimentalWarned) {
            h2ExperimentalWarned = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", {
              code: "UNDICI-H2"
            });
          }
          const session = http2.connect(client[kUrl], {
            createConnection: () => socket,
            peerMaxConcurrentStreams: client[kHTTP2SessionState].maxConcurrentStreams
          });
          client[kHTTPConnVersion] = "h2";
          session[kClient] = client;
          session[kSocket] = socket;
          session.on("error", onHttp2SessionError);
          session.on("frameError", onHttp2FrameError);
          session.on("end", onHttp2SessionEnd);
          session.on("goaway", onHTTP2GoAway);
          session.on("close", onSocketClose);
          session.unref();
          client[kHTTP2Session] = session;
          socket[kHTTP2Session] = session;
        } else {
          if (!llhttpInstance) {
            llhttpInstance = await llhttpPromise;
            llhttpPromise = null;
          }
          socket[kNoRef] = false;
          socket[kWriting] = false;
          socket[kReset] = false;
          socket[kBlocking] = false;
          socket[kParser] = new Parser(client, socket, llhttpInstance);
        }
        socket[kCounter] = 0;
        socket[kMaxRequests] = client[kMaxRequests];
        socket[kClient] = client;
        socket[kError] = null;
        socket.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        client[kSocket] = socket;
        if (channels.connected.hasSubscribers) {
          channels.connected.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            socket
          });
        }
        client.emit("connect", client[kUrl], [client]);
      } catch (err) {
        if (client.destroyed) {
          return;
        }
        client[kConnecting] = false;
        if (channels.connectError.hasSubscribers) {
          channels.connectError.publish({
            connectParams: {
              host,
              hostname,
              protocol,
              port,
              servername: client[kServerName],
              localAddress: client[kLocalAddress]
            },
            connector: client[kConnector],
            error: err
          });
        }
        if (err.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          assert(client[kRunning] === 0);
          while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {
            const request = client[kQueue][client[kPendingIdx]++];
            errorRequest(client, request, err);
          }
        } else {
          onError(client, err);
        }
        client.emit("connectionError", client[kUrl], [client], err);
      }
      resume(client);
    }
    function emitDrain(client) {
      client[kNeedDrain] = 0;
      client.emit("drain", client[kUrl], [client]);
    }
    function resume(client, sync) {
      if (client[kResuming] === 2) {
        return;
      }
      client[kResuming] = 2;
      _resume(client, sync);
      client[kResuming] = 0;
      if (client[kRunningIdx] > 256) {
        client[kQueue].splice(0, client[kRunningIdx]);
        client[kPendingIdx] -= client[kRunningIdx];
        client[kRunningIdx] = 0;
      }
    }
    function _resume(client, sync) {
      while (true) {
        if (client.destroyed) {
          assert(client[kPending] === 0);
          return;
        }
        if (client[kClosedResolve] && !client[kSize]) {
          client[kClosedResolve]();
          client[kClosedResolve] = null;
          return;
        }
        const socket = client[kSocket];
        if (socket && !socket.destroyed && socket.alpnProtocol !== "h2") {
          if (client[kSize] === 0) {
            if (!socket[kNoRef] && socket.unref) {
              socket.unref();
              socket[kNoRef] = true;
            }
          } else if (socket[kNoRef] && socket.ref) {
            socket.ref();
            socket[kNoRef] = false;
          }
          if (client[kSize] === 0) {
            if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
              socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
            }
          } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {
            if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
              const request2 = client[kQueue][client[kRunningIdx]];
              const headersTimeout = request2.headersTimeout != null ? request2.headersTimeout : client[kHeadersTimeout];
              socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
            }
          }
        }
        if (client[kBusy]) {
          client[kNeedDrain] = 2;
        } else if (client[kNeedDrain] === 2) {
          if (sync) {
            client[kNeedDrain] = 1;
            process.nextTick(emitDrain, client);
          } else {
            emitDrain(client);
          }
          continue;
        }
        if (client[kPending] === 0) {
          return;
        }
        if (client[kRunning] >= (client[kPipelining] || 1)) {
          return;
        }
        const request = client[kQueue][client[kPendingIdx]];
        if (client[kUrl].protocol === "https:" && client[kServerName] !== request.servername) {
          if (client[kRunning] > 0) {
            return;
          }
          client[kServerName] = request.servername;
          if (socket && socket.servername !== request.servername) {
            util.destroy(socket, new InformationalError("servername changed"));
            return;
          }
        }
        if (client[kConnecting]) {
          return;
        }
        if (!socket && !client[kHTTP2Session]) {
          connect(client);
          return;
        }
        if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
          return;
        }
        if (client[kRunning] > 0 && !request.idempotent) {
          return;
        }
        if (client[kRunning] > 0 && (request.upgrade || request.method === "CONNECT")) {
          return;
        }
        if (client[kRunning] > 0 && util.bodyLength(request.body) !== 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {
          return;
        }
        if (!request.aborted && write(client, request)) {
          client[kPendingIdx]++;
        } else {
          client[kQueue].splice(client[kPendingIdx], 1);
        }
      }
    }
    function shouldSendContentLength(method) {
      return method !== "GET" && method !== "HEAD" && method !== "OPTIONS" && method !== "TRACE" && method !== "CONNECT";
    }
    function write(client, request) {
      if (client[kHTTPConnVersion] === "h2") {
        writeH2(client, client[kHTTP2Session], request);
        return;
      }
      const { body, method, path, host, upgrade, headers, blocking, reset } = request;
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      const bodyLength = util.bodyLength(body);
      let contentLength = bodyLength;
      if (contentLength === null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 && !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength !== null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      const socket = client[kSocket];
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
          util.destroy(socket, new InformationalError("aborted"));
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      if (method === "HEAD") {
        socket[kReset] = true;
      }
      if (upgrade || method === "CONNECT") {
        socket[kReset] = true;
      }
      if (reset != null) {
        socket[kReset] = reset;
      }
      if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {
        socket[kReset] = true;
      }
      if (blocking) {
        socket[kBlocking] = true;
      }
      let header = `${method} ${path} HTTP/1.1\r
`;
      if (typeof host === "string") {
        header += `host: ${host}\r
`;
      } else {
        header += client[kHostHeader];
      }
      if (upgrade) {
        header += `connection: upgrade\r
upgrade: ${upgrade}\r
`;
      } else if (client[kPipelining] && !socket[kReset]) {
        header += "connection: keep-alive\r\n";
      } else {
        header += "connection: close\r\n";
      }
      if (headers) {
        header += headers;
      }
      if (channels.sendHeaders.hasSubscribers) {
        channels.sendHeaders.publish({ request, headers: header, socket });
      }
      if (!body || bodyLength === 0) {
        if (contentLength === 0) {
          socket.write(`${header}content-length: 0\r
\r
`, "latin1");
        } else {
          assert(contentLength === null, "no body must not have content length");
          socket.write(`${header}\r
`, "latin1");
        }
        request.onRequestSent();
      } else if (util.isBuffer(body)) {
        assert(contentLength === body.byteLength, "buffer body must have content length");
        socket.cork();
        socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
        socket.write(body);
        socket.uncork();
        request.onBodySent(body);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
      } else if (util.isBlobLike(body)) {
        if (typeof body.stream === "function") {
          writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload });
        } else {
          writeBlob({ body, client, request, socket, contentLength, header, expectsPayload });
        }
      } else if (util.isStream(body)) {
        writeStream({ body, client, request, socket, contentLength, header, expectsPayload });
      } else if (util.isIterable(body)) {
        writeIterable({ body, client, request, socket, contentLength, header, expectsPayload });
      } else {
        assert(false);
      }
      return true;
    }
    function writeH2(client, session, request) {
      const { body, method, path, host, upgrade, expectContinue, signal, headers: reqHeaders } = request;
      let headers;
      if (typeof reqHeaders === "string") headers = Request[kHTTP2CopyHeaders](reqHeaders.trim());
      else headers = reqHeaders;
      if (upgrade) {
        errorRequest(client, request, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        request.onConnect((err) => {
          if (request.aborted || request.completed) {
            return;
          }
          errorRequest(client, request, err || new RequestAbortedError());
        });
      } catch (err) {
        errorRequest(client, request, err);
      }
      if (request.aborted) {
        return false;
      }
      let stream;
      const h2State = client[kHTTP2SessionState];
      headers[HTTP2_HEADER_AUTHORITY] = host || client[kHost];
      headers[HTTP2_HEADER_METHOD] = method;
      if (method === "CONNECT") {
        session.ref();
        stream = session.request(headers, { endStream: false, signal });
        if (stream.id && !stream.pending) {
          request.onUpgrade(null, null, stream);
          ++h2State.openStreams;
        } else {
          stream.once("ready", () => {
            request.onUpgrade(null, null, stream);
            ++h2State.openStreams;
          });
        }
        stream.once("close", () => {
          h2State.openStreams -= 1;
          if (h2State.openStreams === 0) session.unref();
        });
        return true;
      }
      headers[HTTP2_HEADER_PATH] = path;
      headers[HTTP2_HEADER_SCHEME] = "https";
      const expectsPayload = method === "PUT" || method === "POST" || method === "PATCH";
      if (body && typeof body.read === "function") {
        body.read(0);
      }
      let contentLength = util.bodyLength(body);
      if (contentLength == null) {
        contentLength = request.contentLength;
      }
      if (contentLength === 0 || !expectsPayload) {
        contentLength = null;
      }
      if (shouldSendContentLength(method) && contentLength > 0 && request.contentLength != null && request.contentLength !== contentLength) {
        if (client[kStrictContentLength]) {
          errorRequest(client, request, new RequestContentLengthMismatchError());
          return false;
        }
        process.emitWarning(new RequestContentLengthMismatchError());
      }
      if (contentLength != null) {
        assert(body, "no body must not have content length");
        headers[HTTP2_HEADER_CONTENT_LENGTH] = `${contentLength}`;
      }
      session.ref();
      const shouldEndStream = method === "GET" || method === "HEAD";
      if (expectContinue) {
        headers[HTTP2_HEADER_EXPECT] = "100-continue";
        stream = session.request(headers, { endStream: shouldEndStream, signal });
        stream.once("continue", writeBodyH2);
      } else {
        stream = session.request(headers, {
          endStream: shouldEndStream,
          signal
        });
        writeBodyH2();
      }
      ++h2State.openStreams;
      stream.once("response", (headers2) => {
        const { [HTTP2_HEADER_STATUS]: statusCode, ...realHeaders } = headers2;
        if (request.onHeaders(Number(statusCode), realHeaders, stream.resume.bind(stream), "") === false) {
          stream.pause();
        }
      });
      stream.once("end", () => {
        request.onComplete([]);
      });
      stream.on("data", (chunk) => {
        if (request.onData(chunk) === false) {
          stream.pause();
        }
      });
      stream.once("close", () => {
        h2State.openStreams -= 1;
        if (h2State.openStreams === 0) {
          session.unref();
        }
      });
      stream.once("error", function(err) {
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      stream.once("frameError", (type, code) => {
        const err = new InformationalError(`HTTP/2: "frameError" received - type ${type}, code ${code}`);
        errorRequest(client, request, err);
        if (client[kHTTP2Session] && !client[kHTTP2Session].destroyed && !this.closed && !this.destroyed) {
          h2State.streams -= 1;
          util.destroy(stream, err);
        }
      });
      return true;
      function writeBodyH2() {
        if (!body) {
          request.onRequestSent();
        } else if (util.isBuffer(body)) {
          assert(contentLength === body.byteLength, "buffer body must have content length");
          stream.cork();
          stream.write(body);
          stream.uncork();
          stream.end();
          request.onBodySent(body);
          request.onRequestSent();
        } else if (util.isBlobLike(body)) {
          if (typeof body.stream === "function") {
            writeIterable({
              client,
              request,
              contentLength,
              h2stream: stream,
              expectsPayload,
              body: body.stream(),
              socket: client[kSocket],
              header: ""
            });
          } else {
            writeBlob({
              body,
              client,
              request,
              contentLength,
              expectsPayload,
              h2stream: stream,
              header: "",
              socket: client[kSocket]
            });
          }
        } else if (util.isStream(body)) {
          writeStream({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            socket: client[kSocket],
            h2stream: stream,
            header: ""
          });
        } else if (util.isIterable(body)) {
          writeIterable({
            body,
            client,
            request,
            contentLength,
            expectsPayload,
            header: "",
            h2stream: stream,
            socket: client[kSocket]
          });
        } else {
          assert(false);
        }
      }
    }
    function writeStream({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "stream body cannot be pipelined");
      if (client[kHTTPConnVersion] === "h2") {
        let onPipeData = function(chunk) {
          request.onBodySent(chunk);
        };
        const pipe = pipeline(
          body,
          h2stream,
          (err) => {
            if (err) {
              util.destroy(body, err);
              util.destroy(h2stream, err);
            } else {
              request.onRequestSent();
            }
          }
        );
        pipe.on("data", onPipeData);
        pipe.once("end", () => {
          pipe.removeListener("data", onPipeData);
          util.destroy(pipe);
        });
        return;
      }
      let finished = false;
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      const onData = function(chunk) {
        if (finished) {
          return;
        }
        try {
          if (!writer.write(chunk) && this.pause) {
            this.pause();
          }
        } catch (err) {
          util.destroy(this, err);
        }
      };
      const onDrain = function() {
        if (finished) {
          return;
        }
        if (body.resume) {
          body.resume();
        }
      };
      const onAbort = function() {
        if (finished) {
          return;
        }
        const err = new RequestAbortedError();
        queueMicrotask(() => onFinished(err));
      };
      const onFinished = function(err) {
        if (finished) {
          return;
        }
        finished = true;
        assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);
        socket.off("drain", onDrain).off("error", onFinished);
        body.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!err) {
          try {
            writer.end();
          } catch (er2) {
            err = er2;
          }
        }
        writer.destroy(err);
        if (err && (err.code !== "UND_ERR_INFO" || err.message !== "reset")) {
          util.destroy(body, err);
        } else {
          util.destroy(body);
        }
      };
      body.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (body.resume) {
        body.resume();
      }
      socket.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength === body.size, "blob body must have content length");
      const isH2 = client[kHTTPConnVersion] === "h2";
      try {
        if (contentLength != null && contentLength !== body.size) {
          throw new RequestContentLengthMismatchError();
        }
        const buffer = Buffer.from(await body.arrayBuffer());
        if (isH2) {
          h2stream.cork();
          h2stream.write(buffer);
          h2stream.uncork();
        } else {
          socket.cork();
          socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          socket.write(buffer);
          socket.uncork();
        }
        request.onBodySent(buffer);
        request.onRequestSent();
        if (!expectsPayload) {
          socket[kReset] = true;
        }
        resume(client);
      } catch (err) {
        util.destroy(isH2 ? h2stream : socket, err);
      }
    }
    async function writeIterable({ h2stream, body, client, request, socket, contentLength, header, expectsPayload }) {
      assert(contentLength !== 0 || client[kRunning] === 0, "iterator body cannot be pipelined");
      let callback = null;
      function onDrain() {
        if (callback) {
          const cb = callback;
          callback = null;
          cb();
        }
      }
      const waitForDrain = () => new Promise((resolve, reject) => {
        assert(callback === null);
        if (socket[kError]) {
          reject(socket[kError]);
        } else {
          callback = resolve;
        }
      });
      if (client[kHTTPConnVersion] === "h2") {
        h2stream.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const chunk of body) {
            if (socket[kError]) {
              throw socket[kError];
            }
            const res = h2stream.write(chunk);
            request.onBodySent(chunk);
            if (!res) {
              await waitForDrain();
            }
          }
        } catch (err) {
          h2stream.destroy(err);
        } finally {
          request.onRequestSent();
          h2stream.end();
          h2stream.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      socket.on("close", onDrain).on("drain", onDrain);
      const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header });
      try {
        for await (const chunk of body) {
          if (socket[kError]) {
            throw socket[kError];
          }
          if (!writer.write(chunk)) {
            await waitForDrain();
          }
        }
        writer.end();
      } catch (err) {
        writer.destroy(err);
      } finally {
        socket.off("close", onDrain).off("drain", onDrain);
      }
    }
    var AsyncWriter = class {
      constructor({ socket, request, contentLength, client, expectsPayload, header }) {
        this.socket = socket;
        this.request = request;
        this.contentLength = contentLength;
        this.client = client;
        this.bytesWritten = 0;
        this.expectsPayload = expectsPayload;
        this.header = header;
        socket[kWriting] = true;
      }
      write(chunk) {
        const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return false;
        }
        const len = Buffer.byteLength(chunk);
        if (!len) {
          return true;
        }
        if (contentLength !== null && bytesWritten + len > contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          }
          process.emitWarning(new RequestContentLengthMismatchError());
        }
        socket.cork();
        if (bytesWritten === 0) {
          if (!expectsPayload) {
            socket[kReset] = true;
          }
          if (contentLength === null) {
            socket.write(`${header}transfer-encoding: chunked\r
`, "latin1");
          } else {
            socket.write(`${header}content-length: ${contentLength}\r
\r
`, "latin1");
          }
        }
        if (contentLength === null) {
          socket.write(`\r
${len.toString(16)}\r
`, "latin1");
        }
        this.bytesWritten += len;
        const ret = socket.write(chunk);
        socket.uncork();
        request.onBodySent(chunk);
        if (!ret) {
          if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
            if (socket[kParser].timeout.refresh) {
              socket[kParser].timeout.refresh();
            }
          }
        }
        return ret;
      }
      end() {
        const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this;
        request.onRequestSent();
        socket[kWriting] = false;
        if (socket[kError]) {
          throw socket[kError];
        }
        if (socket.destroyed) {
          return;
        }
        if (bytesWritten === 0) {
          if (expectsPayload) {
            socket.write(`${header}content-length: 0\r
\r
`, "latin1");
          } else {
            socket.write(`${header}\r
`, "latin1");
          }
        } else if (contentLength === null) {
          socket.write("\r\n0\r\n\r\n", "latin1");
        }
        if (contentLength !== null && bytesWritten !== contentLength) {
          if (client[kStrictContentLength]) {
            throw new RequestContentLengthMismatchError();
          } else {
            process.emitWarning(new RequestContentLengthMismatchError());
          }
        }
        if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
          if (socket[kParser].timeout.refresh) {
            socket[kParser].timeout.refresh();
          }
        }
        resume(client);
      }
      destroy(err) {
        const { socket, client } = this;
        socket[kWriting] = false;
        if (err) {
          assert(client[kRunning] <= 1, "pipeline should only contain this request");
          util.destroy(socket, err);
        }
      }
    };
    function errorRequest(client, request, err) {
      try {
        request.onError(err);
        assert(request.aborted);
      } catch (err2) {
        client.emit("error", err2);
      }
    }
    module.exports = Client;
  }
});

// node_modules/undici/lib/node/fixed-queue.js
var require_fixed_queue = __commonJS({
  "node_modules/undici/lib/node/fixed-queue.js"(exports, module) {
    var kSize = 2048;
    var kMask = kSize - 1;
    var FixedCircularBuffer = class {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(kSize);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return (this.top + 1 & kMask) === this.bottom;
      }
      push(data) {
        this.list[this.top] = data;
        this.top = this.top + 1 & kMask;
      }
      shift() {
        const nextItem = this.list[this.bottom];
        if (nextItem === void 0)
          return null;
        this.list[this.bottom] = void 0;
        this.bottom = this.bottom + 1 & kMask;
        return nextItem;
      }
    };
    module.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(data) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(data);
      }
      shift() {
        const tail = this.tail;
        const next = tail.shift();
        if (tail.isEmpty() && tail.next !== null) {
          this.tail = tail.next;
        }
        return next;
      }
    };
  }
});

// node_modules/undici/lib/pool-stats.js
var require_pool_stats = __commonJS({
  "node_modules/undici/lib/pool-stats.js"(exports, module) {
    var { kFree, kConnected, kPending, kQueued, kRunning, kSize } = require_symbols();
    var kPool = Symbol("pool");
    var PoolStats = class {
      constructor(pool) {
        this[kPool] = pool;
      }
      get connected() {
        return this[kPool][kConnected];
      }
      get free() {
        return this[kPool][kFree];
      }
      get pending() {
        return this[kPool][kPending];
      }
      get queued() {
        return this[kPool][kQueued];
      }
      get running() {
        return this[kPool][kRunning];
      }
      get size() {
        return this[kPool][kSize];
      }
    };
    module.exports = PoolStats;
  }
});

// node_modules/undici/lib/pool-base.js
var require_pool_base = __commonJS({
  "node_modules/undici/lib/pool-base.js"(exports, module) {
    var DispatcherBase = require_dispatcher_base();
    var FixedQueue = require_fixed_queue();
    var { kConnected, kSize, kRunning, kPending, kQueued, kBusy, kFree, kUrl, kClose, kDestroy, kDispatch } = require_symbols();
    var PoolStats = require_pool_stats();
    var kClients = Symbol("clients");
    var kNeedDrain = Symbol("needDrain");
    var kQueue = Symbol("queue");
    var kClosedResolve = Symbol("closed resolve");
    var kOnDrain = Symbol("onDrain");
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kGetDispatcher = Symbol("get dispatcher");
    var kAddClient = Symbol("add client");
    var kRemoveClient = Symbol("remove client");
    var kStats = Symbol("stats");
    var PoolBase = class extends DispatcherBase {
      constructor() {
        super();
        this[kQueue] = new FixedQueue();
        this[kClients] = [];
        this[kQueued] = 0;
        const pool = this;
        this[kOnDrain] = function onDrain(origin, targets) {
          const queue = pool[kQueue];
          let needDrain = false;
          while (!needDrain) {
            const item = queue.shift();
            if (!item) {
              break;
            }
            pool[kQueued]--;
            needDrain = !this.dispatch(item.opts, item.handler);
          }
          this[kNeedDrain] = needDrain;
          if (!this[kNeedDrain] && pool[kNeedDrain]) {
            pool[kNeedDrain] = false;
            pool.emit("drain", origin, [pool, ...targets]);
          }
          if (pool[kClosedResolve] && queue.isEmpty()) {
            Promise.all(pool[kClients].map((c) => c.close())).then(pool[kClosedResolve]);
          }
        };
        this[kOnConnect] = (origin, targets) => {
          pool.emit("connect", origin, [pool, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          pool.emit("disconnect", origin, [pool, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          pool.emit("connectionError", origin, [pool, ...targets], err);
        };
        this[kStats] = new PoolStats(this);
      }
      get [kBusy]() {
        return this[kNeedDrain];
      }
      get [kConnected]() {
        return this[kClients].filter((client) => client[kConnected]).length;
      }
      get [kFree]() {
        return this[kClients].filter((client) => client[kConnected] && !client[kNeedDrain]).length;
      }
      get [kPending]() {
        let ret = this[kQueued];
        for (const { [kPending]: pending } of this[kClients]) {
          ret += pending;
        }
        return ret;
      }
      get [kRunning]() {
        let ret = 0;
        for (const { [kRunning]: running } of this[kClients]) {
          ret += running;
        }
        return ret;
      }
      get [kSize]() {
        let ret = this[kQueued];
        for (const { [kSize]: size2 } of this[kClients]) {
          ret += size2;
        }
        return ret;
      }
      get stats() {
        return this[kStats];
      }
      async [kClose]() {
        if (this[kQueue].isEmpty()) {
          return Promise.all(this[kClients].map((c) => c.close()));
        } else {
          return new Promise((resolve) => {
            this[kClosedResolve] = resolve;
          });
        }
      }
      async [kDestroy](err) {
        while (true) {
          const item = this[kQueue].shift();
          if (!item) {
            break;
          }
          item.handler.onError(err);
        }
        return Promise.all(this[kClients].map((c) => c.destroy(err)));
      }
      [kDispatch](opts, handler) {
        const dispatcher = this[kGetDispatcher]();
        if (!dispatcher) {
          this[kNeedDrain] = true;
          this[kQueue].push({ opts, handler });
          this[kQueued]++;
        } else if (!dispatcher.dispatch(opts, handler)) {
          dispatcher[kNeedDrain] = true;
          this[kNeedDrain] = !this[kGetDispatcher]();
        }
        return !this[kNeedDrain];
      }
      [kAddClient](client) {
        client.on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
        this[kClients].push(client);
        if (this[kNeedDrain]) {
          process.nextTick(() => {
            if (this[kNeedDrain]) {
              this[kOnDrain](client[kUrl], [this, client]);
            }
          });
        }
        return this;
      }
      [kRemoveClient](client) {
        client.close(() => {
          const idx = this[kClients].indexOf(client);
          if (idx !== -1) {
            this[kClients].splice(idx, 1);
          }
        });
        this[kNeedDrain] = this[kClients].some((dispatcher) => !dispatcher[kNeedDrain] && dispatcher.closed !== true && dispatcher.destroyed !== true);
      }
    };
    module.exports = {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    };
  }
});

// node_modules/undici/lib/pool.js
var require_pool = __commonJS({
  "node_modules/undici/lib/pool.js"(exports, module) {
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kGetDispatcher
    } = require_pool_base();
    var Client = require_client();
    var {
      InvalidArgumentError
    } = require_errors();
    var util = require_util();
    var { kUrl, kInterceptors } = require_symbols();
    var buildConnector = require_connect();
    var kOptions = Symbol("options");
    var kConnections = Symbol("connections");
    var kFactory = Symbol("factory");
    function defaultFactory(origin, opts) {
      return new Client(origin, opts);
    }
    var Pool = class extends PoolBase {
      constructor(origin, {
        connections,
        factory = defaultFactory,
        connect,
        connectTimeout,
        tls,
        maxCachedSessions,
        socketPath,
        autoSelectFamily,
        autoSelectFamilyAttemptTimeout,
        allowH2,
        ...options
      } = {}) {
        super();
        if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
          throw new InvalidArgumentError("invalid connections");
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (typeof connect !== "function") {
          connect = buildConnector({
            ...tls,
            maxCachedSessions,
            allowH2,
            socketPath,
            timeout: connectTimeout,
            ...util.nodeHasAutoSelectFamily && autoSelectFamily ? { autoSelectFamily, autoSelectFamilyAttemptTimeout } : void 0,
            ...connect
          });
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Pool && Array.isArray(options.interceptors.Pool) ? options.interceptors.Pool : [];
        this[kConnections] = connections || null;
        this[kUrl] = util.parseOrigin(origin);
        this[kOptions] = { ...util.deepClone(options), connect, allowH2 };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kFactory] = factory;
      }
      [kGetDispatcher]() {
        let dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain]);
        if (dispatcher) {
          return dispatcher;
        }
        if (!this[kConnections] || this[kClients].length < this[kConnections]) {
          dispatcher = this[kFactory](this[kUrl], this[kOptions]);
          this[kAddClient](dispatcher);
        }
        return dispatcher;
      }
    };
    module.exports = Pool;
  }
});

// node_modules/undici/lib/balanced-pool.js
var require_balanced_pool = __commonJS({
  "node_modules/undici/lib/balanced-pool.js"(exports, module) {
    var {
      BalancedPoolMissingUpstreamError,
      InvalidArgumentError
    } = require_errors();
    var {
      PoolBase,
      kClients,
      kNeedDrain,
      kAddClient,
      kRemoveClient,
      kGetDispatcher
    } = require_pool_base();
    var Pool = require_pool();
    var { kUrl, kInterceptors } = require_symbols();
    var { parseOrigin } = require_util();
    var kFactory = Symbol("factory");
    var kOptions = Symbol("options");
    var kGreatestCommonDivisor = Symbol("kGreatestCommonDivisor");
    var kCurrentWeight = Symbol("kCurrentWeight");
    var kIndex = Symbol("kIndex");
    var kWeight = Symbol("kWeight");
    var kMaxWeightPerServer = Symbol("kMaxWeightPerServer");
    var kErrorPenalty = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(a, b) {
      if (b === 0) return a;
      return getGreatestCommonDivisor(b, a % b);
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var BalancedPool = class extends PoolBase {
      constructor(upstreams = [], { factory = defaultFactory, ...opts } = {}) {
        super();
        this[kOptions] = opts;
        this[kIndex] = -1;
        this[kCurrentWeight] = 0;
        this[kMaxWeightPerServer] = this[kOptions].maxWeightPerServer || 100;
        this[kErrorPenalty] = this[kOptions].errorPenalty || 15;
        if (!Array.isArray(upstreams)) {
          upstreams = [upstreams];
        }
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        this[kInterceptors] = opts.interceptors && opts.interceptors.BalancedPool && Array.isArray(opts.interceptors.BalancedPool) ? opts.interceptors.BalancedPool : [];
        this[kFactory] = factory;
        for (const upstream of upstreams) {
          this.addUpstream(upstream);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        if (this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true)) {
          return this;
        }
        const pool = this[kFactory](upstreamOrigin, Object.assign({}, this[kOptions]));
        this[kAddClient](pool);
        pool.on("connect", () => {
          pool[kWeight] = Math.min(this[kMaxWeightPerServer], pool[kWeight] + this[kErrorPenalty]);
        });
        pool.on("connectionError", () => {
          pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
          this._updateBalancedPoolStats();
        });
        pool.on("disconnect", (...args) => {
          const err = args[2];
          if (err && err.code === "UND_ERR_SOCKET") {
            pool[kWeight] = Math.max(1, pool[kWeight] - this[kErrorPenalty]);
            this._updateBalancedPoolStats();
          }
        });
        for (const client of this[kClients]) {
          client[kWeight] = this[kMaxWeightPerServer];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[kGreatestCommonDivisor] = this[kClients].map((p) => p[kWeight]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(upstream) {
        const upstreamOrigin = parseOrigin(upstream).origin;
        const pool = this[kClients].find((pool2) => pool2[kUrl].origin === upstreamOrigin && pool2.closed !== true && pool2.destroyed !== true);
        if (pool) {
          this[kRemoveClient](pool);
        }
        return this;
      }
      get upstreams() {
        return this[kClients].filter((dispatcher) => dispatcher.closed !== true && dispatcher.destroyed !== true).map((p) => p[kUrl].origin);
      }
      [kGetDispatcher]() {
        if (this[kClients].length === 0) {
          throw new BalancedPoolMissingUpstreamError();
        }
        const dispatcher = this[kClients].find((dispatcher2) => !dispatcher2[kNeedDrain] && dispatcher2.closed !== true && dispatcher2.destroyed !== true);
        if (!dispatcher) {
          return;
        }
        const allClientsBusy = this[kClients].map((pool) => pool[kNeedDrain]).reduce((a, b) => a && b, true);
        if (allClientsBusy) {
          return;
        }
        let counter = 0;
        let maxWeightIndex = this[kClients].findIndex((pool) => !pool[kNeedDrain]);
        while (counter++ < this[kClients].length) {
          this[kIndex] = (this[kIndex] + 1) % this[kClients].length;
          const pool = this[kClients][this[kIndex]];
          if (pool[kWeight] > this[kClients][maxWeightIndex][kWeight] && !pool[kNeedDrain]) {
            maxWeightIndex = this[kIndex];
          }
          if (this[kIndex] === 0) {
            this[kCurrentWeight] = this[kCurrentWeight] - this[kGreatestCommonDivisor];
            if (this[kCurrentWeight] <= 0) {
              this[kCurrentWeight] = this[kMaxWeightPerServer];
            }
          }
          if (pool[kWeight] >= this[kCurrentWeight] && !pool[kNeedDrain]) {
            return pool;
          }
        }
        this[kCurrentWeight] = this[kClients][maxWeightIndex][kWeight];
        this[kIndex] = maxWeightIndex;
        return this[kClients][maxWeightIndex];
      }
    };
    module.exports = BalancedPool;
  }
});

// node_modules/undici/lib/compat/dispatcher-weakref.js
var require_dispatcher_weakref = __commonJS({
  "node_modules/undici/lib/compat/dispatcher-weakref.js"(exports, module) {
    var { kConnected, kSize } = require_symbols();
    var CompatWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
      }
    };
    var CompatFinalizer = class {
      constructor(finalizer) {
        this.finalizer = finalizer;
      }
      register(dispatcher, key) {
        if (dispatcher.on) {
          dispatcher.on("disconnect", () => {
            if (dispatcher[kConnected] === 0 && dispatcher[kSize] === 0) {
              this.finalizer(key);
            }
          });
        }
      }
    };
    module.exports = function() {
      if (process.env.NODE_V8_COVERAGE) {
        return {
          WeakRef: CompatWeakRef,
          FinalizationRegistry: CompatFinalizer
        };
      }
      return {
        WeakRef: global.WeakRef || CompatWeakRef,
        FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer
      };
    };
  }
});

// node_modules/undici/lib/agent.js
var require_agent = __commonJS({
  "node_modules/undici/lib/agent.js"(exports, module) {
    var { InvalidArgumentError } = require_errors();
    var { kClients, kRunning, kClose, kDestroy, kDispatch, kInterceptors } = require_symbols();
    var DispatcherBase = require_dispatcher_base();
    var Pool = require_pool();
    var Client = require_client();
    var util = require_util();
    var createRedirectInterceptor = require_redirectInterceptor();
    var { WeakRef: WeakRef2, FinalizationRegistry } = require_dispatcher_weakref()();
    var kOnConnect = Symbol("onConnect");
    var kOnDisconnect = Symbol("onDisconnect");
    var kOnConnectionError = Symbol("onConnectionError");
    var kMaxRedirections = Symbol("maxRedirections");
    var kOnDrain = Symbol("onDrain");
    var kFactory = Symbol("factory");
    var kFinalizer = Symbol("finalizer");
    var kOptions = Symbol("options");
    function defaultFactory(origin, opts) {
      return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
    }
    var Agent = class extends DispatcherBase {
      constructor({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {
        super();
        if (typeof factory !== "function") {
          throw new InvalidArgumentError("factory must be a function.");
        }
        if (connect != null && typeof connect !== "function" && typeof connect !== "object") {
          throw new InvalidArgumentError("connect must be a function or an object");
        }
        if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
          throw new InvalidArgumentError("maxRedirections must be a positive number");
        }
        if (connect && typeof connect !== "function") {
          connect = { ...connect };
        }
        this[kInterceptors] = options.interceptors && options.interceptors.Agent && Array.isArray(options.interceptors.Agent) ? options.interceptors.Agent : [createRedirectInterceptor({ maxRedirections })];
        this[kOptions] = { ...util.deepClone(options), connect };
        this[kOptions].interceptors = options.interceptors ? { ...options.interceptors } : void 0;
        this[kMaxRedirections] = maxRedirections;
        this[kFactory] = factory;
        this[kClients] = /* @__PURE__ */ new Map();
        this[kFinalizer] = new FinalizationRegistry(
          /* istanbul ignore next: gc is undeterministic */
          (key) => {
            const ref = this[kClients].get(key);
            if (ref !== void 0 && ref.deref() === void 0) {
              this[kClients].delete(key);
            }
          }
        );
        const agent = this;
        this[kOnDrain] = (origin, targets) => {
          agent.emit("drain", origin, [agent, ...targets]);
        };
        this[kOnConnect] = (origin, targets) => {
          agent.emit("connect", origin, [agent, ...targets]);
        };
        this[kOnDisconnect] = (origin, targets, err) => {
          agent.emit("disconnect", origin, [agent, ...targets], err);
        };
        this[kOnConnectionError] = (origin, targets, err) => {
          agent.emit("connectionError", origin, [agent, ...targets], err);
        };
      }
      get [kRunning]() {
        let ret = 0;
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            ret += client[kRunning];
          }
        }
        return ret;
      }
      [kDispatch](opts, handler) {
        let key;
        if (opts.origin && (typeof opts.origin === "string" || opts.origin instanceof URL)) {
          key = String(opts.origin);
        } else {
          throw new InvalidArgumentError("opts.origin must be a non-empty string or URL.");
        }
        const ref = this[kClients].get(key);
        let dispatcher = ref ? ref.deref() : null;
        if (!dispatcher) {
          dispatcher = this[kFactory](opts.origin, this[kOptions]).on("drain", this[kOnDrain]).on("connect", this[kOnConnect]).on("disconnect", this[kOnDisconnect]).on("connectionError", this[kOnConnectionError]);
          this[kClients].set(key, new WeakRef2(dispatcher));
          this[kFinalizer].register(dispatcher, key);
        }
        return dispatcher.dispatch(opts, handler);
      }
      async [kClose]() {
        const closePromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            closePromises.push(client.close());
          }
        }
        await Promise.all(closePromises);
      }
      async [kDestroy](err) {
        const destroyPromises = [];
        for (const ref of this[kClients].values()) {
          const client = ref.deref();
          if (client) {
            destroyPromises.push(client.destroy(err));
          }
        }
        await Promise.all(destroyPromises);
      }
    };
    module.exports = Agent;
  }
});

// node_modules/undici/lib/api/readable.js
var require_readable = __commonJS({
  "node_modules/undici/lib/api/readable.js"(exports, module) {
    var assert = __require("assert");
    var { Readable } = __require("stream");
    var { RequestAbortedError, NotSupportedError, InvalidArgumentError } = require_errors();
    var util = require_util();
    var { ReadableStreamFrom, toUSVString } = require_util();
    var Blob2;
    var kConsume = Symbol("kConsume");
    var kReading = Symbol("kReading");
    var kBody = Symbol("kBody");
    var kAbort = Symbol("abort");
    var kContentType = Symbol("kContentType");
    var noop = () => {
    };
    module.exports = class BodyReadable extends Readable {
      constructor({
        resume,
        abort,
        contentType = "",
        highWaterMark = 64 * 1024
        // Same as nodejs fs streams.
      }) {
        super({
          autoDestroy: true,
          read: resume,
          highWaterMark
        });
        this._readableState.dataEmitted = false;
        this[kAbort] = abort;
        this[kConsume] = null;
        this[kBody] = null;
        this[kContentType] = contentType;
        this[kReading] = false;
      }
      destroy(err) {
        if (this.destroyed) {
          return this;
        }
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        if (err) {
          this[kAbort]();
        }
        return super.destroy(err);
      }
      emit(ev, ...args) {
        if (ev === "data") {
          this._readableState.dataEmitted = true;
        } else if (ev === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(ev, ...args);
      }
      on(ev, ...args) {
        if (ev === "data" || ev === "readable") {
          this[kReading] = true;
        }
        return super.on(ev, ...args);
      }
      addListener(ev, ...args) {
        return this.on(ev, ...args);
      }
      off(ev, ...args) {
        const ret = super.off(ev, ...args);
        if (ev === "data" || ev === "readable") {
          this[kReading] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return ret;
      }
      removeListener(ev, ...args) {
        return this.off(ev, ...args);
      }
      push(chunk) {
        if (this[kConsume] && chunk !== null && this.readableLength === 0) {
          consumePush(this[kConsume], chunk);
          return this[kReading] ? super.push(chunk) : true;
        }
        return super.push(chunk);
      }
      // https://fetch.spec.whatwg.org/#dom-body-text
      async text() {
        return consume(this, "text");
      }
      // https://fetch.spec.whatwg.org/#dom-body-json
      async json() {
        return consume(this, "json");
      }
      // https://fetch.spec.whatwg.org/#dom-body-blob
      async blob() {
        return consume(this, "blob");
      }
      // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      // https://fetch.spec.whatwg.org/#dom-body-formdata
      async formData() {
        throw new NotSupportedError();
      }
      // https://fetch.spec.whatwg.org/#dom-body-bodyused
      get bodyUsed() {
        return util.isDisturbed(this);
      }
      // https://fetch.spec.whatwg.org/#dom-body-body
      get body() {
        if (!this[kBody]) {
          this[kBody] = ReadableStreamFrom(this);
          if (this[kConsume]) {
            this[kBody].getReader();
            assert(this[kBody].locked);
          }
        }
        return this[kBody];
      }
      dump(opts) {
        let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
        const signal = opts && opts.signal;
        if (signal) {
          try {
            if (typeof signal !== "object" || !("aborted" in signal)) {
              throw new InvalidArgumentError("signal must be an AbortSignal");
            }
            util.throwIfAborted(signal);
          } catch (err) {
            return Promise.reject(err);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((resolve, reject) => {
          const signalListenerCleanup = signal ? util.addAbortListener(signal, () => {
            this.destroy();
          }) : noop;
          this.on("close", function() {
            signalListenerCleanup();
            if (signal && signal.aborted) {
              reject(signal.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              resolve(null);
            }
          }).on("error", noop).on("data", function(chunk) {
            limit -= chunk.length;
            if (limit <= 0) {
              this.destroy();
            }
          }).resume();
        });
      }
    };
    function isLocked(self2) {
      return self2[kBody] && self2[kBody].locked === true || self2[kConsume];
    }
    function isUnusable(self2) {
      return util.isDisturbed(self2) || isLocked(self2);
    }
    async function consume(stream, type) {
      if (isUnusable(stream)) {
        throw new TypeError("unusable");
      }
      assert(!stream[kConsume]);
      return new Promise((resolve, reject) => {
        stream[kConsume] = {
          type,
          stream,
          resolve,
          reject,
          length: 0,
          body: []
        };
        stream.on("error", function(err) {
          consumeFinish(this[kConsume], err);
        }).on("close", function() {
          if (this[kConsume].body !== null) {
            consumeFinish(this[kConsume], new RequestAbortedError());
          }
        });
        process.nextTick(consumeStart, stream[kConsume]);
      });
    }
    function consumeStart(consume2) {
      if (consume2.body === null) {
        return;
      }
      const { _readableState: state } = consume2.stream;
      for (const chunk of state.buffer) {
        consumePush(consume2, chunk);
      }
      if (state.endEmitted) {
        consumeEnd(this[kConsume]);
      } else {
        consume2.stream.on("end", function() {
          consumeEnd(this[kConsume]);
        });
      }
      consume2.stream.resume();
      while (consume2.stream.read() != null) {
      }
    }
    function consumeEnd(consume2) {
      const { type, body, resolve, stream, length } = consume2;
      try {
        if (type === "text") {
          resolve(toUSVString(Buffer.concat(body)));
        } else if (type === "json") {
          resolve(JSON.parse(Buffer.concat(body)));
        } else if (type === "arrayBuffer") {
          const dst = new Uint8Array(length);
          let pos = 0;
          for (const buf of body) {
            dst.set(buf, pos);
            pos += buf.byteLength;
          }
          resolve(dst.buffer);
        } else if (type === "blob") {
          if (!Blob2) {
            Blob2 = __require("buffer").Blob;
          }
          resolve(new Blob2(body, { type: stream[kContentType] }));
        }
        consumeFinish(consume2);
      } catch (err) {
        stream.destroy(err);
      }
    }
    function consumePush(consume2, chunk) {
      consume2.length += chunk.length;
      consume2.body.push(chunk);
    }
    function consumeFinish(consume2, err) {
      if (consume2.body === null) {
        return;
      }
      if (err) {
        consume2.reject(err);
      } else {
        consume2.resolve();
      }
      consume2.type = null;
      consume2.stream = null;
      consume2.resolve = null;
      consume2.reject = null;
      consume2.length = 0;
      consume2.body = null;
    }
  }
});

// node_modules/undici/lib/api/util.js
var require_util3 = __commonJS({
  "node_modules/undici/lib/api/util.js"(exports, module) {
    var assert = __require("assert");
    var {
      ResponseStatusCodeError
    } = require_errors();
    var { toUSVString } = require_util();
    async function getResolveErrorBodyCallback({ callback, body, contentType, statusCode, statusMessage, headers }) {
      assert(body);
      let chunks = [];
      let limit = 0;
      for await (const chunk of body) {
        chunks.push(chunk);
        limit += chunk.length;
        if (limit > 128 * 1024) {
          chunks = null;
          break;
        }
      }
      if (statusCode === 204 || !contentType || !chunks) {
        process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
        return;
      }
      try {
        if (contentType.startsWith("application/json")) {
          const payload = JSON.parse(toUSVString(Buffer.concat(chunks)));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
        if (contentType.startsWith("text/")) {
          const payload = toUSVString(Buffer.concat(chunks));
          process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers, payload));
          return;
        }
      } catch (err) {
      }
      process.nextTick(callback, new ResponseStatusCodeError(`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ""}`, statusCode, headers));
    }
    module.exports = { getResolveErrorBodyCallback };
  }
});

// node_modules/undici/lib/api/abort-signal.js
var require_abort_signal = __commonJS({
  "node_modules/undici/lib/api/abort-signal.js"(exports, module) {
    var { addAbortListener } = require_util();
    var { RequestAbortedError } = require_errors();
    var kListener = Symbol("kListener");
    var kSignal = Symbol("kSignal");
    function abort(self2) {
      if (self2.abort) {
        self2.abort();
      } else {
        self2.onError(new RequestAbortedError());
      }
    }
    function addSignal(self2, signal) {
      self2[kSignal] = null;
      self2[kListener] = null;
      if (!signal) {
        return;
      }
      if (signal.aborted) {
        abort(self2);
        return;
      }
      self2[kSignal] = signal;
      self2[kListener] = () => {
        abort(self2);
      };
      addAbortListener(self2[kSignal], self2[kListener]);
    }
    function removeSignal(self2) {
      if (!self2[kSignal]) {
        return;
      }
      if ("removeEventListener" in self2[kSignal]) {
        self2[kSignal].removeEventListener("abort", self2[kListener]);
      } else {
        self2[kSignal].removeListener("abort", self2[kListener]);
      }
      self2[kSignal] = null;
      self2[kListener] = null;
    }
    module.exports = {
      addSignal,
      removeSignal
    };
  }
});

// node_modules/undici/lib/api/api-request.js
var require_api_request = __commonJS({
  "node_modules/undici/lib/api/api-request.js"(exports, module) {
    var Readable = require_readable();
    var {
      InvalidArgumentError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var RequestHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError, highWaterMark } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (highWaterMark && (typeof highWaterMark !== "number" || highWaterMark < 0)) {
            throw new InvalidArgumentError("invalid highWaterMark");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.body = body;
        this.trailers = {};
        this.context = null;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError;
        this.highWaterMark = highWaterMark;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { callback, opaque, abort, context, responseHeaders, highWaterMark } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
        const contentType = parsedHeaders["content-type"];
        const body = new Readable({ resume, abort, contentType, highWaterMark });
        this.callback = null;
        this.res = body;
        if (callback !== null) {
          if (this.throwOnError && statusCode >= 400) {
            this.runInAsyncScope(
              getResolveErrorBodyCallback,
              null,
              { callback, body, contentType, statusCode, statusMessage, headers }
            );
          } else {
            this.runInAsyncScope(callback, null, null, {
              statusCode,
              headers,
              trailers: this.trailers,
              opaque,
              body,
              context
            });
          }
        }
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        util.parseHeaders(trailers, this.trailers);
        res.push(null);
      }
      onError(err) {
        const { res, callback, body, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (res) {
          this.res = null;
          queueMicrotask(() => {
            util.destroy(res, err);
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function request(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          request.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new RequestHandler(opts, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = request;
    module.exports.RequestHandler = RequestHandler;
  }
});

// node_modules/undici/lib/api/api-stream.js
var require_api_stream = __commonJS({
  "node_modules/undici/lib/api/api-stream.js"(exports, module) {
    var { finished, PassThrough } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { getResolveErrorBodyCallback } = require_util3();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var StreamHandler = class extends AsyncResource {
      constructor(opts, factory, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        const { signal, method, opaque, body, onInfo, responseHeaders, throwOnError } = opts;
        try {
          if (typeof callback !== "function") {
            throw new InvalidArgumentError("invalid callback");
          }
          if (typeof factory !== "function") {
            throw new InvalidArgumentError("invalid factory");
          }
          if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
            throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
          }
          if (method === "CONNECT") {
            throw new InvalidArgumentError("invalid method");
          }
          if (onInfo && typeof onInfo !== "function") {
            throw new InvalidArgumentError("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (err) {
          if (util.isStream(body)) {
            util.destroy(body.on("error", util.nop), err);
          }
          throw err;
        }
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.factory = factory;
        this.callback = callback;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = body;
        this.onInfo = onInfo || null;
        this.throwOnError = throwOnError || false;
        if (util.isStream(body)) {
          body.on("error", (err) => {
            this.onError(err);
          });
        }
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const { factory, opaque, context, callback, responseHeaders } = this;
        const headers = responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        if (statusCode < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.factory = null;
        let res;
        if (this.throwOnError && statusCode >= 400) {
          const parsedHeaders = responseHeaders === "raw" ? util.parseHeaders(rawHeaders) : headers;
          const contentType = parsedHeaders["content-type"];
          res = new PassThrough();
          this.callback = null;
          this.runInAsyncScope(
            getResolveErrorBodyCallback,
            null,
            { callback, body: res, contentType, statusCode, statusMessage, headers }
          );
        } else {
          if (factory === null) {
            return;
          }
          res = this.runInAsyncScope(factory, null, {
            statusCode,
            headers,
            opaque,
            context
          });
          if (!res || typeof res.write !== "function" || typeof res.end !== "function" || typeof res.on !== "function") {
            throw new InvalidReturnValueError("expected Writable");
          }
          finished(res, { readable: false }, (err) => {
            const { callback: callback2, res: res2, opaque: opaque2, trailers, abort } = this;
            this.res = null;
            if (err || !res2.readable) {
              util.destroy(res2, err);
            }
            this.callback = null;
            this.runInAsyncScope(callback2, null, err || null, { opaque: opaque2, trailers });
            if (err) {
              abort();
            }
          });
        }
        res.on("drain", resume);
        this.res = res;
        const needDrain = res.writableNeedDrain !== void 0 ? res.writableNeedDrain : res._writableState && res._writableState.needDrain;
        return needDrain !== true;
      }
      onData(chunk) {
        const { res } = this;
        return res ? res.write(chunk) : true;
      }
      onComplete(trailers) {
        const { res } = this;
        removeSignal(this);
        if (!res) {
          return;
        }
        this.trailers = util.parseHeaders(trailers);
        res.end();
      }
      onError(err) {
        const { res, callback, opaque, body } = this;
        removeSignal(this);
        this.factory = null;
        if (res) {
          this.res = null;
          util.destroy(res, err);
        } else if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
        if (body) {
          this.body = null;
          util.destroy(body, err);
        }
      }
    };
    function stream(opts, factory, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          stream.call(this, opts, factory, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        this.dispatch(opts, new StreamHandler(opts, factory, callback));
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = stream;
  }
});

// node_modules/undici/lib/api/api-pipeline.js
var require_api_pipeline = __commonJS({
  "node_modules/undici/lib/api/api-pipeline.js"(exports, module) {
    var {
      Readable,
      Duplex,
      PassThrough
    } = __require("stream");
    var {
      InvalidArgumentError,
      InvalidReturnValueError,
      RequestAbortedError
    } = require_errors();
    var util = require_util();
    var { AsyncResource } = __require("async_hooks");
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = __require("assert");
    var kResume = Symbol("resume");
    var PipelineRequest = class extends Readable {
      constructor() {
        super({ autoDestroy: true });
        this[kResume] = null;
      }
      _read() {
        const { [kResume]: resume } = this;
        if (resume) {
          this[kResume] = null;
          resume();
        }
      }
      _destroy(err, callback) {
        this._read();
        callback(err);
      }
    };
    var PipelineResponse = class extends Readable {
      constructor(resume) {
        super({ autoDestroy: true });
        this[kResume] = resume;
      }
      _read() {
        this[kResume]();
      }
      _destroy(err, callback) {
        if (!err && !this._readableState.endEmitted) {
          err = new RequestAbortedError();
        }
        callback(err);
      }
    };
    var PipelineHandler = class extends AsyncResource {
      constructor(opts, handler) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof handler !== "function") {
          throw new InvalidArgumentError("invalid handler");
        }
        const { signal, method, opaque, onInfo, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        if (method === "CONNECT") {
          throw new InvalidArgumentError("invalid method");
        }
        if (onInfo && typeof onInfo !== "function") {
          throw new InvalidArgumentError("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.handler = handler;
        this.abort = null;
        this.context = null;
        this.onInfo = onInfo || null;
        this.req = new PipelineRequest().on("error", util.nop);
        this.ret = new Duplex({
          readableObjectMode: opts.objectMode,
          autoDestroy: true,
          read: () => {
            const { body } = this;
            if (body && body.resume) {
              body.resume();
            }
          },
          write: (chunk, encoding, callback) => {
            const { req } = this;
            if (req.push(chunk, encoding) || req._readableState.destroyed) {
              callback();
            } else {
              req[kResume] = callback;
            }
          },
          destroy: (err, callback) => {
            const { body, req, res, ret, abort } = this;
            if (!err && !ret._readableState.endEmitted) {
              err = new RequestAbortedError();
            }
            if (abort && err) {
              abort();
            }
            util.destroy(body, err);
            util.destroy(req, err);
            util.destroy(res, err);
            removeSignal(this);
            callback(err);
          }
        }).on("prefinish", () => {
          const { req } = this;
          req.push(null);
        });
        this.res = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        const { ret, res } = this;
        assert(!res, "pipeline cannot be retried");
        if (ret.destroyed) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders(statusCode, rawHeaders, resume) {
        const { opaque, handler, context } = this;
        if (statusCode < 200) {
          if (this.onInfo) {
            const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
            this.onInfo({ statusCode, headers });
          }
          return;
        }
        this.res = new PipelineResponse(resume);
        let body;
        try {
          this.handler = null;
          const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
          body = this.runInAsyncScope(handler, null, {
            statusCode,
            headers,
            opaque,
            body: this.res,
            context
          });
        } catch (err) {
          this.res.on("error", util.nop);
          throw err;
        }
        if (!body || typeof body.on !== "function") {
          throw new InvalidReturnValueError("expected Readable");
        }
        body.on("data", (chunk) => {
          const { ret, body: body2 } = this;
          if (!ret.push(chunk) && body2.pause) {
            body2.pause();
          }
        }).on("error", (err) => {
          const { ret } = this;
          util.destroy(ret, err);
        }).on("end", () => {
          const { ret } = this;
          ret.push(null);
        }).on("close", () => {
          const { ret } = this;
          if (!ret._readableState.ended) {
            util.destroy(ret, new RequestAbortedError());
          }
        });
        this.body = body;
      }
      onData(chunk) {
        const { res } = this;
        return res.push(chunk);
      }
      onComplete(trailers) {
        const { res } = this;
        res.push(null);
      }
      onError(err) {
        const { ret } = this;
        this.handler = null;
        util.destroy(ret, err);
      }
    };
    function pipeline(opts, handler) {
      try {
        const pipelineHandler = new PipelineHandler(opts, handler);
        this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
        return pipelineHandler.ret;
      } catch (err) {
        return new PassThrough().destroy(err);
      }
    }
    module.exports = pipeline;
  }
});

// node_modules/undici/lib/api/api-upgrade.js
var require_api_upgrade = __commonJS({
  "node_modules/undici/lib/api/api-upgrade.js"(exports, module) {
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var { AsyncResource } = __require("async_hooks");
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var assert = __require("assert");
    var UpgradeHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = responseHeaders || null;
        this.opaque = opaque || null;
        this.callback = callback;
        this.abort = null;
        this.context = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = null;
      }
      onHeaders() {
        throw new SocketError("bad upgrade", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        assert.strictEqual(statusCode, 101);
        removeSignal(this);
        this.callback = null;
        const headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        this.runInAsyncScope(callback, null, null, {
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function upgrade(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          upgrade.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const upgradeHandler = new UpgradeHandler(opts, callback);
        this.dispatch({
          ...opts,
          method: opts.method || "GET",
          upgrade: opts.protocol || "Websocket"
        }, upgradeHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = upgrade;
  }
});

// node_modules/undici/lib/api/api-connect.js
var require_api_connect = __commonJS({
  "node_modules/undici/lib/api/api-connect.js"(exports, module) {
    var { AsyncResource } = __require("async_hooks");
    var { InvalidArgumentError, RequestAbortedError, SocketError } = require_errors();
    var util = require_util();
    var { addSignal, removeSignal } = require_abort_signal();
    var ConnectHandler = class extends AsyncResource {
      constructor(opts, callback) {
        if (!opts || typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (typeof callback !== "function") {
          throw new InvalidArgumentError("invalid callback");
        }
        const { signal, opaque, responseHeaders } = opts;
        if (signal && typeof signal.on !== "function" && typeof signal.addEventListener !== "function") {
          throw new InvalidArgumentError("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = opaque || null;
        this.responseHeaders = responseHeaders || null;
        this.callback = callback;
        this.abort = null;
        addSignal(this, signal);
      }
      onConnect(abort, context) {
        if (!this.callback) {
          throw new RequestAbortedError();
        }
        this.abort = abort;
        this.context = context;
      }
      onHeaders() {
        throw new SocketError("bad connect", null);
      }
      onUpgrade(statusCode, rawHeaders, socket) {
        const { callback, opaque, context } = this;
        removeSignal(this);
        this.callback = null;
        let headers = rawHeaders;
        if (headers != null) {
          headers = this.responseHeaders === "raw" ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);
        }
        this.runInAsyncScope(callback, null, null, {
          statusCode,
          headers,
          socket,
          opaque,
          context
        });
      }
      onError(err) {
        const { callback, opaque } = this;
        removeSignal(this);
        if (callback) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(callback, null, err, { opaque });
          });
        }
      }
    };
    function connect(opts, callback) {
      if (callback === void 0) {
        return new Promise((resolve, reject) => {
          connect.call(this, opts, (err, data) => {
            return err ? reject(err) : resolve(data);
          });
        });
      }
      try {
        const connectHandler = new ConnectHandler(opts, callback);
        this.dispatch({ ...opts, method: "CONNECT" }, connectHandler);
      } catch (err) {
        if (typeof callback !== "function") {
          throw err;
        }
        const opaque = opts && opts.opaque;
        queueMicrotask(() => callback(err, { opaque }));
      }
    }
    module.exports = connect;
  }
});

// node_modules/undici/lib/api/index.js
var require_api = __commonJS({
  "node_modules/undici/lib/api/index.js"(exports, module) {
    module.exports.request = require_api_request();
    module.exports.stream = require_api_stream();
    module.exports.pipeline = require_api_pipeline();
    module.exports.upgrade = require_api_upgrade();
    module.exports.connect = require_api_connect();
  }
});

// node_modules/undici/lib/mock/mock-errors.js
var require_mock_errors = __commonJS({
  "node_modules/undici/lib/mock/mock-errors.js"(exports, module) {
    var { UndiciError } = require_errors();
    var MockNotMatchedError = class _MockNotMatchedError extends UndiciError {
      constructor(message) {
        super(message);
        Error.captureStackTrace(this, _MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = message || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    };
    module.exports = {
      MockNotMatchedError
    };
  }
});

// node_modules/undici/lib/mock/mock-symbols.js
var require_mock_symbols = __commonJS({
  "node_modules/undici/lib/mock/mock-symbols.js"(exports, module) {
    module.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected")
    };
  }
});

// node_modules/undici/lib/mock/mock-utils.js
var require_mock_utils = __commonJS({
  "node_modules/undici/lib/mock/mock-utils.js"(exports, module) {
    var { MockNotMatchedError } = require_mock_errors();
    var {
      kDispatches,
      kMockAgent,
      kOriginalDispatch,
      kOrigin,
      kGetNetConnect
    } = require_mock_symbols();
    var { buildURL, nop } = require_util();
    var { STATUS_CODES } = __require("http");
    var {
      types: {
        isPromise
      }
    } = __require("util");
    function matchValue(match, value) {
      if (typeof match === "string") {
        return match === value;
      }
      if (match instanceof RegExp) {
        return match.test(value);
      }
      if (typeof match === "function") {
        return match(value) === true;
      }
      return false;
    }
    function lowerCaseEntries(headers) {
      return Object.fromEntries(
        Object.entries(headers).map(([headerName, headerValue]) => {
          return [headerName.toLocaleLowerCase(), headerValue];
        })
      );
    }
    function getHeaderByName(headers, key) {
      if (Array.isArray(headers)) {
        for (let i = 0; i < headers.length; i += 2) {
          if (headers[i].toLocaleLowerCase() === key.toLocaleLowerCase()) {
            return headers[i + 1];
          }
        }
        return void 0;
      } else if (typeof headers.get === "function") {
        return headers.get(key);
      } else {
        return lowerCaseEntries(headers)[key.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(headers) {
      const clone = headers.slice();
      const entries = [];
      for (let index = 0; index < clone.length; index += 2) {
        entries.push([clone[index], clone[index + 1]]);
      }
      return Object.fromEntries(entries);
    }
    function matchHeaders(mockDispatch2, headers) {
      if (typeof mockDispatch2.headers === "function") {
        if (Array.isArray(headers)) {
          headers = buildHeadersFromArray(headers);
        }
        return mockDispatch2.headers(headers ? lowerCaseEntries(headers) : {});
      }
      if (typeof mockDispatch2.headers === "undefined") {
        return true;
      }
      if (typeof headers !== "object" || typeof mockDispatch2.headers !== "object") {
        return false;
      }
      for (const [matchHeaderName, matchHeaderValue] of Object.entries(mockDispatch2.headers)) {
        const headerValue = getHeaderByName(headers, matchHeaderName);
        if (!matchValue(matchHeaderValue, headerValue)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(path) {
      if (typeof path !== "string") {
        return path;
      }
      const pathSegments = path.split("?");
      if (pathSegments.length !== 2) {
        return path;
      }
      const qp = new URLSearchParams(pathSegments.pop());
      qp.sort();
      return [...pathSegments, qp.toString()].join("?");
    }
    function matchKey(mockDispatch2, { path, method, body, headers }) {
      const pathMatch = matchValue(mockDispatch2.path, path);
      const methodMatch = matchValue(mockDispatch2.method, method);
      const bodyMatch = typeof mockDispatch2.body !== "undefined" ? matchValue(mockDispatch2.body, body) : true;
      const headersMatch = matchHeaders(mockDispatch2, headers);
      return pathMatch && methodMatch && bodyMatch && headersMatch;
    }
    function getResponseData(data) {
      if (Buffer.isBuffer(data)) {
        return data;
      } else if (typeof data === "object") {
        return JSON.stringify(data);
      } else {
        return data.toString();
      }
    }
    function getMockDispatch(mockDispatches, key) {
      const basePath = key.query ? buildURL(key.path, key.query) : key.path;
      const resolvedPath = typeof basePath === "string" ? safeUrl(basePath) : basePath;
      let matchedMockDispatches = mockDispatches.filter(({ consumed }) => !consumed).filter(({ path }) => matchValue(safeUrl(path), resolvedPath));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for path '${resolvedPath}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ method }) => matchValue(method, key.method));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for method '${key.method}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter(({ body }) => typeof body !== "undefined" ? matchValue(body, key.body) : true);
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for body '${key.body}'`);
      }
      matchedMockDispatches = matchedMockDispatches.filter((mockDispatch2) => matchHeaders(mockDispatch2, key.headers));
      if (matchedMockDispatches.length === 0) {
        throw new MockNotMatchedError(`Mock dispatch not matched for headers '${typeof key.headers === "object" ? JSON.stringify(key.headers) : key.headers}'`);
      }
      return matchedMockDispatches[0];
    }
    function addMockDispatch(mockDispatches, key, data) {
      const baseData = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const replyData = typeof data === "function" ? { callback: data } : { ...data };
      const newMockDispatch = { ...baseData, ...key, pending: true, data: { error: null, ...replyData } };
      mockDispatches.push(newMockDispatch);
      return newMockDispatch;
    }
    function deleteMockDispatch(mockDispatches, key) {
      const index = mockDispatches.findIndex((dispatch) => {
        if (!dispatch.consumed) {
          return false;
        }
        return matchKey(dispatch, key);
      });
      if (index !== -1) {
        mockDispatches.splice(index, 1);
      }
    }
    function buildKey(opts) {
      const { path, method, body, headers, query } = opts;
      return {
        path,
        method,
        body,
        headers,
        query
      };
    }
    function generateKeyValues(data) {
      return Object.entries(data).reduce((keyValuePairs, [key, value]) => [
        ...keyValuePairs,
        Buffer.from(`${key}`),
        Array.isArray(value) ? value.map((x2) => Buffer.from(`${x2}`)) : Buffer.from(`${value}`)
      ], []);
    }
    function getStatusText(statusCode) {
      return STATUS_CODES[statusCode] || "unknown";
    }
    async function getResponse(body) {
      const buffers = [];
      for await (const data of body) {
        buffers.push(data);
      }
      return Buffer.concat(buffers).toString("utf8");
    }
    function mockDispatch(opts, handler) {
      const key = buildKey(opts);
      const mockDispatch2 = getMockDispatch(this[kDispatches], key);
      mockDispatch2.timesInvoked++;
      if (mockDispatch2.data.callback) {
        mockDispatch2.data = { ...mockDispatch2.data, ...mockDispatch2.data.callback(opts) };
      }
      const { data: { statusCode, data, headers, trailers, error }, delay, persist } = mockDispatch2;
      const { timesInvoked, times } = mockDispatch2;
      mockDispatch2.consumed = !persist && timesInvoked >= times;
      mockDispatch2.pending = timesInvoked < times;
      if (error !== null) {
        deleteMockDispatch(this[kDispatches], key);
        handler.onError(error);
        return true;
      }
      if (typeof delay === "number" && delay > 0) {
        setTimeout(() => {
          handleReply(this[kDispatches]);
        }, delay);
      } else {
        handleReply(this[kDispatches]);
      }
      function handleReply(mockDispatches, _data = data) {
        const optsHeaders = Array.isArray(opts.headers) ? buildHeadersFromArray(opts.headers) : opts.headers;
        const body = typeof _data === "function" ? _data({ ...opts, headers: optsHeaders }) : _data;
        if (isPromise(body)) {
          body.then((newData) => handleReply(mockDispatches, newData));
          return;
        }
        const responseData = getResponseData(body);
        const responseHeaders = generateKeyValues(headers);
        const responseTrailers = generateKeyValues(trailers);
        handler.abort = nop;
        handler.onHeaders(statusCode, responseHeaders, resume, getStatusText(statusCode));
        handler.onData(Buffer.from(responseData));
        handler.onComplete(responseTrailers);
        deleteMockDispatch(mockDispatches, key);
      }
      function resume() {
      }
      return true;
    }
    function buildMockDispatch() {
      const agent = this[kMockAgent];
      const origin = this[kOrigin];
      const originalDispatch = this[kOriginalDispatch];
      return function dispatch(opts, handler) {
        if (agent.isMockActive) {
          try {
            mockDispatch.call(this, opts, handler);
          } catch (error) {
            if (error instanceof MockNotMatchedError) {
              const netConnect = agent[kGetNetConnect]();
              if (netConnect === false) {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(netConnect, origin)) {
                originalDispatch.call(this, opts, handler);
              } else {
                throw new MockNotMatchedError(`${error.message}: subsequent request to origin ${origin} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw error;
            }
          }
        } else {
          originalDispatch.call(this, opts, handler);
        }
      };
    }
    function checkNetConnect(netConnect, origin) {
      const url = new URL(origin);
      if (netConnect === true) {
        return true;
      } else if (Array.isArray(netConnect) && netConnect.some((matcher) => matchValue(matcher, url.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(opts) {
      if (opts) {
        const { agent, ...mockOptions } = opts;
        return mockOptions;
      }
    }
    module.exports = {
      getResponseData,
      getMockDispatch,
      addMockDispatch,
      deleteMockDispatch,
      buildKey,
      generateKeyValues,
      matchValue,
      getResponse,
      getStatusText,
      mockDispatch,
      buildMockDispatch,
      checkNetConnect,
      buildMockOptions,
      getHeaderByName
    };
  }
});

// node_modules/undici/lib/mock/mock-interceptor.js
var require_mock_interceptor = __commonJS({
  "node_modules/undici/lib/mock/mock-interceptor.js"(exports, module) {
    var { getResponseData, buildKey, addMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kDispatchKey,
      kDefaultHeaders,
      kDefaultTrailers,
      kContentLength,
      kMockDispatch
    } = require_mock_symbols();
    var { InvalidArgumentError } = require_errors();
    var { buildURL } = require_util();
    var MockScope = class {
      constructor(mockDispatch) {
        this[kMockDispatch] = mockDispatch;
      }
      /**
       * Delay a reply by a set amount in ms.
       */
      delay(waitInMs) {
        if (typeof waitInMs !== "number" || !Number.isInteger(waitInMs) || waitInMs <= 0) {
          throw new InvalidArgumentError("waitInMs must be a valid integer > 0");
        }
        this[kMockDispatch].delay = waitInMs;
        return this;
      }
      /**
       * For a defined reply, never mark as consumed.
       */
      persist() {
        this[kMockDispatch].persist = true;
        return this;
      }
      /**
       * Allow one to define a reply for a set amount of matching requests.
       */
      times(repeatTimes) {
        if (typeof repeatTimes !== "number" || !Number.isInteger(repeatTimes) || repeatTimes <= 0) {
          throw new InvalidArgumentError("repeatTimes must be a valid integer > 0");
        }
        this[kMockDispatch].times = repeatTimes;
        return this;
      }
    };
    var MockInterceptor = class {
      constructor(opts, mockDispatches) {
        if (typeof opts !== "object") {
          throw new InvalidArgumentError("opts must be an object");
        }
        if (typeof opts.path === "undefined") {
          throw new InvalidArgumentError("opts.path must be defined");
        }
        if (typeof opts.method === "undefined") {
          opts.method = "GET";
        }
        if (typeof opts.path === "string") {
          if (opts.query) {
            opts.path = buildURL(opts.path, opts.query);
          } else {
            const parsedURL = new URL(opts.path, "data://");
            opts.path = parsedURL.pathname + parsedURL.search;
          }
        }
        if (typeof opts.method === "string") {
          opts.method = opts.method.toUpperCase();
        }
        this[kDispatchKey] = buildKey(opts);
        this[kDispatches] = mockDispatches;
        this[kDefaultHeaders] = {};
        this[kDefaultTrailers] = {};
        this[kContentLength] = false;
      }
      createMockScopeDispatchData(statusCode, data, responseOptions = {}) {
        const responseData = getResponseData(data);
        const contentLength = this[kContentLength] ? { "content-length": responseData.length } : {};
        const headers = { ...this[kDefaultHeaders], ...contentLength, ...responseOptions.headers };
        const trailers = { ...this[kDefaultTrailers], ...responseOptions.trailers };
        return { statusCode, data, headers, trailers };
      }
      validateReplyParameters(statusCode, data, responseOptions) {
        if (typeof statusCode === "undefined") {
          throw new InvalidArgumentError("statusCode must be defined");
        }
        if (typeof data === "undefined") {
          throw new InvalidArgumentError("data must be defined");
        }
        if (typeof responseOptions !== "object") {
          throw new InvalidArgumentError("responseOptions must be an object");
        }
      }
      /**
       * Mock an undici request with a defined reply.
       */
      reply(replyData) {
        if (typeof replyData === "function") {
          const wrappedDefaultsCallback = (opts) => {
            const resolvedData = replyData(opts);
            if (typeof resolvedData !== "object") {
              throw new InvalidArgumentError("reply options callback must return an object");
            }
            const { statusCode: statusCode2, data: data2 = "", responseOptions: responseOptions2 = {} } = resolvedData;
            this.validateReplyParameters(statusCode2, data2, responseOptions2);
            return {
              ...this.createMockScopeDispatchData(statusCode2, data2, responseOptions2)
            };
          };
          const newMockDispatch2 = addMockDispatch(this[kDispatches], this[kDispatchKey], wrappedDefaultsCallback);
          return new MockScope(newMockDispatch2);
        }
        const [statusCode, data = "", responseOptions = {}] = [...arguments];
        this.validateReplyParameters(statusCode, data, responseOptions);
        const dispatchData = this.createMockScopeDispatchData(statusCode, data, responseOptions);
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], dispatchData);
        return new MockScope(newMockDispatch);
      }
      /**
       * Mock an undici request with a defined error.
       */
      replyWithError(error) {
        if (typeof error === "undefined") {
          throw new InvalidArgumentError("error must be defined");
        }
        const newMockDispatch = addMockDispatch(this[kDispatches], this[kDispatchKey], { error });
        return new MockScope(newMockDispatch);
      }
      /**
       * Set default reply headers on the interceptor for subsequent replies
       */
      defaultReplyHeaders(headers) {
        if (typeof headers === "undefined") {
          throw new InvalidArgumentError("headers must be defined");
        }
        this[kDefaultHeaders] = headers;
        return this;
      }
      /**
       * Set default reply trailers on the interceptor for subsequent replies
       */
      defaultReplyTrailers(trailers) {
        if (typeof trailers === "undefined") {
          throw new InvalidArgumentError("trailers must be defined");
        }
        this[kDefaultTrailers] = trailers;
        return this;
      }
      /**
       * Set reply content length header for replies on the interceptor
       */
      replyContentLength() {
        this[kContentLength] = true;
        return this;
      }
    };
    module.exports.MockInterceptor = MockInterceptor;
    module.exports.MockScope = MockScope;
  }
});

// node_modules/undici/lib/mock/mock-client.js
var require_mock_client = __commonJS({
  "node_modules/undici/lib/mock/mock-client.js"(exports, module) {
    var { promisify } = __require("util");
    var Client = require_client();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockClient = class extends Client {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockClient;
  }
});

// node_modules/undici/lib/mock/mock-pool.js
var require_mock_pool = __commonJS({
  "node_modules/undici/lib/mock/mock-pool.js"(exports, module) {
    var { promisify } = __require("util");
    var Pool = require_pool();
    var { buildMockDispatch } = require_mock_utils();
    var {
      kDispatches,
      kMockAgent,
      kClose,
      kOriginalClose,
      kOrigin,
      kOriginalDispatch,
      kConnected
    } = require_mock_symbols();
    var { MockInterceptor } = require_mock_interceptor();
    var Symbols = require_symbols();
    var { InvalidArgumentError } = require_errors();
    var MockPool = class extends Pool {
      constructor(origin, opts) {
        super(origin, opts);
        if (!opts || !opts.agent || typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        this[kMockAgent] = opts.agent;
        this[kOrigin] = origin;
        this[kDispatches] = [];
        this[kConnected] = 1;
        this[kOriginalDispatch] = this.dispatch;
        this[kOriginalClose] = this.close.bind(this);
        this.dispatch = buildMockDispatch.call(this);
        this.close = this[kClose];
      }
      get [Symbols.kConnected]() {
        return this[kConnected];
      }
      /**
       * Sets up the base interceptor for mocking replies from undici.
       */
      intercept(opts) {
        return new MockInterceptor(opts, this[kDispatches]);
      }
      async [kClose]() {
        await promisify(this[kOriginalClose])();
        this[kConnected] = 0;
        this[kMockAgent][Symbols.kClients].delete(this[kOrigin]);
      }
    };
    module.exports = MockPool;
  }
});

// node_modules/undici/lib/mock/pluralizer.js
var require_pluralizer = __commonJS({
  "node_modules/undici/lib/mock/pluralizer.js"(exports, module) {
    var singulars = {
      pronoun: "it",
      is: "is",
      was: "was",
      this: "this"
    };
    var plurals = {
      pronoun: "they",
      is: "are",
      was: "were",
      this: "these"
    };
    module.exports = class Pluralizer {
      constructor(singular, plural) {
        this.singular = singular;
        this.plural = plural;
      }
      pluralize(count) {
        const one = count === 1;
        const keys = one ? singulars : plurals;
        const noun = one ? this.singular : this.plural;
        return { ...keys, count, noun };
      }
    };
  }
});

// node_modules/undici/lib/mock/pending-interceptors-formatter.js
var require_pending_interceptors_formatter = __commonJS({
  "node_modules/undici/lib/mock/pending-interceptors-formatter.js"(exports, module) {
    var { Transform } = __require("stream");
    var { Console } = __require("console");
    module.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors } = {}) {
        this.transform = new Transform({
          transform(chunk, _enc, cb) {
            cb(null, chunk);
          }
        });
        this.logger = new Console({
          stdout: this.transform,
          inspectOptions: {
            colors: !disableColors && !process.env.CI
          }
        });
      }
      format(pendingInterceptors) {
        const withPrettyHeaders = pendingInterceptors.map(
          ({ method, path, data: { statusCode }, persist, times, timesInvoked, origin }) => ({
            Method: method,
            Origin: origin,
            Path: path,
            "Status code": statusCode,
            Persistent: persist ? "\u2705" : "\u274C",
            Invocations: timesInvoked,
            Remaining: persist ? Infinity : times - timesInvoked
          })
        );
        this.logger.table(withPrettyHeaders);
        return this.transform.read().toString();
      }
    };
  }
});

// node_modules/undici/lib/mock/mock-agent.js
var require_mock_agent = __commonJS({
  "node_modules/undici/lib/mock/mock-agent.js"(exports, module) {
    var { kClients } = require_symbols();
    var Agent = require_agent();
    var {
      kAgent,
      kMockAgentSet,
      kMockAgentGet,
      kDispatches,
      kIsMockActive,
      kNetConnect,
      kGetNetConnect,
      kOptions,
      kFactory
    } = require_mock_symbols();
    var MockClient = require_mock_client();
    var MockPool = require_mock_pool();
    var { matchValue, buildMockOptions } = require_mock_utils();
    var { InvalidArgumentError, UndiciError } = require_errors();
    var Dispatcher = require_dispatcher();
    var Pluralizer = require_pluralizer();
    var PendingInterceptorsFormatter = require_pending_interceptors_formatter();
    var FakeWeakRef = class {
      constructor(value) {
        this.value = value;
      }
      deref() {
        return this.value;
      }
    };
    var MockAgent = class extends Dispatcher {
      constructor(opts) {
        super(opts);
        this[kNetConnect] = true;
        this[kIsMockActive] = true;
        if (opts && opts.agent && typeof opts.agent.dispatch !== "function") {
          throw new InvalidArgumentError("Argument opts.agent must implement Agent");
        }
        const agent = opts && opts.agent ? opts.agent : new Agent(opts);
        this[kAgent] = agent;
        this[kClients] = agent[kClients];
        this[kOptions] = buildMockOptions(opts);
      }
      get(origin) {
        let dispatcher = this[kMockAgentGet](origin);
        if (!dispatcher) {
          dispatcher = this[kFactory](origin);
          this[kMockAgentSet](origin, dispatcher);
        }
        return dispatcher;
      }
      dispatch(opts, handler) {
        this.get(opts.origin);
        return this[kAgent].dispatch(opts, handler);
      }
      async close() {
        await this[kAgent].close();
        this[kClients].clear();
      }
      deactivate() {
        this[kIsMockActive] = false;
      }
      activate() {
        this[kIsMockActive] = true;
      }
      enableNetConnect(matcher) {
        if (typeof matcher === "string" || typeof matcher === "function" || matcher instanceof RegExp) {
          if (Array.isArray(this[kNetConnect])) {
            this[kNetConnect].push(matcher);
          } else {
            this[kNetConnect] = [matcher];
          }
        } else if (typeof matcher === "undefined") {
          this[kNetConnect] = true;
        } else {
          throw new InvalidArgumentError("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[kNetConnect] = false;
      }
      // This is required to bypass issues caused by using global symbols - see:
      // https://github.com/nodejs/undici/issues/1447
      get isMockActive() {
        return this[kIsMockActive];
      }
      [kMockAgentSet](origin, dispatcher) {
        this[kClients].set(origin, new FakeWeakRef(dispatcher));
      }
      [kFactory](origin) {
        const mockOptions = Object.assign({ agent: this }, this[kOptions]);
        return this[kOptions] && this[kOptions].connections === 1 ? new MockClient(origin, mockOptions) : new MockPool(origin, mockOptions);
      }
      [kMockAgentGet](origin) {
        const ref = this[kClients].get(origin);
        if (ref) {
          return ref.deref();
        }
        if (typeof origin !== "string") {
          const dispatcher = this[kFactory]("http://localhost:9999");
          this[kMockAgentSet](origin, dispatcher);
          return dispatcher;
        }
        for (const [keyMatcher, nonExplicitRef] of Array.from(this[kClients])) {
          const nonExplicitDispatcher = nonExplicitRef.deref();
          if (nonExplicitDispatcher && typeof keyMatcher !== "string" && matchValue(keyMatcher, origin)) {
            const dispatcher = this[kFactory](origin);
            this[kMockAgentSet](origin, dispatcher);
            dispatcher[kDispatches] = nonExplicitDispatcher[kDispatches];
            return dispatcher;
          }
        }
      }
      [kGetNetConnect]() {
        return this[kNetConnect];
      }
      pendingInterceptors() {
        const mockAgentClients = this[kClients];
        return Array.from(mockAgentClients.entries()).flatMap(([origin, scope]) => scope.deref()[kDispatches].map((dispatch) => ({ ...dispatch, origin }))).filter(({ pending }) => pending);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter = new PendingInterceptorsFormatter() } = {}) {
        const pending = this.pendingInterceptors();
        if (pending.length === 0) {
          return;
        }
        const pluralizer = new Pluralizer("interceptor", "interceptors").pluralize(pending.length);
        throw new UndiciError(`
${pluralizer.count} ${pluralizer.noun} ${pluralizer.is} pending:

${pendingInterceptorsFormatter.format(pending)}
`.trim());
      }
    };
    module.exports = MockAgent;
  }
});

// node_modules/undici/lib/proxy-agent.js
var require_proxy_agent = __commonJS({
  "node_modules/undici/lib/proxy-agent.js"(exports, module) {
    var { kProxy, kClose, kDestroy, kInterceptors } = require_symbols();
    var { URL: URL2 } = __require("url");
    var Agent = require_agent();
    var Pool = require_pool();
    var DispatcherBase = require_dispatcher_base();
    var { InvalidArgumentError, RequestAbortedError } = require_errors();
    var buildConnector = require_connect();
    var kAgent = Symbol("proxy agent");
    var kClient = Symbol("proxy client");
    var kProxyHeaders = Symbol("proxy headers");
    var kRequestTls = Symbol("request tls settings");
    var kProxyTls = Symbol("proxy tls settings");
    var kConnectEndpoint = Symbol("connect endpoint function");
    function defaultProtocolPort(protocol) {
      return protocol === "https:" ? 443 : 80;
    }
    function buildProxyOptions(opts) {
      if (typeof opts === "string") {
        opts = { uri: opts };
      }
      if (!opts || !opts.uri) {
        throw new InvalidArgumentError("Proxy opts.uri is mandatory");
      }
      return {
        uri: opts.uri,
        protocol: opts.protocol || "https"
      };
    }
    function defaultFactory(origin, opts) {
      return new Pool(origin, opts);
    }
    var ProxyAgent = class extends DispatcherBase {
      constructor(opts) {
        super(opts);
        this[kProxy] = buildProxyOptions(opts);
        this[kAgent] = new Agent(opts);
        this[kInterceptors] = opts.interceptors && opts.interceptors.ProxyAgent && Array.isArray(opts.interceptors.ProxyAgent) ? opts.interceptors.ProxyAgent : [];
        if (typeof opts === "string") {
          opts = { uri: opts };
        }
        if (!opts || !opts.uri) {
          throw new InvalidArgumentError("Proxy opts.uri is mandatory");
        }
        const { clientFactory = defaultFactory } = opts;
        if (typeof clientFactory !== "function") {
          throw new InvalidArgumentError("Proxy opts.clientFactory must be a function.");
        }
        this[kRequestTls] = opts.requestTls;
        this[kProxyTls] = opts.proxyTls;
        this[kProxyHeaders] = opts.headers || {};
        const resolvedUrl = new URL2(opts.uri);
        const { origin, port, host, username, password } = resolvedUrl;
        if (opts.auth && opts.token) {
          throw new InvalidArgumentError("opts.auth cannot be used in combination with opts.token");
        } else if (opts.auth) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${opts.auth}`;
        } else if (opts.token) {
          this[kProxyHeaders]["proxy-authorization"] = opts.token;
        } else if (username && password) {
          this[kProxyHeaders]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(username)}:${decodeURIComponent(password)}`).toString("base64")}`;
        }
        const connect = buildConnector({ ...opts.proxyTls });
        this[kConnectEndpoint] = buildConnector({ ...opts.requestTls });
        this[kClient] = clientFactory(resolvedUrl, { connect });
        this[kAgent] = new Agent({
          ...opts,
          connect: async (opts2, callback) => {
            let requestedHost = opts2.host;
            if (!opts2.port) {
              requestedHost += `:${defaultProtocolPort(opts2.protocol)}`;
            }
            try {
              const { socket, statusCode } = await this[kClient].connect({
                origin,
                port,
                path: requestedHost,
                signal: opts2.signal,
                headers: {
                  ...this[kProxyHeaders],
                  host
                }
              });
              if (statusCode !== 200) {
                socket.on("error", () => {
                }).destroy();
                callback(new RequestAbortedError(`Proxy response (${statusCode}) !== 200 when HTTP Tunneling`));
              }
              if (opts2.protocol !== "https:") {
                callback(null, socket);
                return;
              }
              let servername;
              if (this[kRequestTls]) {
                servername = this[kRequestTls].servername;
              } else {
                servername = opts2.servername;
              }
              this[kConnectEndpoint]({ ...opts2, servername, httpSocket: socket }, callback);
            } catch (err) {
              callback(err);
            }
          }
        });
      }
      dispatch(opts, handler) {
        const { host } = new URL2(opts.origin);
        const headers = buildHeaders(opts.headers);
        throwIfProxyAuthIsSent(headers);
        return this[kAgent].dispatch(
          {
            ...opts,
            headers: {
              ...headers,
              host
            }
          },
          handler
        );
      }
      async [kClose]() {
        await this[kAgent].close();
        await this[kClient].close();
      }
      async [kDestroy]() {
        await this[kAgent].destroy();
        await this[kClient].destroy();
      }
    };
    function buildHeaders(headers) {
      if (Array.isArray(headers)) {
        const headersPair = {};
        for (let i = 0; i < headers.length; i += 2) {
          headersPair[headers[i]] = headers[i + 1];
        }
        return headersPair;
      }
      return headers;
    }
    function throwIfProxyAuthIsSent(headers) {
      const existProxyAuth = headers && Object.keys(headers).find((key) => key.toLowerCase() === "proxy-authorization");
      if (existProxyAuth) {
        throw new InvalidArgumentError("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    module.exports = ProxyAgent;
  }
});

// node_modules/undici/lib/handler/RetryHandler.js
var require_RetryHandler = __commonJS({
  "node_modules/undici/lib/handler/RetryHandler.js"(exports, module) {
    var assert = __require("assert");
    var { kRetryHandlerDefaultRetry } = require_symbols();
    var { RequestRetryError } = require_errors();
    var { isDisturbed, parseHeaders, parseRangeHeader } = require_util();
    function calculateRetryAfterHeader(retryAfter) {
      const current = Date.now();
      const diff2 = new Date(retryAfter).getTime() - current;
      return diff2;
    }
    var RetryHandler = class _RetryHandler {
      constructor(opts, handlers) {
        const { retryOptions, ...dispatchOpts } = opts;
        const {
          // Retry scoped
          retry: retryFn,
          maxRetries,
          maxTimeout,
          minTimeout,
          timeoutFactor,
          // Response scoped
          methods,
          errorCodes,
          retryAfter,
          statusCodes
        } = retryOptions ?? {};
        this.dispatch = handlers.dispatch;
        this.handler = handlers.handler;
        this.opts = dispatchOpts;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: retryFn ?? _RetryHandler[kRetryHandlerDefaultRetry],
          retryAfter: retryAfter ?? true,
          maxTimeout: maxTimeout ?? 30 * 1e3,
          // 30s,
          timeout: minTimeout ?? 500,
          // .5s
          timeoutFactor: timeoutFactor ?? 2,
          maxRetries: maxRetries ?? 5,
          // What errors we should retry
          methods: methods ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          // Indicates which errors to retry
          statusCodes: statusCodes ?? [500, 502, 503, 504, 429],
          // List of errors to retry
          errorCodes: errorCodes ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE"
          ]
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((reason) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(reason);
          } else {
            this.reason = reason;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(statusCode, headers, socket) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(statusCode, headers, socket);
        }
      }
      onConnect(abort) {
        if (this.aborted) {
          abort(this.reason);
        } else {
          this.abort = abort;
        }
      }
      onBodySent(chunk) {
        if (this.handler.onBodySent) return this.handler.onBodySent(chunk);
      }
      static [kRetryHandlerDefaultRetry](err, { state, opts }, cb) {
        const { statusCode, code, headers } = err;
        const { method, retryOptions } = opts;
        const {
          maxRetries,
          timeout,
          maxTimeout,
          timeoutFactor,
          statusCodes,
          errorCodes,
          methods
        } = retryOptions;
        let { counter, currentTimeout } = state;
        currentTimeout = currentTimeout != null && currentTimeout > 0 ? currentTimeout : timeout;
        if (code && code !== "UND_ERR_REQ_RETRY" && code !== "UND_ERR_SOCKET" && !errorCodes.includes(code)) {
          cb(err);
          return;
        }
        if (Array.isArray(methods) && !methods.includes(method)) {
          cb(err);
          return;
        }
        if (statusCode != null && Array.isArray(statusCodes) && !statusCodes.includes(statusCode)) {
          cb(err);
          return;
        }
        if (counter > maxRetries) {
          cb(err);
          return;
        }
        let retryAfterHeader = headers != null && headers["retry-after"];
        if (retryAfterHeader) {
          retryAfterHeader = Number(retryAfterHeader);
          retryAfterHeader = isNaN(retryAfterHeader) ? calculateRetryAfterHeader(retryAfterHeader) : retryAfterHeader * 1e3;
        }
        const retryTimeout = retryAfterHeader > 0 ? Math.min(retryAfterHeader, maxTimeout) : Math.min(currentTimeout * timeoutFactor ** counter, maxTimeout);
        state.currentTimeout = retryTimeout;
        setTimeout(() => cb(null), retryTimeout);
      }
      onHeaders(statusCode, rawHeaders, resume, statusMessage) {
        const headers = parseHeaders(rawHeaders);
        this.retryCount += 1;
        if (statusCode >= 300) {
          this.abort(
            new RequestRetryError("Request failed", statusCode, {
              headers,
              count: this.retryCount
            })
          );
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (statusCode !== 206) {
            return true;
          }
          const contentRange = parseRangeHeader(headers["content-range"]);
          if (!contentRange) {
            this.abort(
              new RequestRetryError("Content-Range mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          if (this.etag != null && this.etag !== headers.etag) {
            this.abort(
              new RequestRetryError("ETag mismatch", statusCode, {
                headers,
                count: this.retryCount
              })
            );
            return false;
          }
          const { start, size: size2, end = size2 } = contentRange;
          assert(this.start === start, "content-range mismatch");
          assert(this.end == null || this.end === end, "content-range mismatch");
          this.resume = resume;
          return true;
        }
        if (this.end == null) {
          if (statusCode === 206) {
            const range = parseRangeHeader(headers["content-range"]);
            if (range == null) {
              return this.handler.onHeaders(
                statusCode,
                rawHeaders,
                resume,
                statusMessage
              );
            }
            const { start, size: size2, end = size2 } = range;
            assert(
              start != null && Number.isFinite(start) && this.start !== start,
              "content-range mismatch"
            );
            assert(Number.isFinite(start));
            assert(
              end != null && Number.isFinite(end) && this.end !== end,
              "invalid content-length"
            );
            this.start = start;
            this.end = end;
          }
          if (this.end == null) {
            const contentLength = headers["content-length"];
            this.end = contentLength != null ? Number(contentLength) : null;
          }
          assert(Number.isFinite(this.start));
          assert(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length"
          );
          this.resume = resume;
          this.etag = headers.etag != null ? headers.etag : null;
          return this.handler.onHeaders(
            statusCode,
            rawHeaders,
            resume,
            statusMessage
          );
        }
        const err = new RequestRetryError("Request failed", statusCode, {
          headers,
          count: this.retryCount
        });
        this.abort(err);
        return false;
      }
      onData(chunk) {
        this.start += chunk.length;
        return this.handler.onData(chunk);
      }
      onComplete(rawTrailers) {
        this.retryCount = 0;
        return this.handler.onComplete(rawTrailers);
      }
      onError(err) {
        if (this.aborted || isDisturbed(this.opts.body)) {
          return this.handler.onError(err);
        }
        this.retryOpts.retry(
          err,
          {
            state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
            opts: { retryOptions: this.retryOpts, ...this.opts }
          },
          onRetry.bind(this)
        );
        function onRetry(err2) {
          if (err2 != null || this.aborted || isDisturbed(this.opts.body)) {
            return this.handler.onError(err2);
          }
          if (this.start !== 0) {
            this.opts = {
              ...this.opts,
              headers: {
                ...this.opts.headers,
                range: `bytes=${this.start}-${this.end ?? ""}`
              }
            };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (err3) {
            this.handler.onError(err3);
          }
        }
      }
    };
    module.exports = RetryHandler;
  }
});

// node_modules/undici/lib/global.js
var require_global2 = __commonJS({
  "node_modules/undici/lib/global.js"(exports, module) {
    var globalDispatcher = Symbol.for("undici.globalDispatcher.1");
    var { InvalidArgumentError } = require_errors();
    var Agent = require_agent();
    if (getGlobalDispatcher() === void 0) {
      setGlobalDispatcher(new Agent());
    }
    function setGlobalDispatcher(agent) {
      if (!agent || typeof agent.dispatch !== "function") {
        throw new InvalidArgumentError("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, globalDispatcher, {
        value: agent,
        writable: true,
        enumerable: false,
        configurable: false
      });
    }
    function getGlobalDispatcher() {
      return globalThis[globalDispatcher];
    }
    module.exports = {
      setGlobalDispatcher,
      getGlobalDispatcher
    };
  }
});

// node_modules/undici/lib/handler/DecoratorHandler.js
var require_DecoratorHandler = __commonJS({
  "node_modules/undici/lib/handler/DecoratorHandler.js"(exports, module) {
    module.exports = class DecoratorHandler {
      constructor(handler) {
        this.handler = handler;
      }
      onConnect(...args) {
        return this.handler.onConnect(...args);
      }
      onError(...args) {
        return this.handler.onError(...args);
      }
      onUpgrade(...args) {
        return this.handler.onUpgrade(...args);
      }
      onHeaders(...args) {
        return this.handler.onHeaders(...args);
      }
      onData(...args) {
        return this.handler.onData(...args);
      }
      onComplete(...args) {
        return this.handler.onComplete(...args);
      }
      onBodySent(...args) {
        return this.handler.onBodySent(...args);
      }
    };
  }
});

// node_modules/undici/lib/fetch/headers.js
var require_headers = __commonJS({
  "node_modules/undici/lib/fetch/headers.js"(exports, module) {
    var { kHeadersList, kConstruct } = require_symbols();
    var { kGuard } = require_symbols2();
    var { kEnumerableProperty } = require_util();
    var {
      makeIterator,
      isValidHeaderName,
      isValidHeaderValue
    } = require_util2();
    var { webidl } = require_webidl();
    var assert = __require("assert");
    var kHeadersMap = Symbol("headers map");
    var kHeadersSortedMap = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(code) {
      return code === 10 || code === 13 || code === 9 || code === 32;
    }
    function headerValueNormalize(potentialValue) {
      let i = 0;
      let j = potentialValue.length;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(j - 1))) --j;
      while (j > i && isHTTPWhiteSpaceCharCode(potentialValue.charCodeAt(i))) ++i;
      return i === 0 && j === potentialValue.length ? potentialValue : potentialValue.substring(i, j);
    }
    function fill(headers, object) {
      if (Array.isArray(object)) {
        for (let i = 0; i < object.length; ++i) {
          const header = object[i];
          if (header.length !== 2) {
            throw webidl.errors.exception({
              header: "Headers constructor",
              message: `expected name/value pair to be length 2, found ${header.length}.`
            });
          }
          appendHeader(headers, header[0], header[1]);
        }
      } else if (typeof object === "object" && object !== null) {
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; ++i) {
          appendHeader(headers, keys[i], object[keys[i]]);
        }
      } else {
        throw webidl.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
        });
      }
    }
    function appendHeader(headers, name, value) {
      value = headerValueNormalize(value);
      if (!isValidHeaderName(name)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value: name,
          type: "header name"
        });
      } else if (!isValidHeaderValue(value)) {
        throw webidl.errors.invalidArgument({
          prefix: "Headers.append",
          value,
          type: "header value"
        });
      }
      if (headers[kGuard] === "immutable") {
        throw new TypeError("immutable");
      } else if (headers[kGuard] === "request-no-cors") ;
      return headers[kHeadersList].append(name, value);
    }
    var HeadersList = class _HeadersList {
      constructor(init) {
        /** @type {[string, string][]|null} */
        __publicField(this, "cookies", null);
        if (init instanceof _HeadersList) {
          this[kHeadersMap] = new Map(init[kHeadersMap]);
          this[kHeadersSortedMap] = init[kHeadersSortedMap];
          this.cookies = init.cookies === null ? null : [...init.cookies];
        } else {
          this[kHeadersMap] = new Map(init);
          this[kHeadersSortedMap] = null;
        }
      }
      // https://fetch.spec.whatwg.org/#header-list-contains
      contains(name) {
        name = name.toLowerCase();
        return this[kHeadersMap].has(name);
      }
      clear() {
        this[kHeadersMap].clear();
        this[kHeadersSortedMap] = null;
        this.cookies = null;
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-append
      append(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        const exists = this[kHeadersMap].get(lowercaseName);
        if (exists) {
          const delimiter = lowercaseName === "cookie" ? "; " : ", ";
          this[kHeadersMap].set(lowercaseName, {
            name: exists.name,
            value: `${exists.value}${delimiter}${value}`
          });
        } else {
          this[kHeadersMap].set(lowercaseName, { name, value });
        }
        if (lowercaseName === "set-cookie") {
          this.cookies ?? (this.cookies = []);
          this.cookies.push(value);
        }
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-set
      set(name, value) {
        this[kHeadersSortedMap] = null;
        const lowercaseName = name.toLowerCase();
        if (lowercaseName === "set-cookie") {
          this.cookies = [value];
        }
        this[kHeadersMap].set(lowercaseName, { name, value });
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-delete
      delete(name) {
        this[kHeadersSortedMap] = null;
        name = name.toLowerCase();
        if (name === "set-cookie") {
          this.cookies = null;
        }
        this[kHeadersMap].delete(name);
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-get
      get(name) {
        const value = this[kHeadersMap].get(name.toLowerCase());
        return value === void 0 ? null : value.value;
      }
      *[Symbol.iterator]() {
        for (const [name, { value }] of this[kHeadersMap]) {
          yield [name, value];
        }
      }
      get entries() {
        const headers = {};
        if (this[kHeadersMap].size) {
          for (const { name, value } of this[kHeadersMap].values()) {
            headers[name] = value;
          }
        }
        return headers;
      }
    };
    var Headers2 = class _Headers {
      constructor(init = void 0) {
        if (init === kConstruct) {
          return;
        }
        this[kHeadersList] = new HeadersList();
        this[kGuard] = "none";
        if (init !== void 0) {
          init = webidl.converters.HeadersInit(init);
          fill(this, init);
        }
      }
      // https://fetch.spec.whatwg.org/#dom-headers-append
      append(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        return appendHeader(this, name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-delete
      delete(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.delete",
            value: name,
            type: "header name"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") ;
        if (!this[kHeadersList].contains(name)) {
          return;
        }
        this[kHeadersList].delete(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-get
      get(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.get",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].get(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-has
      has(name) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        name = webidl.converters.ByteString(name);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.has",
            value: name,
            type: "header name"
          });
        }
        return this[kHeadersList].contains(name);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-set
      set(name, value) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        name = webidl.converters.ByteString(name);
        value = webidl.converters.ByteString(value);
        value = headerValueNormalize(value);
        if (!isValidHeaderName(name)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value: name,
            type: "header name"
          });
        } else if (!isValidHeaderValue(value)) {
          throw webidl.errors.invalidArgument({
            prefix: "Headers.set",
            value,
            type: "header value"
          });
        }
        if (this[kGuard] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[kGuard] === "request-no-cors") ;
        this[kHeadersList].set(name, value);
      }
      // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
      getSetCookie() {
        webidl.brandCheck(this, _Headers);
        const list = this[kHeadersList].cookies;
        if (list) {
          return [...list];
        }
        return [];
      }
      // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
      get [kHeadersSortedMap]() {
        if (this[kHeadersList][kHeadersSortedMap]) {
          return this[kHeadersList][kHeadersSortedMap];
        }
        const headers = [];
        const names = [...this[kHeadersList]].sort((a, b) => a[0] < b[0] ? -1 : 1);
        const cookies = this[kHeadersList].cookies;
        for (let i = 0; i < names.length; ++i) {
          const [name, value] = names[i];
          if (name === "set-cookie") {
            for (let j = 0; j < cookies.length; ++j) {
              headers.push([name, cookies[j]]);
            }
          } else {
            assert(value !== null);
            headers.push([name, value]);
          }
        }
        this[kHeadersList][kHeadersSortedMap] = headers;
        return headers;
      }
      keys() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key"
        );
      }
      values() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "value"
        );
      }
      entries() {
        webidl.brandCheck(this, _Headers);
        if (this[kGuard] === "immutable") {
          const value = this[kHeadersSortedMap];
          return makeIterator(
            () => value,
            "Headers",
            "key+value"
          );
        }
        return makeIterator(
          () => [...this[kHeadersSortedMap].values()],
          "Headers",
          "key+value"
        );
      }
      /**
       * @param {(value: string, key: string, self: Headers) => void} callbackFn
       * @param {unknown} thisArg
       */
      forEach(callbackFn, thisArg = globalThis) {
        webidl.brandCheck(this, _Headers);
        webidl.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof callbackFn !== "function") {
          throw new TypeError(
            "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
          );
        }
        for (const [key, value] of this) {
          callbackFn.apply(thisArg, [value, key, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        webidl.brandCheck(this, _Headers);
        return this[kHeadersList];
      }
    };
    Headers2.prototype[Symbol.iterator] = Headers2.prototype.entries;
    Object.defineProperties(Headers2.prototype, {
      append: kEnumerableProperty,
      delete: kEnumerableProperty,
      get: kEnumerableProperty,
      has: kEnumerableProperty,
      set: kEnumerableProperty,
      getSetCookie: kEnumerableProperty,
      keys: kEnumerableProperty,
      values: kEnumerableProperty,
      entries: kEnumerableProperty,
      forEach: kEnumerableProperty,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: {
        value: "Headers",
        configurable: true
      }
    });
    webidl.converters.HeadersInit = function(V2) {
      if (webidl.util.Type(V2) === "Object") {
        if (V2[Symbol.iterator]) {
          return webidl.converters["sequence<sequence<ByteString>>"](V2);
        }
        return webidl.converters["record<ByteString, ByteString>"](V2);
      }
      throw webidl.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
    };
    module.exports = {
      fill,
      Headers: Headers2,
      HeadersList
    };
  }
});

// node_modules/undici/lib/fetch/response.js
var require_response = __commonJS({
  "node_modules/undici/lib/fetch/response.js"(exports, module) {
    var { Headers: Headers2, HeadersList, fill } = require_headers();
    var { extractBody, cloneBody, mixinBody } = require_body();
    var util = require_util();
    var { kEnumerableProperty } = util;
    var {
      isValidReasonPhrase,
      isCancelled,
      isAborted,
      isBlobLike,
      serializeJavascriptValueToJSONString,
      isErrorLike,
      isomorphicEncode
    } = require_util2();
    var {
      redirectStatusSet,
      nullBodyStatus,
      DOMException: DOMException2
    } = require_constants2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { FormData } = require_formdata();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = __require("assert");
    var { types } = __require("util");
    var ReadableStream = globalThis.ReadableStream || __require("stream/web").ReadableStream;
    var textEncoder = new TextEncoder("utf-8");
    var Response = class _Response {
      // Creates network error Response.
      static error() {
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kState] = makeNetworkError();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response-json
      static json(data, init = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (init !== null) {
          init = webidl.converters.ResponseInit(init);
        }
        const bytes = textEncoder.encode(
          serializeJavascriptValueToJSONString(data)
        );
        const body = extractBody(bytes);
        const relevantRealm = { settingsObject: {} };
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "response";
        responseObject[kHeaders][kRealm] = relevantRealm;
        initializeResponse(responseObject, init, { body: body[0], type: "application/json" });
        return responseObject;
      }
      // Creates a redirect Response that redirects to url with status status.
      static redirect(url, status = 302) {
        const relevantRealm = { settingsObject: {} };
        webidl.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        url = webidl.converters.USVString(url);
        status = webidl.converters["unsigned short"](status);
        let parsedURL;
        try {
          parsedURL = new URL(url, getGlobalOrigin());
        } catch (err) {
          throw Object.assign(new TypeError("Failed to parse URL from " + url), {
            cause: err
          });
        }
        if (!redirectStatusSet.has(status)) {
          throw new RangeError("Invalid status code " + status);
        }
        const responseObject = new _Response();
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        responseObject[kState].status = status;
        const value = isomorphicEncode(URLSerializer(parsedURL));
        responseObject[kState].headersList.append("location", value);
        return responseObject;
      }
      // https://fetch.spec.whatwg.org/#dom-response
      constructor(body = null, init = {}) {
        if (body !== null) {
          body = webidl.converters.BodyInit(body);
        }
        init = webidl.converters.ResponseInit(init);
        this[kRealm] = { settingsObject: {} };
        this[kState] = makeResponse({});
        this[kHeaders] = new Headers2(kConstruct);
        this[kHeaders][kGuard] = "response";
        this[kHeaders][kHeadersList] = this[kState].headersList;
        this[kHeaders][kRealm] = this[kRealm];
        let bodyWithType = null;
        if (body != null) {
          const [extractedBody, type] = extractBody(body);
          bodyWithType = { body: extractedBody, type };
        }
        initializeResponse(this, init, bodyWithType);
      }
      // Returns response’s type, e.g., "cors".
      get type() {
        webidl.brandCheck(this, _Response);
        return this[kState].type;
      }
      // Returns response’s URL, if it has one; otherwise the empty string.
      get url() {
        webidl.brandCheck(this, _Response);
        const urlList = this[kState].urlList;
        const url = urlList[urlList.length - 1] ?? null;
        if (url === null) {
          return "";
        }
        return URLSerializer(url, true);
      }
      // Returns whether response was obtained through a redirect.
      get redirected() {
        webidl.brandCheck(this, _Response);
        return this[kState].urlList.length > 1;
      }
      // Returns response’s status.
      get status() {
        webidl.brandCheck(this, _Response);
        return this[kState].status;
      }
      // Returns whether response’s status is an ok status.
      get ok() {
        webidl.brandCheck(this, _Response);
        return this[kState].status >= 200 && this[kState].status <= 299;
      }
      // Returns response’s status message.
      get statusText() {
        webidl.brandCheck(this, _Response);
        return this[kState].statusText;
      }
      // Returns response’s headers as Headers.
      get headers() {
        webidl.brandCheck(this, _Response);
        return this[kHeaders];
      }
      get body() {
        webidl.brandCheck(this, _Response);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Response);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      // Returns a clone of response.
      clone() {
        webidl.brandCheck(this, _Response);
        if (this.bodyUsed || this.body && this.body.locked) {
          throw webidl.errors.exception({
            header: "Response.clone",
            message: "Body has already been consumed."
          });
        }
        const clonedResponse = cloneResponse(this[kState]);
        const clonedResponseObject = new _Response();
        clonedResponseObject[kState] = clonedResponse;
        clonedResponseObject[kRealm] = this[kRealm];
        clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;
        clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        return clonedResponseObject;
      }
    };
    mixinBody(Response);
    Object.defineProperties(Response.prototype, {
      type: kEnumerableProperty,
      url: kEnumerableProperty,
      status: kEnumerableProperty,
      ok: kEnumerableProperty,
      redirected: kEnumerableProperty,
      statusText: kEnumerableProperty,
      headers: kEnumerableProperty,
      clone: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Response",
        configurable: true
      }
    });
    Object.defineProperties(Response, {
      json: kEnumerableProperty,
      redirect: kEnumerableProperty,
      error: kEnumerableProperty
    });
    function cloneResponse(response) {
      if (response.internalResponse) {
        return filterResponse(
          cloneResponse(response.internalResponse),
          response.type
        );
      }
      const newResponse = makeResponse({ ...response, body: null });
      if (response.body != null) {
        newResponse.body = cloneBody(response.body);
      }
      return newResponse;
    }
    function makeResponse(init) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList(),
        urlList: init.urlList ? [...init.urlList] : []
      };
    }
    function makeNetworkError(reason) {
      const isError = isErrorLike(reason);
      return makeResponse({
        type: "error",
        status: 0,
        error: isError ? reason : new Error(reason ? String(reason) : reason),
        aborted: reason && reason.name === "AbortError"
      });
    }
    function makeFilteredResponse(response, state) {
      state = {
        internalResponse: response,
        ...state
      };
      return new Proxy(response, {
        get(target, p) {
          return p in state ? state[p] : target[p];
        },
        set(target, p, value) {
          assert(!(p in state));
          target[p] = value;
          return true;
        }
      });
    }
    function filterResponse(response, type) {
      if (type === "basic") {
        return makeFilteredResponse(response, {
          type: "basic",
          headersList: response.headersList
        });
      } else if (type === "cors") {
        return makeFilteredResponse(response, {
          type: "cors",
          headersList: response.headersList
        });
      } else if (type === "opaque") {
        return makeFilteredResponse(response, {
          type: "opaque",
          urlList: Object.freeze([]),
          status: 0,
          statusText: "",
          body: null
        });
      } else if (type === "opaqueredirect") {
        return makeFilteredResponse(response, {
          type: "opaqueredirect",
          status: 0,
          statusText: "",
          headersList: [],
          body: null
        });
      } else {
        assert(false);
      }
    }
    function makeAppropriateNetworkError(fetchParams, err = null) {
      assert(isCancelled(fetchParams));
      return isAborted(fetchParams) ? makeNetworkError(Object.assign(new DOMException2("The operation was aborted.", "AbortError"), { cause: err })) : makeNetworkError(Object.assign(new DOMException2("Request was cancelled."), { cause: err }));
    }
    function initializeResponse(response, init, body) {
      if (init.status !== null && (init.status < 200 || init.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in init && init.statusText != null) {
        if (!isValidReasonPhrase(String(init.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in init && init.status != null) {
        response[kState].status = init.status;
      }
      if ("statusText" in init && init.statusText != null) {
        response[kState].statusText = init.statusText;
      }
      if ("headers" in init && init.headers != null) {
        fill(response[kHeaders], init.headers);
      }
      if (body) {
        if (nullBodyStatus.includes(response.status)) {
          throw webidl.errors.exception({
            header: "Response constructor",
            message: "Invalid response status code " + response.status
          });
        }
        response[kState].body = body.body;
        if (body.type != null && !response[kState].headersList.contains("Content-Type")) {
          response[kState].headersList.append("content-type", body.type);
        }
      }
    }
    webidl.converters.ReadableStream = webidl.interfaceConverter(
      ReadableStream
    );
    webidl.converters.FormData = webidl.interfaceConverter(
      FormData
    );
    webidl.converters.URLSearchParams = webidl.interfaceConverter(
      URLSearchParams
    );
    webidl.converters.XMLHttpRequestBodyInit = function(V2) {
      if (typeof V2 === "string") {
        return webidl.converters.USVString(V2);
      }
      if (isBlobLike(V2)) {
        return webidl.converters.Blob(V2, { strict: false });
      }
      if (types.isArrayBuffer(V2) || types.isTypedArray(V2) || types.isDataView(V2)) {
        return webidl.converters.BufferSource(V2);
      }
      if (util.isFormDataLike(V2)) {
        return webidl.converters.FormData(V2, { strict: false });
      }
      if (V2 instanceof URLSearchParams) {
        return webidl.converters.URLSearchParams(V2);
      }
      return webidl.converters.DOMString(V2);
    };
    webidl.converters.BodyInit = function(V2) {
      if (V2 instanceof ReadableStream) {
        return webidl.converters.ReadableStream(V2);
      }
      if (V2?.[Symbol.asyncIterator]) {
        return V2;
      }
      return webidl.converters.XMLHttpRequestBodyInit(V2);
    };
    webidl.converters.ResponseInit = webidl.dictionaryConverter([
      {
        key: "status",
        converter: webidl.converters["unsigned short"],
        defaultValue: 200
      },
      {
        key: "statusText",
        converter: webidl.converters.ByteString,
        defaultValue: ""
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      }
    ]);
    module.exports = {
      makeNetworkError,
      makeResponse,
      makeAppropriateNetworkError,
      filterResponse,
      Response,
      cloneResponse
    };
  }
});

// node_modules/undici/lib/fetch/request.js
var require_request2 = __commonJS({
  "node_modules/undici/lib/fetch/request.js"(exports, module) {
    var { extractBody, mixinBody, cloneBody } = require_body();
    var { Headers: Headers2, fill: fillHeaders, HeadersList } = require_headers();
    var { FinalizationRegistry } = require_dispatcher_weakref()();
    var util = require_util();
    var {
      isValidHTTPToken,
      sameOrigin,
      normalizeMethod,
      makePolicyContainer,
      normalizeMethodRecord
    } = require_util2();
    var {
      forbiddenMethodsSet,
      corsSafeListedMethodsSet,
      referrerPolicy,
      requestRedirect,
      requestMode,
      requestCredentials,
      requestCache,
      requestDuplex
    } = require_constants2();
    var { kEnumerableProperty } = util;
    var { kHeaders, kSignal, kState, kGuard, kRealm } = require_symbols2();
    var { webidl } = require_webidl();
    var { getGlobalOrigin } = require_global();
    var { URLSerializer } = require_dataURL();
    var { kHeadersList, kConstruct } = require_symbols();
    var assert = __require("assert");
    var { getMaxListeners, setMaxListeners, getEventListeners, defaultMaxListeners } = __require("events");
    var TransformStream = globalThis.TransformStream;
    var kAbortController = Symbol("abortController");
    var requestFinalizer = new FinalizationRegistry(({ signal, abort }) => {
      signal.removeEventListener("abort", abort);
    });
    var Request = class _Request {
      // https://fetch.spec.whatwg.org/#dom-request
      constructor(input, init = {}) {
        if (input === kConstruct) {
          return;
        }
        webidl.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        input = webidl.converters.RequestInfo(input);
        init = webidl.converters.RequestInit(init);
        this[kRealm] = {
          settingsObject: {
            baseUrl: getGlobalOrigin(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: makePolicyContainer()
          }
        };
        let request = null;
        let fallbackMode = null;
        const baseUrl = this[kRealm].settingsObject.baseUrl;
        let signal = null;
        if (typeof input === "string") {
          let parsedURL;
          try {
            parsedURL = new URL(input, baseUrl);
          } catch (err) {
            throw new TypeError("Failed to parse URL from " + input, { cause: err });
          }
          if (parsedURL.username || parsedURL.password) {
            throw new TypeError(
              "Request cannot be constructed from a URL that includes credentials: " + input
            );
          }
          request = makeRequest({ urlList: [parsedURL] });
          fallbackMode = "cors";
        } else {
          assert(input instanceof _Request);
          request = input[kState];
          signal = input[kSignal];
        }
        const origin = this[kRealm].settingsObject.origin;
        let window2 = "client";
        if (request.window?.constructor?.name === "EnvironmentSettingsObject" && sameOrigin(request.window, origin)) {
          window2 = request.window;
        }
        if (init.window != null) {
          throw new TypeError(`'window' option '${window2}' must be null`);
        }
        if ("window" in init) {
          window2 = "no-window";
        }
        request = makeRequest({
          // URL request’s URL.
          // undici implementation note: this is set as the first item in request's urlList in makeRequest
          // method request’s method.
          method: request.method,
          // header list A copy of request’s header list.
          // undici implementation note: headersList is cloned in makeRequest
          headersList: request.headersList,
          // unsafe-request flag Set.
          unsafeRequest: request.unsafeRequest,
          // client This’s relevant settings object.
          client: this[kRealm].settingsObject,
          // window window.
          window: window2,
          // priority request’s priority.
          priority: request.priority,
          // origin request’s origin. The propagation of the origin is only significant for navigation requests
          // being handled by a service worker. In this scenario a request can have an origin that is different
          // from the current client.
          origin: request.origin,
          // referrer request’s referrer.
          referrer: request.referrer,
          // referrer policy request’s referrer policy.
          referrerPolicy: request.referrerPolicy,
          // mode request’s mode.
          mode: request.mode,
          // credentials mode request’s credentials mode.
          credentials: request.credentials,
          // cache mode request’s cache mode.
          cache: request.cache,
          // redirect mode request’s redirect mode.
          redirect: request.redirect,
          // integrity metadata request’s integrity metadata.
          integrity: request.integrity,
          // keepalive request’s keepalive.
          keepalive: request.keepalive,
          // reload-navigation flag request’s reload-navigation flag.
          reloadNavigation: request.reloadNavigation,
          // history-navigation flag request’s history-navigation flag.
          historyNavigation: request.historyNavigation,
          // URL list A clone of request’s URL list.
          urlList: [...request.urlList]
        });
        const initHasKey = Object.keys(init).length !== 0;
        if (initHasKey) {
          if (request.mode === "navigate") {
            request.mode = "same-origin";
          }
          request.reloadNavigation = false;
          request.historyNavigation = false;
          request.origin = "client";
          request.referrer = "client";
          request.referrerPolicy = "";
          request.url = request.urlList[request.urlList.length - 1];
          request.urlList = [request.url];
        }
        if (init.referrer !== void 0) {
          const referrer = init.referrer;
          if (referrer === "") {
            request.referrer = "no-referrer";
          } else {
            let parsedReferrer;
            try {
              parsedReferrer = new URL(referrer, baseUrl);
            } catch (err) {
              throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
            }
            if (parsedReferrer.protocol === "about:" && parsedReferrer.hostname === "client" || origin && !sameOrigin(parsedReferrer, this[kRealm].settingsObject.baseUrl)) {
              request.referrer = "client";
            } else {
              request.referrer = parsedReferrer;
            }
          }
        }
        if (init.referrerPolicy !== void 0) {
          request.referrerPolicy = init.referrerPolicy;
        }
        let mode;
        if (init.mode !== void 0) {
          mode = init.mode;
        } else {
          mode = fallbackMode;
        }
        if (mode === "navigate") {
          throw webidl.errors.exception({
            header: "Request constructor",
            message: "invalid request mode navigate."
          });
        }
        if (mode != null) {
          request.mode = mode;
        }
        if (init.credentials !== void 0) {
          request.credentials = init.credentials;
        }
        if (init.cache !== void 0) {
          request.cache = init.cache;
        }
        if (request.cache === "only-if-cached" && request.mode !== "same-origin") {
          throw new TypeError(
            "'only-if-cached' can be set only with 'same-origin' mode"
          );
        }
        if (init.redirect !== void 0) {
          request.redirect = init.redirect;
        }
        if (init.integrity != null) {
          request.integrity = String(init.integrity);
        }
        if (init.keepalive !== void 0) {
          request.keepalive = Boolean(init.keepalive);
        }
        if (init.method !== void 0) {
          let method = init.method;
          if (!isValidHTTPToken(method)) {
            throw new TypeError(`'${method}' is not a valid HTTP method.`);
          }
          if (forbiddenMethodsSet.has(method.toUpperCase())) {
            throw new TypeError(`'${method}' HTTP method is unsupported.`);
          }
          method = normalizeMethodRecord[method] ?? normalizeMethod(method);
          request.method = method;
        }
        if (init.signal !== void 0) {
          signal = init.signal;
        }
        this[kState] = request;
        const ac = new AbortController();
        this[kSignal] = ac.signal;
        this[kSignal][kRealm] = this[kRealm];
        if (signal != null) {
          if (!signal || typeof signal.aborted !== "boolean" || typeof signal.addEventListener !== "function") {
            throw new TypeError(
              "Failed to construct 'Request': member signal is not of type AbortSignal."
            );
          }
          if (signal.aborted) {
            ac.abort(signal.reason);
          } else {
            this[kAbortController] = ac;
            const acRef = new WeakRef(ac);
            const abort = function() {
              const ac2 = acRef.deref();
              if (ac2 !== void 0) {
                ac2.abort(this.reason);
              }
            };
            try {
              if (typeof getMaxListeners === "function" && getMaxListeners(signal) === defaultMaxListeners) {
                setMaxListeners(100, signal);
              } else if (getEventListeners(signal, "abort").length >= defaultMaxListeners) {
                setMaxListeners(100, signal);
              }
            } catch {
            }
            util.addAbortListener(signal, abort);
            requestFinalizer.register(ac, { signal, abort });
          }
        }
        this[kHeaders] = new Headers2(kConstruct);
        this[kHeaders][kHeadersList] = request.headersList;
        this[kHeaders][kGuard] = "request";
        this[kHeaders][kRealm] = this[kRealm];
        if (mode === "no-cors") {
          if (!corsSafeListedMethodsSet.has(request.method)) {
            throw new TypeError(
              `'${request.method} is unsupported in no-cors mode.`
            );
          }
          this[kHeaders][kGuard] = "request-no-cors";
        }
        if (initHasKey) {
          const headersList = this[kHeaders][kHeadersList];
          const headers = init.headers !== void 0 ? init.headers : new HeadersList(headersList);
          headersList.clear();
          if (headers instanceof HeadersList) {
            for (const [key, val] of headers) {
              headersList.append(key, val);
            }
            headersList.cookies = headers.cookies;
          } else {
            fillHeaders(this[kHeaders], headers);
          }
        }
        const inputBody = input instanceof _Request ? input[kState].body : null;
        if ((init.body != null || inputBody != null) && (request.method === "GET" || request.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let initBody = null;
        if (init.body != null) {
          const [extractedBody, contentType] = extractBody(
            init.body,
            request.keepalive
          );
          initBody = extractedBody;
          if (contentType && !this[kHeaders][kHeadersList].contains("content-type")) {
            this[kHeaders].append("content-type", contentType);
          }
        }
        const inputOrInitBody = initBody ?? inputBody;
        if (inputOrInitBody != null && inputOrInitBody.source == null) {
          if (initBody != null && init.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (request.mode !== "same-origin" && request.mode !== "cors") {
            throw new TypeError(
              'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
            );
          }
          request.useCORSPreflightFlag = true;
        }
        let finalBody = inputOrInitBody;
        if (initBody == null && inputBody != null) {
          if (util.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
            throw new TypeError(
              "Cannot construct a Request with a Request object that has already been used."
            );
          }
          if (!TransformStream) {
            TransformStream = __require("stream/web").TransformStream;
          }
          const identityTransform = new TransformStream();
          inputBody.stream.pipeThrough(identityTransform);
          finalBody = {
            source: inputBody.source,
            length: inputBody.length,
            stream: identityTransform.readable
          };
        }
        this[kState].body = finalBody;
      }
      // Returns request’s HTTP method, which is "GET" by default.
      get method() {
        webidl.brandCheck(this, _Request);
        return this[kState].method;
      }
      // Returns the URL of request as a string.
      get url() {
        webidl.brandCheck(this, _Request);
        return URLSerializer(this[kState].url);
      }
      // Returns a Headers object consisting of the headers associated with request.
      // Note that headers added in the network layer by the user agent will not
      // be accounted for in this object, e.g., the "Host" header.
      get headers() {
        webidl.brandCheck(this, _Request);
        return this[kHeaders];
      }
      // Returns the kind of resource requested by request, e.g., "document"
      // or "script".
      get destination() {
        webidl.brandCheck(this, _Request);
        return this[kState].destination;
      }
      // Returns the referrer of request. Its value can be a same-origin URL if
      // explicitly set in init, the empty string to indicate no referrer, and
      // "about:client" when defaulting to the global’s default. This is used
      // during fetching to determine the value of the `Referer` header of the
      // request being made.
      get referrer() {
        webidl.brandCheck(this, _Request);
        if (this[kState].referrer === "no-referrer") {
          return "";
        }
        if (this[kState].referrer === "client") {
          return "about:client";
        }
        return this[kState].referrer.toString();
      }
      // Returns the referrer policy associated with request.
      // This is used during fetching to compute the value of the request’s
      // referrer.
      get referrerPolicy() {
        webidl.brandCheck(this, _Request);
        return this[kState].referrerPolicy;
      }
      // Returns the mode associated with request, which is a string indicating
      // whether the request will use CORS, or will be restricted to same-origin
      // URLs.
      get mode() {
        webidl.brandCheck(this, _Request);
        return this[kState].mode;
      }
      // Returns the credentials mode associated with request,
      // which is a string indicating whether credentials will be sent with the
      // request always, never, or only when sent to a same-origin URL.
      get credentials() {
        return this[kState].credentials;
      }
      // Returns the cache mode associated with request,
      // which is a string indicating how the request will
      // interact with the browser’s cache when fetching.
      get cache() {
        webidl.brandCheck(this, _Request);
        return this[kState].cache;
      }
      // Returns the redirect mode associated with request,
      // which is a string indicating how redirects for the
      // request will be handled during fetching. A request
      // will follow redirects by default.
      get redirect() {
        webidl.brandCheck(this, _Request);
        return this[kState].redirect;
      }
      // Returns request’s subresource integrity metadata, which is a
      // cryptographic hash of the resource being fetched. Its value
      // consists of multiple hashes separated by whitespace. [SRI]
      get integrity() {
        webidl.brandCheck(this, _Request);
        return this[kState].integrity;
      }
      // Returns a boolean indicating whether or not request can outlive the
      // global in which it was created.
      get keepalive() {
        webidl.brandCheck(this, _Request);
        return this[kState].keepalive;
      }
      // Returns a boolean indicating whether or not request is for a reload
      // navigation.
      get isReloadNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].reloadNavigation;
      }
      // Returns a boolean indicating whether or not request is for a history
      // navigation (a.k.a. back-foward navigation).
      get isHistoryNavigation() {
        webidl.brandCheck(this, _Request);
        return this[kState].historyNavigation;
      }
      // Returns the signal associated with request, which is an AbortSignal
      // object indicating whether or not request has been aborted, and its
      // abort event handler.
      get signal() {
        webidl.brandCheck(this, _Request);
        return this[kSignal];
      }
      get body() {
        webidl.brandCheck(this, _Request);
        return this[kState].body ? this[kState].body.stream : null;
      }
      get bodyUsed() {
        webidl.brandCheck(this, _Request);
        return !!this[kState].body && util.isDisturbed(this[kState].body.stream);
      }
      get duplex() {
        webidl.brandCheck(this, _Request);
        return "half";
      }
      // Returns a clone of request.
      clone() {
        webidl.brandCheck(this, _Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const clonedRequest = cloneRequest(this[kState]);
        const clonedRequestObject = new _Request(kConstruct);
        clonedRequestObject[kState] = clonedRequest;
        clonedRequestObject[kRealm] = this[kRealm];
        clonedRequestObject[kHeaders] = new Headers2(kConstruct);
        clonedRequestObject[kHeaders][kHeadersList] = clonedRequest.headersList;
        clonedRequestObject[kHeaders][kGuard] = this[kHeaders][kGuard];
        clonedRequestObject[kHeaders][kRealm] = this[kHeaders][kRealm];
        const ac = new AbortController();
        if (this.signal.aborted) {
          ac.abort(this.signal.reason);
        } else {
          util.addAbortListener(
            this.signal,
            () => {
              ac.abort(this.signal.reason);
            }
          );
        }
        clonedRequestObject[kSignal] = ac.signal;
        return clonedRequestObject;
      }
    };
    mixinBody(Request);
    function makeRequest(init) {
      const request = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...init,
        headersList: init.headersList ? new HeadersList(init.headersList) : new HeadersList()
      };
      request.url = request.urlList[0];
      return request;
    }
    function cloneRequest(request) {
      const newRequest = makeRequest({ ...request, body: null });
      if (request.body != null) {
        newRequest.body = cloneBody(request.body);
      }
      return newRequest;
    }
    Object.defineProperties(Request.prototype, {
      method: kEnumerableProperty,
      url: kEnumerableProperty,
      headers: kEnumerableProperty,
      redirect: kEnumerableProperty,
      clone: kEnumerableProperty,
      signal: kEnumerableProperty,
      duplex: kEnumerableProperty,
      destination: kEnumerableProperty,
      body: kEnumerableProperty,
      bodyUsed: kEnumerableProperty,
      isHistoryNavigation: kEnumerableProperty,
      isReloadNavigation: kEnumerableProperty,
      keepalive: kEnumerableProperty,
      integrity: kEnumerableProperty,
      cache: kEnumerableProperty,
      credentials: kEnumerableProperty,
      attribute: kEnumerableProperty,
      referrerPolicy: kEnumerableProperty,
      referrer: kEnumerableProperty,
      mode: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "Request",
        configurable: true
      }
    });
    webidl.converters.Request = webidl.interfaceConverter(
      Request
    );
    webidl.converters.RequestInfo = function(V2) {
      if (typeof V2 === "string") {
        return webidl.converters.USVString(V2);
      }
      if (V2 instanceof Request) {
        return webidl.converters.Request(V2);
      }
      return webidl.converters.USVString(V2);
    };
    webidl.converters.AbortSignal = webidl.interfaceConverter(
      AbortSignal
    );
    webidl.converters.RequestInit = webidl.dictionaryConverter([
      {
        key: "method",
        converter: webidl.converters.ByteString
      },
      {
        key: "headers",
        converter: webidl.converters.HeadersInit
      },
      {
        key: "body",
        converter: webidl.nullableConverter(
          webidl.converters.BodyInit
        )
      },
      {
        key: "referrer",
        converter: webidl.converters.USVString
      },
      {
        key: "referrerPolicy",
        converter: webidl.converters.DOMString,
        // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
        allowedValues: referrerPolicy
      },
      {
        key: "mode",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#concept-request-mode
        allowedValues: requestMode
      },
      {
        key: "credentials",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcredentials
        allowedValues: requestCredentials
      },
      {
        key: "cache",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestcache
        allowedValues: requestCache
      },
      {
        key: "redirect",
        converter: webidl.converters.DOMString,
        // https://fetch.spec.whatwg.org/#requestredirect
        allowedValues: requestRedirect
      },
      {
        key: "integrity",
        converter: webidl.converters.DOMString
      },
      {
        key: "keepalive",
        converter: webidl.converters.boolean
      },
      {
        key: "signal",
        converter: webidl.nullableConverter(
          (signal) => webidl.converters.AbortSignal(
            signal,
            { strict: false }
          )
        )
      },
      {
        key: "window",
        converter: webidl.converters.any
      },
      {
        key: "duplex",
        converter: webidl.converters.DOMString,
        allowedValues: requestDuplex
      }
    ]);
    module.exports = { Request, makeRequest };
  }
});

// node_modules/undici/lib/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/undici/lib/fetch/index.js"(exports, module) {
    var {
      Response,
      makeNetworkError,
      makeAppropriateNetworkError,
      filterResponse,
      makeResponse
    } = require_response();
    var { Headers: Headers2 } = require_headers();
    var { Request, makeRequest } = require_request2();
    var zlib = __require("zlib");
    var {
      bytesMatch,
      makePolicyContainer,
      clonePolicyContainer,
      requestBadPort,
      TAOCheck,
      appendRequestOriginHeader,
      responseLocationURL,
      requestCurrentURL,
      setRequestReferrerPolicyOnRedirect,
      tryUpgradeRequestToAPotentiallyTrustworthyURL,
      createOpaqueTimingInfo,
      appendFetchMetadata,
      corsCheck,
      crossOriginResourcePolicyCheck,
      determineRequestsReferrer,
      coarsenedSharedCurrentTime,
      createDeferredPromise,
      isBlobLike,
      sameOrigin,
      isCancelled,
      isAborted,
      isErrorLike,
      fullyReadBody,
      readableStreamClose,
      isomorphicEncode,
      urlIsLocal,
      urlIsHttpHttpsScheme,
      urlHasHttpsScheme
    } = require_util2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var assert = __require("assert");
    var { safelyExtractBody } = require_body();
    var {
      redirectStatusSet,
      nullBodyStatus,
      safeMethodsSet,
      requestBodyHeader,
      subresourceSet,
      DOMException: DOMException2
    } = require_constants2();
    var { kHeadersList } = require_symbols();
    var EE = __require("events");
    var { Readable, pipeline } = __require("stream");
    var { addAbortListener, isErrored, isReadable, nodeMajor, nodeMinor } = require_util();
    var { dataURLProcessor, serializeAMimeType } = require_dataURL();
    var { TransformStream } = __require("stream/web");
    var { getGlobalDispatcher } = require_global2();
    var { webidl } = require_webidl();
    var { STATUS_CODES } = __require("http");
    var GET_OR_HEAD = ["GET", "HEAD"];
    var resolveObjectURL;
    var ReadableStream = globalThis.ReadableStream;
    var Fetch = class extends EE {
      constructor(dispatcher) {
        super();
        this.dispatcher = dispatcher;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(reason) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(reason);
        this.emit("terminated", reason);
      }
      // https://fetch.spec.whatwg.org/#fetch-controller-abort
      abort(error) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!error) {
          error = new DOMException2("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = error;
        this.connection?.destroy(error);
        this.emit("terminated", error);
      }
    };
    function fetch2(input, init = {}) {
      webidl.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const p = createDeferredPromise();
      let requestObject;
      try {
        requestObject = new Request(input, init);
      } catch (e) {
        p.reject(e);
        return p.promise;
      }
      const request = requestObject[kState];
      if (requestObject.signal.aborted) {
        abortFetch(p, request, null, requestObject.signal.reason);
        return p.promise;
      }
      const globalObject = request.client.globalObject;
      if (globalObject?.constructor?.name === "ServiceWorkerGlobalScope") {
        request.serviceWorkers = "none";
      }
      let responseObject = null;
      const relevantRealm = null;
      let locallyAborted = false;
      let controller = null;
      addAbortListener(
        requestObject.signal,
        () => {
          locallyAborted = true;
          assert(controller != null);
          controller.abort(requestObject.signal.reason);
          abortFetch(p, request, responseObject, requestObject.signal.reason);
        }
      );
      const handleFetchDone = (response) => finalizeAndReportTiming(response, "fetch");
      const processResponse = (response) => {
        if (locallyAborted) {
          return Promise.resolve();
        }
        if (response.aborted) {
          abortFetch(p, request, responseObject, controller.serializedAbortReason);
          return Promise.resolve();
        }
        if (response.type === "error") {
          p.reject(
            Object.assign(new TypeError("fetch failed"), { cause: response.error })
          );
          return Promise.resolve();
        }
        responseObject = new Response();
        responseObject[kState] = response;
        responseObject[kRealm] = relevantRealm;
        responseObject[kHeaders][kHeadersList] = response.headersList;
        responseObject[kHeaders][kGuard] = "immutable";
        responseObject[kHeaders][kRealm] = relevantRealm;
        p.resolve(responseObject);
      };
      controller = fetching({
        request,
        processResponseEndOfBody: handleFetchDone,
        processResponse,
        dispatcher: init.dispatcher ?? getGlobalDispatcher()
        // undici
      });
      return p.promise;
    }
    function finalizeAndReportTiming(response, initiatorType = "other") {
      if (response.type === "error" && response.aborted) {
        return;
      }
      if (!response.urlList?.length) {
        return;
      }
      const originalURL = response.urlList[0];
      let timingInfo = response.timingInfo;
      let cacheState = response.cacheState;
      if (!urlIsHttpHttpsScheme(originalURL)) {
        return;
      }
      if (timingInfo === null) {
        return;
      }
      if (!response.timingAllowPassed) {
        timingInfo = createOpaqueTimingInfo({
          startTime: timingInfo.startTime
        });
        cacheState = "";
      }
      timingInfo.endTime = coarsenedSharedCurrentTime();
      response.timingInfo = timingInfo;
      markResourceTiming(
        timingInfo,
        originalURL,
        initiatorType,
        globalThis,
        cacheState
      );
    }
    function markResourceTiming(timingInfo, originalURL, initiatorType, globalThis2, cacheState) {
      if (nodeMajor > 18 || nodeMajor === 18 && nodeMinor >= 2) {
        performance.markResourceTiming(timingInfo, originalURL.href, initiatorType, globalThis2, cacheState);
      }
    }
    function abortFetch(p, request, responseObject, error) {
      if (!error) {
        error = new DOMException2("The operation was aborted.", "AbortError");
      }
      p.reject(error);
      if (request.body != null && isReadable(request.body?.stream)) {
        request.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
      if (responseObject == null) {
        return;
      }
      const response = responseObject[kState];
      if (response.body != null && isReadable(response.body?.stream)) {
        response.body.stream.cancel(error).catch((err) => {
          if (err.code === "ERR_INVALID_STATE") {
            return;
          }
          throw err;
        });
      }
    }
    function fetching({
      request,
      processRequestBodyChunkLength,
      processRequestEndOfBody,
      processResponse,
      processResponseEndOfBody,
      processResponseConsumeBody,
      useParallelQueue = false,
      dispatcher
      // undici
    }) {
      let taskDestination = null;
      let crossOriginIsolatedCapability = false;
      if (request.client != null) {
        taskDestination = request.client.globalObject;
        crossOriginIsolatedCapability = request.client.crossOriginIsolatedCapability;
      }
      const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
      const timingInfo = createOpaqueTimingInfo({
        startTime: currenTime
      });
      const fetchParams = {
        controller: new Fetch(dispatcher),
        request,
        timingInfo,
        processRequestBodyChunkLength,
        processRequestEndOfBody,
        processResponse,
        processResponseConsumeBody,
        processResponseEndOfBody,
        taskDestination,
        crossOriginIsolatedCapability
      };
      assert(!request.body || request.body.stream);
      if (request.window === "client") {
        request.window = request.client?.globalObject?.constructor?.name === "Window" ? request.client : "no-window";
      }
      if (request.origin === "client") {
        request.origin = request.client?.origin;
      }
      if (request.policyContainer === "client") {
        if (request.client != null) {
          request.policyContainer = clonePolicyContainer(
            request.client.policyContainer
          );
        } else {
          request.policyContainer = makePolicyContainer();
        }
      }
      if (!request.headersList.contains("accept")) {
        const value = "*/*";
        request.headersList.append("accept", value);
      }
      if (!request.headersList.contains("accept-language")) {
        request.headersList.append("accept-language", "*");
      }
      if (request.priority === null) ;
      if (subresourceSet.has(request.destination)) ;
      mainFetch(fetchParams).catch((err) => {
        fetchParams.controller.terminate(err);
      });
      return fetchParams.controller;
    }
    async function mainFetch(fetchParams, recursive = false) {
      const request = fetchParams.request;
      let response = null;
      if (request.localURLsOnly && !urlIsLocal(requestCurrentURL(request))) {
        response = makeNetworkError("local URLs only");
      }
      tryUpgradeRequestToAPotentiallyTrustworthyURL(request);
      if (requestBadPort(request) === "blocked") {
        response = makeNetworkError("bad port");
      }
      if (request.referrerPolicy === "") {
        request.referrerPolicy = request.policyContainer.referrerPolicy;
      }
      if (request.referrer !== "no-referrer") {
        request.referrer = determineRequestsReferrer(request);
      }
      if (response === null) {
        response = await (async () => {
          const currentURL = requestCurrentURL(request);
          if (
            // - request’s current URL’s origin is same origin with request’s origin,
            //   and request’s response tainting is "basic"
            sameOrigin(currentURL, request.url) && request.responseTainting === "basic" || // request’s current URL’s scheme is "data"
            currentURL.protocol === "data:" || // - request’s mode is "navigate" or "websocket"
            (request.mode === "navigate" || request.mode === "websocket")
          ) {
            request.responseTainting = "basic";
            return await schemeFetch(fetchParams);
          }
          if (request.mode === "same-origin") {
            return makeNetworkError('request mode cannot be "same-origin"');
          }
          if (request.mode === "no-cors") {
            if (request.redirect !== "follow") {
              return makeNetworkError(
                'redirect mode cannot be "follow" for "no-cors" request'
              );
            }
            request.responseTainting = "opaque";
            return await schemeFetch(fetchParams);
          }
          if (!urlIsHttpHttpsScheme(requestCurrentURL(request))) {
            return makeNetworkError("URL scheme must be a HTTP(S) scheme");
          }
          request.responseTainting = "cors";
          return await httpFetch(fetchParams);
        })();
      }
      if (recursive) {
        return response;
      }
      if (response.status !== 0 && !response.internalResponse) {
        if (request.responseTainting === "cors") ;
        if (request.responseTainting === "basic") {
          response = filterResponse(response, "basic");
        } else if (request.responseTainting === "cors") {
          response = filterResponse(response, "cors");
        } else if (request.responseTainting === "opaque") {
          response = filterResponse(response, "opaque");
        } else {
          assert(false);
        }
      }
      let internalResponse = response.status === 0 ? response : response.internalResponse;
      if (internalResponse.urlList.length === 0) {
        internalResponse.urlList.push(...request.urlList);
      }
      if (!request.timingAllowFailed) {
        response.timingAllowPassed = true;
      }
      if (response.type === "opaque" && internalResponse.status === 206 && internalResponse.rangeRequested && !request.headers.contains("range")) {
        response = internalResponse = makeNetworkError();
      }
      if (response.status !== 0 && (request.method === "HEAD" || request.method === "CONNECT" || nullBodyStatus.includes(internalResponse.status))) {
        internalResponse.body = null;
        fetchParams.controller.dump = true;
      }
      if (request.integrity) {
        const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
        if (request.responseTainting === "opaque" || response.body == null) {
          processBodyError(response.error);
          return;
        }
        const processBody = (bytes) => {
          if (!bytesMatch(bytes, request.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          response.body = safelyExtractBody(bytes)[0];
          fetchFinale(fetchParams, response);
        };
        await fullyReadBody(response.body, processBody, processBodyError);
      } else {
        fetchFinale(fetchParams, response);
      }
    }
    function schemeFetch(fetchParams) {
      if (isCancelled(fetchParams) && fetchParams.request.redirectCount === 0) {
        return Promise.resolve(makeAppropriateNetworkError(fetchParams));
      }
      const { request } = fetchParams;
      const { protocol: scheme } = requestCurrentURL(request);
      switch (scheme) {
        case "about:": {
          return Promise.resolve(makeNetworkError("about scheme is not supported"));
        }
        case "blob:": {
          if (!resolveObjectURL) {
            resolveObjectURL = __require("buffer").resolveObjectURL;
          }
          const blobURLEntry = requestCurrentURL(request);
          if (blobURLEntry.search.length !== 0) {
            return Promise.resolve(makeNetworkError("NetworkError when attempting to fetch resource."));
          }
          const blobURLEntryObject = resolveObjectURL(blobURLEntry.toString());
          if (request.method !== "GET" || !isBlobLike(blobURLEntryObject)) {
            return Promise.resolve(makeNetworkError("invalid method"));
          }
          const bodyWithType = safelyExtractBody(blobURLEntryObject);
          const body = bodyWithType[0];
          const length = isomorphicEncode(`${body.length}`);
          const type = bodyWithType[1] ?? "";
          const response = makeResponse({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: length }],
              ["content-type", { name: "Content-Type", value: type }]
            ]
          });
          response.body = body;
          return Promise.resolve(response);
        }
        case "data:": {
          const currentURL = requestCurrentURL(request);
          const dataURLStruct = dataURLProcessor(currentURL);
          if (dataURLStruct === "failure") {
            return Promise.resolve(makeNetworkError("failed to fetch the data URL"));
          }
          const mimeType = serializeAMimeType(dataURLStruct.mimeType);
          return Promise.resolve(makeResponse({
            statusText: "OK",
            headersList: [
              ["content-type", { name: "Content-Type", value: mimeType }]
            ],
            body: safelyExtractBody(dataURLStruct.body)[0]
          }));
        }
        case "file:": {
          return Promise.resolve(makeNetworkError("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(fetchParams).catch((err) => makeNetworkError(err));
        }
        default: {
          return Promise.resolve(makeNetworkError("unknown scheme"));
        }
      }
    }
    function finalizeResponse(fetchParams, response) {
      fetchParams.request.done = true;
      if (fetchParams.processResponseDone != null) {
        queueMicrotask(() => fetchParams.processResponseDone(response));
      }
    }
    function fetchFinale(fetchParams, response) {
      if (response.type === "error") {
        response.urlList = [fetchParams.request.urlList[0]];
        response.timingInfo = createOpaqueTimingInfo({
          startTime: fetchParams.timingInfo.startTime
        });
      }
      const processResponseEndOfBody = () => {
        fetchParams.request.done = true;
        if (fetchParams.processResponseEndOfBody != null) {
          queueMicrotask(() => fetchParams.processResponseEndOfBody(response));
        }
      };
      if (fetchParams.processResponse != null) {
        queueMicrotask(() => fetchParams.processResponse(response));
      }
      if (response.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (chunk, controller) => {
          controller.enqueue(chunk);
        };
        const transformStream = new TransformStream({
          start() {
          },
          transform: identityTransformAlgorithm,
          flush: processResponseEndOfBody
        }, {
          size() {
            return 1;
          }
        }, {
          size() {
            return 1;
          }
        });
        response.body = { stream: response.body.stream.pipeThrough(transformStream) };
      }
      if (fetchParams.processResponseConsumeBody != null) {
        const processBody = (nullOrBytes) => fetchParams.processResponseConsumeBody(response, nullOrBytes);
        const processBodyError = (failure) => fetchParams.processResponseConsumeBody(response, failure);
        if (response.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return fullyReadBody(response.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(fetchParams) {
      const request = fetchParams.request;
      let response = null;
      let actualResponse = null;
      const timingInfo = fetchParams.timingInfo;
      if (request.serviceWorkers === "all") ;
      if (response === null) {
        if (request.redirect === "follow") {
          request.serviceWorkers = "none";
        }
        actualResponse = response = await httpNetworkOrCacheFetch(fetchParams);
        if (request.responseTainting === "cors" && corsCheck(request, response) === "failure") {
          return makeNetworkError("cors failure");
        }
        if (TAOCheck(request, response) === "failure") {
          request.timingAllowFailed = true;
        }
      }
      if ((request.responseTainting === "opaque" || response.type === "opaque") && crossOriginResourcePolicyCheck(
        request.origin,
        request.client,
        request.destination,
        actualResponse
      ) === "blocked") {
        return makeNetworkError("blocked");
      }
      if (redirectStatusSet.has(actualResponse.status)) {
        if (request.redirect !== "manual") {
          fetchParams.controller.connection.destroy();
        }
        if (request.redirect === "error") {
          response = makeNetworkError("unexpected redirect");
        } else if (request.redirect === "manual") {
          response = actualResponse;
        } else if (request.redirect === "follow") {
          response = await httpRedirectFetch(fetchParams, response);
        } else {
          assert(false);
        }
      }
      response.timingInfo = timingInfo;
      return response;
    }
    function httpRedirectFetch(fetchParams, response) {
      const request = fetchParams.request;
      const actualResponse = response.internalResponse ? response.internalResponse : response;
      let locationURL;
      try {
        locationURL = responseLocationURL(
          actualResponse,
          requestCurrentURL(request).hash
        );
        if (locationURL == null) {
          return response;
        }
      } catch (err) {
        return Promise.resolve(makeNetworkError(err));
      }
      if (!urlIsHttpHttpsScheme(locationURL)) {
        return Promise.resolve(makeNetworkError("URL scheme must be a HTTP(S) scheme"));
      }
      if (request.redirectCount === 20) {
        return Promise.resolve(makeNetworkError("redirect count exceeded"));
      }
      request.redirectCount += 1;
      if (request.mode === "cors" && (locationURL.username || locationURL.password) && !sameOrigin(request, locationURL)) {
        return Promise.resolve(makeNetworkError('cross origin not allowed for request mode "cors"'));
      }
      if (request.responseTainting === "cors" && (locationURL.username || locationURL.password)) {
        return Promise.resolve(makeNetworkError(
          'URL cannot contain credentials for request mode "cors"'
        ));
      }
      if (actualResponse.status !== 303 && request.body != null && request.body.source == null) {
        return Promise.resolve(makeNetworkError());
      }
      if ([301, 302].includes(actualResponse.status) && request.method === "POST" || actualResponse.status === 303 && !GET_OR_HEAD.includes(request.method)) {
        request.method = "GET";
        request.body = null;
        for (const headerName of requestBodyHeader) {
          request.headersList.delete(headerName);
        }
      }
      if (!sameOrigin(requestCurrentURL(request), locationURL)) {
        request.headersList.delete("authorization");
        request.headersList.delete("proxy-authorization", true);
        request.headersList.delete("cookie");
        request.headersList.delete("host");
      }
      if (request.body != null) {
        assert(request.body.source != null);
        request.body = safelyExtractBody(request.body.source)[0];
      }
      const timingInfo = fetchParams.timingInfo;
      timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(fetchParams.crossOriginIsolatedCapability);
      if (timingInfo.redirectStartTime === 0) {
        timingInfo.redirectStartTime = timingInfo.startTime;
      }
      request.urlList.push(locationURL);
      setRequestReferrerPolicyOnRedirect(request, actualResponse);
      return mainFetch(fetchParams, true);
    }
    async function httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch = false, isNewConnectionFetch = false) {
      const request = fetchParams.request;
      let httpFetchParams = null;
      let httpRequest = null;
      let response = null;
      if (request.window === "no-window" && request.redirect === "error") {
        httpFetchParams = fetchParams;
        httpRequest = request;
      } else {
        httpRequest = makeRequest(request);
        httpFetchParams = { ...fetchParams };
        httpFetchParams.request = httpRequest;
      }
      const includeCredentials = request.credentials === "include" || request.credentials === "same-origin" && request.responseTainting === "basic";
      const contentLength = httpRequest.body ? httpRequest.body.length : null;
      let contentLengthHeaderValue = null;
      if (httpRequest.body == null && ["POST", "PUT"].includes(httpRequest.method)) {
        contentLengthHeaderValue = "0";
      }
      if (contentLength != null) {
        contentLengthHeaderValue = isomorphicEncode(`${contentLength}`);
      }
      if (contentLengthHeaderValue != null) {
        httpRequest.headersList.append("content-length", contentLengthHeaderValue);
      }
      if (contentLength != null && httpRequest.keepalive) ;
      if (httpRequest.referrer instanceof URL) {
        httpRequest.headersList.append("referer", isomorphicEncode(httpRequest.referrer.href));
      }
      appendRequestOriginHeader(httpRequest);
      appendFetchMetadata(httpRequest);
      if (!httpRequest.headersList.contains("user-agent")) {
        httpRequest.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (httpRequest.cache === "default" && (httpRequest.headersList.contains("if-modified-since") || httpRequest.headersList.contains("if-none-match") || httpRequest.headersList.contains("if-unmodified-since") || httpRequest.headersList.contains("if-match") || httpRequest.headersList.contains("if-range"))) {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.cache === "no-cache" && !httpRequest.preventNoCacheCacheControlHeaderModification && !httpRequest.headersList.contains("cache-control")) {
        httpRequest.headersList.append("cache-control", "max-age=0");
      }
      if (httpRequest.cache === "no-store" || httpRequest.cache === "reload") {
        if (!httpRequest.headersList.contains("pragma")) {
          httpRequest.headersList.append("pragma", "no-cache");
        }
        if (!httpRequest.headersList.contains("cache-control")) {
          httpRequest.headersList.append("cache-control", "no-cache");
        }
      }
      if (httpRequest.headersList.contains("range")) {
        httpRequest.headersList.append("accept-encoding", "identity");
      }
      if (!httpRequest.headersList.contains("accept-encoding")) {
        if (urlHasHttpsScheme(requestCurrentURL(httpRequest))) {
          httpRequest.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          httpRequest.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      httpRequest.headersList.delete("host");
      {
        httpRequest.cache = "no-store";
      }
      if (httpRequest.mode !== "no-store" && httpRequest.mode !== "reload") ;
      if (response == null) {
        if (httpRequest.mode === "only-if-cached") {
          return makeNetworkError("only if cached");
        }
        const forwardResponse = await httpNetworkFetch(
          httpFetchParams,
          includeCredentials,
          isNewConnectionFetch
        );
        if (!safeMethodsSet.has(httpRequest.method) && forwardResponse.status >= 200 && forwardResponse.status <= 399) ;
        if (response == null) {
          response = forwardResponse;
        }
      }
      response.urlList = [...httpRequest.urlList];
      if (httpRequest.headersList.contains("range")) {
        response.rangeRequested = true;
      }
      response.requestIncludesCredentials = includeCredentials;
      if (response.status === 407) {
        if (request.window === "no-window") {
          return makeNetworkError();
        }
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        return makeNetworkError("proxy authentication required");
      }
      if (
        // response’s status is 421
        response.status === 421 && // isNewConnectionFetch is false
        !isNewConnectionFetch && // request’s body is null, or request’s body is non-null and request’s body’s source is non-null
        (request.body == null || request.body.source != null)
      ) {
        if (isCancelled(fetchParams)) {
          return makeAppropriateNetworkError(fetchParams);
        }
        fetchParams.controller.connection.destroy();
        response = await httpNetworkOrCacheFetch(
          fetchParams,
          isAuthenticationFetch,
          true
        );
      }
      return response;
    }
    async function httpNetworkFetch(fetchParams, includeCredentials = false, forceNewConnection = false) {
      assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
      fetchParams.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(err) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(err ?? new DOMException2("The operation was aborted.", "AbortError"));
          }
        }
      };
      const request = fetchParams.request;
      let response = null;
      const timingInfo = fetchParams.timingInfo;
      {
        request.cache = "no-store";
      }
      if (request.mode === "websocket") ;
      let requestBody = null;
      if (request.body == null && fetchParams.processRequestEndOfBody) {
        queueMicrotask(() => fetchParams.processRequestEndOfBody());
      } else if (request.body != null) {
        const processBodyChunk = async function* (bytes) {
          if (isCancelled(fetchParams)) {
            return;
          }
          yield bytes;
          fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
        };
        const processEndOfBody = () => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (fetchParams.processRequestEndOfBody) {
            fetchParams.processRequestEndOfBody();
          }
        };
        const processBodyError = (e) => {
          if (isCancelled(fetchParams)) {
            return;
          }
          if (e.name === "AbortError") {
            fetchParams.controller.abort();
          } else {
            fetchParams.controller.terminate(e);
          }
        };
        requestBody = async function* () {
          try {
            for await (const bytes of request.body.stream) {
              yield* processBodyChunk(bytes);
            }
            processEndOfBody();
          } catch (err) {
            processBodyError(err);
          }
        }();
      }
      try {
        const { body, status, statusText, headersList, socket } = await dispatch({ body: requestBody });
        if (socket) {
          response = makeResponse({ status, statusText, headersList, socket });
        } else {
          const iterator = body[Symbol.asyncIterator]();
          fetchParams.controller.next = () => iterator.next();
          response = makeResponse({ status, statusText, headersList });
        }
      } catch (err) {
        if (err.name === "AbortError") {
          fetchParams.controller.connection.destroy();
          return makeAppropriateNetworkError(fetchParams, err);
        }
        return makeNetworkError(err);
      }
      const pullAlgorithm = () => {
        fetchParams.controller.resume();
      };
      const cancelAlgorithm = (reason) => {
        fetchParams.controller.abort(reason);
      };
      if (!ReadableStream) {
        ReadableStream = __require("stream/web").ReadableStream;
      }
      const stream = new ReadableStream(
        {
          async start(controller) {
            fetchParams.controller.controller = controller;
          },
          async pull(controller) {
            await pullAlgorithm();
          },
          async cancel(reason) {
            await cancelAlgorithm(reason);
          }
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          }
        }
      );
      response.body = { stream };
      fetchParams.controller.on("terminated", onAborted);
      fetchParams.controller.resume = async () => {
        while (true) {
          let bytes;
          let isFailure;
          try {
            const { done, value } = await fetchParams.controller.next();
            if (isAborted(fetchParams)) {
              break;
            }
            bytes = done ? void 0 : value;
          } catch (err) {
            if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
              bytes = void 0;
            } else {
              bytes = err;
              isFailure = true;
            }
          }
          if (bytes === void 0) {
            readableStreamClose(fetchParams.controller.controller);
            finalizeResponse(fetchParams, response);
            return;
          }
          timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
          if (isFailure) {
            fetchParams.controller.terminate(bytes);
            return;
          }
          fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
          if (isErrored(stream)) {
            fetchParams.controller.terminate();
            return;
          }
          if (!fetchParams.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(reason) {
        if (isAborted(fetchParams)) {
          response.aborted = true;
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(
              fetchParams.controller.serializedAbortReason
            );
          }
        } else {
          if (isReadable(stream)) {
            fetchParams.controller.controller.error(new TypeError("terminated", {
              cause: isErrorLike(reason) ? reason : void 0
            }));
          }
        }
        fetchParams.controller.connection.destroy();
      }
      return response;
      async function dispatch({ body }) {
        const url = requestCurrentURL(request);
        const agent = fetchParams.controller.dispatcher;
        return new Promise((resolve, reject) => agent.dispatch(
          {
            path: url.pathname + url.search,
            origin: url.origin,
            method: request.method,
            body: fetchParams.controller.dispatcher.isMockActive ? request.body && (request.body.source || request.body.stream) : body,
            headers: request.headersList.entries,
            maxRedirections: 0,
            upgrade: request.mode === "websocket" ? "websocket" : void 0
          },
          {
            body: null,
            abort: null,
            onConnect(abort) {
              const { connection } = fetchParams.controller;
              if (connection.destroyed) {
                abort(new DOMException2("The operation was aborted.", "AbortError"));
              } else {
                fetchParams.controller.on("terminated", abort);
                this.abort = connection.abort = abort;
              }
            },
            onHeaders(status, headersList, resume, statusText) {
              if (status < 200) {
                return;
              }
              let codings = [];
              let location = "";
              const headers = new Headers2();
              if (Array.isArray(headersList)) {
                for (let n = 0; n < headersList.length; n += 2) {
                  const key = headersList[n + 0].toString("latin1");
                  const val = headersList[n + 1].toString("latin1");
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x2) => x2.trim());
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              } else {
                const keys = Object.keys(headersList);
                for (const key of keys) {
                  const val = headersList[key];
                  if (key.toLowerCase() === "content-encoding") {
                    codings = val.toLowerCase().split(",").map((x2) => x2.trim()).reverse();
                  } else if (key.toLowerCase() === "location") {
                    location = val;
                  }
                  headers[kHeadersList].append(key, val);
                }
              }
              this.body = new Readable({ read: resume });
              const decoders = [];
              const willFollow = request.redirect === "follow" && location && redirectStatusSet.has(status);
              if (request.method !== "HEAD" && request.method !== "CONNECT" && !nullBodyStatus.includes(status) && !willFollow) {
                for (const coding of codings) {
                  if (coding === "x-gzip" || coding === "gzip") {
                    decoders.push(zlib.createGunzip({
                      // Be less strict when decoding compressed responses, since sometimes
                      // servers send slightly invalid responses that are still accepted
                      // by common browsers.
                      // Always using Z_SYNC_FLUSH is what cURL does.
                      flush: zlib.constants.Z_SYNC_FLUSH,
                      finishFlush: zlib.constants.Z_SYNC_FLUSH
                    }));
                  } else if (coding === "deflate") {
                    decoders.push(zlib.createInflate());
                  } else if (coding === "br") {
                    decoders.push(zlib.createBrotliDecompress());
                  } else {
                    decoders.length = 0;
                    break;
                  }
                }
              }
              resolve({
                status,
                statusText,
                headersList: headers[kHeadersList],
                body: decoders.length ? pipeline(this.body, ...decoders, () => {
                }) : this.body.on("error", () => {
                })
              });
              return true;
            },
            onData(chunk) {
              if (fetchParams.controller.dump) {
                return;
              }
              const bytes = chunk;
              timingInfo.encodedBodySize += bytes.byteLength;
              return this.body.push(bytes);
            },
            onComplete() {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              fetchParams.controller.ended = true;
              this.body.push(null);
            },
            onError(error) {
              if (this.abort) {
                fetchParams.controller.off("terminated", this.abort);
              }
              this.body?.destroy(error);
              fetchParams.controller.terminate(error);
              reject(error);
            },
            onUpgrade(status, headersList, socket) {
              if (status !== 101) {
                return;
              }
              const headers = new Headers2();
              for (let n = 0; n < headersList.length; n += 2) {
                const key = headersList[n + 0].toString("latin1");
                const val = headersList[n + 1].toString("latin1");
                headers[kHeadersList].append(key, val);
              }
              resolve({
                status,
                statusText: STATUS_CODES[status],
                headersList: headers[kHeadersList],
                socket
              });
              return true;
            }
          }
        ));
      }
    }
    module.exports = {
      fetch: fetch2,
      Fetch,
      fetching,
      finalizeAndReportTiming
    };
  }
});

// node_modules/undici/lib/fileapi/symbols.js
var require_symbols3 = __commonJS({
  "node_modules/undici/lib/fileapi/symbols.js"(exports, module) {
    module.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted")
    };
  }
});

// node_modules/undici/lib/fileapi/progressevent.js
var require_progressevent = __commonJS({
  "node_modules/undici/lib/fileapi/progressevent.js"(exports, module) {
    var { webidl } = require_webidl();
    var kState = Symbol("ProgressEvent state");
    var ProgressEvent = class _ProgressEvent extends Event {
      constructor(type, eventInitDict = {}) {
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ProgressEventInit(eventInitDict ?? {});
        super(type, eventInitDict);
        this[kState] = {
          lengthComputable: eventInitDict.lengthComputable,
          loaded: eventInitDict.loaded,
          total: eventInitDict.total
        };
      }
      get lengthComputable() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].lengthComputable;
      }
      get loaded() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].loaded;
      }
      get total() {
        webidl.brandCheck(this, _ProgressEvent);
        return this[kState].total;
      }
    };
    webidl.converters.ProgressEventInit = webidl.dictionaryConverter([
      {
        key: "lengthComputable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "loaded",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "total",
        converter: webidl.converters["unsigned long long"],
        defaultValue: 0
      },
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ]);
    module.exports = {
      ProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/encoding.js
var require_encoding = __commonJS({
  "node_modules/undici/lib/fileapi/encoding.js"(exports, module) {
    function getEncoding(label) {
      if (!label) {
        return "failure";
      }
      switch (label.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    module.exports = {
      getEncoding
    };
  }
});

// node_modules/undici/lib/fileapi/util.js
var require_util4 = __commonJS({
  "node_modules/undici/lib/fileapi/util.js"(exports, module) {
    var {
      kState,
      kError,
      kResult,
      kAborted,
      kLastProgressEventFired
    } = require_symbols3();
    var { ProgressEvent } = require_progressevent();
    var { getEncoding } = require_encoding();
    var { DOMException: DOMException2 } = require_constants2();
    var { serializeAMimeType, parseMIMEType } = require_dataURL();
    var { types } = __require("util");
    var { StringDecoder } = __require("string_decoder");
    var { btoa } = __require("buffer");
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    function readOperation(fr2, blob, type, encodingName) {
      if (fr2[kState] === "loading") {
        throw new DOMException2("Invalid state", "InvalidStateError");
      }
      fr2[kState] = "loading";
      fr2[kResult] = null;
      fr2[kError] = null;
      const stream = blob.stream();
      const reader = stream.getReader();
      const bytes = [];
      let chunkPromise = reader.read();
      let isFirstChunk = true;
      (async () => {
        while (!fr2[kAborted]) {
          try {
            const { done, value } = await chunkPromise;
            if (isFirstChunk && !fr2[kAborted]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", fr2);
              });
            }
            isFirstChunk = false;
            if (!done && types.isUint8Array(value)) {
              bytes.push(value);
              if ((fr2[kLastProgressEventFired] === void 0 || Date.now() - fr2[kLastProgressEventFired] >= 50) && !fr2[kAborted]) {
                fr2[kLastProgressEventFired] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", fr2);
                });
              }
              chunkPromise = reader.read();
            } else if (done) {
              queueMicrotask(() => {
                fr2[kState] = "done";
                try {
                  const result = packageData(bytes, type, blob.type, encodingName);
                  if (fr2[kAborted]) {
                    return;
                  }
                  fr2[kResult] = result;
                  fireAProgressEvent("load", fr2);
                } catch (error) {
                  fr2[kError] = error;
                  fireAProgressEvent("error", fr2);
                }
                if (fr2[kState] !== "loading") {
                  fireAProgressEvent("loadend", fr2);
                }
              });
              break;
            }
          } catch (error) {
            if (fr2[kAborted]) {
              return;
            }
            queueMicrotask(() => {
              fr2[kState] = "done";
              fr2[kError] = error;
              fireAProgressEvent("error", fr2);
              if (fr2[kState] !== "loading") {
                fireAProgressEvent("loadend", fr2);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, reader) {
      const event = new ProgressEvent(e, {
        bubbles: false,
        cancelable: false
      });
      reader.dispatchEvent(event);
    }
    function packageData(bytes, type, mimeType, encodingName) {
      switch (type) {
        case "DataURL": {
          let dataURL = "data:";
          const parsed = parseMIMEType(mimeType || "application/octet-stream");
          if (parsed !== "failure") {
            dataURL += serializeAMimeType(parsed);
          }
          dataURL += ";base64,";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            dataURL += btoa(decoder.write(chunk));
          }
          dataURL += btoa(decoder.end());
          return dataURL;
        }
        case "Text": {
          let encoding = "failure";
          if (encodingName) {
            encoding = getEncoding(encodingName);
          }
          if (encoding === "failure" && mimeType) {
            const type2 = parseMIMEType(mimeType);
            if (type2 !== "failure") {
              encoding = getEncoding(type2.parameters.get("charset"));
            }
          }
          if (encoding === "failure") {
            encoding = "UTF-8";
          }
          return decode(bytes, encoding);
        }
        case "ArrayBuffer": {
          const sequence = combineByteSequences(bytes);
          return sequence.buffer;
        }
        case "BinaryString": {
          let binaryString = "";
          const decoder = new StringDecoder("latin1");
          for (const chunk of bytes) {
            binaryString += decoder.write(chunk);
          }
          binaryString += decoder.end();
          return binaryString;
        }
      }
    }
    function decode(ioQueue, encoding) {
      const bytes = combineByteSequences(ioQueue);
      const BOMEncoding = BOMSniffing(bytes);
      let slice2 = 0;
      if (BOMEncoding !== null) {
        encoding = BOMEncoding;
        slice2 = BOMEncoding === "UTF-8" ? 3 : 2;
      }
      const sliced = bytes.slice(slice2);
      return new TextDecoder(encoding).decode(sliced);
    }
    function BOMSniffing(ioQueue) {
      const [a, b, c] = ioQueue;
      if (a === 239 && b === 187 && c === 191) {
        return "UTF-8";
      } else if (a === 254 && b === 255) {
        return "UTF-16BE";
      } else if (a === 255 && b === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(sequences) {
      const size2 = sequences.reduce((a, b) => {
        return a + b.byteLength;
      }, 0);
      let offset = 0;
      return sequences.reduce((a, b) => {
        a.set(b, offset);
        offset += b.byteLength;
        return a;
      }, new Uint8Array(size2));
    }
    module.exports = {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    };
  }
});

// node_modules/undici/lib/fileapi/filereader.js
var require_filereader = __commonJS({
  "node_modules/undici/lib/fileapi/filereader.js"(exports, module) {
    var {
      staticPropertyDescriptors,
      readOperation,
      fireAProgressEvent
    } = require_util4();
    var {
      kState,
      kError,
      kResult,
      kEvents,
      kAborted
    } = require_symbols3();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var FileReader = class _FileReader extends EventTarget {
      constructor() {
        super();
        this[kState] = "empty";
        this[kResult] = null;
        this[kError] = null;
        this[kEvents] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null
        };
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
       * @param {import('buffer').Blob} blob
       */
      readAsArrayBuffer(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "ArrayBuffer");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsBinaryString
       * @param {import('buffer').Blob} blob
       */
      readAsBinaryString(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "BinaryString");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#readAsDataText
       * @param {import('buffer').Blob} blob
       * @param {string?} encoding
       */
      readAsText(blob, encoding = void 0) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        blob = webidl.converters.Blob(blob, { strict: false });
        if (encoding !== void 0) {
          encoding = webidl.converters.DOMString(encoding);
        }
        readOperation(this, blob, "Text", encoding);
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
       * @param {import('buffer').Blob} blob
       */
      readAsDataURL(blob) {
        webidl.brandCheck(this, _FileReader);
        webidl.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        blob = webidl.converters.Blob(blob, { strict: false });
        readOperation(this, blob, "DataURL");
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dfn-abort
       */
      abort() {
        if (this[kState] === "empty" || this[kState] === "done") {
          this[kResult] = null;
          return;
        }
        if (this[kState] === "loading") {
          this[kState] = "done";
          this[kResult] = null;
        }
        this[kAborted] = true;
        fireAProgressEvent("abort", this);
        if (this[kState] !== "loading") {
          fireAProgressEvent("loadend", this);
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
       */
      get readyState() {
        webidl.brandCheck(this, _FileReader);
        switch (this[kState]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-result
       */
      get result() {
        webidl.brandCheck(this, _FileReader);
        return this[kResult];
      }
      /**
       * @see https://w3c.github.io/FileAPI/#dom-filereader-error
       */
      get error() {
        webidl.brandCheck(this, _FileReader);
        return this[kError];
      }
      get onloadend() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadend;
      }
      set onloadend(fn2) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadend) {
          this.removeEventListener("loadend", this[kEvents].loadend);
        }
        if (typeof fn2 === "function") {
          this[kEvents].loadend = fn2;
          this.addEventListener("loadend", fn2);
        } else {
          this[kEvents].loadend = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].error;
      }
      set onerror(fn2) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].error) {
          this.removeEventListener("error", this[kEvents].error);
        }
        if (typeof fn2 === "function") {
          this[kEvents].error = fn2;
          this.addEventListener("error", fn2);
        } else {
          this[kEvents].error = null;
        }
      }
      get onloadstart() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].loadstart;
      }
      set onloadstart(fn2) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].loadstart) {
          this.removeEventListener("loadstart", this[kEvents].loadstart);
        }
        if (typeof fn2 === "function") {
          this[kEvents].loadstart = fn2;
          this.addEventListener("loadstart", fn2);
        } else {
          this[kEvents].loadstart = null;
        }
      }
      get onprogress() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].progress;
      }
      set onprogress(fn2) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].progress) {
          this.removeEventListener("progress", this[kEvents].progress);
        }
        if (typeof fn2 === "function") {
          this[kEvents].progress = fn2;
          this.addEventListener("progress", fn2);
        } else {
          this[kEvents].progress = null;
        }
      }
      get onload() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].load;
      }
      set onload(fn2) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].load) {
          this.removeEventListener("load", this[kEvents].load);
        }
        if (typeof fn2 === "function") {
          this[kEvents].load = fn2;
          this.addEventListener("load", fn2);
        } else {
          this[kEvents].load = null;
        }
      }
      get onabort() {
        webidl.brandCheck(this, _FileReader);
        return this[kEvents].abort;
      }
      set onabort(fn2) {
        webidl.brandCheck(this, _FileReader);
        if (this[kEvents].abort) {
          this.removeEventListener("abort", this[kEvents].abort);
        }
        if (typeof fn2 === "function") {
          this[kEvents].abort = fn2;
          this.addEventListener("abort", fn2);
        } else {
          this[kEvents].abort = null;
        }
      }
    };
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors,
      readAsArrayBuffer: kEnumerableProperty,
      readAsBinaryString: kEnumerableProperty,
      readAsText: kEnumerableProperty,
      readAsDataURL: kEnumerableProperty,
      abort: kEnumerableProperty,
      readyState: kEnumerableProperty,
      result: kEnumerableProperty,
      error: kEnumerableProperty,
      onloadstart: kEnumerableProperty,
      onprogress: kEnumerableProperty,
      onload: kEnumerableProperty,
      onabort: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onloadend: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "FileReader",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(FileReader, {
      EMPTY: staticPropertyDescriptors,
      LOADING: staticPropertyDescriptors,
      DONE: staticPropertyDescriptors
    });
    module.exports = {
      FileReader
    };
  }
});

// node_modules/undici/lib/cache/symbols.js
var require_symbols4 = __commonJS({
  "node_modules/undici/lib/cache/symbols.js"(exports, module) {
    module.exports = {
      kConstruct: require_symbols().kConstruct
    };
  }
});

// node_modules/undici/lib/cache/util.js
var require_util5 = __commonJS({
  "node_modules/undici/lib/cache/util.js"(exports, module) {
    var assert = __require("assert");
    var { URLSerializer } = require_dataURL();
    var { isValidHeaderName } = require_util2();
    function urlEquals(A2, B2, excludeFragment = false) {
      const serializedA = URLSerializer(A2, excludeFragment);
      const serializedB = URLSerializer(B2, excludeFragment);
      return serializedA === serializedB;
    }
    function fieldValues(header) {
      assert(header !== null);
      const values = [];
      for (let value of header.split(",")) {
        value = value.trim();
        if (!value.length) {
          continue;
        } else if (!isValidHeaderName(value)) {
          continue;
        }
        values.push(value);
      }
      return values;
    }
    module.exports = {
      urlEquals,
      fieldValues
    };
  }
});

// node_modules/undici/lib/cache/cache.js
var require_cache = __commonJS({
  "node_modules/undici/lib/cache/cache.js"(exports, module) {
    var { kConstruct } = require_symbols4();
    var { urlEquals, fieldValues: getFieldValues } = require_util5();
    var { kEnumerableProperty, isDisturbed } = require_util();
    var { kHeadersList } = require_symbols();
    var { webidl } = require_webidl();
    var { Response, cloneResponse } = require_response();
    var { Request } = require_request2();
    var { kState, kHeaders, kGuard, kRealm } = require_symbols2();
    var { fetching } = require_fetch();
    var { urlIsHttpHttpsScheme, createDeferredPromise, readAllBytes } = require_util2();
    var assert = __require("assert");
    var { getGlobalDispatcher } = require_global2();
    var _relevantRequestResponseList, _Cache_instances, batchCacheOperations_fn, queryCache_fn, requestMatchesCachedItem_fn;
    var _Cache = class _Cache {
      constructor() {
        __privateAdd(this, _Cache_instances);
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
         * @type {requestResponseList}
         */
        __privateAdd(this, _relevantRequestResponseList);
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
        __privateSet(this, _relevantRequestResponseList, arguments[1]);
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        const p = await this.matchAll(request, options);
        if (p.length === 0) {
          return;
        }
        return p[0];
      }
      async matchAll(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const responses = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            responses.push(requestResponse[1]);
          }
        } else {
          const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            responses.push(requestResponse[1]);
          }
        }
        const responseList = [];
        for (const response of responses) {
          const responseObject = new Response(response.body?.source ?? null);
          const body = responseObject[kState].body;
          responseObject[kState] = response;
          responseObject[kState].body = body;
          responseObject[kHeaders][kHeadersList] = response.headersList;
          responseObject[kHeaders][kGuard] = "immutable";
          responseList.push(responseObject);
        }
        return Object.freeze(responseList);
      }
      async add(request) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        request = webidl.converters.RequestInfo(request);
        const requests = [request];
        const responseArrayPromise = this.addAll(requests);
        return await responseArrayPromise;
      }
      async addAll(requests) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        requests = webidl.converters["sequence<RequestInfo>"](requests);
        const responsePromises = [];
        const requestList = [];
        for (const request of requests) {
          if (typeof request === "string") {
            continue;
          }
          const r = request[kState];
          if (!urlIsHttpHttpsScheme(r.url) || r.method !== "GET") {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme when method is not GET."
            });
          }
        }
        const fetchControllers = [];
        for (const request of requests) {
          const r = new Request(request)[kState];
          if (!urlIsHttpHttpsScheme(r.url)) {
            throw webidl.errors.exception({
              header: "Cache.addAll",
              message: "Expected http/s scheme."
            });
          }
          r.initiator = "fetch";
          r.destination = "subresource";
          requestList.push(r);
          const responsePromise = createDeferredPromise();
          fetchControllers.push(fetching({
            request: r,
            dispatcher: getGlobalDispatcher(),
            processResponse(response) {
              if (response.type === "error" || response.status === 206 || response.status < 200 || response.status > 299) {
                responsePromise.reject(webidl.errors.exception({
                  header: "Cache.addAll",
                  message: "Received an invalid status code or the request failed."
                }));
              } else if (response.headersList.contains("vary")) {
                const fieldValues = getFieldValues(response.headersList.get("vary"));
                for (const fieldValue of fieldValues) {
                  if (fieldValue === "*") {
                    responsePromise.reject(webidl.errors.exception({
                      header: "Cache.addAll",
                      message: "invalid vary field value"
                    }));
                    for (const controller of fetchControllers) {
                      controller.abort();
                    }
                    return;
                  }
                }
              }
            },
            processResponseEndOfBody(response) {
              if (response.aborted) {
                responsePromise.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              responsePromise.resolve(response);
            }
          }));
          responsePromises.push(responsePromise.promise);
        }
        const p = Promise.all(responsePromises);
        const responses = await p;
        const operations = [];
        let index = 0;
        for (const response of responses) {
          const operation = {
            type: "put",
            // 7.3.2
            request: requestList[index],
            // 7.3.3
            response
            // 7.3.4
          };
          operations.push(operation);
          index++;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(void 0);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async put(request, response) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        request = webidl.converters.RequestInfo(request);
        response = webidl.converters.Response(response);
        let innerRequest = null;
        if (request instanceof Request) {
          innerRequest = request[kState];
        } else {
          innerRequest = new Request(request)[kState];
        }
        if (!urlIsHttpHttpsScheme(innerRequest.url) || innerRequest.method !== "GET") {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Expected an http/s scheme when method is not GET"
          });
        }
        const innerResponse = response[kState];
        if (innerResponse.status === 206) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Got 206 status"
          });
        }
        if (innerResponse.headersList.contains("vary")) {
          const fieldValues = getFieldValues(innerResponse.headersList.get("vary"));
          for (const fieldValue of fieldValues) {
            if (fieldValue === "*") {
              throw webidl.errors.exception({
                header: "Cache.put",
                message: "Got * vary field value"
              });
            }
          }
        }
        if (innerResponse.body && (isDisturbed(innerResponse.body.stream) || innerResponse.body.stream.locked)) {
          throw webidl.errors.exception({
            header: "Cache.put",
            message: "Response body is locked or disturbed"
          });
        }
        const clonedResponse = cloneResponse(innerResponse);
        const bodyReadPromise = createDeferredPromise();
        if (innerResponse.body != null) {
          const stream = innerResponse.body.stream;
          const reader = stream.getReader();
          readAllBytes(reader).then(bodyReadPromise.resolve, bodyReadPromise.reject);
        } else {
          bodyReadPromise.resolve(void 0);
        }
        const operations = [];
        const operation = {
          type: "put",
          // 14.
          request: innerRequest,
          // 15.
          response: clonedResponse
          // 16.
        };
        operations.push(operation);
        const bytes = await bodyReadPromise.promise;
        if (clonedResponse.body != null) {
          clonedResponse.body.source = bytes;
        }
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        try {
          __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve();
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      async delete(request, options = {}) {
        webidl.brandCheck(this, _Cache);
        webidl.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request instanceof Request) {
          r = request[kState];
          if (r.method !== "GET" && !options.ignoreMethod) {
            return false;
          }
        } else {
          assert(typeof request === "string");
          r = new Request(request)[kState];
        }
        const operations = [];
        const operation = {
          type: "delete",
          request: r,
          options
        };
        operations.push(operation);
        const cacheJobPromise = createDeferredPromise();
        let errorData = null;
        let requestResponses;
        try {
          requestResponses = __privateMethod(this, _Cache_instances, batchCacheOperations_fn).call(this, operations);
        } catch (e) {
          errorData = e;
        }
        queueMicrotask(() => {
          if (errorData === null) {
            cacheJobPromise.resolve(!!requestResponses?.length);
          } else {
            cacheJobPromise.reject(errorData);
          }
        });
        return cacheJobPromise.promise;
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
       * @param {any} request
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @returns {readonly Request[]}
       */
      async keys(request = void 0, options = {}) {
        webidl.brandCheck(this, _Cache);
        if (request !== void 0) request = webidl.converters.RequestInfo(request);
        options = webidl.converters.CacheQueryOptions(options);
        let r = null;
        if (request !== void 0) {
          if (request instanceof Request) {
            r = request[kState];
            if (r.method !== "GET" && !options.ignoreMethod) {
              return [];
            }
          } else if (typeof request === "string") {
            r = new Request(request)[kState];
          }
        }
        const promise = createDeferredPromise();
        const requests = [];
        if (request === void 0) {
          for (const requestResponse of __privateGet(this, _relevantRequestResponseList)) {
            requests.push(requestResponse[0]);
          }
        } else {
          const requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, r, options);
          for (const requestResponse of requestResponses) {
            requests.push(requestResponse[0]);
          }
        }
        queueMicrotask(() => {
          const requestList = [];
          for (const request2 of requests) {
            const requestObject = new Request("https://a");
            requestObject[kState] = request2;
            requestObject[kHeaders][kHeadersList] = request2.headersList;
            requestObject[kHeaders][kGuard] = "immutable";
            requestObject[kRealm] = request2.client;
            requestList.push(requestObject);
          }
          promise.resolve(Object.freeze(requestList));
        });
        return promise.promise;
      }
    };
    _relevantRequestResponseList = new WeakMap();
    _Cache_instances = new WeakSet();
    /**
     * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
     * @param {CacheBatchOperation[]} operations
     * @returns {requestResponseList}
     */
    batchCacheOperations_fn = function(operations) {
      const cache = __privateGet(this, _relevantRequestResponseList);
      const backupCache = [...cache];
      const addedItems = [];
      const resultList = [];
      try {
        for (const operation of operations) {
          if (operation.type !== "delete" && operation.type !== "put") {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"'
            });
          }
          if (operation.type === "delete" && operation.response != null) {
            throw webidl.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "delete operation should not have an associated response"
            });
          }
          if (__privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options, addedItems).length) {
            throw new DOMException("???", "InvalidStateError");
          }
          let requestResponses;
          if (operation.type === "delete") {
            requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request, operation.options);
            if (requestResponses.length === 0) {
              return [];
            }
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
          } else if (operation.type === "put") {
            if (operation.response == null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response"
              });
            }
            const r = operation.request;
            if (!urlIsHttpHttpsScheme(r.url)) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme"
              });
            }
            if (r.method !== "GET") {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method"
              });
            }
            if (operation.options != null) {
              throw webidl.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined"
              });
            }
            requestResponses = __privateMethod(this, _Cache_instances, queryCache_fn).call(this, operation.request);
            for (const requestResponse of requestResponses) {
              const idx = cache.indexOf(requestResponse);
              assert(idx !== -1);
              cache.splice(idx, 1);
            }
            cache.push([operation.request, operation.response]);
            addedItems.push([operation.request, operation.response]);
          }
          resultList.push([operation.request, operation.response]);
        }
        return resultList;
      } catch (e) {
        __privateGet(this, _relevantRequestResponseList).length = 0;
        __privateSet(this, _relevantRequestResponseList, backupCache);
        throw e;
      }
    };
    /**
     * @see https://w3c.github.io/ServiceWorker/#query-cache
     * @param {any} requestQuery
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @param {requestResponseList} targetStorage
     * @returns {requestResponseList}
     */
    queryCache_fn = function(requestQuery, options, targetStorage) {
      const resultList = [];
      const storage = targetStorage ?? __privateGet(this, _relevantRequestResponseList);
      for (const requestResponse of storage) {
        const [cachedRequest, cachedResponse] = requestResponse;
        if (__privateMethod(this, _Cache_instances, requestMatchesCachedItem_fn).call(this, requestQuery, cachedRequest, cachedResponse, options)) {
          resultList.push(requestResponse);
        }
      }
      return resultList;
    };
    /**
     * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
     * @param {any} requestQuery
     * @param {any} request
     * @param {any | null} response
     * @param {import('../../types/cache').CacheQueryOptions | undefined} options
     * @returns {boolean}
     */
    requestMatchesCachedItem_fn = function(requestQuery, request, response = null, options) {
      const queryURL = new URL(requestQuery.url);
      const cachedURL = new URL(request.url);
      if (options?.ignoreSearch) {
        cachedURL.search = "";
        queryURL.search = "";
      }
      if (!urlEquals(queryURL, cachedURL, true)) {
        return false;
      }
      if (response == null || options?.ignoreVary || !response.headersList.contains("vary")) {
        return true;
      }
      const fieldValues = getFieldValues(response.headersList.get("vary"));
      for (const fieldValue of fieldValues) {
        if (fieldValue === "*") {
          return false;
        }
        const requestValue = request.headersList.get(fieldValue);
        const queryValue = requestQuery.headersList.get(fieldValue);
        if (requestValue !== queryValue) {
          return false;
        }
      }
      return true;
    };
    var Cache = _Cache;
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: {
        value: "Cache",
        configurable: true
      },
      match: kEnumerableProperty,
      matchAll: kEnumerableProperty,
      add: kEnumerableProperty,
      addAll: kEnumerableProperty,
      put: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    var cacheQueryOptionConverters = [
      {
        key: "ignoreSearch",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreMethod",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "ignoreVary",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.CacheQueryOptions = webidl.dictionaryConverter(cacheQueryOptionConverters);
    webidl.converters.MultiCacheQueryOptions = webidl.dictionaryConverter([
      ...cacheQueryOptionConverters,
      {
        key: "cacheName",
        converter: webidl.converters.DOMString
      }
    ]);
    webidl.converters.Response = webidl.interfaceConverter(Response);
    webidl.converters["sequence<RequestInfo>"] = webidl.sequenceConverter(
      webidl.converters.RequestInfo
    );
    module.exports = {
      Cache
    };
  }
});

// node_modules/undici/lib/cache/cachestorage.js
var require_cachestorage = __commonJS({
  "node_modules/undici/lib/cache/cachestorage.js"(exports, module) {
    var { kConstruct } = require_symbols4();
    var { Cache } = require_cache();
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var _caches;
    var _CacheStorage = class _CacheStorage {
      constructor() {
        /**
         * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
         * @type {Map<string, import('./cache').requestResponseList}
         */
        __privateAdd(this, _caches, /* @__PURE__ */ new Map());
        if (arguments[0] !== kConstruct) {
          webidl.illegalConstructor();
        }
      }
      async match(request, options = {}) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        request = webidl.converters.RequestInfo(request);
        options = webidl.converters.MultiCacheQueryOptions(options);
        if (options.cacheName != null) {
          if (__privateGet(this, _caches).has(options.cacheName)) {
            const cacheList = __privateGet(this, _caches).get(options.cacheName);
            const cache = new Cache(kConstruct, cacheList);
            return await cache.match(request, options);
          }
        } else {
          for (const cacheList of __privateGet(this, _caches).values()) {
            const cache = new Cache(kConstruct, cacheList);
            const response = await cache.match(request, options);
            if (response !== void 0) {
              return response;
            }
          }
        }
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async has(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).has(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
       * @param {string} cacheName
       * @returns {Promise<Cache>}
       */
      async open(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        cacheName = webidl.converters.DOMString(cacheName);
        if (__privateGet(this, _caches).has(cacheName)) {
          const cache2 = __privateGet(this, _caches).get(cacheName);
          return new Cache(kConstruct, cache2);
        }
        const cache = [];
        __privateGet(this, _caches).set(cacheName, cache);
        return new Cache(kConstruct, cache);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
       * @param {string} cacheName
       * @returns {Promise<boolean>}
       */
      async delete(cacheName) {
        webidl.brandCheck(this, _CacheStorage);
        webidl.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        cacheName = webidl.converters.DOMString(cacheName);
        return __privateGet(this, _caches).delete(cacheName);
      }
      /**
       * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
       * @returns {string[]}
       */
      async keys() {
        webidl.brandCheck(this, _CacheStorage);
        const keys = __privateGet(this, _caches).keys();
        return [...keys];
      }
    };
    _caches = new WeakMap();
    var CacheStorage = _CacheStorage;
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: {
        value: "CacheStorage",
        configurable: true
      },
      match: kEnumerableProperty,
      has: kEnumerableProperty,
      open: kEnumerableProperty,
      delete: kEnumerableProperty,
      keys: kEnumerableProperty
    });
    module.exports = {
      CacheStorage
    };
  }
});

// node_modules/undici/lib/cookies/constants.js
var require_constants4 = __commonJS({
  "node_modules/undici/lib/cookies/constants.js"(exports, module) {
    var maxAttributeValueSize = 1024;
    var maxNameValuePairSize = 4096;
    module.exports = {
      maxAttributeValueSize,
      maxNameValuePairSize
    };
  }
});

// node_modules/undici/lib/cookies/util.js
var require_util6 = __commonJS({
  "node_modules/undici/lib/cookies/util.js"(exports, module) {
    var assert = __require("assert");
    var { kHeadersList } = require_symbols();
    function isCTLExcludingHtab(value) {
      if (value.length === 0) {
        return false;
      }
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code >= 0 || code <= 8 || (code >= 10 || code <= 31) || code === 127) {
          return false;
        }
      }
    }
    function validateCookieName(name) {
      for (const char of name) {
        const code = char.charCodeAt(0);
        if (code <= 32 || code > 127 || char === "(" || char === ")" || char === ">" || char === "<" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}") {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(value) {
      for (const char of value) {
        const code = char.charCodeAt(0);
        if (code < 33 || // exclude CTLs (0-31)
        code === 34 || code === 44 || code === 59 || code === 92 || code > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(path) {
      for (const char of path) {
        const code = char.charCodeAt(0);
        if (code < 33 || char === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(domain) {
      if (domain.startsWith("-") || domain.endsWith(".") || domain.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(date) {
      if (typeof date === "number") {
        date = new Date(date);
      }
      const days = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      const months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      const dayName = days[date.getUTCDay()];
      const day = date.getUTCDate().toString().padStart(2, "0");
      const month = months[date.getUTCMonth()];
      const year = date.getUTCFullYear();
      const hour = date.getUTCHours().toString().padStart(2, "0");
      const minute = date.getUTCMinutes().toString().padStart(2, "0");
      const second = date.getUTCSeconds().toString().padStart(2, "0");
      return `${dayName}, ${day} ${month} ${year} ${hour}:${minute}:${second} GMT`;
    }
    function validateCookieMaxAge(maxAge) {
      if (maxAge < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(cookie) {
      if (cookie.name.length === 0) {
        return null;
      }
      validateCookieName(cookie.name);
      validateCookieValue(cookie.value);
      const out = [`${cookie.name}=${cookie.value}`];
      if (cookie.name.startsWith("__Secure-")) {
        cookie.secure = true;
      }
      if (cookie.name.startsWith("__Host-")) {
        cookie.secure = true;
        cookie.domain = null;
        cookie.path = "/";
      }
      if (cookie.secure) {
        out.push("Secure");
      }
      if (cookie.httpOnly) {
        out.push("HttpOnly");
      }
      if (typeof cookie.maxAge === "number") {
        validateCookieMaxAge(cookie.maxAge);
        out.push(`Max-Age=${cookie.maxAge}`);
      }
      if (cookie.domain) {
        validateCookieDomain(cookie.domain);
        out.push(`Domain=${cookie.domain}`);
      }
      if (cookie.path) {
        validateCookiePath(cookie.path);
        out.push(`Path=${cookie.path}`);
      }
      if (cookie.expires && cookie.expires.toString() !== "Invalid Date") {
        out.push(`Expires=${toIMFDate(cookie.expires)}`);
      }
      if (cookie.sameSite) {
        out.push(`SameSite=${cookie.sameSite}`);
      }
      for (const part of cookie.unparsed) {
        if (!part.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [key, ...value] = part.split("=");
        out.push(`${key.trim()}=${value.join("=")}`);
      }
      return out.join("; ");
    }
    var kHeadersListNode;
    function getHeadersList(headers) {
      if (headers[kHeadersList]) {
        return headers[kHeadersList];
      }
      if (!kHeadersListNode) {
        kHeadersListNode = Object.getOwnPropertySymbols(headers).find(
          (symbol) => symbol.description === "headers list"
        );
        assert(kHeadersListNode, "Headers cannot be parsed");
      }
      const headersList = headers[kHeadersListNode];
      assert(headersList);
      return headersList;
    }
    module.exports = {
      isCTLExcludingHtab,
      stringify,
      getHeadersList
    };
  }
});

// node_modules/undici/lib/cookies/parse.js
var require_parse = __commonJS({
  "node_modules/undici/lib/cookies/parse.js"(exports, module) {
    var { maxNameValuePairSize, maxAttributeValueSize } = require_constants4();
    var { isCTLExcludingHtab } = require_util6();
    var { collectASequenceOfCodePointsFast } = require_dataURL();
    var assert = __require("assert");
    function parseSetCookie(header) {
      if (isCTLExcludingHtab(header)) {
        return null;
      }
      let nameValuePair = "";
      let unparsedAttributes = "";
      let name = "";
      let value = "";
      if (header.includes(";")) {
        const position = { position: 0 };
        nameValuePair = collectASequenceOfCodePointsFast(";", header, position);
        unparsedAttributes = header.slice(position.position);
      } else {
        nameValuePair = header;
      }
      if (!nameValuePair.includes("=")) {
        value = nameValuePair;
      } else {
        const position = { position: 0 };
        name = collectASequenceOfCodePointsFast(
          "=",
          nameValuePair,
          position
        );
        value = nameValuePair.slice(position.position + 1);
      }
      name = name.trim();
      value = value.trim();
      if (name.length + value.length > maxNameValuePairSize) {
        return null;
      }
      return {
        name,
        value,
        ...parseUnparsedAttributes(unparsedAttributes)
      };
    }
    function parseUnparsedAttributes(unparsedAttributes, cookieAttributeList = {}) {
      if (unparsedAttributes.length === 0) {
        return cookieAttributeList;
      }
      assert(unparsedAttributes[0] === ";");
      unparsedAttributes = unparsedAttributes.slice(1);
      let cookieAv = "";
      if (unparsedAttributes.includes(";")) {
        cookieAv = collectASequenceOfCodePointsFast(
          ";",
          unparsedAttributes,
          { position: 0 }
        );
        unparsedAttributes = unparsedAttributes.slice(cookieAv.length);
      } else {
        cookieAv = unparsedAttributes;
        unparsedAttributes = "";
      }
      let attributeName = "";
      let attributeValue = "";
      if (cookieAv.includes("=")) {
        const position = { position: 0 };
        attributeName = collectASequenceOfCodePointsFast(
          "=",
          cookieAv,
          position
        );
        attributeValue = cookieAv.slice(position.position + 1);
      } else {
        attributeName = cookieAv;
      }
      attributeName = attributeName.trim();
      attributeValue = attributeValue.trim();
      if (attributeValue.length > maxAttributeValueSize) {
        return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
      }
      const attributeNameLowercase = attributeName.toLowerCase();
      if (attributeNameLowercase === "expires") {
        const expiryTime = new Date(attributeValue);
        cookieAttributeList.expires = expiryTime;
      } else if (attributeNameLowercase === "max-age") {
        const charCode = attributeValue.charCodeAt(0);
        if ((charCode < 48 || charCode > 57) && attributeValue[0] !== "-") {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        if (!/^\d+$/.test(attributeValue)) {
          return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
        }
        const deltaSeconds = Number(attributeValue);
        cookieAttributeList.maxAge = deltaSeconds;
      } else if (attributeNameLowercase === "domain") {
        let cookieDomain = attributeValue;
        if (cookieDomain[0] === ".") {
          cookieDomain = cookieDomain.slice(1);
        }
        cookieDomain = cookieDomain.toLowerCase();
        cookieAttributeList.domain = cookieDomain;
      } else if (attributeNameLowercase === "path") {
        let cookiePath = "";
        if (attributeValue.length === 0 || attributeValue[0] !== "/") {
          cookiePath = "/";
        } else {
          cookiePath = attributeValue;
        }
        cookieAttributeList.path = cookiePath;
      } else if (attributeNameLowercase === "secure") {
        cookieAttributeList.secure = true;
      } else if (attributeNameLowercase === "httponly") {
        cookieAttributeList.httpOnly = true;
      } else if (attributeNameLowercase === "samesite") {
        let enforcement = "Default";
        const attributeValueLowercase = attributeValue.toLowerCase();
        if (attributeValueLowercase.includes("none")) {
          enforcement = "None";
        }
        if (attributeValueLowercase.includes("strict")) {
          enforcement = "Strict";
        }
        if (attributeValueLowercase.includes("lax")) {
          enforcement = "Lax";
        }
        cookieAttributeList.sameSite = enforcement;
      } else {
        cookieAttributeList.unparsed ?? (cookieAttributeList.unparsed = []);
        cookieAttributeList.unparsed.push(`${attributeName}=${attributeValue}`);
      }
      return parseUnparsedAttributes(unparsedAttributes, cookieAttributeList);
    }
    module.exports = {
      parseSetCookie,
      parseUnparsedAttributes
    };
  }
});

// node_modules/undici/lib/cookies/index.js
var require_cookies = __commonJS({
  "node_modules/undici/lib/cookies/index.js"(exports, module) {
    var { parseSetCookie } = require_parse();
    var { stringify, getHeadersList } = require_util6();
    var { webidl } = require_webidl();
    var { Headers: Headers2 } = require_headers();
    function getCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      webidl.brandCheck(headers, Headers2, { strict: false });
      const cookie = headers.get("cookie");
      const out = {};
      if (!cookie) {
        return out;
      }
      for (const piece of cookie.split(";")) {
        const [name, ...value] = piece.split("=");
        out[name.trim()] = value.join("=");
      }
      return out;
    }
    function deleteCookie(headers, name, attributes) {
      webidl.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      webidl.brandCheck(headers, Headers2, { strict: false });
      name = webidl.converters.DOMString(name);
      attributes = webidl.converters.DeleteCookieAttributes(attributes);
      setCookie(headers, {
        name,
        value: "",
        expires: /* @__PURE__ */ new Date(0),
        ...attributes
      });
    }
    function getSetCookies(headers) {
      webidl.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      webidl.brandCheck(headers, Headers2, { strict: false });
      const cookies = getHeadersList(headers).cookies;
      if (!cookies) {
        return [];
      }
      return cookies.map((pair) => parseSetCookie(Array.isArray(pair) ? pair[1] : pair));
    }
    function setCookie(headers, cookie) {
      webidl.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      webidl.brandCheck(headers, Headers2, { strict: false });
      cookie = webidl.converters.Cookie(cookie);
      const str = stringify(cookie);
      if (str) {
        headers.append("Set-Cookie", stringify(cookie));
      }
    }
    webidl.converters.DeleteCookieAttributes = webidl.dictionaryConverter([
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      }
    ]);
    webidl.converters.Cookie = webidl.dictionaryConverter([
      {
        converter: webidl.converters.DOMString,
        key: "name"
      },
      {
        converter: webidl.converters.DOMString,
        key: "value"
      },
      {
        converter: webidl.nullableConverter((value) => {
          if (typeof value === "number") {
            return webidl.converters["unsigned long long"](value);
          }
          return new Date(value);
        }),
        key: "expires",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters["long long"]),
        key: "maxAge",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "domain",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.DOMString),
        key: "path",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "secure",
        defaultValue: null
      },
      {
        converter: webidl.nullableConverter(webidl.converters.boolean),
        key: "httpOnly",
        defaultValue: null
      },
      {
        converter: webidl.converters.USVString,
        key: "sameSite",
        allowedValues: ["Strict", "Lax", "None"]
      },
      {
        converter: webidl.sequenceConverter(webidl.converters.DOMString),
        key: "unparsed",
        defaultValue: []
      }
    ]);
    module.exports = {
      getCookies,
      deleteCookie,
      getSetCookies,
      setCookie
    };
  }
});

// node_modules/undici/lib/websocket/constants.js
var require_constants5 = __commonJS({
  "node_modules/undici/lib/websocket/constants.js"(exports, module) {
    var uid = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var staticPropertyDescriptors = {
      enumerable: true,
      writable: false,
      configurable: false
    };
    var states = {
      CONNECTING: 0,
      OPEN: 1,
      CLOSING: 2,
      CLOSED: 3
    };
    var opcodes = {
      CONTINUATION: 0,
      TEXT: 1,
      BINARY: 2,
      CLOSE: 8,
      PING: 9,
      PONG: 10
    };
    var maxUnsigned16Bit = 2 ** 16 - 1;
    var parserStates = {
      INFO: 0,
      PAYLOADLENGTH_16: 2,
      PAYLOADLENGTH_64: 3,
      READ_DATA: 4
    };
    var emptyBuffer = Buffer.allocUnsafe(0);
    module.exports = {
      uid,
      staticPropertyDescriptors,
      states,
      opcodes,
      maxUnsigned16Bit,
      parserStates,
      emptyBuffer
    };
  }
});

// node_modules/undici/lib/websocket/symbols.js
var require_symbols5 = __commonJS({
  "node_modules/undici/lib/websocket/symbols.js"(exports, module) {
    module.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser")
    };
  }
});

// node_modules/undici/lib/websocket/events.js
var require_events = __commonJS({
  "node_modules/undici/lib/websocket/events.js"(exports, module) {
    var { webidl } = require_webidl();
    var { kEnumerableProperty } = require_util();
    var { MessagePort } = __require("worker_threads");
    var _eventInit;
    var _MessageEvent = class _MessageEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.MessageEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit);
        __privateSet(this, _eventInit, eventInitDict);
      }
      get data() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).data;
      }
      get origin() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).origin;
      }
      get lastEventId() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).lastEventId;
      }
      get source() {
        webidl.brandCheck(this, _MessageEvent);
        return __privateGet(this, _eventInit).source;
      }
      get ports() {
        webidl.brandCheck(this, _MessageEvent);
        if (!Object.isFrozen(__privateGet(this, _eventInit).ports)) {
          Object.freeze(__privateGet(this, _eventInit).ports);
        }
        return __privateGet(this, _eventInit).ports;
      }
      initMessageEvent(type, bubbles = false, cancelable = false, data = null, origin = "", lastEventId = "", source = null, ports = []) {
        webidl.brandCheck(this, _MessageEvent);
        webidl.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new _MessageEvent(type, {
          bubbles,
          cancelable,
          data,
          origin,
          lastEventId,
          source,
          ports
        });
      }
    };
    _eventInit = new WeakMap();
    var MessageEvent = _MessageEvent;
    var _eventInit2;
    var _CloseEvent = class _CloseEvent extends Event {
      constructor(type, eventInitDict = {}) {
        webidl.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.CloseEventInit(eventInitDict);
        super(type, eventInitDict);
        __privateAdd(this, _eventInit2);
        __privateSet(this, _eventInit2, eventInitDict);
      }
      get wasClean() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).wasClean;
      }
      get code() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).code;
      }
      get reason() {
        webidl.brandCheck(this, _CloseEvent);
        return __privateGet(this, _eventInit2).reason;
      }
    };
    _eventInit2 = new WeakMap();
    var CloseEvent = _CloseEvent;
    var _eventInit3;
    var _ErrorEvent = class _ErrorEvent extends Event {
      constructor(type, eventInitDict) {
        webidl.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(type, eventInitDict);
        __privateAdd(this, _eventInit3);
        type = webidl.converters.DOMString(type);
        eventInitDict = webidl.converters.ErrorEventInit(eventInitDict ?? {});
        __privateSet(this, _eventInit3, eventInitDict);
      }
      get message() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).message;
      }
      get filename() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).filename;
      }
      get lineno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).lineno;
      }
      get colno() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).colno;
      }
      get error() {
        webidl.brandCheck(this, _ErrorEvent);
        return __privateGet(this, _eventInit3).error;
      }
    };
    _eventInit3 = new WeakMap();
    var ErrorEvent = _ErrorEvent;
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "MessageEvent",
        configurable: true
      },
      data: kEnumerableProperty,
      origin: kEnumerableProperty,
      lastEventId: kEnumerableProperty,
      source: kEnumerableProperty,
      ports: kEnumerableProperty,
      initMessageEvent: kEnumerableProperty
    });
    Object.defineProperties(CloseEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "CloseEvent",
        configurable: true
      },
      reason: kEnumerableProperty,
      code: kEnumerableProperty,
      wasClean: kEnumerableProperty
    });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: {
        value: "ErrorEvent",
        configurable: true
      },
      message: kEnumerableProperty,
      filename: kEnumerableProperty,
      lineno: kEnumerableProperty,
      colno: kEnumerableProperty,
      error: kEnumerableProperty
    });
    webidl.converters.MessagePort = webidl.interfaceConverter(MessagePort);
    webidl.converters["sequence<MessagePort>"] = webidl.sequenceConverter(
      webidl.converters.MessagePort
    );
    var eventInit = [
      {
        key: "bubbles",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "cancelable",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "composed",
        converter: webidl.converters.boolean,
        defaultValue: false
      }
    ];
    webidl.converters.MessageEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "data",
        converter: webidl.converters.any,
        defaultValue: null
      },
      {
        key: "origin",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lastEventId",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "source",
        // Node doesn't implement WindowProxy or ServiceWorker, so the only
        // valid value for source is a MessagePort.
        converter: webidl.nullableConverter(webidl.converters.MessagePort),
        defaultValue: null
      },
      {
        key: "ports",
        converter: webidl.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        }
      }
    ]);
    webidl.converters.CloseEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "wasClean",
        converter: webidl.converters.boolean,
        defaultValue: false
      },
      {
        key: "code",
        converter: webidl.converters["unsigned short"],
        defaultValue: 0
      },
      {
        key: "reason",
        converter: webidl.converters.USVString,
        defaultValue: ""
      }
    ]);
    webidl.converters.ErrorEventInit = webidl.dictionaryConverter([
      ...eventInit,
      {
        key: "message",
        converter: webidl.converters.DOMString,
        defaultValue: ""
      },
      {
        key: "filename",
        converter: webidl.converters.USVString,
        defaultValue: ""
      },
      {
        key: "lineno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "colno",
        converter: webidl.converters["unsigned long"],
        defaultValue: 0
      },
      {
        key: "error",
        converter: webidl.converters.any
      }
    ]);
    module.exports = {
      MessageEvent,
      CloseEvent,
      ErrorEvent
    };
  }
});

// node_modules/undici/lib/websocket/util.js
var require_util7 = __commonJS({
  "node_modules/undici/lib/websocket/util.js"(exports, module) {
    var { kReadyState, kController, kResponse, kBinaryType, kWebSocketURL } = require_symbols5();
    var { states, opcodes } = require_constants5();
    var { MessageEvent, ErrorEvent } = require_events();
    function isEstablished(ws) {
      return ws[kReadyState] === states.OPEN;
    }
    function isClosing(ws) {
      return ws[kReadyState] === states.CLOSING;
    }
    function isClosed(ws) {
      return ws[kReadyState] === states.CLOSED;
    }
    function fireEvent(e, target, eventConstructor = Event, eventInitDict) {
      const event = new eventConstructor(e, eventInitDict);
      target.dispatchEvent(event);
    }
    function websocketMessageReceived(ws, type, data) {
      if (ws[kReadyState] !== states.OPEN) {
        return;
      }
      let dataForEvent;
      if (type === opcodes.TEXT) {
        try {
          dataForEvent = new TextDecoder("utf-8", { fatal: true }).decode(data);
        } catch {
          failWebsocketConnection(ws, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (type === opcodes.BINARY) {
        if (ws[kBinaryType] === "blob") {
          dataForEvent = new Blob([data]);
        } else {
          dataForEvent = new Uint8Array(data).buffer;
        }
      }
      fireEvent("message", ws, MessageEvent, {
        origin: ws[kWebSocketURL].origin,
        data: dataForEvent
      });
    }
    function isValidSubprotocol(protocol) {
      if (protocol.length === 0) {
        return false;
      }
      for (const char of protocol) {
        const code = char.charCodeAt(0);
        if (code < 33 || code > 126 || char === "(" || char === ")" || char === "<" || char === ">" || char === "@" || char === "," || char === ";" || char === ":" || char === "\\" || char === '"' || char === "/" || char === "[" || char === "]" || char === "?" || char === "=" || char === "{" || char === "}" || code === 32 || // SP
        code === 9) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(code) {
      if (code >= 1e3 && code < 1015) {
        return code !== 1004 && // reserved
        code !== 1005 && // "MUST NOT be set as a status code"
        code !== 1006;
      }
      return code >= 3e3 && code <= 4999;
    }
    function failWebsocketConnection(ws, reason) {
      const { [kController]: controller, [kResponse]: response } = ws;
      controller.abort();
      if (response?.socket && !response.socket.destroyed) {
        response.socket.destroy();
      }
      if (reason) {
        fireEvent("error", ws, ErrorEvent, {
          error: new Error(reason)
        });
      }
    }
    module.exports = {
      isEstablished,
      isClosing,
      isClosed,
      fireEvent,
      isValidSubprotocol,
      isValidStatusCode,
      failWebsocketConnection,
      websocketMessageReceived
    };
  }
});

// node_modules/undici/lib/websocket/connection.js
var require_connection = __commonJS({
  "node_modules/undici/lib/websocket/connection.js"(exports, module) {
    var diagnosticsChannel = __require("diagnostics_channel");
    var { uid, states } = require_constants5();
    var {
      kReadyState,
      kSentClose,
      kByteParser,
      kReceivedClose
    } = require_symbols5();
    var { fireEvent, failWebsocketConnection } = require_util7();
    var { CloseEvent } = require_events();
    var { makeRequest } = require_request2();
    var { fetching } = require_fetch();
    var { Headers: Headers2 } = require_headers();
    var { getGlobalDispatcher } = require_global2();
    var { kHeadersList } = require_symbols();
    var channels = {};
    channels.open = diagnosticsChannel.channel("undici:websocket:open");
    channels.close = diagnosticsChannel.channel("undici:websocket:close");
    channels.socketError = diagnosticsChannel.channel("undici:websocket:socket_error");
    var crypto;
    try {
      crypto = __require("crypto");
    } catch {
    }
    function establishWebSocketConnection(url, protocols, ws, onEstablish, options) {
      const requestURL = url;
      requestURL.protocol = url.protocol === "ws:" ? "http:" : "https:";
      const request = makeRequest({
        urlList: [requestURL],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error"
      });
      if (options.headers) {
        const headersList = new Headers2(options.headers)[kHeadersList];
        request.headersList = headersList;
      }
      const keyValue = crypto.randomBytes(16).toString("base64");
      request.headersList.append("sec-websocket-key", keyValue);
      request.headersList.append("sec-websocket-version", "13");
      for (const protocol of protocols) {
        request.headersList.append("sec-websocket-protocol", protocol);
      }
      const permessageDeflate = "";
      const controller = fetching({
        request,
        useParallelQueue: true,
        dispatcher: options.dispatcher ?? getGlobalDispatcher(),
        processResponse(response) {
          if (response.type === "error" || response.status !== 101) {
            failWebsocketConnection(ws, "Received network error or non-101 status code.");
            return;
          }
          if (protocols.length !== 0 && !response.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Server did not respond with sent protocols.");
            return;
          }
          if (response.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            failWebsocketConnection(ws, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (response.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            failWebsocketConnection(ws, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const secWSAccept = response.headersList.get("Sec-WebSocket-Accept");
          const digest = crypto.createHash("sha1").update(keyValue + uid).digest("base64");
          if (secWSAccept !== digest) {
            failWebsocketConnection(ws, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const secExtension = response.headersList.get("Sec-WebSocket-Extensions");
          if (secExtension !== null && secExtension !== permessageDeflate) {
            failWebsocketConnection(ws, "Received different permessage-deflate than the one set.");
            return;
          }
          const secProtocol = response.headersList.get("Sec-WebSocket-Protocol");
          if (secProtocol !== null && secProtocol !== request.headersList.get("Sec-WebSocket-Protocol")) {
            failWebsocketConnection(ws, "Protocol was not set in the opening handshake.");
            return;
          }
          response.socket.on("data", onSocketData);
          response.socket.on("close", onSocketClose);
          response.socket.on("error", onSocketError);
          if (channels.open.hasSubscribers) {
            channels.open.publish({
              address: response.socket.address(),
              protocol: secProtocol,
              extensions: secExtension
            });
          }
          onEstablish(response);
        }
      });
      return controller;
    }
    function onSocketData(chunk) {
      if (!this.ws[kByteParser].write(chunk)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws } = this;
      const wasClean = ws[kSentClose] && ws[kReceivedClose];
      let code = 1005;
      let reason = "";
      const result = ws[kByteParser].closingInfo;
      if (result) {
        code = result.code ?? 1005;
        reason = result.reason;
      } else if (!ws[kSentClose]) {
        code = 1006;
      }
      ws[kReadyState] = states.CLOSED;
      fireEvent("close", ws, CloseEvent, {
        wasClean,
        code,
        reason
      });
      if (channels.close.hasSubscribers) {
        channels.close.publish({
          websocket: ws,
          code,
          reason
        });
      }
    }
    function onSocketError(error) {
      const { ws } = this;
      ws[kReadyState] = states.CLOSING;
      if (channels.socketError.hasSubscribers) {
        channels.socketError.publish(error);
      }
      this.destroy();
    }
    module.exports = {
      establishWebSocketConnection
    };
  }
});

// node_modules/undici/lib/websocket/frame.js
var require_frame = __commonJS({
  "node_modules/undici/lib/websocket/frame.js"(exports, module) {
    var { maxUnsigned16Bit } = require_constants5();
    var crypto;
    try {
      crypto = __require("crypto");
    } catch {
    }
    var WebsocketFrameSend = class {
      /**
       * @param {Buffer|undefined} data
       */
      constructor(data) {
        this.frameData = data;
        this.maskKey = crypto.randomBytes(4);
      }
      createFrame(opcode) {
        const bodyLength = this.frameData?.byteLength ?? 0;
        let payloadLength = bodyLength;
        let offset = 6;
        if (bodyLength > maxUnsigned16Bit) {
          offset += 8;
          payloadLength = 127;
        } else if (bodyLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const buffer = Buffer.allocUnsafe(bodyLength + offset);
        buffer[0] = buffer[1] = 0;
        buffer[0] |= 128;
        buffer[0] = (buffer[0] & 240) + opcode;
        buffer[offset - 4] = this.maskKey[0];
        buffer[offset - 3] = this.maskKey[1];
        buffer[offset - 2] = this.maskKey[2];
        buffer[offset - 1] = this.maskKey[3];
        buffer[1] = payloadLength;
        if (payloadLength === 126) {
          buffer.writeUInt16BE(bodyLength, 2);
        } else if (payloadLength === 127) {
          buffer[2] = buffer[3] = 0;
          buffer.writeUIntBE(bodyLength, 4, 6);
        }
        buffer[1] |= 128;
        for (let i = 0; i < bodyLength; i++) {
          buffer[offset + i] = this.frameData[i] ^ this.maskKey[i % 4];
        }
        return buffer;
      }
    };
    module.exports = {
      WebsocketFrameSend
    };
  }
});

// node_modules/undici/lib/websocket/receiver.js
var require_receiver = __commonJS({
  "node_modules/undici/lib/websocket/receiver.js"(exports, module) {
    var { Writable } = __require("stream");
    var diagnosticsChannel = __require("diagnostics_channel");
    var { parserStates, opcodes, states, emptyBuffer } = require_constants5();
    var { kReadyState, kSentClose, kResponse, kReceivedClose } = require_symbols5();
    var { isValidStatusCode, failWebsocketConnection, websocketMessageReceived } = require_util7();
    var { WebsocketFrameSend } = require_frame();
    var channels = {};
    channels.ping = diagnosticsChannel.channel("undici:websocket:ping");
    channels.pong = diagnosticsChannel.channel("undici:websocket:pong");
    var _buffers, _byteOffset, _state, _info, _fragments;
    var ByteParser = class extends Writable {
      constructor(ws) {
        super();
        __privateAdd(this, _buffers, []);
        __privateAdd(this, _byteOffset, 0);
        __privateAdd(this, _state, parserStates.INFO);
        __privateAdd(this, _info, {});
        __privateAdd(this, _fragments, []);
        this.ws = ws;
      }
      /**
       * @param {Buffer} chunk
       * @param {() => void} callback
       */
      _write(chunk, _2, callback) {
        __privateGet(this, _buffers).push(chunk);
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) + chunk.length);
        this.run(callback);
      }
      /**
       * Runs whenever a new chunk is received.
       * Callback is called whenever there are no more chunks buffering,
       * or not enough bytes are buffered to parse.
       */
      run(callback) {
        var _a;
        while (true) {
          if (__privateGet(this, _state) === parserStates.INFO) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).fin = (buffer[0] & 128) !== 0;
            __privateGet(this, _info).opcode = buffer[0] & 15;
            (_a = __privateGet(this, _info)).originalOpcode ?? (_a.originalOpcode = __privateGet(this, _info).opcode);
            __privateGet(this, _info).fragmented = !__privateGet(this, _info).fin && __privateGet(this, _info).opcode !== opcodes.CONTINUATION;
            if (__privateGet(this, _info).fragmented && __privateGet(this, _info).opcode !== opcodes.BINARY && __privateGet(this, _info).opcode !== opcodes.TEXT) {
              failWebsocketConnection(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const payloadLength = buffer[1] & 127;
            if (payloadLength <= 125) {
              __privateGet(this, _info).payloadLength = payloadLength;
              __privateSet(this, _state, parserStates.READ_DATA);
            } else if (payloadLength === 126) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_16);
            } else if (payloadLength === 127) {
              __privateSet(this, _state, parserStates.PAYLOADLENGTH_64);
            }
            if (__privateGet(this, _info).fragmented && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((__privateGet(this, _info).opcode === opcodes.PING || __privateGet(this, _info).opcode === opcodes.PONG || __privateGet(this, _info).opcode === opcodes.CLOSE) && payloadLength > 125) {
              failWebsocketConnection(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.CLOSE) {
              if (payloadLength === 1) {
                failWebsocketConnection(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const body = this.consume(payloadLength);
              __privateGet(this, _info).closeInfo = this.parseCloseBody(false, body);
              if (!this.ws[kSentClose]) {
                const body2 = Buffer.allocUnsafe(2);
                body2.writeUInt16BE(__privateGet(this, _info).closeInfo.code, 0);
                const closeFrame = new WebsocketFrameSend(body2);
                this.ws[kResponse].socket.write(
                  closeFrame.createFrame(opcodes.CLOSE),
                  (err) => {
                    if (!err) {
                      this.ws[kSentClose] = true;
                    }
                  }
                );
              }
              this.ws[kReadyState] = states.CLOSING;
              this.ws[kReceivedClose] = true;
              this.end();
              return;
            } else if (__privateGet(this, _info).opcode === opcodes.PING) {
              const body = this.consume(payloadLength);
              if (!this.ws[kReceivedClose]) {
                const frame = new WebsocketFrameSend(body);
                this.ws[kResponse].socket.write(frame.createFrame(opcodes.PONG));
                if (channels.ping.hasSubscribers) {
                  channels.ping.publish({
                    payload: body
                  });
                }
              }
              __privateSet(this, _state, parserStates.INFO);
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            } else if (__privateGet(this, _info).opcode === opcodes.PONG) {
              const body = this.consume(payloadLength);
              if (channels.pong.hasSubscribers) {
                channels.pong.publish({
                  payload: body
                });
              }
              if (__privateGet(this, _byteOffset) > 0) {
                continue;
              } else {
                callback();
                return;
              }
            }
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_16) {
            if (__privateGet(this, _byteOffset) < 2) {
              return callback();
            }
            const buffer = this.consume(2);
            __privateGet(this, _info).payloadLength = buffer.readUInt16BE(0);
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.PAYLOADLENGTH_64) {
            if (__privateGet(this, _byteOffset) < 8) {
              return callback();
            }
            const buffer = this.consume(8);
            const upper = buffer.readUInt32BE(0);
            if (upper > 2 ** 31 - 1) {
              failWebsocketConnection(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const lower = buffer.readUInt32BE(4);
            __privateGet(this, _info).payloadLength = (upper << 8) + lower;
            __privateSet(this, _state, parserStates.READ_DATA);
          } else if (__privateGet(this, _state) === parserStates.READ_DATA) {
            if (__privateGet(this, _byteOffset) < __privateGet(this, _info).payloadLength) {
              return callback();
            } else if (__privateGet(this, _byteOffset) >= __privateGet(this, _info).payloadLength) {
              const body = this.consume(__privateGet(this, _info).payloadLength);
              __privateGet(this, _fragments).push(body);
              if (!__privateGet(this, _info).fragmented || __privateGet(this, _info).fin && __privateGet(this, _info).opcode === opcodes.CONTINUATION) {
                const fullMessage = Buffer.concat(__privateGet(this, _fragments));
                websocketMessageReceived(this.ws, __privateGet(this, _info).originalOpcode, fullMessage);
                __privateSet(this, _info, {});
                __privateGet(this, _fragments).length = 0;
              }
              __privateSet(this, _state, parserStates.INFO);
            }
          }
          if (__privateGet(this, _byteOffset) > 0) {
            continue;
          } else {
            callback();
            break;
          }
        }
      }
      /**
       * Take n bytes from the buffered Buffers
       * @param {number} n
       * @returns {Buffer|null}
       */
      consume(n) {
        if (n > __privateGet(this, _byteOffset)) {
          return null;
        } else if (n === 0) {
          return emptyBuffer;
        }
        if (__privateGet(this, _buffers)[0].length === n) {
          __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - __privateGet(this, _buffers)[0].length);
          return __privateGet(this, _buffers).shift();
        }
        const buffer = Buffer.allocUnsafe(n);
        let offset = 0;
        while (offset !== n) {
          const next = __privateGet(this, _buffers)[0];
          const { length } = next;
          if (length + offset === n) {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            break;
          } else if (length + offset > n) {
            buffer.set(next.subarray(0, n - offset), offset);
            __privateGet(this, _buffers)[0] = next.subarray(n - offset);
            break;
          } else {
            buffer.set(__privateGet(this, _buffers).shift(), offset);
            offset += next.length;
          }
        }
        __privateSet(this, _byteOffset, __privateGet(this, _byteOffset) - n);
        return buffer;
      }
      parseCloseBody(onlyCode, data) {
        let code;
        if (data.length >= 2) {
          code = data.readUInt16BE(0);
        }
        if (onlyCode) {
          if (!isValidStatusCode(code)) {
            return null;
          }
          return { code };
        }
        let reason = data.subarray(2);
        if (reason[0] === 239 && reason[1] === 187 && reason[2] === 191) {
          reason = reason.subarray(3);
        }
        if (code !== void 0 && !isValidStatusCode(code)) {
          return null;
        }
        try {
          reason = new TextDecoder("utf-8", { fatal: true }).decode(reason);
        } catch {
          return null;
        }
        return { code, reason };
      }
      get closingInfo() {
        return __privateGet(this, _info).closeInfo;
      }
    };
    _buffers = new WeakMap();
    _byteOffset = new WeakMap();
    _state = new WeakMap();
    _info = new WeakMap();
    _fragments = new WeakMap();
    module.exports = {
      ByteParser
    };
  }
});

// node_modules/undici/lib/websocket/websocket.js
var require_websocket = __commonJS({
  "node_modules/undici/lib/websocket/websocket.js"(exports, module) {
    var { webidl } = require_webidl();
    var { DOMException: DOMException2 } = require_constants2();
    var { URLSerializer } = require_dataURL();
    var { getGlobalOrigin } = require_global();
    var { staticPropertyDescriptors, states, opcodes, emptyBuffer } = require_constants5();
    var {
      kWebSocketURL,
      kReadyState,
      kController,
      kBinaryType,
      kResponse,
      kSentClose,
      kByteParser
    } = require_symbols5();
    var { isEstablished, isClosing, isValidSubprotocol, failWebsocketConnection, fireEvent } = require_util7();
    var { establishWebSocketConnection } = require_connection();
    var { WebsocketFrameSend } = require_frame();
    var { ByteParser } = require_receiver();
    var { kEnumerableProperty, isBlobLike } = require_util();
    var { getGlobalDispatcher } = require_global2();
    var { types } = __require("util");
    var experimentalWarned = false;
    var _events, _bufferedAmount, _protocol, _extensions, _WebSocket_instances, onConnectionEstablished_fn;
    var _WebSocket = class _WebSocket extends EventTarget {
      /**
       * @param {string} url
       * @param {string|string[]} protocols
       */
      constructor(url, protocols = []) {
        super();
        __privateAdd(this, _WebSocket_instances);
        __privateAdd(this, _events, {
          open: null,
          error: null,
          close: null,
          message: null
        });
        __privateAdd(this, _bufferedAmount, 0);
        __privateAdd(this, _protocol, "");
        __privateAdd(this, _extensions, "");
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!experimentalWarned) {
          experimentalWarned = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
            code: "UNDICI-WS"
          });
        }
        const options = webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"](protocols);
        url = webidl.converters.USVString(url);
        protocols = options.protocols;
        const baseURL = getGlobalOrigin();
        let urlRecord;
        try {
          urlRecord = new URL(url, baseURL);
        } catch (e) {
          throw new DOMException2(e, "SyntaxError");
        }
        if (urlRecord.protocol === "http:") {
          urlRecord.protocol = "ws:";
        } else if (urlRecord.protocol === "https:") {
          urlRecord.protocol = "wss:";
        }
        if (urlRecord.protocol !== "ws:" && urlRecord.protocol !== "wss:") {
          throw new DOMException2(
            `Expected a ws: or wss: protocol, got ${urlRecord.protocol}`,
            "SyntaxError"
          );
        }
        if (urlRecord.hash || urlRecord.href.endsWith("#")) {
          throw new DOMException2("Got fragment", "SyntaxError");
        }
        if (typeof protocols === "string") {
          protocols = [protocols];
        }
        if (protocols.length !== new Set(protocols.map((p) => p.toLowerCase())).size) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (protocols.length > 0 && !protocols.every((p) => isValidSubprotocol(p))) {
          throw new DOMException2("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[kWebSocketURL] = new URL(urlRecord.href);
        this[kController] = establishWebSocketConnection(
          urlRecord,
          protocols,
          this,
          (response) => __privateMethod(this, _WebSocket_instances, onConnectionEstablished_fn).call(this, response),
          options
        );
        this[kReadyState] = _WebSocket.CONNECTING;
        this[kBinaryType] = "blob";
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-close
       * @param {number|undefined} code
       * @param {string|undefined} reason
       */
      close(code = void 0, reason = void 0) {
        webidl.brandCheck(this, _WebSocket);
        if (code !== void 0) {
          code = webidl.converters["unsigned short"](code, { clamp: true });
        }
        if (reason !== void 0) {
          reason = webidl.converters.USVString(reason);
        }
        if (code !== void 0) {
          if (code !== 1e3 && (code < 3e3 || code > 4999)) {
            throw new DOMException2("invalid code", "InvalidAccessError");
          }
        }
        let reasonByteLength = 0;
        if (reason !== void 0) {
          reasonByteLength = Buffer.byteLength(reason);
          if (reasonByteLength > 123) {
            throw new DOMException2(
              `Reason must be less than 123 bytes; received ${reasonByteLength}`,
              "SyntaxError"
            );
          }
        }
        if (this[kReadyState] === _WebSocket.CLOSING || this[kReadyState] === _WebSocket.CLOSED) ; else if (!isEstablished(this)) {
          failWebsocketConnection(this, "Connection was closed before it was established.");
          this[kReadyState] = _WebSocket.CLOSING;
        } else if (!isClosing(this)) {
          const frame = new WebsocketFrameSend();
          if (code !== void 0 && reason === void 0) {
            frame.frameData = Buffer.allocUnsafe(2);
            frame.frameData.writeUInt16BE(code, 0);
          } else if (code !== void 0 && reason !== void 0) {
            frame.frameData = Buffer.allocUnsafe(2 + reasonByteLength);
            frame.frameData.writeUInt16BE(code, 0);
            frame.frameData.write(reason, 2, "utf-8");
          } else {
            frame.frameData = emptyBuffer;
          }
          const socket = this[kResponse].socket;
          socket.write(frame.createFrame(opcodes.CLOSE), (err) => {
            if (!err) {
              this[kSentClose] = true;
            }
          });
          this[kReadyState] = states.CLOSING;
        } else {
          this[kReadyState] = _WebSocket.CLOSING;
        }
      }
      /**
       * @see https://websockets.spec.whatwg.org/#dom-websocket-send
       * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
       */
      send(data) {
        webidl.brandCheck(this, _WebSocket);
        webidl.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        data = webidl.converters.WebSocketSendData(data);
        if (this[kReadyState] === _WebSocket.CONNECTING) {
          throw new DOMException2("Sent before connected.", "InvalidStateError");
        }
        if (!isEstablished(this) || isClosing(this)) {
          return;
        }
        const socket = this[kResponse].socket;
        if (typeof data === "string") {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.TEXT);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (types.isArrayBuffer(data)) {
          const value = Buffer.from(data);
          const frame = new WebsocketFrameSend(value);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
          });
        } else if (ArrayBuffer.isView(data)) {
          const ab = Buffer.from(data, data.byteOffset, data.byteLength);
          const frame = new WebsocketFrameSend(ab);
          const buffer = frame.createFrame(opcodes.BINARY);
          __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + ab.byteLength);
          socket.write(buffer, () => {
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - ab.byteLength);
          });
        } else if (isBlobLike(data)) {
          const frame = new WebsocketFrameSend();
          data.arrayBuffer().then((ab) => {
            const value = Buffer.from(ab);
            frame.frameData = value;
            const buffer = frame.createFrame(opcodes.BINARY);
            __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) + value.byteLength);
            socket.write(buffer, () => {
              __privateSet(this, _bufferedAmount, __privateGet(this, _bufferedAmount) - value.byteLength);
            });
          });
        }
      }
      get readyState() {
        webidl.brandCheck(this, _WebSocket);
        return this[kReadyState];
      }
      get bufferedAmount() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _bufferedAmount);
      }
      get url() {
        webidl.brandCheck(this, _WebSocket);
        return URLSerializer(this[kWebSocketURL]);
      }
      get extensions() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _extensions);
      }
      get protocol() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _protocol);
      }
      get onopen() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).open;
      }
      set onopen(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).open) {
          this.removeEventListener("open", __privateGet(this, _events).open);
        }
        if (typeof fn2 === "function") {
          __privateGet(this, _events).open = fn2;
          this.addEventListener("open", fn2);
        } else {
          __privateGet(this, _events).open = null;
        }
      }
      get onerror() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).error;
      }
      set onerror(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).error) {
          this.removeEventListener("error", __privateGet(this, _events).error);
        }
        if (typeof fn2 === "function") {
          __privateGet(this, _events).error = fn2;
          this.addEventListener("error", fn2);
        } else {
          __privateGet(this, _events).error = null;
        }
      }
      get onclose() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).close;
      }
      set onclose(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).close) {
          this.removeEventListener("close", __privateGet(this, _events).close);
        }
        if (typeof fn2 === "function") {
          __privateGet(this, _events).close = fn2;
          this.addEventListener("close", fn2);
        } else {
          __privateGet(this, _events).close = null;
        }
      }
      get onmessage() {
        webidl.brandCheck(this, _WebSocket);
        return __privateGet(this, _events).message;
      }
      set onmessage(fn2) {
        webidl.brandCheck(this, _WebSocket);
        if (__privateGet(this, _events).message) {
          this.removeEventListener("message", __privateGet(this, _events).message);
        }
        if (typeof fn2 === "function") {
          __privateGet(this, _events).message = fn2;
          this.addEventListener("message", fn2);
        } else {
          __privateGet(this, _events).message = null;
        }
      }
      get binaryType() {
        webidl.brandCheck(this, _WebSocket);
        return this[kBinaryType];
      }
      set binaryType(type) {
        webidl.brandCheck(this, _WebSocket);
        if (type !== "blob" && type !== "arraybuffer") {
          this[kBinaryType] = "blob";
        } else {
          this[kBinaryType] = type;
        }
      }
    };
    _events = new WeakMap();
    _bufferedAmount = new WeakMap();
    _protocol = new WeakMap();
    _extensions = new WeakMap();
    _WebSocket_instances = new WeakSet();
    /**
     * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
     */
    onConnectionEstablished_fn = function(response) {
      this[kResponse] = response;
      const parser = new ByteParser(this);
      parser.on("drain", function onParserDrain() {
        this.ws[kResponse].socket.resume();
      });
      response.socket.ws = this;
      this[kByteParser] = parser;
      this[kReadyState] = states.OPEN;
      const extensions = response.headersList.get("sec-websocket-extensions");
      if (extensions !== null) {
        __privateSet(this, _extensions, extensions);
      }
      const protocol = response.headersList.get("sec-websocket-protocol");
      if (protocol !== null) {
        __privateSet(this, _protocol, protocol);
      }
      fireEvent("open", this);
    };
    var WebSocket = _WebSocket;
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = states.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = states.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = states.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = states.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors,
      url: kEnumerableProperty,
      readyState: kEnumerableProperty,
      bufferedAmount: kEnumerableProperty,
      onopen: kEnumerableProperty,
      onerror: kEnumerableProperty,
      onclose: kEnumerableProperty,
      close: kEnumerableProperty,
      onmessage: kEnumerableProperty,
      binaryType: kEnumerableProperty,
      send: kEnumerableProperty,
      extensions: kEnumerableProperty,
      protocol: kEnumerableProperty,
      [Symbol.toStringTag]: {
        value: "WebSocket",
        writable: false,
        enumerable: false,
        configurable: true
      }
    });
    Object.defineProperties(WebSocket, {
      CONNECTING: staticPropertyDescriptors,
      OPEN: staticPropertyDescriptors,
      CLOSING: staticPropertyDescriptors,
      CLOSED: staticPropertyDescriptors
    });
    webidl.converters["sequence<DOMString>"] = webidl.sequenceConverter(
      webidl.converters.DOMString
    );
    webidl.converters["DOMString or sequence<DOMString>"] = function(V2) {
      if (webidl.util.Type(V2) === "Object" && Symbol.iterator in V2) {
        return webidl.converters["sequence<DOMString>"](V2);
      }
      return webidl.converters.DOMString(V2);
    };
    webidl.converters.WebSocketInit = webidl.dictionaryConverter([
      {
        key: "protocols",
        converter: webidl.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        }
      },
      {
        key: "dispatcher",
        converter: (V2) => V2,
        get defaultValue() {
          return getGlobalDispatcher();
        }
      },
      {
        key: "headers",
        converter: webidl.nullableConverter(webidl.converters.HeadersInit)
      }
    ]);
    webidl.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(V2) {
      if (webidl.util.Type(V2) === "Object" && !(Symbol.iterator in V2)) {
        return webidl.converters.WebSocketInit(V2);
      }
      return { protocols: webidl.converters["DOMString or sequence<DOMString>"](V2) };
    };
    webidl.converters.WebSocketSendData = function(V2) {
      if (webidl.util.Type(V2) === "Object") {
        if (isBlobLike(V2)) {
          return webidl.converters.Blob(V2, { strict: false });
        }
        if (ArrayBuffer.isView(V2) || types.isAnyArrayBuffer(V2)) {
          return webidl.converters.BufferSource(V2);
        }
      }
      return webidl.converters.USVString(V2);
    };
    module.exports = {
      WebSocket
    };
  }
});

// node_modules/undici/index.js
var require_undici = __commonJS({
  "node_modules/undici/index.js"(exports, module) {
    var Client = require_client();
    var Dispatcher = require_dispatcher();
    var errors = require_errors();
    var Pool = require_pool();
    var BalancedPool = require_balanced_pool();
    var Agent = require_agent();
    var util = require_util();
    var { InvalidArgumentError } = errors;
    var api = require_api();
    var buildConnector = require_connect();
    var MockClient = require_mock_client();
    var MockAgent = require_mock_agent();
    var MockPool = require_mock_pool();
    var mockErrors = require_mock_errors();
    var ProxyAgent = require_proxy_agent();
    var RetryHandler = require_RetryHandler();
    var { getGlobalDispatcher, setGlobalDispatcher } = require_global2();
    var DecoratorHandler = require_DecoratorHandler();
    var RedirectHandler = require_RedirectHandler();
    var createRedirectInterceptor = require_redirectInterceptor();
    var hasCrypto;
    try {
      __require("crypto");
      hasCrypto = true;
    } catch {
      hasCrypto = false;
    }
    Object.assign(Dispatcher.prototype, api);
    module.exports.Dispatcher = Dispatcher;
    module.exports.Client = Client;
    module.exports.Pool = Pool;
    module.exports.BalancedPool = BalancedPool;
    module.exports.Agent = Agent;
    module.exports.ProxyAgent = ProxyAgent;
    module.exports.RetryHandler = RetryHandler;
    module.exports.DecoratorHandler = DecoratorHandler;
    module.exports.RedirectHandler = RedirectHandler;
    module.exports.createRedirectInterceptor = createRedirectInterceptor;
    module.exports.buildConnector = buildConnector;
    module.exports.errors = errors;
    function makeDispatcher(fn2) {
      return (url, opts, handler) => {
        if (typeof opts === "function") {
          handler = opts;
          opts = null;
        }
        if (!url || typeof url !== "string" && typeof url !== "object" && !(url instanceof URL)) {
          throw new InvalidArgumentError("invalid url");
        }
        if (opts != null && typeof opts !== "object") {
          throw new InvalidArgumentError("invalid opts");
        }
        if (opts && opts.path != null) {
          if (typeof opts.path !== "string") {
            throw new InvalidArgumentError("invalid opts.path");
          }
          let path = opts.path;
          if (!opts.path.startsWith("/")) {
            path = `/${path}`;
          }
          url = new URL(util.parseOrigin(url).origin + path);
        } else {
          if (!opts) {
            opts = typeof url === "object" ? url : {};
          }
          url = util.parseURL(url);
        }
        const { agent, dispatcher = getGlobalDispatcher() } = opts;
        if (agent) {
          throw new InvalidArgumentError("unsupported opts.agent. Did you mean opts.client?");
        }
        return fn2.call(dispatcher, {
          ...opts,
          origin: url.origin,
          path: url.search ? `${url.pathname}${url.search}` : url.pathname,
          method: opts.method || (opts.body ? "PUT" : "GET")
        }, handler);
      };
    }
    module.exports.setGlobalDispatcher = setGlobalDispatcher;
    module.exports.getGlobalDispatcher = getGlobalDispatcher;
    if (util.nodeMajor > 16 || util.nodeMajor === 16 && util.nodeMinor >= 8) {
      let fetchImpl = null;
      module.exports.fetch = async function fetch2(resource) {
        if (!fetchImpl) {
          fetchImpl = require_fetch().fetch;
        }
        try {
          return await fetchImpl(...arguments);
        } catch (err) {
          if (typeof err === "object") {
            Error.captureStackTrace(err, this);
          }
          throw err;
        }
      };
      module.exports.Headers = require_headers().Headers;
      module.exports.Response = require_response().Response;
      module.exports.Request = require_request2().Request;
      module.exports.FormData = require_formdata().FormData;
      module.exports.File = require_file().File;
      module.exports.FileReader = require_filereader().FileReader;
      const { setGlobalOrigin, getGlobalOrigin } = require_global();
      module.exports.setGlobalOrigin = setGlobalOrigin;
      module.exports.getGlobalOrigin = getGlobalOrigin;
      const { CacheStorage } = require_cachestorage();
      const { kConstruct } = require_symbols4();
      module.exports.caches = new CacheStorage(kConstruct);
    }
    if (util.nodeMajor >= 16) {
      const { deleteCookie, getCookies, getSetCookies, setCookie } = require_cookies();
      module.exports.deleteCookie = deleteCookie;
      module.exports.getCookies = getCookies;
      module.exports.getSetCookies = getSetCookies;
      module.exports.setCookie = setCookie;
      const { parseMIMEType, serializeAMimeType } = require_dataURL();
      module.exports.parseMIMEType = parseMIMEType;
      module.exports.serializeAMimeType = serializeAMimeType;
    }
    if (util.nodeMajor >= 18 && hasCrypto) {
      const { WebSocket } = require_websocket();
      module.exports.WebSocket = WebSocket;
    }
    module.exports.request = makeDispatcher(api.request);
    module.exports.stream = makeDispatcher(api.stream);
    module.exports.pipeline = makeDispatcher(api.pipeline);
    module.exports.connect = makeDispatcher(api.connect);
    module.exports.upgrade = makeDispatcher(api.upgrade);
    module.exports.MockClient = MockClient;
    module.exports.MockPool = MockPool;
    module.exports.MockAgent = MockAgent;
    module.exports.mockErrors = mockErrors;
  }
});

// node_modules/@actions/http-client/lib/index.js
var require_lib = __commonJS({
  "node_modules/@actions/http-client/lib/index.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;
    var http = __importStar(__require("http"));
    var https = __importStar(__require("https"));
    var pm = __importStar(require_proxy());
    var tunnel = __importStar(require_tunnel2());
    var undici_1 = require_undici();
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports.HttpCodes = HttpCodes = {}));
    var Headers2;
    (function(Headers3) {
      Headers3["Accept"] = "accept";
      Headers3["ContentType"] = "content-type";
    })(Headers2 || (exports.Headers = Headers2 = {}));
    var MediaTypes;
    (function(MediaTypes2) {
      MediaTypes2["ApplicationJson"] = "application/json";
    })(MediaTypes || (exports.MediaTypes = MediaTypes = {}));
    function getProxyUrl(serverUrl) {
      const proxyUrl = pm.getProxyUrl(new URL(serverUrl));
      return proxyUrl ? proxyUrl.href : "";
    }
    exports.getProxyUrl = getProxyUrl;
    var HttpRedirectCodes = [
      HttpCodes.MovedPermanently,
      HttpCodes.ResourceMoved,
      HttpCodes.SeeOther,
      HttpCodes.TemporaryRedirect,
      HttpCodes.PermanentRedirect
    ];
    var HttpResponseRetryCodes = [
      HttpCodes.BadGateway,
      HttpCodes.ServiceUnavailable,
      HttpCodes.GatewayTimeout
    ];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientError = class _HttpClientError extends Error {
      constructor(message, statusCode) {
        super(message);
        this.name = "HttpClientError";
        this.statusCode = statusCode;
        Object.setPrototypeOf(this, _HttpClientError.prototype);
      }
    };
    exports.HttpClientError = HttpClientError;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            let output = Buffer.alloc(0);
            this.message.on("data", (chunk) => {
              output = Buffer.concat([output, chunk]);
            });
            this.message.on("end", () => {
              resolve(output.toString());
            });
          }));
        });
      }
      readBodyBuffer() {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const chunks = [];
            this.message.on("data", (chunk) => {
              chunks.push(chunk);
            });
            this.message.on("end", () => {
              resolve(Buffer.concat(chunks));
            });
          }));
        });
      }
    };
    exports.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      const parsedUrl = new URL(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports.isHttps = isHttps;
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
        });
      }
      get(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("GET", requestUrl, null, additionalHeaders || {});
        });
      }
      del(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("DELETE", requestUrl, null, additionalHeaders || {});
        });
      }
      post(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("POST", requestUrl, data, additionalHeaders || {});
        });
      }
      patch(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PATCH", requestUrl, data, additionalHeaders || {});
        });
      }
      put(requestUrl, data, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("PUT", requestUrl, data, additionalHeaders || {});
        });
      }
      head(requestUrl, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request("HEAD", requestUrl, null, additionalHeaders || {});
        });
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return __awaiter(this, void 0, void 0, function* () {
          return this.request(verb, requestUrl, stream, additionalHeaders);
        });
      }
      /**
       * Gets a typed object from an endpoint
       * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
       */
      getJson(requestUrl, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
          const res = yield this.get(requestUrl, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      postJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.post(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      putJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.put(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      patchJson(requestUrl, obj, additionalHeaders = {}) {
        return __awaiter(this, void 0, void 0, function* () {
          const data = JSON.stringify(obj, null, 2);
          additionalHeaders[Headers2.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.Accept, MediaTypes.ApplicationJson);
          additionalHeaders[Headers2.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers2.ContentType, MediaTypes.ApplicationJson);
          const res = yield this.patch(requestUrl, data, additionalHeaders);
          return this._processResponse(res, this.requestOptions);
        });
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const parsedUrl = new URL(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb) ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          do {
            response = yield this.requestRaw(info, data);
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (const handler of this.handlers) {
                if (handler.canHandleAuthentication(response)) {
                  authenticationHandler = handler;
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (response.message.statusCode && HttpRedirectCodes.includes(response.message.statusCode) && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              const parsedRedirectUrl = new URL(redirectUrl);
              if (parsedUrl.protocol === "https:" && parsedUrl.protocol !== parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
                for (const header in headers) {
                  if (header.toLowerCase() === "authorization") {
                    delete headers[header];
                  }
                }
              }
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (!response.message.statusCode || !HttpResponseRetryCodes.includes(response.message.statusCode)) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          } while (numTries < maxTries);
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            function callbackForResult(err, res) {
              if (err) {
                reject(err);
              } else if (!res) {
                reject(new Error("Unknown error"));
              } else {
                resolve(res);
              }
            }
            this.requestRawWithCallback(info, data, callbackForResult);
          });
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        if (typeof data === "string") {
          if (!info.options.headers) {
            info.options.headers = {};
          }
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        function handleResult(err, res) {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        }
        const req = info.httpModule.request(info.options, (msg) => {
          const res = new HttpClientResponse(msg);
          handleResult(void 0, res);
        });
        let socket;
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.end();
          }
          handleResult(new Error(`Request timeout: ${info.options.path}`));
        });
        req.on("error", function(err) {
          handleResult(err);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      /**
       * Gets an http agent. This function is useful when you need an http agent that handles
       * routing through a proxy server - depending upon the url and proxy environment variables.
       * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
       */
      getAgent(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        return this._getAgent(parsedUrl);
      }
      getAgentDispatcher(serverUrl) {
        const parsedUrl = new URL(serverUrl);
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (!useProxy) {
          return;
        }
        return this._getProxyAgentDispatcher(parsedUrl, proxyUrl);
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers) {
          for (const handler of this.handlers) {
            handler.prepareRequest(info.options);
          }
        }
        return info;
      }
      _mergeHeaders(headers) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));
        }
        return lowercaseKeys(headers || {});
      }
      _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
        let clientHeader;
        if (this.requestOptions && this.requestOptions.headers) {
          clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
        }
        return additionalHeaders[header] || clientHeader || _default;
      }
      _getAgent(parsedUrl) {
        let agent;
        const proxyUrl = pm.getProxyUrl(parsedUrl);
        const useProxy = proxyUrl && proxyUrl.hostname;
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (!useProxy) {
          agent = this._agent;
        }
        if (agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (proxyUrl && proxyUrl.hostname) {
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (proxyUrl.username || proxyUrl.password) && {
              proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`
            }), { host: proxyUrl.hostname, port: proxyUrl.port })
          };
          let tunnelAgent;
          const overHttps = proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (!agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, {
            rejectUnauthorized: false
          });
        }
        return agent;
      }
      _getProxyAgentDispatcher(parsedUrl, proxyUrl) {
        let proxyAgent;
        if (this._keepAlive) {
          proxyAgent = this._proxyAgentDispatcher;
        }
        if (proxyAgent) {
          return proxyAgent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        proxyAgent = new undici_1.ProxyAgent(Object.assign({ uri: proxyUrl.href, pipelining: !this._keepAlive ? 0 : 1 }, (proxyUrl.username || proxyUrl.password) && {
          token: `Basic ${Buffer.from(`${proxyUrl.username}:${proxyUrl.password}`).toString("base64")}`
        }));
        this._proxyAgentDispatcher = proxyAgent;
        if (usingSsl && this._ignoreSslError) {
          proxyAgent.options = Object.assign(proxyAgent.options.requestTls || {}, {
            rejectUnauthorized: false
          });
        }
        return proxyAgent;
      }
      _performExponentialBackoff(retryNumber) {
        return __awaiter(this, void 0, void 0, function* () {
          retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
          const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
          return new Promise((resolve) => setTimeout(() => resolve(), ms));
        });
      }
      _processResponse(res, options) {
        return __awaiter(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode || 0;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode === HttpCodes.NotFound) {
              resolve(response);
            }
            function dateTimeDeserializer(key, value) {
              if (typeof value === "string") {
                const a = new Date(value);
                if (!isNaN(a.valueOf())) {
                  return a;
                }
              }
              return value;
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                response.result = obj;
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = `Failed request: (${statusCode})`;
              }
              const err = new HttpClientError(msg, statusCode);
              err.result = response.result;
              reject(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports.HttpClient = HttpClient;
    var lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k2) => (c[k2.toLowerCase()] = obj[k2], c), {});
  }
});

// node_modules/@actions/http-client/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@actions/http-client/lib/auth.js"(exports) {
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password) {
        this.username = username;
        this.password = password;
      }
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BasicCredentialHandler = BasicCredentialHandler;
    var BearerCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Bearer ${this.token}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.BearerCredentialHandler = BearerCredentialHandler;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token) {
        this.token = token;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!options.headers) {
          throw Error("The request has no headers");
        }
        options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      // This handler cannot handle 401
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    };
    exports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// node_modules/@actions/core/lib/oidc-utils.js
var require_oidc_utils = __commonJS({
  "node_modules/@actions/core/lib/oidc-utils.js"(exports) {
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OidcClient = void 0;
    var http_client_1 = require_lib();
    var auth_1 = require_auth();
    var core_1 = require_core();
    var OidcClient = class _OidcClient {
      static createHttpClient(allowRetry = true, maxRetry = 10) {
        const requestOptions = {
          allowRetries: allowRetry,
          maxRetries: maxRetry
        };
        return new http_client_1.HttpClient("actions/oidc-client", [new auth_1.BearerCredentialHandler(_OidcClient.getRequestToken())], requestOptions);
      }
      static getRequestToken() {
        const token = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!token) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return token;
      }
      static getIDTokenUrl() {
        const runtimeUrl = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!runtimeUrl) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return runtimeUrl;
      }
      static getCall(id_token_url) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const httpclient = _OidcClient.createHttpClient();
          const res = yield httpclient.getJson(id_token_url).catch((error) => {
            throw new Error(`Failed to get ID Token. 
 
        Error Code : ${error.statusCode}
 
        Error Message: ${error.message}`);
          });
          const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;
          if (!id_token) {
            throw new Error("Response json body do not have ID Token field");
          }
          return id_token;
        });
      }
      static getIDToken(audience) {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            let id_token_url = _OidcClient.getIDTokenUrl();
            if (audience) {
              const encodedAudience = encodeURIComponent(audience);
              id_token_url = `${id_token_url}&audience=${encodedAudience}`;
            }
            (0, core_1.debug)(`ID token url is ${id_token_url}`);
            const id_token = yield _OidcClient.getCall(id_token_url);
            (0, core_1.setSecret)(id_token);
            return id_token;
          } catch (error) {
            throw new Error(`Error message: ${error.message}`);
          }
        });
      }
    };
    exports.OidcClient = OidcClient;
  }
});

// node_modules/@actions/core/lib/summary.js
var require_summary = __commonJS({
  "node_modules/@actions/core/lib/summary.js"(exports) {
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;
    var os_1 = __require("os");
    var fs_1 = __require("fs");
    var { access, appendFile, writeFile } = fs_1.promises;
    exports.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    exports.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    var Summary = class {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return __awaiter(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];
          if (!pathFromEnv) {
            throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);
          } catch (_a) {
            throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = pathFromEnv;
          return this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(tag, content, attrs = {}) {
        const htmlAttrs = Object.entries(attrs).map(([key, value]) => ` ${key}="${value}"`).join("");
        if (!content) {
          return `<${tag}${htmlAttrs}>`;
        }
        return `<${tag}${htmlAttrs}>${content}</${tag}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(options) {
        return __awaiter(this, void 0, void 0, function* () {
          const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);
          const filePath = yield this.filePath();
          const writeFunc = overwrite ? writeFile : appendFile;
          yield writeFunc(filePath, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return __awaiter(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(text, addEOL = false) {
        this._buffer += text;
        return addEOL ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(os_1.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(code, lang) {
        const attrs = Object.assign({}, lang && { lang });
        const element = this.wrap("pre", this.wrap("code", code), attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(items, ordered = false) {
        const tag = ordered ? "ol" : "ul";
        const listItems = items.map((item) => this.wrap("li", item)).join("");
        const element = this.wrap(tag, listItems);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(rows) {
        const tableBody = rows.map((row) => {
          const cells = row.map((cell) => {
            if (typeof cell === "string") {
              return this.wrap("td", cell);
            }
            const { header, data, colspan, rowspan } = cell;
            const tag = header ? "th" : "td";
            const attrs = Object.assign(Object.assign({}, colspan && { colspan }), rowspan && { rowspan });
            return this.wrap(tag, data, attrs);
          }).join("");
          return this.wrap("tr", cells);
        }).join("");
        const element = this.wrap("table", tableBody);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(label, content) {
        const element = this.wrap("details", this.wrap("summary", label) + content);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(src, alt, options) {
        const { width, height } = options || {};
        const attrs = Object.assign(Object.assign({}, width && { width }), height && { height });
        const element = this.wrap("img", null, Object.assign({ src, alt }, attrs));
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(text, level) {
        const tag = `h${level}`;
        const allowedTag = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(tag) ? tag : "h1";
        const element = this.wrap(allowedTag, text);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const element = this.wrap("hr", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const element = this.wrap("br", null);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(text, cite) {
        const attrs = Object.assign({}, cite && { cite });
        const element = this.wrap("blockquote", text, attrs);
        return this.addRaw(element).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(text, href) {
        const element = this.wrap("a", text, { href });
        return this.addRaw(element).addEOL();
      }
    };
    var _summary = new Summary();
    exports.markdownSummary = _summary;
    exports.summary = _summary;
  }
});

// node_modules/@actions/core/lib/path-utils.js
var require_path_utils = __commonJS({
  "node_modules/@actions/core/lib/path-utils.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;
    var path = __importStar(__require("path"));
    function toPosixPath(pth) {
      return pth.replace(/[\\]/g, "/");
    }
    exports.toPosixPath = toPosixPath;
    function toWin32Path(pth) {
      return pth.replace(/[/]/g, "\\");
    }
    exports.toWin32Path = toWin32Path;
    function toPlatformPath(pth) {
      return pth.replace(/[/\\]/g, path.sep);
    }
    exports.toPlatformPath = toPlatformPath;
  }
});

// node_modules/@actions/io/lib/io-util.js
var require_io_util = __commonJS({
  "node_modules/@actions/io/lib/io-util.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;
    var fs = __importStar(__require("fs"));
    var path = __importStar(__require("path"));
    _a = fs.promises, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;
    exports.IS_WINDOWS = process.platform === "win32";
    exports.UV_FS_O_EXLOCK = 268435456;
    exports.READONLY = fs.constants.O_RDONLY;
    function exists(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield exports.stat(fsPath);
        } catch (err) {
          if (err.code === "ENOENT") {
            return false;
          }
          throw err;
        }
        return true;
      });
    }
    exports.exists = exists;
    function isDirectory(fsPath, useStat = false) {
      return __awaiter(this, void 0, void 0, function* () {
        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);
        return stats.isDirectory();
      });
    }
    exports.isDirectory = isDirectory;
    function isRooted(p) {
      p = normalizeSeparators(p);
      if (!p) {
        throw new Error('isRooted() parameter "p" cannot be empty');
      }
      if (exports.IS_WINDOWS) {
        return p.startsWith("\\") || /^[A-Z]:/i.test(p);
      }
      return p.startsWith("/");
    }
    exports.isRooted = isRooted;
    function tryGetExecutablePath(filePath, extensions) {
      return __awaiter(this, void 0, void 0, function* () {
        let stats = void 0;
        try {
          stats = yield exports.stat(filePath);
        } catch (err) {
          if (err.code !== "ENOENT") {
            console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
          }
        }
        if (stats && stats.isFile()) {
          if (exports.IS_WINDOWS) {
            const upperExt = path.extname(filePath).toUpperCase();
            if (extensions.some((validExt) => validExt.toUpperCase() === upperExt)) {
              return filePath;
            }
          } else {
            if (isUnixExecutable(stats)) {
              return filePath;
            }
          }
        }
        const originalFilePath = filePath;
        for (const extension of extensions) {
          filePath = originalFilePath + extension;
          stats = void 0;
          try {
            stats = yield exports.stat(filePath);
          } catch (err) {
            if (err.code !== "ENOENT") {
              console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);
            }
          }
          if (stats && stats.isFile()) {
            if (exports.IS_WINDOWS) {
              try {
                const directory = path.dirname(filePath);
                const upperName = path.basename(filePath).toUpperCase();
                for (const actualName of yield exports.readdir(directory)) {
                  if (upperName === actualName.toUpperCase()) {
                    filePath = path.join(directory, actualName);
                    break;
                  }
                }
              } catch (err) {
                console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);
              }
              return filePath;
            } else {
              if (isUnixExecutable(stats)) {
                return filePath;
              }
            }
          }
        }
        return "";
      });
    }
    exports.tryGetExecutablePath = tryGetExecutablePath;
    function normalizeSeparators(p) {
      p = p || "";
      if (exports.IS_WINDOWS) {
        p = p.replace(/\//g, "\\");
        return p.replace(/\\\\+/g, "\\");
      }
      return p.replace(/\/\/+/g, "/");
    }
    function isUnixExecutable(stats) {
      return (stats.mode & 1) > 0 || (stats.mode & 8) > 0 && stats.gid === process.getgid() || (stats.mode & 64) > 0 && stats.uid === process.getuid();
    }
    function getCmdPath() {
      var _a2;
      return (_a2 = process.env["COMSPEC"]) !== null && _a2 !== void 0 ? _a2 : `cmd.exe`;
    }
    exports.getCmdPath = getCmdPath;
  }
});

// node_modules/@actions/io/lib/io.js
var require_io = __commonJS({
  "node_modules/@actions/io/lib/io.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;
    var assert_1 = __require("assert");
    var path = __importStar(__require("path"));
    var ioUtil = __importStar(require_io_util());
    function cp(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        const { force, recursive, copySourceDirectory } = readCopyOptions(options);
        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;
        if (destStat && destStat.isFile() && !force) {
          return;
        }
        const newDest = destStat && destStat.isDirectory() && copySourceDirectory ? path.join(dest, path.basename(source)) : dest;
        if (!(yield ioUtil.exists(source))) {
          throw new Error(`no such file or directory: ${source}`);
        }
        const sourceStat = yield ioUtil.stat(source);
        if (sourceStat.isDirectory()) {
          if (!recursive) {
            throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);
          } else {
            yield cpDirRecursive(source, newDest, 0, force);
          }
        } else {
          if (path.relative(source, newDest) === "") {
            throw new Error(`'${newDest}' and '${source}' are the same file`);
          }
          yield copyFile(source, newDest, force);
        }
      });
    }
    exports.cp = cp;
    function mv(source, dest, options = {}) {
      return __awaiter(this, void 0, void 0, function* () {
        if (yield ioUtil.exists(dest)) {
          let destExists = true;
          if (yield ioUtil.isDirectory(dest)) {
            dest = path.join(dest, path.basename(source));
            destExists = yield ioUtil.exists(dest);
          }
          if (destExists) {
            if (options.force == null || options.force) {
              yield rmRF(dest);
            } else {
              throw new Error("Destination already exists");
            }
          }
        }
        yield mkdirP(path.dirname(dest));
        yield ioUtil.rename(source, dest);
      });
    }
    exports.mv = mv;
    function rmRF(inputPath) {
      return __awaiter(this, void 0, void 0, function* () {
        if (ioUtil.IS_WINDOWS) {
          if (/[*"<>|]/.test(inputPath)) {
            throw new Error('File path must not contain `*`, `"`, `<`, `>` or `|` on Windows');
          }
        }
        try {
          yield ioUtil.rm(inputPath, {
            force: true,
            maxRetries: 3,
            recursive: true,
            retryDelay: 300
          });
        } catch (err) {
          throw new Error(`File was unable to be removed ${err}`);
        }
      });
    }
    exports.rmRF = rmRF;
    function mkdirP(fsPath) {
      return __awaiter(this, void 0, void 0, function* () {
        assert_1.ok(fsPath, "a path argument must be provided");
        yield ioUtil.mkdir(fsPath, { recursive: true });
      });
    }
    exports.mkdirP = mkdirP;
    function which(tool, check) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        if (check) {
          const result = yield which(tool, false);
          if (!result) {
            if (ioUtil.IS_WINDOWS) {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);
            } else {
              throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);
            }
          }
          return result;
        }
        const matches = yield findInPath(tool);
        if (matches && matches.length > 0) {
          return matches[0];
        }
        return "";
      });
    }
    exports.which = which;
    function findInPath(tool) {
      return __awaiter(this, void 0, void 0, function* () {
        if (!tool) {
          throw new Error("parameter 'tool' is required");
        }
        const extensions = [];
        if (ioUtil.IS_WINDOWS && process.env["PATHEXT"]) {
          for (const extension of process.env["PATHEXT"].split(path.delimiter)) {
            if (extension) {
              extensions.push(extension);
            }
          }
        }
        if (ioUtil.isRooted(tool)) {
          const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);
          if (filePath) {
            return [filePath];
          }
          return [];
        }
        if (tool.includes(path.sep)) {
          return [];
        }
        const directories = [];
        if (process.env.PATH) {
          for (const p of process.env.PATH.split(path.delimiter)) {
            if (p) {
              directories.push(p);
            }
          }
        }
        const matches = [];
        for (const directory of directories) {
          const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);
          if (filePath) {
            matches.push(filePath);
          }
        }
        return matches;
      });
    }
    exports.findInPath = findInPath;
    function readCopyOptions(options) {
      const force = options.force == null ? true : options.force;
      const recursive = Boolean(options.recursive);
      const copySourceDirectory = options.copySourceDirectory == null ? true : Boolean(options.copySourceDirectory);
      return { force, recursive, copySourceDirectory };
    }
    function cpDirRecursive(sourceDir, destDir, currentDepth, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if (currentDepth >= 255)
          return;
        currentDepth++;
        yield mkdirP(destDir);
        const files = yield ioUtil.readdir(sourceDir);
        for (const fileName of files) {
          const srcFile = `${sourceDir}/${fileName}`;
          const destFile = `${destDir}/${fileName}`;
          const srcFileStat = yield ioUtil.lstat(srcFile);
          if (srcFileStat.isDirectory()) {
            yield cpDirRecursive(srcFile, destFile, currentDepth, force);
          } else {
            yield copyFile(srcFile, destFile, force);
          }
        }
        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);
      });
    }
    function copyFile(srcFile, destFile, force) {
      return __awaiter(this, void 0, void 0, function* () {
        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {
          try {
            yield ioUtil.lstat(destFile);
            yield ioUtil.unlink(destFile);
          } catch (e) {
            if (e.code === "EPERM") {
              yield ioUtil.chmod(destFile, "0666");
              yield ioUtil.unlink(destFile);
            }
          }
          const symlinkFull = yield ioUtil.readlink(srcFile);
          yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? "junction" : null);
        } else if (!(yield ioUtil.exists(destFile)) || force) {
          yield ioUtil.copyFile(srcFile, destFile);
        }
      });
    }
  }
});

// node_modules/@actions/exec/lib/toolrunner.js
var require_toolrunner = __commonJS({
  "node_modules/@actions/exec/lib/toolrunner.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.argStringToArray = exports.ToolRunner = void 0;
    var os = __importStar(__require("os"));
    var events = __importStar(__require("events"));
    var child = __importStar(__require("child_process"));
    var path = __importStar(__require("path"));
    var io2 = __importStar(require_io());
    var ioUtil = __importStar(require_io_util());
    var timers_1 = __require("timers");
    var IS_WINDOWS = process.platform === "win32";
    var ToolRunner = class extends events.EventEmitter {
      constructor(toolPath, args, options) {
        super();
        if (!toolPath) {
          throw new Error("Parameter 'toolPath' cannot be null or empty.");
        }
        this.toolPath = toolPath;
        this.args = args || [];
        this.options = options || {};
      }
      _debug(message) {
        if (this.options.listeners && this.options.listeners.debug) {
          this.options.listeners.debug(message);
        }
      }
      _getCommandString(options, noPrefix) {
        const toolPath = this._getSpawnFileName();
        const args = this._getSpawnArgs(options);
        let cmd = noPrefix ? "" : "[command]";
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            cmd += toolPath;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else if (options.windowsVerbatimArguments) {
            cmd += `"${toolPath}"`;
            for (const a of args) {
              cmd += ` ${a}`;
            }
          } else {
            cmd += this._windowsQuoteCmdArg(toolPath);
            for (const a of args) {
              cmd += ` ${this._windowsQuoteCmdArg(a)}`;
            }
          }
        } else {
          cmd += toolPath;
          for (const a of args) {
            cmd += ` ${a}`;
          }
        }
        return cmd;
      }
      _processLineBuffer(data, strBuffer, onLine) {
        try {
          let s = strBuffer + data.toString();
          let n = s.indexOf(os.EOL);
          while (n > -1) {
            const line = s.substring(0, n);
            onLine(line);
            s = s.substring(n + os.EOL.length);
            n = s.indexOf(os.EOL);
          }
          return s;
        } catch (err) {
          this._debug(`error processing line. Failed with error ${err}`);
          return "";
        }
      }
      _getSpawnFileName() {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            return process.env["COMSPEC"] || "cmd.exe";
          }
        }
        return this.toolPath;
      }
      _getSpawnArgs(options) {
        if (IS_WINDOWS) {
          if (this._isCmdFile()) {
            let argline = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
            for (const a of this.args) {
              argline += " ";
              argline += options.windowsVerbatimArguments ? a : this._windowsQuoteCmdArg(a);
            }
            argline += '"';
            return [argline];
          }
        }
        return this.args;
      }
      _endsWith(str, end) {
        return str.endsWith(end);
      }
      _isCmdFile() {
        const upperToolPath = this.toolPath.toUpperCase();
        return this._endsWith(upperToolPath, ".CMD") || this._endsWith(upperToolPath, ".BAT");
      }
      _windowsQuoteCmdArg(arg) {
        if (!this._isCmdFile()) {
          return this._uvQuoteCmdArg(arg);
        }
        if (!arg) {
          return '""';
        }
        const cmdSpecialChars = [
          " ",
          "	",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"'
        ];
        let needsQuotes = false;
        for (const char of arg) {
          if (cmdSpecialChars.some((x2) => x2 === char)) {
            needsQuotes = true;
            break;
          }
        }
        if (!needsQuotes) {
          return arg;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += '"';
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _uvQuoteCmdArg(arg) {
        if (!arg) {
          return '""';
        }
        if (!arg.includes(" ") && !arg.includes("	") && !arg.includes('"')) {
          return arg;
        }
        if (!arg.includes('"') && !arg.includes("\\")) {
          return `"${arg}"`;
        }
        let reverse = '"';
        let quoteHit = true;
        for (let i = arg.length; i > 0; i--) {
          reverse += arg[i - 1];
          if (quoteHit && arg[i - 1] === "\\") {
            reverse += "\\";
          } else if (arg[i - 1] === '"') {
            quoteHit = true;
            reverse += "\\";
          } else {
            quoteHit = false;
          }
        }
        reverse += '"';
        return reverse.split("").reverse().join("");
      }
      _cloneExecOptions(options) {
        options = options || {};
        const result = {
          cwd: options.cwd || process.cwd(),
          env: options.env || process.env,
          silent: options.silent || false,
          windowsVerbatimArguments: options.windowsVerbatimArguments || false,
          failOnStdErr: options.failOnStdErr || false,
          ignoreReturnCode: options.ignoreReturnCode || false,
          delay: options.delay || 1e4
        };
        result.outStream = options.outStream || process.stdout;
        result.errStream = options.errStream || process.stderr;
        return result;
      }
      _getSpawnOptions(options, toolPath) {
        options = options || {};
        const result = {};
        result.cwd = options.cwd;
        result.env = options.env;
        result["windowsVerbatimArguments"] = options.windowsVerbatimArguments || this._isCmdFile();
        if (options.windowsVerbatimArguments) {
          result.argv0 = `"${toolPath}"`;
        }
        return result;
      }
      /**
       * Exec a tool.
       * Output will be streamed to the live console.
       * Returns promise with return code
       *
       * @param     tool     path to tool to exec
       * @param     options  optional exec options.  See ExecOptions
       * @returns   number
       */
      exec() {
        return __awaiter(this, void 0, void 0, function* () {
          if (!ioUtil.isRooted(this.toolPath) && (this.toolPath.includes("/") || IS_WINDOWS && this.toolPath.includes("\\"))) {
            this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);
          }
          this.toolPath = yield io2.which(this.toolPath, true);
          return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            this._debug(`exec tool: ${this.toolPath}`);
            this._debug("arguments:");
            for (const arg of this.args) {
              this._debug(`   ${arg}`);
            }
            const optionsNonNull = this._cloneExecOptions(this.options);
            if (!optionsNonNull.silent && optionsNonNull.outStream) {
              optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);
            }
            const state = new ExecState(optionsNonNull, this.toolPath);
            state.on("debug", (message) => {
              this._debug(message);
            });
            if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {
              return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));
            }
            const fileName = this._getSpawnFileName();
            const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));
            let stdbuffer = "";
            if (cp.stdout) {
              cp.stdout.on("data", (data) => {
                if (this.options.listeners && this.options.listeners.stdout) {
                  this.options.listeners.stdout(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.outStream) {
                  optionsNonNull.outStream.write(data);
                }
                stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.stdline) {
                    this.options.listeners.stdline(line);
                  }
                });
              });
            }
            let errbuffer = "";
            if (cp.stderr) {
              cp.stderr.on("data", (data) => {
                state.processStderr = true;
                if (this.options.listeners && this.options.listeners.stderr) {
                  this.options.listeners.stderr(data);
                }
                if (!optionsNonNull.silent && optionsNonNull.errStream && optionsNonNull.outStream) {
                  const s = optionsNonNull.failOnStdErr ? optionsNonNull.errStream : optionsNonNull.outStream;
                  s.write(data);
                }
                errbuffer = this._processLineBuffer(data, errbuffer, (line) => {
                  if (this.options.listeners && this.options.listeners.errline) {
                    this.options.listeners.errline(line);
                  }
                });
              });
            }
            cp.on("error", (err) => {
              state.processError = err.message;
              state.processExited = true;
              state.processClosed = true;
              state.CheckComplete();
            });
            cp.on("exit", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            cp.on("close", (code) => {
              state.processExitCode = code;
              state.processExited = true;
              state.processClosed = true;
              this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);
              state.CheckComplete();
            });
            state.on("done", (error, exitCode) => {
              if (stdbuffer.length > 0) {
                this.emit("stdline", stdbuffer);
              }
              if (errbuffer.length > 0) {
                this.emit("errline", errbuffer);
              }
              cp.removeAllListeners();
              if (error) {
                reject(error);
              } else {
                resolve(exitCode);
              }
            });
            if (this.options.input) {
              if (!cp.stdin) {
                throw new Error("child process missing stdin");
              }
              cp.stdin.end(this.options.input);
            }
          }));
        });
      }
    };
    exports.ToolRunner = ToolRunner;
    function argStringToArray(argString) {
      const args = [];
      let inQuotes = false;
      let escaped = false;
      let arg = "";
      function append(c) {
        if (escaped && c !== '"') {
          arg += "\\";
        }
        arg += c;
        escaped = false;
      }
      for (let i = 0; i < argString.length; i++) {
        const c = argString.charAt(i);
        if (c === '"') {
          if (!escaped) {
            inQuotes = !inQuotes;
          } else {
            append(c);
          }
          continue;
        }
        if (c === "\\" && escaped) {
          append(c);
          continue;
        }
        if (c === "\\" && inQuotes) {
          escaped = true;
          continue;
        }
        if (c === " " && !inQuotes) {
          if (arg.length > 0) {
            args.push(arg);
            arg = "";
          }
          continue;
        }
        append(c);
      }
      if (arg.length > 0) {
        args.push(arg.trim());
      }
      return args;
    }
    exports.argStringToArray = argStringToArray;
    var ExecState = class _ExecState extends events.EventEmitter {
      constructor(options, toolPath) {
        super();
        this.processClosed = false;
        this.processError = "";
        this.processExitCode = 0;
        this.processExited = false;
        this.processStderr = false;
        this.delay = 1e4;
        this.done = false;
        this.timeout = null;
        if (!toolPath) {
          throw new Error("toolPath must not be empty");
        }
        this.options = options;
        this.toolPath = toolPath;
        if (options.delay) {
          this.delay = options.delay;
        }
      }
      CheckComplete() {
        if (this.done) {
          return;
        }
        if (this.processClosed) {
          this._setResult();
        } else if (this.processExited) {
          this.timeout = timers_1.setTimeout(_ExecState.HandleTimeout, this.delay, this);
        }
      }
      _debug(message) {
        this.emit("debug", message);
      }
      _setResult() {
        let error;
        if (this.processExited) {
          if (this.processError) {
            error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);
          } else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {
            error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);
          } else if (this.processStderr && this.options.failOnStdErr) {
            error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);
          }
        }
        if (this.timeout) {
          clearTimeout(this.timeout);
          this.timeout = null;
        }
        this.done = true;
        this.emit("done", error, this.processExitCode);
      }
      static HandleTimeout(state) {
        if (state.done) {
          return;
        }
        if (!state.processClosed && state.processExited) {
          const message = `The STDIO streams did not close within ${state.delay / 1e3} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
          state._debug(message);
        }
        state._setResult();
      }
    };
  }
});

// node_modules/@actions/exec/lib/exec.js
var require_exec = __commonJS({
  "node_modules/@actions/exec/lib/exec.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      Object.defineProperty(o, k22, { enumerable: true, get: function() {
        return m[k2];
      } });
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getExecOutput = exports.exec = void 0;
    var string_decoder_1 = __require("string_decoder");
    var tr2 = __importStar(require_toolrunner());
    function exec(commandLine, args, options) {
      return __awaiter(this, void 0, void 0, function* () {
        const commandArgs = tr2.argStringToArray(commandLine);
        if (commandArgs.length === 0) {
          throw new Error(`Parameter 'commandLine' cannot be null or empty.`);
        }
        const toolPath = commandArgs[0];
        args = commandArgs.slice(1).concat(args || []);
        const runner = new tr2.ToolRunner(toolPath, args, options);
        return runner.exec();
      });
    }
    exports.exec = exec;
    function getExecOutput(commandLine, args, options) {
      var _a, _b;
      return __awaiter(this, void 0, void 0, function* () {
        let stdout = "";
        let stderr = "";
        const stdoutDecoder = new string_decoder_1.StringDecoder("utf8");
        const stderrDecoder = new string_decoder_1.StringDecoder("utf8");
        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;
        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;
        const stdErrListener = (data) => {
          stderr += stderrDecoder.write(data);
          if (originalStdErrListener) {
            originalStdErrListener(data);
          }
        };
        const stdOutListener = (data) => {
          stdout += stdoutDecoder.write(data);
          if (originalStdoutListener) {
            originalStdoutListener(data);
          }
        };
        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });
        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));
        stdout += stdoutDecoder.end();
        stderr += stderrDecoder.end();
        return {
          exitCode,
          stdout,
          stderr
        };
      });
    }
    exports.getExecOutput = getExecOutput;
  }
});

// node_modules/@actions/core/lib/platform.js
var require_platform = __commonJS({
  "node_modules/@actions/core/lib/platform.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDetails = exports.isLinux = exports.isMacOS = exports.isWindows = exports.arch = exports.platform = void 0;
    var os_1 = __importDefault(__require("os"));
    var exec = __importStar(require_exec());
    var getWindowsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout: version2 } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"', void 0, {
        silent: true
      });
      const { stdout: name } = yield exec.getExecOutput('powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"', void 0, {
        silent: true
      });
      return {
        name: name.trim(),
        version: version2.trim()
      };
    });
    var getMacOsInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      var _a, _b, _c, _d;
      const { stdout } = yield exec.getExecOutput("sw_vers", void 0, {
        silent: true
      });
      const version2 = (_b = (_a = stdout.match(/ProductVersion:\s*(.+)/)) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : "";
      const name = (_d = (_c = stdout.match(/ProductName:\s*(.+)/)) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : "";
      return {
        name,
        version: version2
      };
    });
    var getLinuxInfo = () => __awaiter(void 0, void 0, void 0, function* () {
      const { stdout } = yield exec.getExecOutput("lsb_release", ["-i", "-r", "-s"], {
        silent: true
      });
      const [name, version2] = stdout.trim().split("\n");
      return {
        name,
        version: version2
      };
    });
    exports.platform = os_1.default.platform();
    exports.arch = os_1.default.arch();
    exports.isWindows = exports.platform === "win32";
    exports.isMacOS = exports.platform === "darwin";
    exports.isLinux = exports.platform === "linux";
    function getDetails() {
      return __awaiter(this, void 0, void 0, function* () {
        return Object.assign(Object.assign({}, yield exports.isWindows ? getWindowsInfo() : exports.isMacOS ? getMacOsInfo() : getLinuxInfo()), {
          platform: exports.platform,
          arch: exports.arch,
          isWindows: exports.isWindows,
          isMacOS: exports.isMacOS,
          isLinux: exports.isLinux
        });
      });
    }
    exports.getDetails = getDetails;
  }
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS({
  "node_modules/@actions/core/lib/core.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      var desc = Object.getOwnPropertyDescriptor(m, k2);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k2];
        } };
      }
      Object.defineProperty(o, k22, desc);
    } : function(o, m, k2, k22) {
      if (k22 === void 0) k22 = k2;
      o[k22] = m[k2];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod) if (k2 !== "default" && Object.prototype.hasOwnProperty.call(mod, k2)) __createBinding(result, mod, k2);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.platform = exports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = exports.markdownSummary = exports.summary = exports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;
    var command_1 = require_command();
    var file_command_1 = require_file_command();
    var utils_1 = require_utils();
    var os = __importStar(__require("os"));
    var path = __importStar(__require("path"));
    var oidc_utils_1 = require_oidc_utils();
    var ExitCode;
    (function(ExitCode2) {
      ExitCode2[ExitCode2["Success"] = 0] = "Success";
      ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
    })(ExitCode || (exports.ExitCode = ExitCode = {}));
    function exportVariable2(name, val) {
      const convertedVal = (0, utils_1.toCommandValue)(val);
      process.env[name] = convertedVal;
      const filePath = process.env["GITHUB_ENV"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("ENV", (0, file_command_1.prepareKeyValueMessage)(name, val));
      }
      (0, command_1.issueCommand)("set-env", { name }, convertedVal);
    }
    exports.exportVariable = exportVariable2;
    function setSecret(secret) {
      (0, command_1.issueCommand)("add-mask", {}, secret);
    }
    exports.setSecret = setSecret;
    function addPath(inputPath) {
      const filePath = process.env["GITHUB_PATH"] || "";
      if (filePath) {
        (0, file_command_1.issueFileCommand)("PATH", inputPath);
      } else {
        (0, command_1.issueCommand)("add-path", {}, inputPath);
      }
      process.env["PATH"] = `${inputPath}${path.delimiter}${process.env["PATH"]}`;
    }
    exports.addPath = addPath;
    function getInput2(name, options) {
      const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
      if (options && options.required && !val) {
        throw new Error(`Input required and not supplied: ${name}`);
      }
      if (options && options.trimWhitespace === false) {
        return val;
      }
      return val.trim();
    }
    exports.getInput = getInput2;
    function getMultilineInput(name, options) {
      const inputs = getInput2(name, options).split("\n").filter((x2) => x2 !== "");
      if (options && options.trimWhitespace === false) {
        return inputs;
      }
      return inputs.map((input) => input.trim());
    }
    exports.getMultilineInput = getMultilineInput;
    function getBooleanInput(name, options) {
      const trueValue = ["true", "True", "TRUE"];
      const falseValue = ["false", "False", "FALSE"];
      const val = getInput2(name, options);
      if (trueValue.includes(val))
        return true;
      if (falseValue.includes(val))
        return false;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${name}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    exports.getBooleanInput = getBooleanInput;
    function setOutput(name, value) {
      const filePath = process.env["GITHUB_OUTPUT"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("OUTPUT", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      process.stdout.write(os.EOL);
      (0, command_1.issueCommand)("set-output", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.setOutput = setOutput;
    function setCommandEcho(enabled) {
      (0, command_1.issue)("echo", enabled ? "on" : "off");
    }
    exports.setCommandEcho = setCommandEcho;
    function setFailed(message) {
      process.exitCode = ExitCode.Failure;
      error(message);
    }
    exports.setFailed = setFailed;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    exports.isDebug = isDebug;
    function debug2(message) {
      (0, command_1.issueCommand)("debug", {}, message);
    }
    exports.debug = debug2;
    function error(message, properties = {}) {
      (0, command_1.issueCommand)("error", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.error = error;
    function warning(message, properties = {}) {
      (0, command_1.issueCommand)("warning", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.warning = warning;
    function notice(message, properties = {}) {
      (0, command_1.issueCommand)("notice", (0, utils_1.toCommandProperties)(properties), message instanceof Error ? message.toString() : message);
    }
    exports.notice = notice;
    function info(message) {
      process.stdout.write(message + os.EOL);
    }
    exports.info = info;
    function startGroup(name) {
      (0, command_1.issue)("group", name);
    }
    exports.startGroup = startGroup;
    function endGroup() {
      (0, command_1.issue)("endgroup");
    }
    exports.endGroup = endGroup;
    function group(name, fn2) {
      return __awaiter(this, void 0, void 0, function* () {
        startGroup(name);
        let result;
        try {
          result = yield fn2();
        } finally {
          endGroup();
        }
        return result;
      });
    }
    exports.group = group;
    function saveState(name, value) {
      const filePath = process.env["GITHUB_STATE"] || "";
      if (filePath) {
        return (0, file_command_1.issueFileCommand)("STATE", (0, file_command_1.prepareKeyValueMessage)(name, value));
      }
      (0, command_1.issueCommand)("save-state", { name }, (0, utils_1.toCommandValue)(value));
    }
    exports.saveState = saveState;
    function getState(name) {
      return process.env[`STATE_${name}`] || "";
    }
    exports.getState = getState;
    function getIDToken(aud) {
      return __awaiter(this, void 0, void 0, function* () {
        return yield oidc_utils_1.OidcClient.getIDToken(aud);
      });
    }
    exports.getIDToken = getIDToken;
    var summary_1 = require_summary();
    Object.defineProperty(exports, "summary", { enumerable: true, get: function() {
      return summary_1.summary;
    } });
    var summary_2 = require_summary();
    Object.defineProperty(exports, "markdownSummary", { enumerable: true, get: function() {
      return summary_2.markdownSummary;
    } });
    var path_utils_1 = require_path_utils();
    Object.defineProperty(exports, "toPosixPath", { enumerable: true, get: function() {
      return path_utils_1.toPosixPath;
    } });
    Object.defineProperty(exports, "toWin32Path", { enumerable: true, get: function() {
      return path_utils_1.toWin32Path;
    } });
    Object.defineProperty(exports, "toPlatformPath", { enumerable: true, get: function() {
      return path_utils_1.toPlatformPath;
    } });
    exports.platform = __importStar(require_platform());
  }
});

// node_modules/viem/_esm/utils/data/isHex.js
function isHex(value, { strict = true } = {}) {
  if (!value)
    return false;
  if (typeof value !== "string")
    return false;
  return strict ? /^0x[0-9a-fA-F]*$/.test(value) : value.startsWith("0x");
}
var init_isHex = __esm({
  "node_modules/viem/_esm/utils/data/isHex.js"() {
  }
});

// node_modules/viem/_esm/utils/data/size.js
function size(value) {
  if (isHex(value, { strict: false }))
    return Math.ceil((value.length - 2) / 2);
  return value.length;
}
var init_size = __esm({
  "node_modules/viem/_esm/utils/data/size.js"() {
    init_isHex();
  }
});

// node_modules/viem/_esm/errors/version.js
var version;
var init_version = __esm({
  "node_modules/viem/_esm/errors/version.js"() {
    version = "2.23.12";
  }
});

// node_modules/viem/_esm/errors/base.js
function walk(err, fn2) {
  if (fn2?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err && err.cause !== void 0)
    return walk(err.cause, fn2);
  return fn2 ? null : err;
}
var errorConfig, BaseError;
var init_base = __esm({
  "node_modules/viem/_esm/errors/base.js"() {
    init_version();
    errorConfig = {
      getDocsUrl: ({ docsBaseUrl, docsPath = "", docsSlug }) => docsPath ? `${docsBaseUrl ?? "https://viem.sh"}${docsPath}${docsSlug ? `#${docsSlug}` : ""}` : void 0,
      version: `viem@${version}`
    };
    BaseError = class _BaseError extends Error {
      constructor(shortMessage, args = {}) {
        const details = (() => {
          if (args.cause instanceof _BaseError)
            return args.cause.details;
          if (args.cause?.message)
            return args.cause.message;
          return args.details;
        })();
        const docsPath = (() => {
          if (args.cause instanceof _BaseError)
            return args.cause.docsPath || args.docsPath;
          return args.docsPath;
        })();
        const docsUrl = errorConfig.getDocsUrl?.({ ...args, docsPath });
        const message = [
          shortMessage || "An error occurred.",
          "",
          ...args.metaMessages ? [...args.metaMessages, ""] : [],
          ...docsUrl ? [`Docs: ${docsUrl}`] : [],
          ...details ? [`Details: ${details}`] : [],
          ...errorConfig.version ? [`Version: ${errorConfig.version}`] : []
        ].join("\n");
        super(message, args.cause ? { cause: args.cause } : void 0);
        Object.defineProperty(this, "details", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "docsPath", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "metaMessages", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "shortMessage", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "version", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "name", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: "BaseError"
        });
        this.details = details;
        this.docsPath = docsPath;
        this.metaMessages = args.metaMessages;
        this.name = args.name ?? this.name;
        this.shortMessage = shortMessage;
        this.version = version;
      }
      walk(fn2) {
        return walk(this, fn2);
      }
    };
  }
});

// node_modules/viem/_esm/errors/data.js
var SliceOffsetOutOfBoundsError, SizeExceedsPaddingSizeError;
var init_data = __esm({
  "node_modules/viem/_esm/errors/data.js"() {
    init_base();
    SliceOffsetOutOfBoundsError = class extends BaseError {
      constructor({ offset, position, size: size2 }) {
        super(`Slice ${position === "start" ? "starting" : "ending"} at offset "${offset}" is out-of-bounds (size: ${size2}).`, { name: "SliceOffsetOutOfBoundsError" });
      }
    };
    SizeExceedsPaddingSizeError = class extends BaseError {
      constructor({ size: size2, targetSize, type }) {
        super(`${type.charAt(0).toUpperCase()}${type.slice(1).toLowerCase()} size (${size2}) exceeds padding size (${targetSize}).`, { name: "SizeExceedsPaddingSizeError" });
      }
    };
  }
});

// node_modules/viem/_esm/utils/data/pad.js
function pad(hexOrBytes, { dir, size: size2 = 32 } = {}) {
  if (typeof hexOrBytes === "string")
    return padHex(hexOrBytes, { dir, size: size2 });
  return padBytes(hexOrBytes, { dir, size: size2 });
}
function padHex(hex_, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return hex_;
  const hex = hex_.replace("0x", "");
  if (hex.length > size2 * 2)
    throw new SizeExceedsPaddingSizeError({
      size: Math.ceil(hex.length / 2),
      targetSize: size2,
      type: "hex"
    });
  return `0x${hex[dir === "right" ? "padEnd" : "padStart"](size2 * 2, "0")}`;
}
function padBytes(bytes, { dir, size: size2 = 32 } = {}) {
  if (size2 === null)
    return bytes;
  if (bytes.length > size2)
    throw new SizeExceedsPaddingSizeError({
      size: bytes.length,
      targetSize: size2,
      type: "bytes"
    });
  const paddedBytes = new Uint8Array(size2);
  for (let i = 0; i < size2; i++) {
    const padEnd = dir === "right";
    paddedBytes[padEnd ? i : size2 - i - 1] = bytes[padEnd ? i : bytes.length - i - 1];
  }
  return paddedBytes;
}
var init_pad = __esm({
  "node_modules/viem/_esm/utils/data/pad.js"() {
    init_data();
  }
});

// node_modules/viem/_esm/errors/encoding.js
var IntegerOutOfRangeError, SizeOverflowError;
var init_encoding = __esm({
  "node_modules/viem/_esm/errors/encoding.js"() {
    init_base();
    IntegerOutOfRangeError = class extends BaseError {
      constructor({ max, min, signed, size: size2, value }) {
        super(`Number "${value}" is not in safe ${size2 ? `${size2 * 8}-bit ${signed ? "signed" : "unsigned"} ` : ""}integer range ${max ? `(${min} to ${max})` : `(above ${min})`}`, { name: "IntegerOutOfRangeError" });
      }
    };
    SizeOverflowError = class extends BaseError {
      constructor({ givenSize, maxSize }) {
        super(`Size cannot exceed ${maxSize} bytes. Given size: ${givenSize} bytes.`, { name: "SizeOverflowError" });
      }
    };
  }
});

// node_modules/viem/_esm/utils/data/trim.js
function trim(hexOrBytes, { dir = "left" } = {}) {
  let data = typeof hexOrBytes === "string" ? hexOrBytes.replace("0x", "") : hexOrBytes;
  let sliceLength = 0;
  for (let i = 0; i < data.length - 1; i++) {
    if (data[dir === "left" ? i : data.length - i - 1].toString() === "0")
      sliceLength++;
    else
      break;
  }
  data = dir === "left" ? data.slice(sliceLength) : data.slice(0, data.length - sliceLength);
  if (typeof hexOrBytes === "string") {
    if (data.length === 1 && dir === "right")
      data = `${data}0`;
    return `0x${data.length % 2 === 1 ? `0${data}` : data}`;
  }
  return data;
}
var init_trim = __esm({
  "node_modules/viem/_esm/utils/data/trim.js"() {
  }
});

// node_modules/viem/_esm/utils/encoding/fromHex.js
function assertSize(hexOrBytes, { size: size2 }) {
  if (size(hexOrBytes) > size2)
    throw new SizeOverflowError({
      givenSize: size(hexOrBytes),
      maxSize: size2
    });
}
function hexToBigInt(hex, opts = {}) {
  const { signed } = opts;
  if (opts.size)
    assertSize(hex, { size: opts.size });
  const value = BigInt(hex);
  if (!signed)
    return value;
  const size2 = (hex.length - 2) / 2;
  const max = (1n << BigInt(size2) * 8n - 1n) - 1n;
  if (value <= max)
    return value;
  return value - BigInt(`0x${"f".padStart(size2 * 2, "f")}`) - 1n;
}
function hexToNumber(hex, opts = {}) {
  return Number(hexToBigInt(hex, opts));
}
var init_fromHex = __esm({
  "node_modules/viem/_esm/utils/encoding/fromHex.js"() {
    init_encoding();
    init_size();
  }
});

// node_modules/viem/_esm/utils/encoding/toHex.js
function toHex(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToHex(value, opts);
  if (typeof value === "string") {
    return stringToHex(value, opts);
  }
  if (typeof value === "boolean")
    return boolToHex(value, opts);
  return bytesToHex(value, opts);
}
function boolToHex(value, opts = {}) {
  const hex = `0x${Number(value)}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { size: opts.size });
  }
  return hex;
}
function bytesToHex(value, opts = {}) {
  let string = "";
  for (let i = 0; i < value.length; i++) {
    string += hexes[value[i]];
  }
  const hex = `0x${string}`;
  if (typeof opts.size === "number") {
    assertSize(hex, { size: opts.size });
    return pad(hex, { dir: "right", size: opts.size });
  }
  return hex;
}
function numberToHex(value_, opts = {}) {
  const { signed, size: size2 } = opts;
  const value = BigInt(value_);
  let maxValue;
  if (size2) {
    if (signed)
      maxValue = (1n << BigInt(size2) * 8n - 1n) - 1n;
    else
      maxValue = 2n ** (BigInt(size2) * 8n) - 1n;
  } else if (typeof value_ === "number") {
    maxValue = BigInt(Number.MAX_SAFE_INTEGER);
  }
  const minValue = typeof maxValue === "bigint" && signed ? -maxValue - 1n : 0;
  if (maxValue && value > maxValue || value < minValue) {
    const suffix = typeof value_ === "bigint" ? "n" : "";
    throw new IntegerOutOfRangeError({
      max: maxValue ? `${maxValue}${suffix}` : void 0,
      min: `${minValue}${suffix}`,
      signed,
      size: size2,
      value: `${value_}${suffix}`
    });
  }
  const hex = `0x${(signed && value < 0 ? (1n << BigInt(size2 * 8)) + BigInt(value) : value).toString(16)}`;
  if (size2)
    return pad(hex, { size: size2 });
  return hex;
}
function stringToHex(value_, opts = {}) {
  const value = encoder.encode(value_);
  return bytesToHex(value, opts);
}
var hexes, encoder;
var init_toHex = __esm({
  "node_modules/viem/_esm/utils/encoding/toHex.js"() {
    init_encoding();
    init_pad();
    init_fromHex();
    hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
    encoder = /* @__PURE__ */ new TextEncoder();
  }
});

// node_modules/viem/_esm/utils/encoding/toBytes.js
function toBytes(value, opts = {}) {
  if (typeof value === "number" || typeof value === "bigint")
    return numberToBytes(value, opts);
  if (typeof value === "boolean")
    return boolToBytes(value, opts);
  if (isHex(value))
    return hexToBytes(value, opts);
  return stringToBytes(value, opts);
}
function boolToBytes(value, opts = {}) {
  const bytes = new Uint8Array(1);
  bytes[0] = Number(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { size: opts.size });
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return void 0;
}
function hexToBytes(hex_, opts = {}) {
  let hex = hex_;
  if (opts.size) {
    assertSize(hex, { size: opts.size });
    hex = pad(hex, { dir: "right", size: opts.size });
  }
  let hexString = hex.slice(2);
  if (hexString.length % 2)
    hexString = `0${hexString}`;
  const length = hexString.length / 2;
  const bytes = new Uint8Array(length);
  for (let index = 0, j = 0; index < length; index++) {
    const nibbleLeft = charCodeToBase16(hexString.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hexString.charCodeAt(j++));
    if (nibbleLeft === void 0 || nibbleRight === void 0) {
      throw new BaseError(`Invalid byte sequence ("${hexString[j - 2]}${hexString[j - 1]}" in "${hexString}").`);
    }
    bytes[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes;
}
function numberToBytes(value, opts) {
  const hex = numberToHex(value, opts);
  return hexToBytes(hex);
}
function stringToBytes(value, opts = {}) {
  const bytes = encoder2.encode(value);
  if (typeof opts.size === "number") {
    assertSize(bytes, { size: opts.size });
    return pad(bytes, { dir: "right", size: opts.size });
  }
  return bytes;
}
var encoder2, charCodeMap;
var init_toBytes = __esm({
  "node_modules/viem/_esm/utils/encoding/toBytes.js"() {
    init_base();
    init_isHex();
    init_pad();
    init_fromHex();
    init_toHex();
    encoder2 = /* @__PURE__ */ new TextEncoder();
    charCodeMap = {
      zero: 48,
      nine: 57,
      A: 65,
      F: 70,
      a: 97,
      f: 102
    };
  }
});

// node_modules/@noble/hashes/esm/_assert.js
function anumber(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error("positive integer expected, got " + n);
}
function isBytes(a) {
  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === "Uint8Array";
}
function abytes(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b.length);
}
function aexists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput(out, instance) {
  abytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}
var init_assert = __esm({
  "node_modules/@noble/hashes/esm/_assert.js"() {
  }
});

// node_modules/@noble/hashes/esm/_u64.js
function fromBig(n, le2 = false) {
  if (le2)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0; i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le2);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
var U32_MASK64, _32n, rotlSH, rotlSL, rotlBH, rotlBL;
var init_u64 = __esm({
  "node_modules/@noble/hashes/esm/_u64.js"() {
    U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);
    _32n = /* @__PURE__ */ BigInt(32);
    rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
  }
});

// node_modules/@noble/hashes/esm/utils.js
function u32(arr) {
  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
}
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function byteSwap(word) {
  return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
}
function byteSwap32(arr) {
  for (let i = 0; i < arr.length; i++) {
    arr[i] = byteSwap(arr[i]);
  }
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes2(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes(data);
  return data;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes2(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
var isLE, Hash;
var init_utils = __esm({
  "node_modules/@noble/hashes/esm/utils.js"() {
    init_assert();
    isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
    Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
  }
});

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s[x2] ^ s[x2 + 10] ^ s[x2 + 20] ^ s[x2 + 30] ^ s[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y2 = 0; y2 < 50; y2 += 10) {
        s[x2 + y2] ^= Th;
        s[x2 + y2 + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y2 = 0; y2 < 50; y2 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s[y2 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B2.fill(0);
}
var SHA3_PI, SHA3_ROTL, _SHA3_IOTA, _0n, _1n, _2n, _7n, _256n, _0x71n, SHA3_IOTA_H, SHA3_IOTA_L, rotlH, rotlL, Keccak, gen, keccak_256;
var init_sha3 = __esm({
  "node_modules/@noble/hashes/esm/sha3.js"() {
    init_assert();
    init_u64();
    init_utils();
    SHA3_PI = [];
    SHA3_ROTL = [];
    _SHA3_IOTA = [];
    _0n = /* @__PURE__ */ BigInt(0);
    _1n = /* @__PURE__ */ BigInt(1);
    _2n = /* @__PURE__ */ BigInt(2);
    _7n = /* @__PURE__ */ BigInt(7);
    _256n = /* @__PURE__ */ BigInt(256);
    _0x71n = /* @__PURE__ */ BigInt(113);
    for (let round = 0, R2 = _1n, x2 = 1, y2 = 0; round < 24; round++) {
      [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
      SHA3_PI.push(2 * (5 * y2 + x2));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R2 = (R2 << _1n ^ (R2 >> _7n) * _0x71n) % _256n;
        if (R2 & _2n)
          t ^= _1n << (_1n << /* @__PURE__ */ BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ split(_SHA3_IOTA, true);
    rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
    rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
    Keccak = class _Keccak extends Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        anumber(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = u32(this.state);
      }
      keccak() {
        if (!isLE)
          byteSwap32(this.state32);
        keccakP(this.state32, this.rounds);
        if (!isLE)
          byteSwap32(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        aexists(this);
        const { blockLen, state } = this;
        data = toBytes2(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        aexists(this, false);
        abytes(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        anumber(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        aoutput(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to2) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to2 || (to2 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to2.state32.set(this.state32);
        to2.pos = this.pos;
        to2.posOut = this.posOut;
        to2.finished = this.finished;
        to2.rounds = rounds;
        to2.suffix = suffix;
        to2.outputLen = outputLen;
        to2.enableXOF = enableXOF;
        to2.destroyed = this.destroyed;
        return to2;
      }
    };
    gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
    keccak_256 = /* @__PURE__ */ gen(1, 136, 256 / 8);
  }
});

// node_modules/viem/_esm/utils/hash/keccak256.js
function keccak256(value, to_) {
  const bytes = keccak_256(isHex(value, { strict: false }) ? toBytes(value) : value);
  return bytes;
}
var init_keccak256 = __esm({
  "node_modules/viem/_esm/utils/hash/keccak256.js"() {
    init_sha3();
    init_isHex();
    init_toBytes();
    init_toHex();
  }
});

// node_modules/viem/_esm/errors/address.js
var InvalidAddressError;
var init_address = __esm({
  "node_modules/viem/_esm/errors/address.js"() {
    init_base();
    InvalidAddressError = class extends BaseError {
      constructor({ address }) {
        super(`Address "${address}" is invalid.`, {
          metaMessages: [
            "- Address must be a hex value of 20 bytes (40 hex characters).",
            "- Address must match its checksum counterpart."
          ],
          name: "InvalidAddressError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/utils/lru.js
var LruMap;
var init_lru = __esm({
  "node_modules/viem/_esm/utils/lru.js"() {
    LruMap = class extends Map {
      constructor(size2) {
        super();
        Object.defineProperty(this, "maxSize", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.maxSize = size2;
      }
      get(key) {
        const value = super.get(key);
        if (super.has(key) && value !== void 0) {
          this.delete(key);
          super.set(key, value);
        }
        return value;
      }
      set(key, value) {
        super.set(key, value);
        if (this.maxSize && this.size > this.maxSize) {
          const firstKey = this.keys().next().value;
          if (firstKey)
            this.delete(firstKey);
        }
        return this;
      }
    };
  }
});

// node_modules/viem/_esm/utils/address/getAddress.js
function checksumAddress(address_, chainId) {
  if (checksumAddressCache.has(`${address_}.${chainId}`))
    return checksumAddressCache.get(`${address_}.${chainId}`);
  const hexAddress = address_.substring(2).toLowerCase();
  const hash = keccak256(stringToBytes(hexAddress));
  const address = (hexAddress).split("");
  for (let i = 0; i < 40; i += 2) {
    if (hash[i >> 1] >> 4 >= 8 && address[i]) {
      address[i] = address[i].toUpperCase();
    }
    if ((hash[i >> 1] & 15) >= 8 && address[i + 1]) {
      address[i + 1] = address[i + 1].toUpperCase();
    }
  }
  const result = `0x${address.join("")}`;
  checksumAddressCache.set(`${address_}.${chainId}`, result);
  return result;
}
var checksumAddressCache;
var init_getAddress = __esm({
  "node_modules/viem/_esm/utils/address/getAddress.js"() {
    init_toBytes();
    init_keccak256();
    init_lru();
    checksumAddressCache = /* @__PURE__ */ new LruMap(8192);
  }
});

// node_modules/viem/_esm/utils/address/isAddress.js
function isAddress(address, options) {
  const { strict = true } = options ?? {};
  const cacheKey = `${address}.${strict}`;
  if (isAddressCache.has(cacheKey))
    return isAddressCache.get(cacheKey);
  const result = (() => {
    if (!addressRegex.test(address))
      return false;
    if (address.toLowerCase() === address)
      return true;
    if (strict)
      return checksumAddress(address) === address;
    return true;
  })();
  isAddressCache.set(cacheKey, result);
  return result;
}
var addressRegex, isAddressCache;
var init_isAddress = __esm({
  "node_modules/viem/_esm/utils/address/isAddress.js"() {
    init_lru();
    init_getAddress();
    addressRegex = /^0x[a-fA-F0-9]{40}$/;
    isAddressCache = /* @__PURE__ */ new LruMap(8192);
  }
});

// node_modules/viem/_esm/utils/data/concat.js
function concatHex(values) {
  return `0x${values.reduce((acc, x2) => acc + x2.replace("0x", ""), "")}`;
}
var init_concat = __esm({
  "node_modules/viem/_esm/utils/data/concat.js"() {
  }
});

// node_modules/viem/_esm/utils/data/slice.js
function slice(value, start, end, { strict } = {}) {
  if (isHex(value, { strict: false }))
    return sliceHex(value, start, end, {
      strict
    });
  return sliceBytes(value, start, end, {
    strict
  });
}
function assertEndOffset(value, start, end) {
  if (size(value) !== end - start) {
    throw new SliceOffsetOutOfBoundsError({
      offset: end,
      position: "end",
      size: size(value)
    });
  }
}
function sliceBytes(value_, start, end, { strict } = {}) {
  const value = value_.slice(start, end);
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
function sliceHex(value_, start, end, { strict } = {}) {
  const value = `0x${value_.replace("0x", "").slice((start) * 2, (end) * 2)}`;
  if (strict)
    assertEndOffset(value, start, end);
  return value;
}
var init_slice = __esm({
  "node_modules/viem/_esm/utils/data/slice.js"() {
    init_data();
    init_isHex();
    init_size();
  }
});

// node_modules/viem/_esm/accounts/utils/parseAccount.js
function parseAccount(account) {
  if (typeof account === "string")
    return { address: account, type: "json-rpc" };
  return account;
}
var init_parseAccount = __esm({
  "node_modules/viem/_esm/accounts/utils/parseAccount.js"() {
  }
});

// node_modules/viem/_esm/errors/cursor.js
var NegativeOffsetError, PositionOutOfBoundsError, RecursiveReadLimitExceededError;
var init_cursor = __esm({
  "node_modules/viem/_esm/errors/cursor.js"() {
    init_base();
    NegativeOffsetError = class extends BaseError {
      constructor({ offset }) {
        super(`Offset \`${offset}\` cannot be negative.`, {
          name: "NegativeOffsetError"
        });
      }
    };
    PositionOutOfBoundsError = class extends BaseError {
      constructor({ length, position }) {
        super(`Position \`${position}\` is out of bounds (\`0 < position < ${length}\`).`, { name: "PositionOutOfBoundsError" });
      }
    };
    RecursiveReadLimitExceededError = class extends BaseError {
      constructor({ count, limit }) {
        super(`Recursive read limit of \`${limit}\` exceeded (recursive read count: \`${count}\`).`, { name: "RecursiveReadLimitExceededError" });
      }
    };
  }
});

// node_modules/viem/_esm/utils/cursor.js
function createCursor(bytes, { recursiveReadLimit = 8192 } = {}) {
  const cursor = Object.create(staticCursor);
  cursor.bytes = bytes;
  cursor.dataView = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);
  cursor.positionReadCount = /* @__PURE__ */ new Map();
  cursor.recursiveReadLimit = recursiveReadLimit;
  return cursor;
}
var staticCursor;
var init_cursor2 = __esm({
  "node_modules/viem/_esm/utils/cursor.js"() {
    init_cursor();
    staticCursor = {
      bytes: new Uint8Array(),
      dataView: new DataView(new ArrayBuffer(0)),
      position: 0,
      positionReadCount: /* @__PURE__ */ new Map(),
      recursiveReadCount: 0,
      recursiveReadLimit: Number.POSITIVE_INFINITY,
      assertReadLimit() {
        if (this.recursiveReadCount >= this.recursiveReadLimit)
          throw new RecursiveReadLimitExceededError({
            count: this.recursiveReadCount + 1,
            limit: this.recursiveReadLimit
          });
      },
      assertPosition(position) {
        if (position < 0 || position > this.bytes.length - 1)
          throw new PositionOutOfBoundsError({
            length: this.bytes.length,
            position
          });
      },
      decrementPosition(offset) {
        if (offset < 0)
          throw new NegativeOffsetError({ offset });
        const position = this.position - offset;
        this.assertPosition(position);
        this.position = position;
      },
      getReadCount(position) {
        return this.positionReadCount.get(position || this.position) || 0;
      },
      incrementPosition(offset) {
        if (offset < 0)
          throw new NegativeOffsetError({ offset });
        const position = this.position + offset;
        this.assertPosition(position);
        this.position = position;
      },
      inspectByte(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectBytes(length, position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + length - 1);
        return this.bytes.subarray(position, position + length);
      },
      inspectUint8(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position);
        return this.bytes[position];
      },
      inspectUint16(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 1);
        return this.dataView.getUint16(position);
      },
      inspectUint24(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 2);
        return (this.dataView.getUint16(position) << 8) + this.dataView.getUint8(position + 2);
      },
      inspectUint32(position_) {
        const position = position_ ?? this.position;
        this.assertPosition(position + 3);
        return this.dataView.getUint32(position);
      },
      pushByte(byte) {
        this.assertPosition(this.position);
        this.bytes[this.position] = byte;
        this.position++;
      },
      pushBytes(bytes) {
        this.assertPosition(this.position + bytes.length - 1);
        this.bytes.set(bytes, this.position);
        this.position += bytes.length;
      },
      pushUint8(value) {
        this.assertPosition(this.position);
        this.bytes[this.position] = value;
        this.position++;
      },
      pushUint16(value) {
        this.assertPosition(this.position + 1);
        this.dataView.setUint16(this.position, value);
        this.position += 2;
      },
      pushUint24(value) {
        this.assertPosition(this.position + 2);
        this.dataView.setUint16(this.position, value >> 8);
        this.dataView.setUint8(this.position + 2, value & ~4294967040);
        this.position += 3;
      },
      pushUint32(value) {
        this.assertPosition(this.position + 3);
        this.dataView.setUint32(this.position, value);
        this.position += 4;
      },
      readByte() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectByte();
        this.position++;
        return value;
      },
      readBytes(length, size2) {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectBytes(length);
        this.position += size2 ?? length;
        return value;
      },
      readUint8() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint8();
        this.position += 1;
        return value;
      },
      readUint16() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint16();
        this.position += 2;
        return value;
      },
      readUint24() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint24();
        this.position += 3;
        return value;
      },
      readUint32() {
        this.assertReadLimit();
        this._touch();
        const value = this.inspectUint32();
        this.position += 4;
        return value;
      },
      get remaining() {
        return this.bytes.length - this.position;
      },
      setPosition(position) {
        const oldPosition = this.position;
        this.assertPosition(position);
        this.position = position;
        return () => this.position = oldPosition;
      },
      _touch() {
        if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
          return;
        const count = this.getReadCount();
        this.positionReadCount.set(this.position, count + 1);
        if (count > 0)
          this.recursiveReadCount++;
      }
    };
  }
});

// node_modules/viem/_esm/constants/unit.js
var etherUnits, gweiUnits;
var init_unit = __esm({
  "node_modules/viem/_esm/constants/unit.js"() {
    etherUnits = {
      gwei: 9,
      wei: 18
    };
    gweiUnits = {
      ether: -9,
      wei: 9
    };
  }
});

// node_modules/viem/_esm/utils/unit/formatUnits.js
function formatUnits(value, decimals) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
var init_formatUnits = __esm({
  "node_modules/viem/_esm/utils/unit/formatUnits.js"() {
  }
});

// node_modules/viem/_esm/utils/unit/formatEther.js
function formatEther(wei, unit = "wei") {
  return formatUnits(wei, etherUnits[unit]);
}
var init_formatEther = __esm({
  "node_modules/viem/_esm/utils/unit/formatEther.js"() {
    init_unit();
    init_formatUnits();
  }
});

// node_modules/viem/_esm/utils/unit/formatGwei.js
function formatGwei(wei, unit = "wei") {
  return formatUnits(wei, gweiUnits[unit]);
}
var init_formatGwei = __esm({
  "node_modules/viem/_esm/utils/unit/formatGwei.js"() {
    init_unit();
    init_formatUnits();
  }
});

// node_modules/viem/_esm/errors/stateOverride.js
function prettyStateMapping(stateMapping) {
  return stateMapping.reduce((pretty, { slot, value }) => {
    return `${pretty}        ${slot}: ${value}
`;
  }, "");
}
function prettyStateOverride(stateOverride) {
  return stateOverride.reduce((pretty, { address, ...state }) => {
    let val = `${pretty}    ${address}:
`;
    if (state.nonce)
      val += `      nonce: ${state.nonce}
`;
    if (state.balance)
      val += `      balance: ${state.balance}
`;
    if (state.code)
      val += `      code: ${state.code}
`;
    if (state.state) {
      val += "      state:\n";
      val += prettyStateMapping(state.state);
    }
    if (state.stateDiff) {
      val += "      stateDiff:\n";
      val += prettyStateMapping(state.stateDiff);
    }
    return val;
  }, "  State Override:\n").slice(0, -1);
}
var init_stateOverride = __esm({
  "node_modules/viem/_esm/errors/stateOverride.js"() {
  }
});

// node_modules/viem/_esm/errors/transaction.js
function prettyPrint(args) {
  const entries = Object.entries(args).map(([key, value]) => {
    if (value === void 0 || value === false)
      return null;
    return [key, value];
  }).filter(Boolean);
  const maxLength = entries.reduce((acc, [key]) => Math.max(acc, key.length), 0);
  return entries.map(([key, value]) => `  ${`${key}:`.padEnd(maxLength + 1)}  ${value}`).join("\n");
}
var FeeConflictError, InvalidLegacyVError, InvalidSerializableTransactionError, InvalidStorageKeySizeError;
var init_transaction = __esm({
  "node_modules/viem/_esm/errors/transaction.js"() {
    init_base();
    FeeConflictError = class extends BaseError {
      constructor() {
        super([
          "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
          "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
        ].join("\n"), { name: "FeeConflictError" });
      }
    };
    InvalidLegacyVError = class extends BaseError {
      constructor({ v }) {
        super(`Invalid \`v\` value "${v}". Expected 27 or 28.`, {
          name: "InvalidLegacyVError"
        });
      }
    };
    InvalidSerializableTransactionError = class extends BaseError {
      constructor({ transaction }) {
        super("Cannot infer a transaction type from provided transaction.", {
          metaMessages: [
            "Provided Transaction:",
            "{",
            prettyPrint(transaction),
            "}",
            "",
            "To infer the type, either provide:",
            "- a `type` to the Transaction, or",
            "- an EIP-1559 Transaction with `maxFeePerGas`, or",
            "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
            "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
            "- an EIP-7702 Transaction with `authorizationList`, or",
            "- a Legacy Transaction with `gasPrice`"
          ],
          name: "InvalidSerializableTransactionError"
        });
      }
    };
    InvalidStorageKeySizeError = class extends BaseError {
      constructor({ storageKey }) {
        super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${Math.floor((storageKey.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
      }
    };
  }
});

// node_modules/viem/_esm/errors/contract.js
var CallExecutionError;
var init_contract = __esm({
  "node_modules/viem/_esm/errors/contract.js"() {
    init_parseAccount();
    init_formatEther();
    init_formatGwei();
    init_base();
    init_stateOverride();
    init_transaction();
    CallExecutionError = class extends BaseError {
      constructor(cause, { account: account_, docsPath, chain, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to2, value, stateOverride }) {
        const account = account_ ? parseAccount(account_) : void 0;
        let prettyArgs = prettyPrint({
          from: account?.address,
          to: to2,
          value: typeof value !== "undefined" && `${formatEther(value)} ${chain?.nativeCurrency?.symbol || "ETH"}`,
          data,
          gas,
          gasPrice: typeof gasPrice !== "undefined" && `${formatGwei(gasPrice)} gwei`,
          maxFeePerGas: typeof maxFeePerGas !== "undefined" && `${formatGwei(maxFeePerGas)} gwei`,
          maxPriorityFeePerGas: typeof maxPriorityFeePerGas !== "undefined" && `${formatGwei(maxPriorityFeePerGas)} gwei`,
          nonce
        });
        if (stateOverride) {
          prettyArgs += `
${prettyStateOverride(stateOverride)}`;
        }
        super(cause.shortMessage, {
          cause,
          docsPath,
          metaMessages: [
            ...cause.metaMessages ? [...cause.metaMessages, " "] : [],
            "Raw Call Arguments:",
            prettyArgs
          ].filter(Boolean),
          name: "CallExecutionError"
        });
        Object.defineProperty(this, "cause", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.cause = cause;
      }
    };
  }
});

// node_modules/viem/_esm/errors/node.js
var ExecutionRevertedError, FeeCapTooHighError, FeeCapTooLowError, NonceTooHighError, NonceTooLowError, NonceMaxValueError, InsufficientFundsError, IntrinsicGasTooHighError, IntrinsicGasTooLowError, TransactionTypeNotSupportedError, TipAboveFeeCapError, UnknownNodeError;
var init_node = __esm({
  "node_modules/viem/_esm/errors/node.js"() {
    init_formatGwei();
    init_base();
    ExecutionRevertedError = class extends BaseError {
      constructor({ cause, message } = {}) {
        const reason = message?.replace("execution reverted: ", "")?.replace("execution reverted", "");
        super(`Execution reverted ${reason ? `with reason: ${reason}` : "for an unknown reason"}.`, {
          cause,
          name: "ExecutionRevertedError"
        });
      }
    };
    Object.defineProperty(ExecutionRevertedError, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 3
    });
    Object.defineProperty(ExecutionRevertedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /execution reverted/
    });
    FeeCapTooHighError = class extends BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
          cause,
          name: "FeeCapTooHighError"
        });
      }
    };
    Object.defineProperty(FeeCapTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
    });
    FeeCapTooLowError = class extends BaseError {
      constructor({ cause, maxFeePerGas } = {}) {
        super(`The fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)}` : ""} gwei) cannot be lower than the block base fee.`, {
          cause,
          name: "FeeCapTooLowError"
        });
      }
    };
    Object.defineProperty(FeeCapTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
    });
    NonceTooHighError = class extends BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is higher than the next one expected.`, { cause, name: "NonceTooHighError" });
      }
    };
    Object.defineProperty(NonceTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too high/
    });
    NonceTooLowError = class extends BaseError {
      constructor({ cause, nonce } = {}) {
        super([
          `Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}is lower than the current nonce of the account.`,
          "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
        ].join("\n"), { cause, name: "NonceTooLowError" });
      }
    };
    Object.defineProperty(NonceTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce too low|transaction already imported|already known/
    });
    NonceMaxValueError = class extends BaseError {
      constructor({ cause, nonce } = {}) {
        super(`Nonce provided for the transaction ${nonce ? `(${nonce}) ` : ""}exceeds the maximum allowed nonce.`, { cause, name: "NonceMaxValueError" });
      }
    };
    Object.defineProperty(NonceMaxValueError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /nonce has max value/
    });
    InsufficientFundsError = class extends BaseError {
      constructor({ cause } = {}) {
        super([
          "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
        ].join("\n"), {
          cause,
          metaMessages: [
            "This error could arise when the account does not have enough funds to:",
            " - pay for the total gas fee,",
            " - pay for the value to send.",
            " ",
            "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
            " - `gas` is the amount of gas needed for transaction to execute,",
            " - `gas fee` is the gas fee,",
            " - `value` is the amount of ether to send to the recipient."
          ],
          name: "InsufficientFundsError"
        });
      }
    };
    Object.defineProperty(InsufficientFundsError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /insufficient funds|exceeds transaction sender account balance/
    });
    IntrinsicGasTooHighError = class extends BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
          cause,
          name: "IntrinsicGasTooHighError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooHighError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too high|gas limit reached/
    });
    IntrinsicGasTooLowError = class extends BaseError {
      constructor({ cause, gas } = {}) {
        super(`The amount of gas ${gas ? `(${gas}) ` : ""}provided for the transaction is too low.`, {
          cause,
          name: "IntrinsicGasTooLowError"
        });
      }
    };
    Object.defineProperty(IntrinsicGasTooLowError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /intrinsic gas too low/
    });
    TransactionTypeNotSupportedError = class extends BaseError {
      constructor({ cause }) {
        super("The transaction type is not supported for this chain.", {
          cause,
          name: "TransactionTypeNotSupportedError"
        });
      }
    };
    Object.defineProperty(TransactionTypeNotSupportedError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /transaction type not valid/
    });
    TipAboveFeeCapError = class extends BaseError {
      constructor({ cause, maxPriorityFeePerGas, maxFeePerGas } = {}) {
        super([
          `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
        ].join("\n"), {
          cause,
          name: "TipAboveFeeCapError"
        });
      }
    };
    Object.defineProperty(TipAboveFeeCapError, "nodeMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
    });
    UnknownNodeError = class extends BaseError {
      constructor({ cause }) {
        super(`An error occurred while executing: ${cause?.shortMessage}`, {
          cause,
          name: "UnknownNodeError"
        });
      }
    };
  }
});

// node_modules/viem/_esm/utils/errors/getNodeError.js
function getNodeError(err, args) {
  const message = (err.details || "").toLowerCase();
  const executionRevertedError = err instanceof BaseError ? err.walk((e) => e?.code === ExecutionRevertedError.code) : err;
  if (executionRevertedError instanceof BaseError)
    return new ExecutionRevertedError({
      cause: err,
      message: executionRevertedError.details
    });
  if (ExecutionRevertedError.nodeMessage.test(message))
    return new ExecutionRevertedError({
      cause: err,
      message: err.details
    });
  if (FeeCapTooHighError.nodeMessage.test(message))
    return new FeeCapTooHighError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (FeeCapTooLowError.nodeMessage.test(message))
    return new FeeCapTooLowError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas
    });
  if (NonceTooHighError.nodeMessage.test(message))
    return new NonceTooHighError({ cause: err, nonce: args?.nonce });
  if (NonceTooLowError.nodeMessage.test(message))
    return new NonceTooLowError({ cause: err, nonce: args?.nonce });
  if (NonceMaxValueError.nodeMessage.test(message))
    return new NonceMaxValueError({ cause: err, nonce: args?.nonce });
  if (InsufficientFundsError.nodeMessage.test(message))
    return new InsufficientFundsError({ cause: err });
  if (IntrinsicGasTooHighError.nodeMessage.test(message))
    return new IntrinsicGasTooHighError({ cause: err, gas: args?.gas });
  if (IntrinsicGasTooLowError.nodeMessage.test(message))
    return new IntrinsicGasTooLowError({ cause: err, gas: args?.gas });
  if (TransactionTypeNotSupportedError.nodeMessage.test(message))
    return new TransactionTypeNotSupportedError({ cause: err });
  if (TipAboveFeeCapError.nodeMessage.test(message))
    return new TipAboveFeeCapError({
      cause: err,
      maxFeePerGas: args?.maxFeePerGas,
      maxPriorityFeePerGas: args?.maxPriorityFeePerGas
    });
  return new UnknownNodeError({
    cause: err
  });
}
var init_getNodeError = __esm({
  "node_modules/viem/_esm/utils/errors/getNodeError.js"() {
    init_base();
    init_node();
  }
});

// node_modules/viem/_esm/utils/formatters/extract.js
function extract(value_, { format }) {
  if (!format)
    return {};
  const value = {};
  function extract_(formatted2) {
    const keys = Object.keys(formatted2);
    for (const key of keys) {
      if (key in value_)
        value[key] = value_[key];
      if (formatted2[key] && typeof formatted2[key] === "object" && !Array.isArray(formatted2[key]))
        extract_(formatted2[key]);
    }
  }
  const formatted = format(value_ || {});
  extract_(formatted);
  return value;
}
var init_extract = __esm({
  "node_modules/viem/_esm/utils/formatters/extract.js"() {
  }
});

// node_modules/viem/_esm/utils/formatters/formatter.js
function defineFormatter(type, format) {
  return ({ exclude, format: overrides }) => {
    return {
      exclude,
      format: (args) => {
        const formatted = format(args);
        if (exclude) {
          for (const key of exclude) {
            delete formatted[key];
          }
        }
        return {
          ...formatted,
          ...overrides(args)
        };
      },
      type
    };
  };
}
var init_formatter = __esm({
  "node_modules/viem/_esm/utils/formatters/formatter.js"() {
  }
});

// node_modules/viem/_esm/utils/formatters/transactionRequest.js
function formatTransactionRequest(request) {
  const rpcRequest = {};
  if (typeof request.authorizationList !== "undefined")
    rpcRequest.authorizationList = formatAuthorizationList(request.authorizationList);
  if (typeof request.accessList !== "undefined")
    rpcRequest.accessList = request.accessList;
  if (typeof request.blobVersionedHashes !== "undefined")
    rpcRequest.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined") {
    if (typeof request.blobs[0] !== "string")
      rpcRequest.blobs = request.blobs.map((x2) => bytesToHex(x2));
    else
      rpcRequest.blobs = request.blobs;
  }
  if (typeof request.data !== "undefined")
    rpcRequest.data = request.data;
  if (typeof request.from !== "undefined")
    rpcRequest.from = request.from;
  if (typeof request.gas !== "undefined")
    rpcRequest.gas = numberToHex(request.gas);
  if (typeof request.gasPrice !== "undefined")
    rpcRequest.gasPrice = numberToHex(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    rpcRequest.maxFeePerBlobGas = numberToHex(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    rpcRequest.maxFeePerGas = numberToHex(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    rpcRequest.maxPriorityFeePerGas = numberToHex(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    rpcRequest.nonce = numberToHex(request.nonce);
  if (typeof request.to !== "undefined")
    rpcRequest.to = request.to;
  if (typeof request.type !== "undefined")
    rpcRequest.type = rpcTransactionType[request.type];
  if (typeof request.value !== "undefined")
    rpcRequest.value = numberToHex(request.value);
  return rpcRequest;
}
function formatAuthorizationList(authorizationList) {
  return authorizationList.map((authorization) => ({
    address: authorization.contractAddress,
    r: authorization.r ? numberToHex(BigInt(authorization.r)) : authorization.r,
    s: authorization.s ? numberToHex(BigInt(authorization.s)) : authorization.s,
    chainId: numberToHex(authorization.chainId),
    nonce: numberToHex(authorization.nonce),
    ...typeof authorization.yParity !== "undefined" ? { yParity: numberToHex(authorization.yParity) } : {},
    ...typeof authorization.v !== "undefined" && typeof authorization.yParity === "undefined" ? { v: numberToHex(authorization.v) } : {}
  }));
}
var rpcTransactionType, defineTransactionRequest;
var init_transactionRequest = __esm({
  "node_modules/viem/_esm/utils/formatters/transactionRequest.js"() {
    init_toHex();
    init_formatter();
    rpcTransactionType = {
      legacy: "0x0",
      eip2930: "0x1",
      eip1559: "0x2",
      eip4844: "0x3",
      eip7702: "0x4"
    };
    defineTransactionRequest = /* @__PURE__ */ defineFormatter("transactionRequest", formatTransactionRequest);
  }
});

// node_modules/viem/_esm/constants/number.js
var maxUint16, maxUint256;
var init_number = __esm({
  "node_modules/viem/_esm/constants/number.js"() {
    maxUint16 = 2n ** 16n - 1n;
    maxUint256 = 2n ** 256n - 1n;
  }
});

// node_modules/viem/_esm/utils/transaction/assertRequest.js
function assertRequest(args) {
  const { account: account_, gasPrice, maxFeePerGas, maxPriorityFeePerGas, to: to2 } = args;
  const account = account_ ? parseAccount(account_) : void 0;
  if (account && !isAddress(account.address))
    throw new InvalidAddressError({ address: account.address });
  if (to2 && !isAddress(to2))
    throw new InvalidAddressError({ address: to2 });
  if (typeof gasPrice !== "undefined" && (typeof maxFeePerGas !== "undefined" || typeof maxPriorityFeePerGas !== "undefined"))
    throw new FeeConflictError();
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
var init_assertRequest = __esm({
  "node_modules/viem/_esm/utils/transaction/assertRequest.js"() {
    init_parseAccount();
    init_number();
    init_address();
    init_node();
    init_transaction();
    init_isAddress();
  }
});

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
}
function Chi(a, b, c) {
  return a & b ^ ~a & c;
}
function Maj(a, b, c) {
  return a & b ^ a & c ^ b & c;
}
var HashMD;
var init_md = __esm({
  "node_modules/@noble/hashes/esm/_md.js"() {
    init_assert();
    init_utils();
    HashMD = class extends Hash {
      constructor(blockLen, outputLen, padOffset, isLE2) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE2;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = createView(this.buffer);
      }
      update(data) {
        aexists(this);
        const { view, buffer, blockLen } = this;
        data = toBytes2(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = createView(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        aexists(this);
        aoutput(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE: isLE2 } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
        this.process(view, 0);
        const oview = createView(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE2);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to2) {
        to2 || (to2 = new this.constructor());
        to2.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to2.length = length;
        to2.pos = pos;
        to2.finished = finished;
        to2.destroyed = destroyed;
        if (length % blockLen)
          to2.buffer.set(buffer);
        return to2;
      }
    };
  }
});

// node_modules/@noble/hashes/esm/sha256.js
var SHA256_K, SHA256_IV, SHA256_W, SHA256, sha256;
var init_sha256 = __esm({
  "node_modules/@noble/hashes/esm/sha256.js"() {
    init_md();
    init_utils();
    SHA256_K = /* @__PURE__ */ new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    SHA256_IV = /* @__PURE__ */ new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    SHA256_W = /* @__PURE__ */ new Uint32Array(64);
    SHA256 = class extends HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A: A2, B: B2, C, D, E, F, G: G2, H: H2 } = this;
        return [A2, B2, C, D, E, F, G2, H2];
      }
      // prettier-ignore
      set(A2, B2, C, D, E, F, G2, H2) {
        this.A = A2 | 0;
        this.B = B2 | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G2 | 0;
        this.H = H2 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
          const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A: A2, B: B2, C, D, E, F, G: G2, H: H2 } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
          const T1 = H2 + sigma1 + Chi(E, F, G2) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = rotr(A2, 2) ^ rotr(A2, 13) ^ rotr(A2, 22);
          const T2 = sigma0 + Maj(A2, B2, C) | 0;
          H2 = G2;
          G2 = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B2;
          B2 = A2;
          A2 = T1 + T2 | 0;
        }
        A2 = A2 + this.A | 0;
        B2 = B2 + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G2 = G2 + this.G | 0;
        H2 = H2 + this.H | 0;
        this.set(A2, B2, C, D, E, F, G2, H2);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());
  }
});

// node_modules/viem/_esm/errors/chain.js
var InvalidChainIdError;
var init_chain = __esm({
  "node_modules/viem/_esm/errors/chain.js"() {
    init_base();
    InvalidChainIdError = class extends BaseError {
      constructor({ chainId }) {
        super(typeof chainId === "number" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
      }
    };
  }
});

// node_modules/viem/_esm/utils/errors/getCallError.js
function getCallError(err, { docsPath, ...args }) {
  const cause = (() => {
    const cause2 = getNodeError(err, args);
    if (cause2 instanceof UnknownNodeError)
      return err;
    return cause2;
  })();
  return new CallExecutionError(cause, {
    docsPath,
    ...args
  });
}
var init_getCallError = __esm({
  "node_modules/viem/_esm/utils/errors/getCallError.js"() {
    init_contract();
    init_node();
    init_getNodeError();
  }
});

// node_modules/prettier/standalone.js
var require_standalone = __commonJS({
  "node_modules/prettier/standalone.js"(exports, module) {
    (function(t) {
      function e() {
        var o = t();
        return o.default || o;
      }
      if (typeof exports == "object" && typeof module == "object") module.exports = e();
      else if (typeof define == "function" && define.amd) define(e);
      else {
        var f = typeof globalThis < "u" ? globalThis : typeof global < "u" ? global : typeof self < "u" ? self : this || {};
        f.prettier = e();
      }
    })(function() {
      var Au2 = Object.create;
      var Me2 = Object.defineProperty;
      var vu2 = Object.getOwnPropertyDescriptor;
      var Bu2 = Object.getOwnPropertyNames;
      var wu2 = Object.getPrototypeOf, _u2 = Object.prototype.hasOwnProperty;
      var fr2 = (e) => {
        throw TypeError(e);
      };
      var dr2 = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports), vt2 = (e, t) => {
        for (var r in t) Me2(e, r, { get: t[r], enumerable: true });
      }, pr2 = (e, t, r, n) => {
        if (t && typeof t == "object" || typeof t == "function") for (let u of Bu2(t)) !_u2.call(e, u) && u !== r && Me2(e, u, { get: () => t[u], enumerable: !(n = vu2(t, u)) || n.enumerable });
        return e;
      };
      var Ve2 = (e, t, r) => (r = e != null ? Au2(wu2(e)) : {}, pr2(Me2(r, "default", { value: e, enumerable: true }) , e)), xu2 = (e) => pr2(Me2({}, "__esModule", { value: true }), e);
      var bu2 = (e, t, r) => t.has(e) || fr2("Cannot " + r);
      var Fr2 = (e, t, r) => t.has(e) ? fr2("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
      var pe2 = (e, t, r) => (bu2(e, t, "access private method"), r);
      var st2 = dr2((la, mn) => {
        var Fn = new Proxy(String, { get: () => Fn });
        mn.exports = Fn;
      });
      var $n2 = dr2((ur) => {
        Object.defineProperty(ur, "__esModule", { value: true });
        function wi() {
          return new Proxy({}, { get: () => (e) => e });
        }
        var Wn = /\r\n|[\n\r\u2028\u2029]/;
        function _i(e, t, r) {
          let n = Object.assign({ column: 0, line: -1 }, e.start), u = Object.assign({}, n, e.end), { linesAbove: i = 2, linesBelow: o = 3 } = r || {}, s = n.line, a = n.column, D = u.line, l = u.column, p = Math.max(s - (i + 1), 0), f = Math.min(t.length, D + o);
          s === -1 && (p = 0), D === -1 && (f = t.length);
          let d = D - s, c = {};
          if (d) for (let F = 0; F <= d; F++) {
            let m = F + s;
            if (!a) c[m] = true;
            else if (F === 0) {
              let h = t[m - 1].length;
              c[m] = [a, h - a + 1];
            } else if (F === d) c[m] = [0, l];
            else {
              let h = t[m - F].length;
              c[m] = [0, h];
            }
          }
          else a === l ? a ? c[s] = [a, 0] : c[s] = true : c[s] = [a, l - a];
          return { start: p, end: f, markerLines: c };
        }
        function xi(e, t, r = {}) {
          let u = wi(), i = e.split(Wn), { start: o, end: s, markerLines: a } = _i(t, i, r), D = t.start && typeof t.start.column == "number", l = String(s).length, f = e.split(Wn, s).slice(o, s).map((d, c) => {
            let F = o + 1 + c, h = ` ${` ${F}`.slice(-l)} |`, C = a[F], v = !a[F + 1];
            if (C) {
              let E = "";
              if (Array.isArray(C)) {
                let g = d.slice(0, Math.max(C[0] - 1, 0)).replace(/[^\t]/g, " "), j = C[1] || 1;
                E = [`
 `, u.gutter(h.replace(/\d/g, " ")), " ", g, u.marker("^").repeat(j)].join(""), v && r.message && (E += " " + u.message(r.message));
              }
              return [u.marker(">"), u.gutter(h), d.length > 0 ? ` ${d}` : "", E].join("");
            } else return ` ${u.gutter(h)}${d.length > 0 ? ` ${d}` : ""}`;
          }).join(`
`);
          return r.message && !D && (f = `${" ".repeat(l + 1)}${r.message}
${f}`), f;
        }
        ur.codeFrameColumns = xi;
      });
      var co = {};
      vt2(co, { __debug: () => lo2, check: () => ao2, doc: () => Dr2, format: () => yu2, formatWithCursor: () => gu2, getSupportInfo: () => Do2, util: () => cr2, version: () => cu2 });
      var Nu2 = (e, t, r, n) => {
        if (!(e && t == null)) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
      }, ne2 = Nu2;
      function U2() {
      }
      U2.prototype = { diff: function(t, r) {
        var n, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = u.callback;
        typeof u == "function" && (i = u, u = {});
        var o = this;
        function s(E) {
          return E = o.postProcess(E, u), i ? (setTimeout(function() {
            i(E);
          }, 0), true) : E;
        }
        t = this.castInput(t, u), r = this.castInput(r, u), t = this.removeEmpty(this.tokenize(t, u)), r = this.removeEmpty(this.tokenize(r, u));
        var a = r.length, D = t.length, l = 1, p = a + D;
        u.maxEditLength != null && (p = Math.min(p, u.maxEditLength));
        var f = (n = u.timeout) !== null && n !== void 0 ? n : 1 / 0, d = Date.now() + f, c = [{ oldPos: -1, lastComponent: void 0 }], F = this.extractCommon(c[0], r, t, 0, u);
        if (c[0].oldPos + 1 >= D && F + 1 >= a) return s(mr2(o, c[0].lastComponent, r, t, o.useLongestToken));
        var m = -1 / 0, h = 1 / 0;
        function C() {
          for (var E = Math.max(m, -l); E <= Math.min(h, l); E += 2) {
            var g = void 0, j = c[E - 1], b = c[E + 1];
            j && (c[E - 1] = void 0);
            var X = false;
            if (b) {
              var ae = b.oldPos - E;
              X = b && 0 <= ae && ae < a;
            }
            var $e = j && j.oldPos + 1 < D;
            if (!X && !$e) {
              c[E] = void 0;
              continue;
            }
            if (!$e || X && j.oldPos < b.oldPos ? g = o.addToPath(b, true, false, 0, u) : g = o.addToPath(j, false, true, 1, u), F = o.extractCommon(g, r, t, E, u), g.oldPos + 1 >= D && F + 1 >= a) return s(mr2(o, g.lastComponent, r, t, o.useLongestToken));
            c[E] = g, g.oldPos + 1 >= D && (h = Math.min(h, E - 1)), F + 1 >= a && (m = Math.max(m, E + 1));
          }
          l++;
        }
        if (i) (function E() {
          setTimeout(function() {
            if (l > p || Date.now() > d) return i();
            C() || E();
          }, 0);
        })();
        else for (; l <= p && Date.now() <= d; ) {
          var v = C();
          if (v) return v;
        }
      }, addToPath: function(t, r, n, u, i) {
        var o = t.lastComponent;
        return o && !i.oneChangePerToken && o.added === r && o.removed === n ? { oldPos: t.oldPos + u, lastComponent: { count: o.count + 1, added: r, removed: n, previousComponent: o.previousComponent } } : { oldPos: t.oldPos + u, lastComponent: { count: 1, added: r, removed: n, previousComponent: o } };
      }, extractCommon: function(t, r, n, u, i) {
        for (var o = r.length, s = n.length, a = t.oldPos, D = a - u, l = 0; D + 1 < o && a + 1 < s && this.equals(n[a + 1], r[D + 1], i); ) D++, a++, l++, i.oneChangePerToken && (t.lastComponent = { count: 1, previousComponent: t.lastComponent, added: false, removed: false });
        return l && !i.oneChangePerToken && (t.lastComponent = { count: l, previousComponent: t.lastComponent, added: false, removed: false }), t.oldPos = a, D;
      }, equals: function(t, r, n) {
        return n.comparator ? n.comparator(t, r) : t === r || n.ignoreCase && t.toLowerCase() === r.toLowerCase();
      }, removeEmpty: function(t) {
        for (var r = [], n = 0; n < t.length; n++) t[n] && r.push(t[n]);
        return r;
      }, castInput: function(t) {
        return t;
      }, tokenize: function(t) {
        return Array.from(t);
      }, join: function(t) {
        return t.join("");
      }, postProcess: function(t) {
        return t;
      } };
      function mr2(e, t, r, n, u) {
        for (var i = [], o; t; ) i.push(t), o = t.previousComponent, delete t.previousComponent, t = o;
        i.reverse();
        for (var s = 0, a = i.length, D = 0, l = 0; s < a; s++) {
          var p = i[s];
          if (p.removed) p.value = e.join(n.slice(l, l + p.count)), l += p.count;
          else {
            if (!p.added && u) {
              var f = r.slice(D, D + p.count);
              f = f.map(function(d, c) {
                var F = n[l + c];
                return F.length > d.length ? F : d;
              }), p.value = e.join(f);
            } else p.value = e.join(r.slice(D, D + p.count));
            D += p.count, p.added || (l += p.count);
          }
        }
        return i;
      }
      function hr2(e, t) {
        var r;
        for (r = 0; r < e.length && r < t.length; r++) if (e[r] != t[r]) return e.slice(0, r);
        return e.slice(0, r);
      }
      function Er2(e, t) {
        var r;
        if (!e || !t || e[e.length - 1] != t[t.length - 1]) return "";
        for (r = 0; r < e.length && r < t.length; r++) if (e[e.length - (r + 1)] != t[t.length - (r + 1)]) return e.slice(-r);
        return e.slice(-r);
      }
      function Bt2(e, t, r) {
        if (e.slice(0, t.length) != t) throw Error("string ".concat(JSON.stringify(e), " doesn't start with prefix ").concat(JSON.stringify(t), "; this is a bug"));
        return r + e.slice(t.length);
      }
      function wt2(e, t, r) {
        if (!t) return e + r;
        if (e.slice(-t.length) != t) throw Error("string ".concat(JSON.stringify(e), " doesn't end with suffix ").concat(JSON.stringify(t), "; this is a bug"));
        return e.slice(0, -t.length) + r;
      }
      function _e2(e, t) {
        return Bt2(e, t, "");
      }
      function Ue2(e, t) {
        return wt2(e, t, "");
      }
      function Cr2(e, t) {
        return t.slice(0, Ou2(e, t));
      }
      function Ou2(e, t) {
        var r = 0;
        e.length > t.length && (r = e.length - t.length);
        var n = t.length;
        e.length < t.length && (n = e.length);
        var u = Array(n), i = 0;
        u[0] = 0;
        for (var o = 1; o < n; o++) {
          for (t[o] == t[i] ? u[o] = u[i] : u[o] = i; i > 0 && t[o] != t[i]; ) i = u[i];
          t[o] == t[i] && i++;
        }
        i = 0;
        for (var s = r; s < e.length; s++) {
          for (; i > 0 && e[s] != t[i]; ) i = u[i];
          e[s] == t[i] && i++;
        }
        return i;
      }
      var ze2 = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}", Su2 = new RegExp("[".concat(ze2, "]+|\\s+|[^").concat(ze2, "]"), "ug"), Ke2 = new U2();
      Ke2.equals = function(e, t, r) {
        return r.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e.trim() === t.trim();
      };
      Ke2.tokenize = function(e) {
        var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r;
        if (t.intlSegmenter) {
          if (t.intlSegmenter.resolvedOptions().granularity != "word") throw new Error('The segmenter passed must have a granularity of "word"');
          r = Array.from(t.intlSegmenter.segment(e), function(i) {
            return i.segment;
          });
        } else r = e.match(Su2) || [];
        var n = [], u = null;
        return r.forEach(function(i) {
          /\s/.test(i) ? u == null ? n.push(i) : n.push(n.pop() + i) : /\s/.test(u) ? n[n.length - 1] == u ? n.push(n.pop() + i) : n.push(u + i) : n.push(i), u = i;
        }), n;
      };
      Ke2.join = function(e) {
        return e.map(function(t, r) {
          return r == 0 ? t : t.replace(/^\s+/, "");
        }).join("");
      };
      Ke2.postProcess = function(e, t) {
        if (!e || t.oneChangePerToken) return e;
        var r = null, n = null, u = null;
        return e.forEach(function(i) {
          i.added ? n = i : i.removed ? u = i : ((n || u) && gr2(r, u, n, i), r = i, n = null, u = null);
        }), (n || u) && gr2(r, u, n, null), e;
      };
      function gr2(e, t, r, n) {
        if (t && r) {
          var u = t.value.match(/^\s*/)[0], i = t.value.match(/\s*$/)[0], o = r.value.match(/^\s*/)[0], s = r.value.match(/\s*$/)[0];
          if (e) {
            var a = hr2(u, o);
            e.value = wt2(e.value, o, a), t.value = _e2(t.value, a), r.value = _e2(r.value, a);
          }
          if (n) {
            var D = Er2(i, s);
            n.value = Bt2(n.value, s, D), t.value = Ue2(t.value, D), r.value = Ue2(r.value, D);
          }
        } else if (r) e && (r.value = r.value.replace(/^\s*/, "")), n && (n.value = n.value.replace(/^\s*/, ""));
        else if (e && n) {
          var l = n.value.match(/^\s*/)[0], p = t.value.match(/^\s*/)[0], f = t.value.match(/\s*$/)[0], d = hr2(l, p);
          t.value = _e2(t.value, d);
          var c = Er2(_e2(l, d), f);
          t.value = Ue2(t.value, c), n.value = Bt2(n.value, l, c), e.value = wt2(e.value, l, l.slice(0, l.length - c.length));
        } else if (n) {
          var F = n.value.match(/^\s*/)[0], m = t.value.match(/\s*$/)[0], h = Cr2(m, F);
          t.value = Ue2(t.value, h);
        } else if (e) {
          var C = e.value.match(/\s*$/)[0], v = t.value.match(/^\s*/)[0], E = Cr2(C, v);
          t.value = _e2(t.value, E);
        }
      }
      var Tu2 = new U2();
      Tu2.tokenize = function(e) {
        var t = new RegExp("(\\r?\\n)|[".concat(ze2, "]+|[^\\S\\n\\r]+|[^").concat(ze2, "]"), "ug");
        return e.match(t) || [];
      };
      var bt2 = new U2();
      bt2.tokenize = function(e, t) {
        t.stripTrailingCr && (e = e.replace(/\r\n/g, `
`));
        var r = [], n = e.split(/(\n|\r\n)/);
        n[n.length - 1] || n.pop();
        for (var u = 0; u < n.length; u++) {
          var i = n[u];
          u % 2 && !t.newlineIsToken ? r[r.length - 1] += i : r.push(i);
        }
        return r;
      };
      bt2.equals = function(e, t, r) {
        return r.ignoreWhitespace ? ((!r.newlineIsToken || !e.includes(`
`)) && (e = e.trim()), (!r.newlineIsToken || !t.includes(`
`)) && (t = t.trim())) : r.ignoreNewlineAtEof && !r.newlineIsToken && (e.endsWith(`
`) && (e = e.slice(0, -1)), t.endsWith(`
`) && (t = t.slice(0, -1))), U2.prototype.equals.call(this, e, t, r);
      };
      var ku2 = new U2();
      ku2.tokenize = function(e) {
        return e.split(/(\S.+?[.!?])(?=\s+|$)/);
      };
      var Lu2 = new U2();
      Lu2.tokenize = function(e) {
        return e.split(/([{}:;,]|\s+)/);
      };
      function _t2(e) {
        "@babel/helpers - typeof";
        return _t2 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
          return typeof t;
        } : function(t) {
          return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
        }, _t2(e);
      }
      var xe2 = new U2();
      xe2.useLongestToken = true;
      xe2.tokenize = bt2.tokenize;
      xe2.castInput = function(e, t) {
        var r = t.undefinedReplacement, n = t.stringifyReplacer, u = n === void 0 ? function(i, o) {
          return typeof o > "u" ? r : o;
        } : n;
        return typeof e == "string" ? e : JSON.stringify(xt2(e, null, null, u), u, "  ");
      };
      xe2.equals = function(e, t, r) {
        return U2.prototype.equals.call(xe2, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"), r);
      };
      function xt2(e, t, r, n, u) {
        t = t || [], r = r || [], n && (e = n(u, e));
        var i;
        for (i = 0; i < t.length; i += 1) if (t[i] === e) return r[i];
        var o;
        if (Object.prototype.toString.call(e) === "[object Array]") {
          for (t.push(e), o = new Array(e.length), r.push(o), i = 0; i < e.length; i += 1) o[i] = xt2(e[i], t, r, n, u);
          return t.pop(), r.pop(), o;
        }
        if (e && e.toJSON && (e = e.toJSON()), _t2(e) === "object" && e !== null) {
          t.push(e), o = {}, r.push(o);
          var s = [], a;
          for (a in e) Object.prototype.hasOwnProperty.call(e, a) && s.push(a);
          for (s.sort(), i = 0; i < s.length; i += 1) a = s[i], o[a] = xt2(e[a], t, r, n, a);
          t.pop(), r.pop();
        } else o = e;
        return o;
      }
      var Ge2 = new U2();
      Ge2.tokenize = function(e) {
        return e.slice();
      };
      Ge2.join = Ge2.removeEmpty = function(e) {
        return e;
      };
      function yr2(e, t, r) {
        return Ge2.diff(e, t, r);
      }
      function Ar2(e) {
        let t = e.indexOf("\r");
        return t !== -1 ? e.charAt(t + 1) === `
` ? "crlf" : "cr" : "lf";
      }
      function be2(e) {
        switch (e) {
          case "cr":
            return "\r";
          case "crlf":
            return `\r
`;
          default:
            return `
`;
        }
      }
      function Nt2(e, t) {
        let r;
        switch (t) {
          case `
`:
            r = /\n/gu;
            break;
          case "\r":
            r = /\r/gu;
            break;
          case `\r
`:
            r = /\r\n/gu;
            break;
          default:
            throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
        }
        let n = e.match(r);
        return n ? n.length : 0;
      }
      function vr2(e) {
        return ne2(false, e, /\r\n?/gu, `
`);
      }
      var $2 = "string", H2 = "array", z2 = "cursor", T2 = "indent", k2 = "align", L2 = "trim", B2 = "group", N2 = "fill", w2 = "if-break", P2 = "indent-if-break", I2 = "line-suffix", R2 = "line-suffix-boundary", y2 = "line", O2 = "label", _2 = "break-parent", Je2 = /* @__PURE__ */ new Set([z2, T2, k2, L2, B2, N2, w2, P2, I2, R2, y2, O2, _2]);
      var Pu2 = (e, t, r) => {
        if (!(e && t == null)) return Array.isArray(t) || typeof t == "string" ? t[r < 0 ? t.length + r : r] : t.at(r);
      }, A2 = Pu2;
      function Iu2(e) {
        if (typeof e == "string") return $2;
        if (Array.isArray(e)) return H2;
        if (!e) return;
        let { type: t } = e;
        if (Je2.has(t)) return t;
      }
      var M2 = Iu2;
      var Ru2 = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
      function Yu2(e) {
        let t = e === null ? "null" : typeof e;
        if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
        if (M2(e)) throw new Error("doc is valid.");
        let r = Object.prototype.toString.call(e);
        if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
        let n = Ru2([...Je2].map((u) => `'${u}'`));
        return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
      }
      var Ot2 = class extends Error {
        constructor(t) {
          super(Yu2(t));
          __publicField(this, "name", "InvalidDocError");
          this.doc = t;
        }
      }, Q2 = Ot2;
      var Br2 = {};
      function ju2(e, t, r, n) {
        let u = [e];
        for (; u.length > 0; ) {
          let i = u.pop();
          if (i === Br2) {
            r(u.pop());
            continue;
          }
          r && u.push(i, Br2);
          let o = M2(i);
          if (!o) throw new Q2(i);
          if ((t == null ? void 0 : t(i)) !== false) switch (o) {
            case H2:
            case N2: {
              let s = o === H2 ? i : i.parts;
              for (let a = s.length, D = a - 1; D >= 0; --D) u.push(s[D]);
              break;
            }
            case w2:
              u.push(i.flatContents, i.breakContents);
              break;
            case B2:
              if (n && i.expandedStates) for (let s = i.expandedStates.length, a = s - 1; a >= 0; --a) u.push(i.expandedStates[a]);
              else u.push(i.contents);
              break;
            case k2:
            case T2:
            case P2:
            case O2:
            case I2:
              u.push(i.contents);
              break;
            case $2:
            case z2:
            case L2:
            case R2:
            case y2:
            case _2:
              break;
            default:
              throw new Q2(i);
          }
        }
      }
      var Fe2 = ju2;
      function Oe2(e, t) {
        if (typeof e == "string") return t(e);
        let r = /* @__PURE__ */ new Map();
        return n(e);
        function n(i) {
          if (r.has(i)) return r.get(i);
          let o = u(i);
          return r.set(i, o), o;
        }
        function u(i) {
          switch (M2(i)) {
            case H2:
              return t(i.map(n));
            case N2:
              return t({ ...i, parts: i.parts.map(n) });
            case w2:
              return t({ ...i, breakContents: n(i.breakContents), flatContents: n(i.flatContents) });
            case B2: {
              let { expandedStates: o, contents: s } = i;
              return o ? (o = o.map(n), s = o[0]) : s = n(s), t({ ...i, contents: s, expandedStates: o });
            }
            case k2:
            case T2:
            case P2:
            case O2:
            case I2:
              return t({ ...i, contents: n(i.contents) });
            case $2:
            case z2:
            case L2:
            case R2:
            case y2:
            case _2:
              return t(i);
            default:
              throw new Q2(i);
          }
        }
      }
      function qe2(e, t, r) {
        let n = r, u = false;
        function i(o) {
          if (u) return false;
          let s = t(o);
          s !== void 0 && (u = true, n = s);
        }
        return Fe2(e, i), n;
      }
      function Hu2(e) {
        if (e.type === B2 && e.break || e.type === y2 && e.hard || e.type === _2) return true;
      }
      function xr2(e) {
        return qe2(e, Hu2, false);
      }
      function wr2(e) {
        if (e.length > 0) {
          let t = A2(false, e, -1);
          !t.expandedStates && !t.break && (t.break = "propagated");
        }
        return null;
      }
      function br2(e) {
        let t = /* @__PURE__ */ new Set(), r = [];
        function n(i) {
          if (i.type === _2 && wr2(r), i.type === B2) {
            if (r.push(i), t.has(i)) return false;
            t.add(i);
          }
        }
        function u(i) {
          i.type === B2 && r.pop().break && wr2(r);
        }
        Fe2(e, n, u, true);
      }
      function Wu2(e) {
        return e.type === y2 && !e.hard ? e.soft ? "" : " " : e.type === w2 ? e.flatContents : e;
      }
      function Nr2(e) {
        return Oe2(e, Wu2);
      }
      function _r2(e) {
        for (e = [...e]; e.length >= 2 && A2(false, e, -2).type === y2 && A2(false, e, -1).type === _2; ) e.length -= 2;
        if (e.length > 0) {
          let t = Ne2(A2(false, e, -1));
          e[e.length - 1] = t;
        }
        return e;
      }
      function Ne2(e) {
        switch (M2(e)) {
          case T2:
          case P2:
          case B2:
          case I2:
          case O2: {
            let t = Ne2(e.contents);
            return { ...e, contents: t };
          }
          case w2:
            return { ...e, breakContents: Ne2(e.breakContents), flatContents: Ne2(e.flatContents) };
          case N2:
            return { ...e, parts: _r2(e.parts) };
          case H2:
            return _r2(e);
          case $2:
            return e.replace(/[\n\r]*$/u, "");
          case k2:
          case z2:
          case L2:
          case R2:
          case y2:
          case _2:
            break;
          default:
            throw new Q2(e);
        }
        return e;
      }
      function Xe2(e) {
        return Ne2(Mu2(e));
      }
      function $u2(e) {
        switch (M2(e)) {
          case N2:
            if (e.parts.every((t) => t === "")) return "";
            break;
          case B2:
            if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
            if (e.contents.type === B2 && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
            break;
          case k2:
          case T2:
          case P2:
          case I2:
            if (!e.contents) return "";
            break;
          case w2:
            if (!e.flatContents && !e.breakContents) return "";
            break;
          case H2: {
            let t = [];
            for (let r of e) {
              if (!r) continue;
              let [n, ...u] = Array.isArray(r) ? r : [r];
              typeof n == "string" && typeof A2(false, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...u);
            }
            return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
          }
          case $2:
          case z2:
          case L2:
          case R2:
          case y2:
          case O2:
          case _2:
            break;
          default:
            throw new Q2(e);
        }
        return e;
      }
      function Mu2(e) {
        return Oe2(e, (t) => $u2(t));
      }
      function Or2(e, t = Qe2) {
        return Oe2(e, (r) => typeof r == "string" ? Se2(t, r.split(`
`)) : r);
      }
      function Vu2(e) {
        if (e.type === y2) return true;
      }
      function Sr2(e) {
        return qe2(e, Vu2, false);
      }
      function me2(e, t) {
        return e.type === O2 ? { ...e, contents: t(e.contents) } : t(e);
      }
      var St2 = () => {
      }, Tt2 = St2;
      function le2(e) {
        return { type: T2, contents: e };
      }
      function De2(e, t) {
        return { type: k2, contents: t, n: e };
      }
      function kt2(e, t = {}) {
        return Tt2(t.expandedStates), { type: B2, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
      }
      function kr2(e) {
        return De2(Number.NEGATIVE_INFINITY, e);
      }
      function Lr2(e) {
        return De2({ type: "root" }, e);
      }
      function Pr2(e) {
        return De2(-1, e);
      }
      function Ir2(e, t) {
        return kt2(e[0], { ...t, expandedStates: e });
      }
      function Rr2(e) {
        return { type: N2, parts: e };
      }
      function Yr2(e, t = "", r = {}) {
        return { type: w2, breakContents: e, flatContents: t, groupId: r.groupId };
      }
      function jr2(e, t) {
        return { type: P2, contents: e, groupId: t.groupId, negate: t.negate };
      }
      function Te2(e) {
        return { type: I2, contents: e };
      }
      var Hr2 = { type: R2 }, he2 = { type: _2 }, Wr2 = { type: L2 }, ke2 = { type: y2, hard: true }, Lt2 = { type: y2, hard: true, literal: true }, Ze2 = { type: y2 }, $r2 = { type: y2, soft: true }, K2 = [ke2, he2], Qe2 = [Lt2, he2], Z2 = { type: z2 };
      function Se2(e, t) {
        let r = [];
        for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
        return r;
      }
      function et2(e, t, r) {
        let n = e;
        if (t > 0) {
          for (let u = 0; u < Math.floor(t / r); ++u) n = le2(n);
          n = De2(t % r, n), n = De2(Number.NEGATIVE_INFINITY, n);
        }
        return n;
      }
      function Mr2(e, t) {
        return e ? { type: O2, label: e, contents: t } : t;
      }
      function ee2(e) {
        var t;
        if (!e) return "";
        if (Array.isArray(e)) {
          let r = [];
          for (let n of e) if (Array.isArray(n)) r.push(...ee2(n));
          else {
            let u = ee2(n);
            u !== "" && r.push(u);
          }
          return r;
        }
        return e.type === w2 ? { ...e, breakContents: ee2(e.breakContents), flatContents: ee2(e.flatContents) } : e.type === B2 ? { ...e, contents: ee2(e.contents), expandedStates: (t = e.expandedStates) == null ? void 0 : t.map(ee2) } : e.type === N2 ? { type: "fill", parts: e.parts.map(ee2) } : e.contents ? { ...e, contents: ee2(e.contents) } : e;
      }
      function Vr2(e) {
        let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
        return n(ee2(e));
        function n(i, o, s) {
          var a, D;
          if (typeof i == "string") return JSON.stringify(i);
          if (Array.isArray(i)) {
            let l = i.map(n).filter(Boolean);
            return l.length === 1 ? l[0] : `[${l.join(", ")}]`;
          }
          if (i.type === y2) {
            let l = ((a = s == null ? void 0 : s[o + 1]) == null ? void 0 : a.type) === _2;
            return i.literal ? l ? "literalline" : "literallineWithoutBreakParent" : i.hard ? l ? "hardline" : "hardlineWithoutBreakParent" : i.soft ? "softline" : "line";
          }
          if (i.type === _2) return ((D = s == null ? void 0 : s[o - 1]) == null ? void 0 : D.type) === y2 && s[o - 1].hard ? void 0 : "breakParent";
          if (i.type === L2) return "trim";
          if (i.type === T2) return "indent(" + n(i.contents) + ")";
          if (i.type === k2) return i.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(i.contents) + ")" : i.n < 0 ? "dedent(" + n(i.contents) + ")" : i.n.type === "root" ? "markAsRoot(" + n(i.contents) + ")" : "align(" + JSON.stringify(i.n) + ", " + n(i.contents) + ")";
          if (i.type === w2) return "ifBreak(" + n(i.breakContents) + (i.flatContents ? ", " + n(i.flatContents) : "") + (i.groupId ? (i.flatContents ? "" : ', ""') + `, { groupId: ${u(i.groupId)} }` : "") + ")";
          if (i.type === P2) {
            let l = [];
            i.negate && l.push("negate: true"), i.groupId && l.push(`groupId: ${u(i.groupId)}`);
            let p = l.length > 0 ? `, { ${l.join(", ")} }` : "";
            return `indentIfBreak(${n(i.contents)}${p})`;
          }
          if (i.type === B2) {
            let l = [];
            i.break && i.break !== "propagated" && l.push("shouldBreak: true"), i.id && l.push(`id: ${u(i.id)}`);
            let p = l.length > 0 ? `, { ${l.join(", ")} }` : "";
            return i.expandedStates ? `conditionalGroup([${i.expandedStates.map((f) => n(f)).join(",")}]${p})` : `group(${n(i.contents)}${p})`;
          }
          if (i.type === N2) return `fill([${i.parts.map((l) => n(l)).join(", ")}])`;
          if (i.type === I2) return "lineSuffix(" + n(i.contents) + ")";
          if (i.type === R2) return "lineSuffixBoundary";
          if (i.type === O2) return `label(${JSON.stringify(i.label)}, ${n(i.contents)})`;
          throw new Error("Unknown doc type " + i.type);
        }
        function u(i) {
          if (typeof i != "symbol") return JSON.stringify(String(i));
          if (i in t) return t[i];
          let o = i.description || "symbol";
          for (let s = 0; ; s++) {
            let a = o + (s > 0 ? ` #${s}` : "");
            if (!r.has(a)) return r.add(a), t[i] = `Symbol.for(${JSON.stringify(a)})`;
          }
        }
      }
      var Ur2 = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
      function zr2(e) {
        return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
      }
      function Gr2(e) {
        return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101631 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129673 || e >= 129679 && e <= 129734 || e >= 129742 && e <= 129756 || e >= 129759 && e <= 129769 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
      }
      var Kr2 = (e) => !(zr2(e) || Gr2(e));
      var Uu2 = /[^\x20-\x7F]/u;
      function zu2(e) {
        if (!e) return 0;
        if (!Uu2.test(e)) return e.length;
        e = e.replace(Ur2(), "  ");
        let t = 0;
        for (let r of e) {
          let n = r.codePointAt(0);
          n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t += Kr2(n) ? 1 : 2);
        }
        return t;
      }
      var Le2 = zu2;
      var Y2 = Symbol("MODE_BREAK"), J2 = Symbol("MODE_FLAT"), Ee2 = Symbol("cursor"), Pt2 = Symbol("DOC_FILL_PRINTED_LENGTH");
      function Jr2() {
        return { value: "", length: 0, queue: [] };
      }
      function Gu2(e, t) {
        return It2(e, { type: "indent" }, t);
      }
      function Ku2(e, t, r) {
        return t === Number.NEGATIVE_INFINITY ? e.root || Jr2() : t < 0 ? It2(e, { type: "dedent" }, r) : t ? t.type === "root" ? { ...e, root: e } : It2(e, { type: typeof t == "string" ? "stringAlign" : "numberAlign", n: t }, r) : e;
      }
      function It2(e, t, r) {
        let n = t.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t], u = "", i = 0, o = 0, s = 0;
        for (let c of n) switch (c.type) {
          case "indent":
            l(), r.useTabs ? a(1) : D(r.tabWidth);
            break;
          case "stringAlign":
            l(), u += c.n, i += c.n.length;
            break;
          case "numberAlign":
            o += 1, s += c.n;
            break;
          default:
            throw new Error(`Unexpected type '${c.type}'`);
        }
        return f(), { ...e, value: u, length: i, queue: n };
        function a(c) {
          u += "	".repeat(c), i += r.tabWidth * c;
        }
        function D(c) {
          u += " ".repeat(c), i += c;
        }
        function l() {
          r.useTabs ? p() : f();
        }
        function p() {
          o > 0 && a(o), d();
        }
        function f() {
          s > 0 && D(s), d();
        }
        function d() {
          o = 0, s = 0;
        }
      }
      function Rt2(e) {
        let t = 0, r = 0, n = e.length;
        e: for (; n--; ) {
          let u = e[n];
          if (u === Ee2) {
            r++;
            continue;
          }
          for (let i = u.length - 1; i >= 0; i--) {
            let o = u[i];
            if (o === " " || o === "	") t++;
            else {
              e[n] = u.slice(0, i + 1);
              break e;
            }
          }
        }
        if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Ee2);
        return t;
      }
      function tt2(e, t, r, n, u, i) {
        if (r === Number.POSITIVE_INFINITY) return true;
        let o = t.length, s = [e], a = [];
        for (; r >= 0; ) {
          if (s.length === 0) {
            if (o === 0) return true;
            s.push(t[--o]);
            continue;
          }
          let { mode: D, doc: l } = s.pop(), p = M2(l);
          switch (p) {
            case $2:
              a.push(l), r -= Le2(l);
              break;
            case H2:
            case N2: {
              let f = p === H2 ? l : l.parts, d = l[Pt2] ?? 0;
              for (let c = f.length - 1; c >= d; c--) s.push({ mode: D, doc: f[c] });
              break;
            }
            case T2:
            case k2:
            case P2:
            case O2:
              s.push({ mode: D, doc: l.contents });
              break;
            case L2:
              r += Rt2(a);
              break;
            case B2: {
              if (i && l.break) return false;
              let f = l.break ? Y2 : D, d = l.expandedStates && f === Y2 ? A2(false, l.expandedStates, -1) : l.contents;
              s.push({ mode: f, doc: d });
              break;
            }
            case w2: {
              let d = (l.groupId ? u[l.groupId] || J2 : D) === Y2 ? l.breakContents : l.flatContents;
              d && s.push({ mode: D, doc: d });
              break;
            }
            case y2:
              if (D === Y2 || l.hard) return true;
              l.soft || (a.push(" "), r--);
              break;
            case I2:
              n = true;
              break;
            case R2:
              if (n) return false;
              break;
          }
        }
        return false;
      }
      function Ce2(e, t) {
        let r = {}, n = t.printWidth, u = be2(t.endOfLine), i = 0, o = [{ ind: Jr2(), mode: Y2, doc: e }], s = [], a = false, D = [], l = 0;
        for (br2(e); o.length > 0; ) {
          let { ind: f, mode: d, doc: c } = o.pop();
          switch (M2(c)) {
            case $2: {
              let F = u !== `
` ? ne2(false, c, `
`, u) : c;
              s.push(F), o.length > 0 && (i += Le2(F));
              break;
            }
            case H2:
              for (let F = c.length - 1; F >= 0; F--) o.push({ ind: f, mode: d, doc: c[F] });
              break;
            case z2:
              if (l >= 2) throw new Error("There are too many 'cursor' in doc.");
              s.push(Ee2), l++;
              break;
            case T2:
              o.push({ ind: Gu2(f, t), mode: d, doc: c.contents });
              break;
            case k2:
              o.push({ ind: Ku2(f, c.n, t), mode: d, doc: c.contents });
              break;
            case L2:
              i -= Rt2(s);
              break;
            case B2:
              switch (d) {
                case J2:
                  if (!a) {
                    o.push({ ind: f, mode: c.break ? Y2 : J2, doc: c.contents });
                    break;
                  }
                case Y2: {
                  a = false;
                  let F = { ind: f, mode: J2, doc: c.contents }, m = n - i, h = D.length > 0;
                  if (!c.break && tt2(F, o, m, h, r)) o.push(F);
                  else if (c.expandedStates) {
                    let C = A2(false, c.expandedStates, -1);
                    if (c.break) {
                      o.push({ ind: f, mode: Y2, doc: C });
                      break;
                    } else for (let v = 1; v < c.expandedStates.length + 1; v++) if (v >= c.expandedStates.length) {
                      o.push({ ind: f, mode: Y2, doc: C });
                      break;
                    } else {
                      let E = c.expandedStates[v], g = { ind: f, mode: J2, doc: E };
                      if (tt2(g, o, m, h, r)) {
                        o.push(g);
                        break;
                      }
                    }
                  } else o.push({ ind: f, mode: Y2, doc: c.contents });
                  break;
                }
              }
              c.id && (r[c.id] = A2(false, o, -1).mode);
              break;
            case N2: {
              let F = n - i, m = c[Pt2] ?? 0, { parts: h } = c, C = h.length - m;
              if (C === 0) break;
              let v = h[m + 0], E = h[m + 1], g = { ind: f, mode: J2, doc: v }, j = { ind: f, mode: Y2, doc: v }, b = tt2(g, [], F, D.length > 0, r, true);
              if (C === 1) {
                b ? o.push(g) : o.push(j);
                break;
              }
              let X = { ind: f, mode: J2, doc: E }, ae = { ind: f, mode: Y2, doc: E };
              if (C === 2) {
                b ? o.push(X, g) : o.push(ae, j);
                break;
              }
              let $e = h[m + 2], At2 = { ind: f, mode: d, doc: { ...c, [Pt2]: m + 2 } };
              tt2({ ind: f, mode: J2, doc: [v, E, $e] }, [], F, D.length > 0, r, true) ? o.push(At2, X, g) : b ? o.push(At2, ae, g) : o.push(At2, ae, j);
              break;
            }
            case w2:
            case P2: {
              let F = c.groupId ? r[c.groupId] : d;
              if (F === Y2) {
                let m = c.type === w2 ? c.breakContents : c.negate ? c.contents : le2(c.contents);
                m && o.push({ ind: f, mode: d, doc: m });
              }
              if (F === J2) {
                let m = c.type === w2 ? c.flatContents : c.negate ? le2(c.contents) : c.contents;
                m && o.push({ ind: f, mode: d, doc: m });
              }
              break;
            }
            case I2:
              D.push({ ind: f, mode: d, doc: c.contents });
              break;
            case R2:
              D.length > 0 && o.push({ ind: f, mode: d, doc: ke2 });
              break;
            case y2:
              switch (d) {
                case J2:
                  if (c.hard) a = true;
                  else {
                    c.soft || (s.push(" "), i += 1);
                    break;
                  }
                case Y2:
                  if (D.length > 0) {
                    o.push({ ind: f, mode: d, doc: c }, ...D.reverse()), D.length = 0;
                    break;
                  }
                  c.literal ? f.root ? (s.push(u, f.root.value), i = f.root.length) : (s.push(u), i = 0) : (i -= Rt2(s), s.push(u + f.value), i = f.length);
                  break;
              }
              break;
            case O2:
              o.push({ ind: f, mode: d, doc: c.contents });
              break;
            case _2:
              break;
            default:
              throw new Q2(c);
          }
          o.length === 0 && D.length > 0 && (o.push(...D.reverse()), D.length = 0);
        }
        let p = s.indexOf(Ee2);
        if (p !== -1) {
          let f = s.indexOf(Ee2, p + 1);
          if (f === -1) return { formatted: s.filter((m) => m !== Ee2).join("") };
          let d = s.slice(0, p).join(""), c = s.slice(p + 1, f).join(""), F = s.slice(f + 1).join("");
          return { formatted: d + c + F, cursorNodeStart: d.length, cursorNodeText: c };
        }
        return { formatted: s.join("") };
      }
      function Ju2(e, t, r = 0) {
        let n = 0;
        for (let u = r; u < e.length; ++u) e[u] === "	" ? n = n + t - n % t : n++;
        return n;
      }
      var ge2 = Ju2;
      var te2, jt2, rt2, Yt2 = class {
        constructor(t) {
          Fr2(this, te2);
          this.stack = [t];
        }
        get key() {
          let { stack: t, siblings: r } = this;
          return A2(false, t, r === null ? -2 : -4) ?? null;
        }
        get index() {
          return this.siblings === null ? null : A2(false, this.stack, -2);
        }
        get node() {
          return A2(false, this.stack, -1);
        }
        get parent() {
          return this.getNode(1);
        }
        get grandparent() {
          return this.getNode(2);
        }
        get isInArray() {
          return this.siblings !== null;
        }
        get siblings() {
          let { stack: t } = this, r = A2(false, t, -3);
          return Array.isArray(r) ? r : null;
        }
        get next() {
          let { siblings: t } = this;
          return t === null ? null : t[this.index + 1];
        }
        get previous() {
          let { siblings: t } = this;
          return t === null ? null : t[this.index - 1];
        }
        get isFirst() {
          return this.index === 0;
        }
        get isLast() {
          let { siblings: t, index: r } = this;
          return t !== null && r === t.length - 1;
        }
        get isRoot() {
          return this.stack.length === 1;
        }
        get root() {
          return this.stack[0];
        }
        get ancestors() {
          return [...pe2(this, te2, rt2).call(this)];
        }
        getName() {
          let { stack: t } = this, { length: r } = t;
          return r > 1 ? A2(false, t, -2) : null;
        }
        getValue() {
          return A2(false, this.stack, -1);
        }
        getNode(t = 0) {
          let r = pe2(this, te2, jt2).call(this, t);
          return r === -1 ? null : this.stack[r];
        }
        getParentNode(t = 0) {
          return this.getNode(t + 1);
        }
        call(t, ...r) {
          let { stack: n } = this, { length: u } = n, i = A2(false, n, -1);
          for (let o of r) i = i[o], n.push(o, i);
          try {
            return t(this);
          } finally {
            n.length = u;
          }
        }
        callParent(t, r = 0) {
          let n = pe2(this, te2, jt2).call(this, r + 1), u = this.stack.splice(n + 1);
          try {
            return t(this);
          } finally {
            this.stack.push(...u);
          }
        }
        each(t, ...r) {
          let { stack: n } = this, { length: u } = n, i = A2(false, n, -1);
          for (let o of r) i = i[o], n.push(o, i);
          try {
            for (let o = 0; o < i.length; ++o) n.push(o, i[o]), t(this, o, i), n.length -= 2;
          } finally {
            n.length = u;
          }
        }
        map(t, ...r) {
          let n = [];
          return this.each((u, i, o) => {
            n[i] = t(u, i, o);
          }, ...r), n;
        }
        match(...t) {
          let r = this.stack.length - 1, n = null, u = this.stack[r--];
          for (let i of t) {
            if (u === void 0) return false;
            let o = null;
            if (typeof n == "number" && (o = n, n = this.stack[r--], u = this.stack[r--]), i && !i(u, n, o)) return false;
            n = this.stack[r--], u = this.stack[r--];
          }
          return true;
        }
        findAncestor(t) {
          for (let r of pe2(this, te2, rt2).call(this)) if (t(r)) return r;
        }
        hasAncestor(t) {
          for (let r of pe2(this, te2, rt2).call(this)) if (t(r)) return true;
          return false;
        }
      };
      te2 = /* @__PURE__ */ new WeakSet(), jt2 = function(t) {
        let { stack: r } = this;
        for (let n = r.length - 1; n >= 0; n -= 2) if (!Array.isArray(r[n]) && --t < 0) return n;
        return -1;
      }, rt2 = function* () {
        let { stack: t } = this;
        for (let r = t.length - 3; r >= 0; r -= 2) {
          let n = t[r];
          Array.isArray(n) || (yield n);
        }
      };
      var qr2 = Yt2;
      var Xr2 = new Proxy(() => {
      }, { get: () => Xr2 }), Pe2 = Xr2;
      function qu2(e) {
        return e !== null && typeof e == "object";
      }
      var Qr2 = qu2;
      function* ye2(e, t) {
        let { getVisitorKeys: r, filter: n = () => true } = t, u = (i) => Qr2(i) && n(i);
        for (let i of r(e)) {
          let o = e[i];
          if (Array.isArray(o)) for (let s of o) u(s) && (yield s);
          else u(o) && (yield o);
        }
      }
      function* Zr2(e, t) {
        let r = [e];
        for (let n = 0; n < r.length; n++) {
          let u = r[n];
          for (let i of ye2(u, t)) yield i, r.push(i);
        }
      }
      function en2(e, t) {
        return ye2(e, t).next().done;
      }
      function Ae2(e) {
        return (t, r, n) => {
          let u = !!(n != null && n.backwards);
          if (r === false) return false;
          let { length: i } = t, o = r;
          for (; o >= 0 && o < i; ) {
            let s = t.charAt(o);
            if (e instanceof RegExp) {
              if (!e.test(s)) return o;
            } else if (!e.includes(s)) return o;
            u ? o-- : o++;
          }
          return o === -1 || o === i ? o : false;
        };
      }
      var tn2 = Ae2(/\s/u), S2 = Ae2(" 	"), nt2 = Ae2(",; 	"), ut2 = Ae2(/[^\n\r]/u);
      function Xu2(e, t, r) {
        let n = !!(r != null && r.backwards);
        if (t === false) return false;
        let u = e.charAt(t);
        if (n) {
          if (e.charAt(t - 1) === "\r" && u === `
`) return t - 2;
          if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t - 1;
        } else {
          if (u === "\r" && e.charAt(t + 1) === `
`) return t + 2;
          if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t + 1;
        }
        return t;
      }
      var W2 = Xu2;
      function Qu2(e, t, r = {}) {
        let n = S2(e, r.backwards ? t - 1 : t, r), u = W2(e, n, r);
        return n !== u;
      }
      var V2 = Qu2;
      function Zu2(e) {
        return Array.isArray(e) && e.length > 0;
      }
      var Ht2 = Zu2;
      var rn2 = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]), ei2 = (e) => Object.keys(e).filter((t) => !rn2.has(t));
      function ti2(e) {
        return e ? (t) => e(t, rn2) : ei2;
      }
      var q2 = ti2;
      function ri2(e) {
        let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
        return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t + (r ? " " + r : "");
      }
      function Wt2(e, t) {
        (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = ri2(e);
      }
      function ue2(e, t) {
        t.leading = true, t.trailing = false, Wt2(e, t);
      }
      function re2(e, t, r) {
        t.leading = false, t.trailing = false, r && (t.marker = r), Wt2(e, t);
      }
      function ie2(e, t) {
        t.leading = false, t.trailing = true, Wt2(e, t);
      }
      var $t2 = /* @__PURE__ */ new WeakMap();
      function it2(e, t) {
        if ($t2.has(e)) return $t2.get(e);
        let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: u }, locStart: i, locEnd: o } = t;
        if (!n) return [];
        let s = ((r == null ? void 0 : r(e, t)) ?? [...ye2(e, { getVisitorKeys: q2(u) })]).flatMap((a) => n(a) ? [a] : it2(a, t));
        return s.sort((a, D) => i(a) - i(D) || o(a) - o(D)), $t2.set(e, s), s;
      }
      function un2(e, t, r, n) {
        let { locStart: u, locEnd: i } = r, o = u(t), s = i(t), a = it2(e, r), D, l, p = 0, f = a.length;
        for (; p < f; ) {
          let d = p + f >> 1, c = a[d], F = u(c), m = i(c);
          if (F <= o && s <= m) return un2(c, t, r, c);
          if (m <= o) {
            D = c, p = d + 1;
            continue;
          }
          if (s <= F) {
            l = c, f = d;
            continue;
          }
          throw new Error("Comment location overlaps with node location");
        }
        if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
          let { quasis: d } = n, c = Vt2(d, t, r);
          D && Vt2(d, D, r) !== c && (D = null), l && Vt2(d, l, r) !== c && (l = null);
        }
        return { enclosingNode: n, precedingNode: D, followingNode: l };
      }
      var Mt2 = () => false;
      function on2(e, t) {
        let { comments: r } = e;
        if (delete e.comments, !Ht2(r) || !t.printer.canAttachComment) return;
        let n = [], { locStart: u, locEnd: i, printer: { experimentalFeatures: { avoidAstMutation: o = false } = {}, handleComments: s = {} }, originalText: a } = t, { ownLine: D = Mt2, endOfLine: l = Mt2, remaining: p = Mt2 } = s, f = r.map((d, c) => ({ ...un2(e, d, t), comment: d, text: a, options: t, ast: e, isLastComment: r.length - 1 === c }));
        for (let [d, c] of f.entries()) {
          let { comment: F, precedingNode: m, enclosingNode: h, followingNode: C, text: v, options: E, ast: g, isLastComment: j } = c;
          if (E.parser === "json" || E.parser === "json5" || E.parser === "jsonc" || E.parser === "__js_expression" || E.parser === "__ts_expression" || E.parser === "__vue_expression" || E.parser === "__vue_ts_expression") {
            if (u(F) - u(g) <= 0) {
              ue2(g, F);
              continue;
            }
            if (i(F) - i(g) >= 0) {
              ie2(g, F);
              continue;
            }
          }
          let b;
          if (o ? b = [c] : (F.enclosingNode = h, F.precedingNode = m, F.followingNode = C, b = [F, v, E, g, j]), ni2(v, E, f, d)) F.placement = "ownLine", D(...b) || (C ? ue2(C, F) : m ? ie2(m, F) : h ? re2(h, F) : re2(g, F));
          else if (ui2(v, E, f, d)) F.placement = "endOfLine", l(...b) || (m ? ie2(m, F) : C ? ue2(C, F) : h ? re2(h, F) : re2(g, F));
          else if (F.placement = "remaining", !p(...b)) if (m && C) {
            let X = n.length;
            X > 0 && n[X - 1].followingNode !== C && nn2(n, E), n.push(c);
          } else m ? ie2(m, F) : C ? ue2(C, F) : h ? re2(h, F) : re2(g, F);
        }
        if (nn2(n, t), !o) for (let d of r) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
      }
      var sn2 = (e) => !/[\S\n\u2028\u2029]/u.test(e);
      function ni2(e, t, r, n) {
        let { comment: u, precedingNode: i } = r[n], { locStart: o, locEnd: s } = t, a = o(u);
        if (i) for (let D = n - 1; D >= 0; D--) {
          let { comment: l, precedingNode: p } = r[D];
          if (p !== i || !sn2(e.slice(s(l), a))) break;
          a = o(l);
        }
        return V2(e, a, { backwards: true });
      }
      function ui2(e, t, r, n) {
        let { comment: u, followingNode: i } = r[n], { locStart: o, locEnd: s } = t, a = s(u);
        if (i) for (let D = n + 1; D < r.length; D++) {
          let { comment: l, followingNode: p } = r[D];
          if (p !== i || !sn2(e.slice(a, o(l)))) break;
          a = s(l);
        }
        return V2(e, a);
      }
      function nn2(e, t) {
        var s, a;
        let r = e.length;
        if (r === 0) return;
        let { precedingNode: n, followingNode: u } = e[0], i = t.locStart(u), o;
        for (o = r; o > 0; --o) {
          let { comment: D, precedingNode: l, followingNode: p } = e[o - 1];
          Pe2.strictEqual(l, n), Pe2.strictEqual(p, u);
          let f = t.originalText.slice(t.locEnd(D), i);
          if (((a = (s = t.printer).isGap) == null ? void 0 : a.call(s, f, t)) ?? /^[\s(]*$/u.test(f)) i = t.locStart(D);
          else break;
        }
        for (let [D, { comment: l }] of e.entries()) D < o ? ie2(n, l) : ue2(u, l);
        for (let D of [n, u]) D.comments && D.comments.length > 1 && D.comments.sort((l, p) => t.locStart(l) - t.locStart(p));
        e.length = 0;
      }
      function Vt2(e, t, r) {
        let n = r.locStart(t) - 1;
        for (let u = 1; u < e.length; ++u) if (n < r.locStart(e[u])) return u - 1;
        return 0;
      }
      function ii2(e, t) {
        let r = t - 1;
        r = S2(e, r, { backwards: true }), r = W2(e, r, { backwards: true }), r = S2(e, r, { backwards: true });
        let n = W2(e, r, { backwards: true });
        return r !== n;
      }
      var Ie2 = ii2;
      function an2(e, t) {
        let r = e.node;
        return r.printed = true, t.printer.printComment(e, t);
      }
      function oi2(e, t) {
        var l;
        let r = e.node, n = [an2(e, t)], { printer: u, originalText: i, locStart: o, locEnd: s } = t;
        if ((l = u.isBlockComment) == null ? void 0 : l.call(u, r)) {
          let p = V2(i, s(r)) ? V2(i, o(r), { backwards: true }) ? K2 : Ze2 : " ";
          n.push(p);
        } else n.push(K2);
        let D = W2(i, S2(i, s(r)));
        return D !== false && V2(i, D) && n.push(K2), n;
      }
      function si2(e, t, r) {
        var D;
        let n = e.node, u = an2(e, t), { printer: i, originalText: o, locStart: s } = t, a = (D = i.isBlockComment) == null ? void 0 : D.call(i, n);
        if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || V2(o, s(n), { backwards: true })) {
          let l = Ie2(o, s(n));
          return { doc: Te2([K2, l ? K2 : "", u]), isBlock: a, hasLineSuffix: true };
        }
        return !a || r != null && r.hasLineSuffix ? { doc: [Te2([" ", u]), he2], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
      }
      function ai2(e, t) {
        let r = e.node;
        if (!r) return {};
        let n = t[Symbol.for("printedComments")];
        if ((r.comments || []).filter((a) => !n.has(a)).length === 0) return { leading: "", trailing: "" };
        let i = [], o = [], s;
        return e.each(() => {
          let a = e.node;
          if (n != null && n.has(a)) return;
          let { leading: D, trailing: l } = a;
          D ? i.push(oi2(e, t)) : l && (s = si2(e, t, s), o.push(s.doc));
        }, "comments"), { leading: i, trailing: o };
      }
      function Dn2(e, t, r) {
        let { leading: n, trailing: u } = ai2(e, r);
        return !n && !u ? t : me2(t, (i) => [n, i, u]);
      }
      function ln2(e) {
        let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: r } = e;
        for (let n of t) {
          if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
          delete n.printed;
        }
      }
      var Re2 = class extends Error {
        constructor() {
          super(...arguments);
          __publicField(this, "name", "ConfigError");
        }
      }, Ye2 = class extends Error {
        constructor() {
          super(...arguments);
          __publicField(this, "name", "UndefinedParserError");
        }
      };
      var fn2 = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
      function ot2({ plugins: e = [], showDeprecated: t = false } = {}) {
        let r = e.flatMap((u) => u.languages ?? []), n = [];
        for (let u of ci2(Object.assign({}, ...e.map(({ options: i }) => i), fn2))) !t && u.deprecated || (Array.isArray(u.choices) && (t || (u.choices = u.choices.filter((i) => !i.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...li2(u.choices, r, e)])), u.pluginDefaults = Object.fromEntries(e.filter((i) => {
          var o;
          return ((o = i.defaultOptions) == null ? void 0 : o[u.name]) !== void 0;
        }).map((i) => [i.name, i.defaultOptions[u.name]])), n.push(u));
        return { languages: r, options: n };
      }
      function* li2(e, t, r) {
        let n = new Set(e.map((u) => u.value));
        for (let u of t) if (u.parsers) {
          for (let i of u.parsers) if (!n.has(i)) {
            n.add(i);
            let o = r.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, i)), s = u.name;
            o != null && o.name && (s += ` (plugin: ${o.name})`), yield { value: i, description: s };
          }
        }
      }
      function ci2(e) {
        let t = [];
        for (let [r, n] of Object.entries(e)) {
          let u = { name: r, ...n };
          Array.isArray(u.default) && (u.default = A2(false, u.default, -1).value), t.push(u);
        }
        return t;
      }
      var fi2 = (e) => String(e).split(/[/\\]/u).pop();
      function dn2(e, t) {
        if (!t) return;
        let r = fi2(t).toLowerCase();
        return e.find(({ filenames: n }) => n == null ? void 0 : n.some((u) => u.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n == null ? void 0 : n.some((u) => r.endsWith(u)));
      }
      function di2(e, t) {
        if (t) return e.find(({ name: r }) => r.toLowerCase() === t) ?? e.find(({ aliases: r }) => r == null ? void 0 : r.includes(t)) ?? e.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${t}`));
      }
      function pi2(e, t) {
        let r = e.plugins.flatMap((u) => u.languages ?? []), n = di2(r, t.language) ?? dn2(r, t.physicalFile) ?? dn2(r, t.file) ?? (t.physicalFile, void 0);
        return n == null ? void 0 : n.parsers[0];
      }
      var pn2 = pi2;
      var oe2 = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
        if (e === null || typeof e != "object") return JSON.stringify(e);
        if (Array.isArray(e)) return `[${e.map((r) => oe2.value(r)).join(", ")}]`;
        let t = Object.keys(e);
        return t.length === 0 ? "{}" : `{ ${t.map((r) => `${oe2.key(r)}: ${oe2.value(e[r])}`).join(", ")} }`;
      }, pair: ({ key: e, value: t }) => oe2.value({ [e]: t }) };
      var Ut2 = Ve2(st2()), hn2 = (e, t, { descriptor: r }) => {
        let n = [`${Ut2.default.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
        return t && n.push(`we now treat it as ${Ut2.default.blue(typeof t == "string" ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
      };
      var ce2 = Ve2(st2());
      var at2 = Symbol.for("vnopts.VALUE_NOT_EXIST"), ve2 = Symbol.for("vnopts.VALUE_UNCHANGED");
      var En2 = " ".repeat(2), gn2 = (e, t, r) => {
        let { text: n, list: u } = r.normalizeExpectedResult(r.schemas[e].expected(r)), i = [];
        return n && i.push(Cn2(e, t, n, r.descriptor)), u && i.push([Cn2(e, t, u.title, r.descriptor)].concat(u.values.map((o) => yn2(o, r.loggerPrintWidth))).join(`
`)), An2(i, r.loggerPrintWidth);
      };
      function Cn2(e, t, r, n) {
        return [`Invalid ${ce2.default.red(n.key(e))} value.`, `Expected ${ce2.default.blue(r)},`, `but received ${t === at2 ? ce2.default.gray("nothing") : ce2.default.red(n.value(t))}.`].join(" ");
      }
      function yn2({ text: e, list: t }, r) {
        let n = [];
        return e && n.push(`- ${ce2.default.blue(e)}`), t && n.push([`- ${ce2.default.blue(t.title)}:`].concat(t.values.map((u) => yn2(u, r - En2.length).replace(/^|\n/g, `$&${En2}`))).join(`
`)), An2(n, r);
      }
      function An2(e, t) {
        if (e.length === 1) return e[0];
        let [r, n] = e, [u, i] = e.map((o) => o.split(`
`, 1)[0].length);
        return u > t && u > i ? n : r;
      }
      var Kt2 = Ve2(st2());
      var zt2 = [], vn2 = [];
      function Gt2(e, t) {
        if (e === t) return 0;
        let r = e;
        e.length > t.length && (e = t, t = r);
        let n = e.length, u = t.length;
        for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-u); ) n--, u--;
        let i = 0;
        for (; i < n && e.charCodeAt(i) === t.charCodeAt(i); ) i++;
        if (n -= i, u -= i, n === 0) return u;
        let o, s, a, D, l = 0, p = 0;
        for (; l < n; ) vn2[l] = e.charCodeAt(i + l), zt2[l] = ++l;
        for (; p < u; ) for (o = t.charCodeAt(i + p), a = p++, s = p, l = 0; l < n; l++) D = o === vn2[l] ? a : a + 1, a = zt2[l], s = zt2[l] = a > s ? D > s ? s + 1 : D : D > a ? a + 1 : D;
        return s;
      }
      var Dt2 = (e, t, { descriptor: r, logger: n, schemas: u }) => {
        let i = [`Ignored unknown option ${Kt2.default.yellow(r.pair({ key: e, value: t }))}.`], o = Object.keys(u).sort().find((s) => Gt2(e, s) < 3);
        o && i.push(`Did you mean ${Kt2.default.blue(r.key(o))}?`), n.warn(i.join(" "));
      };
      var Fi2 = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
      function mi2(e, t) {
        let r = new e(t), n = Object.create(r);
        for (let u of Fi2) u in t && (n[u] = hi2(t[u], r, x2.prototype[u].length));
        return n;
      }
      var x2 = class {
        static create(t) {
          return mi2(this, t);
        }
        constructor(t) {
          this.name = t.name;
        }
        default(t) {
        }
        expected(t) {
          return "nothing";
        }
        validate(t, r) {
          return false;
        }
        deprecated(t, r) {
          return false;
        }
        forward(t, r) {
        }
        redirect(t, r) {
        }
        overlap(t, r, n) {
          return t;
        }
        preprocess(t, r) {
          return t;
        }
        postprocess(t, r) {
          return ve2;
        }
      };
      function hi2(e, t, r) {
        return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
      }
      var lt2 = class extends x2 {
        constructor(t) {
          super(t), this._sourceName = t.sourceName;
        }
        expected(t) {
          return t.schemas[this._sourceName].expected(t);
        }
        validate(t, r) {
          return r.schemas[this._sourceName].validate(t, r);
        }
        redirect(t, r) {
          return this._sourceName;
        }
      };
      var ct2 = class extends x2 {
        expected() {
          return "anything";
        }
        validate() {
          return true;
        }
      };
      var ft2 = class extends x2 {
        constructor({ valueSchema: t, name: r = t.name, ...n }) {
          super({ ...n, name: r }), this._valueSchema = t;
        }
        expected(t) {
          let { text: r, list: n } = t.normalizeExpectedResult(this._valueSchema.expected(t));
          return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
        }
        validate(t, r) {
          if (!Array.isArray(t)) return false;
          let n = [];
          for (let u of t) {
            let i = r.normalizeValidateResult(this._valueSchema.validate(u, r), u);
            i !== true && n.push(i.value);
          }
          return n.length === 0 ? true : { value: n };
        }
        deprecated(t, r) {
          let n = [];
          for (let u of t) {
            let i = r.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r), u);
            i !== false && n.push(...i.map(({ value: o }) => ({ value: [o] })));
          }
          return n;
        }
        forward(t, r) {
          let n = [];
          for (let u of t) {
            let i = r.normalizeForwardResult(this._valueSchema.forward(u, r), u);
            n.push(...i.map(Bn2));
          }
          return n;
        }
        redirect(t, r) {
          let n = [], u = [];
          for (let i of t) {
            let o = r.normalizeRedirectResult(this._valueSchema.redirect(i, r), i);
            "remain" in o && n.push(o.remain), u.push(...o.redirect.map(Bn2));
          }
          return n.length === 0 ? { redirect: u } : { redirect: u, remain: n };
        }
        overlap(t, r) {
          return t.concat(r);
        }
      };
      function Bn2({ from: e, to: t }) {
        return { from: [e], to: t };
      }
      var dt2 = class extends x2 {
        expected() {
          return "true or false";
        }
        validate(t) {
          return typeof t == "boolean";
        }
      };
      function _n2(e, t) {
        let r = /* @__PURE__ */ Object.create(null);
        for (let n of e) {
          let u = n[t];
          if (r[u]) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
          r[u] = n;
        }
        return r;
      }
      function xn2(e, t) {
        let r = /* @__PURE__ */ new Map();
        for (let n of e) {
          let u = n[t];
          if (r.has(u)) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
          r.set(u, n);
        }
        return r;
      }
      function bn2() {
        let e = /* @__PURE__ */ Object.create(null);
        return (t) => {
          let r = JSON.stringify(t);
          return e[r] ? true : (e[r] = true, false);
        };
      }
      function Nn2(e, t) {
        let r = [], n = [];
        for (let u of e) t(u) ? r.push(u) : n.push(u);
        return [r, n];
      }
      function On2(e) {
        return e === Math.floor(e);
      }
      function Sn2(e, t) {
        if (e === t) return 0;
        let r = typeof e, n = typeof t, u = ["undefined", "object", "boolean", "number", "string"];
        return r !== n ? u.indexOf(r) - u.indexOf(n) : r !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
      }
      function Tn2(e) {
        return (...t) => {
          let r = e(...t);
          return typeof r == "string" ? new Error(r) : r;
        };
      }
      function Jt2(e) {
        return e === void 0 ? {} : e;
      }
      function qt2(e) {
        if (typeof e == "string") return { text: e };
        let { text: t, list: r } = e;
        return Ei2((t || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: t, list: { title: r.title, values: r.values.map(qt2) } } : { text: t };
      }
      function Xt2(e, t) {
        return e === true ? true : e === false ? { value: t } : e;
      }
      function Qt2(e, t, r = false) {
        return e === false ? false : e === true ? r ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
      }
      function wn2(e, t) {
        return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
      }
      function pt2(e, t) {
        return e === void 0 ? [] : Array.isArray(e) ? e.map((r) => wn2(r, t)) : [wn2(e, t)];
      }
      function Zt2(e, t) {
        let r = pt2(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
        return r.length === 0 ? { remain: t, redirect: r } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r };
      }
      function Ei2(e, t) {
        if (!e) throw new Error(t);
      }
      var Ft2 = class extends x2 {
        constructor(t) {
          super(t), this._choices = xn2(t.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
        }
        expected({ descriptor: t }) {
          let r = Array.from(this._choices.keys()).map((o) => this._choices.get(o)).filter(({ hidden: o }) => !o).map((o) => o.value).sort(Sn2).map(t.value), n = r.slice(0, -2), u = r.slice(-2);
          return { text: n.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
        }
        validate(t) {
          return this._choices.has(t);
        }
        deprecated(t) {
          let r = this._choices.get(t);
          return r && r.deprecated ? { value: t } : false;
        }
        forward(t) {
          let r = this._choices.get(t);
          return r ? r.forward : void 0;
        }
        redirect(t) {
          let r = this._choices.get(t);
          return r ? r.redirect : void 0;
        }
      };
      var mt2 = class extends x2 {
        expected() {
          return "a number";
        }
        validate(t, r) {
          return typeof t == "number";
        }
      };
      var ht2 = class extends mt2 {
        expected() {
          return "an integer";
        }
        validate(t, r) {
          return r.normalizeValidateResult(super.validate(t, r), t) === true && On2(t);
        }
      };
      var je2 = class extends x2 {
        expected() {
          return "a string";
        }
        validate(t) {
          return typeof t == "string";
        }
      };
      var kn2 = oe2, Ln2 = Dt2, Pn2 = gn2, In2 = hn2;
      var Et2 = class {
        constructor(t, r) {
          let { logger: n = console, loggerPrintWidth: u = 80, descriptor: i = kn2, unknown: o = Ln2, invalid: s = Pn2, deprecated: a = In2, missing: D = () => false, required: l = () => false, preprocess: p = (d) => d, postprocess: f = () => ve2 } = r || {};
          this._utils = { descriptor: i, logger: n || { warn: () => {
          } }, loggerPrintWidth: u, schemas: _n2(t, "name"), normalizeDefaultResult: Jt2, normalizeExpectedResult: qt2, normalizeDeprecatedResult: Qt2, normalizeForwardResult: pt2, normalizeRedirectResult: Zt2, normalizeValidateResult: Xt2 }, this._unknownHandler = o, this._invalidHandler = Tn2(s), this._deprecatedHandler = a, this._identifyMissing = (d, c) => !(d in c) || D(d, c), this._identifyRequired = l, this._preprocess = p, this._postprocess = f, this.cleanHistory();
        }
        cleanHistory() {
          this._hasDeprecationWarned = bn2();
        }
        normalize(t) {
          let r = {}, u = [this._preprocess(t, this._utils)], i = () => {
            for (; u.length !== 0; ) {
              let o = u.shift(), s = this._applyNormalization(o, r);
              u.push(...s);
            }
          };
          i();
          for (let o of Object.keys(this._utils.schemas)) {
            let s = this._utils.schemas[o];
            if (!(o in r)) {
              let a = Jt2(s.default(this._utils));
              "value" in a && u.push({ [o]: a.value });
            }
          }
          i();
          for (let o of Object.keys(this._utils.schemas)) {
            if (!(o in r)) continue;
            let s = this._utils.schemas[o], a = r[o], D = s.postprocess(a, this._utils);
            D !== ve2 && (this._applyValidation(D, o, s), r[o] = D);
          }
          return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
        }
        _applyNormalization(t, r) {
          let n = [], { knownKeys: u, unknownKeys: i } = this._partitionOptionKeys(t);
          for (let o of u) {
            let s = this._utils.schemas[o], a = s.preprocess(t[o], this._utils);
            this._applyValidation(a, o, s);
            let D = ({ from: d, to: c }) => {
              n.push(typeof c == "string" ? { [c]: d } : { [c.key]: c.value });
            }, l = ({ value: d, redirectTo: c }) => {
              let F = Qt2(s.deprecated(d, this._utils), a, true);
              if (F !== false) if (F === true) this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, c, this._utils));
              else for (let { value: m } of F) {
                let h = { key: o, value: m };
                if (!this._hasDeprecationWarned(h)) {
                  let C = typeof c == "string" ? { key: c, value: m } : c;
                  this._utils.logger.warn(this._deprecatedHandler(h, C, this._utils));
                }
              }
            };
            pt2(s.forward(a, this._utils), a).forEach(D);
            let f = Zt2(s.redirect(a, this._utils), a);
            if (f.redirect.forEach(D), "remain" in f) {
              let d = f.remain;
              r[o] = o in r ? s.overlap(r[o], d, this._utils) : d, l({ value: d });
            }
            for (let { from: d, to: c } of f.redirect) l({ value: d, redirectTo: c });
          }
          for (let o of i) {
            let s = t[o];
            this._applyUnknownHandler(o, s, r, (a, D) => {
              n.push({ [a]: D });
            });
          }
          return n;
        }
        _applyRequiredCheck(t) {
          for (let r of Object.keys(this._utils.schemas)) if (this._identifyMissing(r, t) && this._identifyRequired(r)) throw this._invalidHandler(r, at2, this._utils);
        }
        _partitionOptionKeys(t) {
          let [r, n] = Nn2(Object.keys(t).filter((u) => !this._identifyMissing(u, t)), (u) => u in this._utils.schemas);
          return { knownKeys: r, unknownKeys: n };
        }
        _applyValidation(t, r, n) {
          let u = Xt2(n.validate(t, this._utils), t);
          if (u !== true) throw this._invalidHandler(r, u.value, this._utils);
        }
        _applyUnknownHandler(t, r, n, u) {
          let i = this._unknownHandler(t, r, this._utils);
          if (i) for (let o of Object.keys(i)) {
            if (this._identifyMissing(o, i)) continue;
            let s = i[o];
            o in this._utils.schemas ? u(o, s) : n[o] = s;
          }
        }
        _applyPostprocess(t) {
          let r = this._postprocess(t, this._utils);
          if (r !== ve2) {
            if (r.delete) for (let n of r.delete) delete t[n];
            if (r.override) {
              let { knownKeys: n, unknownKeys: u } = this._partitionOptionKeys(r.override);
              for (let i of n) {
                let o = r.override[i];
                this._applyValidation(o, i, this._utils.schemas[i]), t[i] = o;
              }
              for (let i of u) {
                let o = r.override[i];
                this._applyUnknownHandler(i, o, t, (s, a) => {
                  let D = this._utils.schemas[s];
                  this._applyValidation(a, s, D), t[s] = a;
                });
              }
            }
          }
        }
      };
      var er2;
      function gi2(e, t, { logger: r = false, isCLI: n = false, passThrough: u = false, FlagSchema: i, descriptor: o } = {}) {
        if (n) {
          if (!i) throw new Error("'FlagSchema' option is required.");
          if (!o) throw new Error("'descriptor' option is required.");
        } else o = oe2;
        let s = u ? Array.isArray(u) ? (f, d) => u.includes(f) ? { [f]: d } : void 0 : (f, d) => ({ [f]: d }) : (f, d, c) => {
          let { _: F, ...m } = c.schemas;
          return Dt2(f, d, { ...c, schemas: m });
        }, a = yi2(t, { isCLI: n, FlagSchema: i }), D = new Et2(a, { logger: r, unknown: s, descriptor: o }), l = r !== false;
        l && er2 && (D._hasDeprecationWarned = er2);
        let p = D.normalize(e);
        return l && (er2 = D._hasDeprecationWarned), p;
      }
      function yi2(e, { isCLI: t, FlagSchema: r }) {
        let n = [];
        t && n.push(ct2.create({ name: "_" }));
        for (let u of e) n.push(Ai2(u, { isCLI: t, optionInfos: e, FlagSchema: r })), u.alias && t && n.push(lt2.create({ name: u.alias, sourceName: u.name }));
        return n;
      }
      function Ai2(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
        let { name: u } = e, i = { name: u }, o, s = {};
        switch (e.type) {
          case "int":
            o = ht2, t && (i.preprocess = Number);
            break;
          case "string":
            o = je2;
            break;
          case "choice":
            o = Ft2, i.choices = e.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e.name, value: a.redirect } } } : a);
            break;
          case "boolean":
            o = dt2;
            break;
          case "flag":
            o = n, i.flags = r.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
            break;
          case "path":
            o = je2;
            break;
          default:
            throw new Error(`Unexpected type ${e.type}`);
        }
        if (e.exception ? i.validate = (a, D, l) => e.exception(a) || D.validate(a, l) : i.validate = (a, D, l) => a === void 0 || D.validate(a, l), e.redirect && (s.redirect = (a) => a ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
          let a = i.preprocess || ((D) => D);
          i.preprocess = (D, l, p) => l.preprocess(a(Array.isArray(D) ? A2(false, D, -1) : D), p);
        }
        return e.array ? ft2.create({ ...t ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s, valueSchema: o.create(i) }) : o.create({ ...i, ...s });
      }
      var Rn2 = gi2;
      var vi2 = (e, t, r) => {
        if (!(e && t == null)) {
          if (t.findLast) return t.findLast(r);
          for (let n = t.length - 1; n >= 0; n--) {
            let u = t[n];
            if (r(u, n, t)) return u;
          }
        }
      }, tr2 = vi2;
      function rr2(e, t) {
        if (!t) throw new Error("parserName is required.");
        let r = tr2(false, e, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t));
        if (r) return r;
        let n = `Couldn't resolve parser "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new Re2(n);
      }
      function Yn2(e, t) {
        if (!t) throw new Error("astFormat is required.");
        let r = tr2(false, e, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t));
        if (r) return r;
        let n = `Couldn't find plugin for AST format "${t}".`;
        throw n += " Plugins must be explicitly added to the standalone bundle.", new Re2(n);
      }
      function Ct2({ plugins: e, parser: t }) {
        let r = rr2(e, t);
        return nr2(r, t);
      }
      function nr2(e, t) {
        let r = e.parsers[t];
        return typeof r == "function" ? r() : r;
      }
      function jn2(e, t) {
        let r = e.printers[t];
        return typeof r == "function" ? r() : r;
      }
      var Hn2 = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
      async function Bi2(e, t = {}) {
        var p;
        let r = { ...e };
        if (!r.parser) if (r.filepath) {
          if (r.parser = pn2(r, { physicalFile: r.filepath }), !r.parser) throw new Ye2(`No parser could be inferred for file "${r.filepath}".`);
        } else throw new Ye2("No parser and no file path given, couldn't infer a parser.");
        let n = ot2({ plugins: e.plugins, showDeprecated: true }).options, u = { ...Hn2, ...Object.fromEntries(n.filter((f) => f.default !== void 0).map((f) => [f.name, f.default])) }, i = rr2(r.plugins, r.parser), o = await nr2(i, r.parser);
        r.astFormat = o.astFormat, r.locEnd = o.locEnd, r.locStart = o.locStart;
        let s = (p = i.printers) != null && p[o.astFormat] ? i : Yn2(r.plugins, o.astFormat), a = await jn2(s, o.astFormat);
        r.printer = a;
        let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, f]) => f !== void 0)) : {}, l = { ...u, ...D };
        for (let [f, d] of Object.entries(l)) (r[f] === null || r[f] === void 0) && (r[f] = d);
        return r.parser === "json" && (r.trailingComma = "none"), Rn2(r, n, { passThrough: Object.keys(Hn2), ...t });
      }
      var se2 = Bi2;
      var Mn2 = Ve2($n2());
      async function bi2(e, t) {
        let r = await Ct2(t), n = r.preprocess ? r.preprocess(e, t) : e;
        t.originalText = n;
        let u;
        try {
          u = await r.parse(n, t, t);
        } catch (i) {
          Ni2(i, e);
        }
        return { text: n, ast: u };
      }
      function Ni2(e, t) {
        let { loc: r } = e;
        if (r) {
          let n = (0, Mn2.codeFrameColumns)(t, r, { highlightCode: true });
          throw e.message += `
` + n, e.codeFrame = n, e;
        }
        throw e;
      }
      var fe2 = bi2;
      async function Vn2(e, t, r, n, u) {
        let { embeddedLanguageFormatting: i, printer: { embed: o, hasPrettierIgnore: s = () => false, getVisitorKeys: a } } = r;
        if (!o || i !== "auto") return;
        if (o.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
        let D = q2(o.getVisitorKeys ?? a), l = [];
        d();
        let p = e.stack;
        for (let { print: c, node: F, pathStack: m } of l) try {
          e.stack = m;
          let h = await c(f, t, e, r);
          h && u.set(F, h);
        } catch (h) {
          if (globalThis.PRETTIER_DEBUG) throw h;
        }
        e.stack = p;
        function f(c, F) {
          return Oi2(c, F, r, n);
        }
        function d() {
          let { node: c } = e;
          if (c === null || typeof c != "object" || s(e)) return;
          for (let m of D(c)) Array.isArray(c[m]) ? e.each(d, m) : e.call(d, m);
          let F = o(e, r);
          if (F) {
            if (typeof F == "function") {
              l.push({ print: F, node: c, pathStack: [...e.stack] });
              return;
            }
            u.set(c, F);
          }
        }
      }
      async function Oi2(e, t, r, n) {
        let u = await se2({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: true }), { ast: i } = await fe2(e, u), o = await n(i, u);
        return Xe2(o);
      }
      function Si2(e, t) {
        let { originalText: r, [Symbol.for("comments")]: n, locStart: u, locEnd: i, [Symbol.for("printedComments")]: o } = t, { node: s } = e, a = u(s), D = i(s);
        for (let l of n) u(l) >= a && i(l) <= D && o.add(l);
        return r.slice(a, D);
      }
      var Un2 = Si2;
      async function He2(e, t) {
        ({ ast: e } = await ir2(e, t));
        let r = /* @__PURE__ */ new Map(), n = new qr2(e), i = /* @__PURE__ */ new Map();
        await Vn2(n, s, t, He2, i);
        let o = await zn2(n, t, s, void 0, i);
        if (ln2(t), t.nodeAfterCursor && !t.nodeBeforeCursor) return [Z2, o];
        if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [o, Z2];
        return o;
        function s(D, l) {
          return D === void 0 || D === n ? a(l) : Array.isArray(D) ? n.call(() => a(l), ...D) : n.call(() => a(l), D);
        }
        function a(D) {
          let l = n.node;
          if (l == null) return "";
          let p = l && typeof l == "object" && D === void 0;
          if (p && r.has(l)) return r.get(l);
          let f = zn2(n, t, s, D, i);
          return p && r.set(l, f), f;
        }
      }
      function zn2(e, t, r, n, u) {
        var a;
        let { node: i } = e, { printer: o } = t, s;
        switch ((a = o.hasPrettierIgnore) != null && a.call(o, e) ? s = Un2(e, t) : u.has(i) ? s = u.get(i) : s = o.print(e, t, r, n), i) {
          case t.cursorNode:
            s = me2(s, (D) => [Z2, D, Z2]);
            break;
          case t.nodeBeforeCursor:
            s = me2(s, (D) => [D, Z2]);
            break;
          case t.nodeAfterCursor:
            s = me2(s, (D) => [Z2, D]);
            break;
        }
        return o.printComment && (!o.willPrintOwnComments || !o.willPrintOwnComments(e, t)) && (s = Dn2(e, s, t)), s;
      }
      async function ir2(e, t) {
        let r = e.comments ?? [];
        t[Symbol.for("comments")] = r, t[Symbol.for("tokens")] = e.tokens ?? [], t[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), on2(e, t);
        let { printer: { preprocess: n } } = t;
        return e = n ? await n(e, t) : e, { ast: e, comments: r };
      }
      function Ti2(e, t) {
        let { cursorOffset: r, locStart: n, locEnd: u } = t, i = q2(t.printer.getVisitorKeys), o = (d) => n(d) <= r && u(d) >= r, s = e, a = [e];
        for (let d of Zr2(e, { getVisitorKeys: i, filter: o })) a.push(d), s = d;
        if (en2(s, { getVisitorKeys: i })) return { cursorNode: s };
        let D, l, p = -1, f = Number.POSITIVE_INFINITY;
        for (; a.length > 0 && (D === void 0 || l === void 0); ) {
          s = a.pop();
          let d = D !== void 0, c = l !== void 0;
          for (let F of ye2(s, { getVisitorKeys: i })) {
            if (!d) {
              let m = u(F);
              m <= r && m > p && (D = F, p = m);
            }
            if (!c) {
              let m = n(F);
              m >= r && m < f && (l = F, f = m);
            }
          }
        }
        return { nodeBeforeCursor: D, nodeAfterCursor: l };
      }
      var Gn2 = Ti2;
      function ki2(e, t) {
        let { printer: { massageAstNode: r, getVisitorKeys: n } } = t;
        if (!r) return e;
        let u = q2(n), i = r.ignoredProperties ?? /* @__PURE__ */ new Set();
        return o(e);
        function o(s, a) {
          if (!(s !== null && typeof s == "object")) return s;
          if (Array.isArray(s)) return s.map((f) => o(f, a)).filter(Boolean);
          let D = {}, l = new Set(u(s));
          for (let f in s) !Object.prototype.hasOwnProperty.call(s, f) || i.has(f) || (l.has(f) ? D[f] = o(s[f], s) : D[f] = s[f]);
          let p = r(s, D, a);
          if (p !== null) return p ?? D;
        }
      }
      var Kn2 = ki2;
      var Li2 = (e, t, r) => {
        if (!(e && t == null)) {
          if (t.findLastIndex) return t.findLastIndex(r);
          for (let n = t.length - 1; n >= 0; n--) {
            let u = t[n];
            if (r(u, n, t)) return n;
          }
          return -1;
        }
      }, Jn2 = Li2;
      var Pi2 = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
      function Ii2(e, t) {
        let r = [e.node, ...e.parentNodes], n = /* @__PURE__ */ new Set([t.node, ...t.parentNodes]);
        return r.find((u) => Qn2.has(u.type) && n.has(u));
      }
      function qn2(e) {
        let t = Jn2(false, e, (r) => r.type !== "Program" && r.type !== "File");
        return t === -1 ? e : e.slice(0, t + 1);
      }
      function Ri2(e, t, { locStart: r, locEnd: n }) {
        let u = e.node, i = t.node;
        if (u === i) return { startNode: u, endNode: i };
        let o = r(e.node);
        for (let a of qn2(t.parentNodes)) if (r(a) >= o) i = a;
        else break;
        let s = n(t.node);
        for (let a of qn2(e.parentNodes)) {
          if (n(a) <= s) u = a;
          else break;
          if (u === i) break;
        }
        return { startNode: u, endNode: i };
      }
      function or2(e, t, r, n, u = [], i) {
        let { locStart: o, locEnd: s } = r, a = o(e), D = s(e);
        if (!(t > D || t < a || i === "rangeEnd" && t === a || i === "rangeStart" && t === D)) {
          for (let l of it2(e, r)) {
            let p = or2(l, t, r, n, [e, ...u], i);
            if (p) return p;
          }
          if (!n || n(e, u[0])) return { node: e, parentNodes: u };
        }
      }
      function Yi2(e, t) {
        return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
      }
      var Qn2 = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]), ji2 = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
      function Xn2(e, t, r) {
        if (!t) return false;
        switch (e.parser) {
          case "flow":
          case "babel":
          case "babel-flow":
          case "babel-ts":
          case "typescript":
          case "acorn":
          case "espree":
          case "meriyah":
          case "__babel_estree":
            return Yi2(t.type, r == null ? void 0 : r.type);
          case "json":
          case "json5":
          case "jsonc":
          case "json-stringify":
            return Qn2.has(t.type);
          case "graphql":
            return ji2.has(t.kind);
          case "vue":
            return t.tag !== "root";
        }
        return false;
      }
      function Zn2(e, t, r) {
        let { rangeStart: n, rangeEnd: u, locStart: i, locEnd: o } = t;
        Pe2.ok(u > n);
        let s = e.slice(n, u).search(/\S/u), a = s === -1;
        if (!a) for (n += s; u > n && !/\S/u.test(e[u - 1]); --u) ;
        let D = or2(r, n, t, (d, c) => Xn2(t, d, c), [], "rangeStart"), l = a ? D : or2(r, u, t, (d) => Xn2(t, d), [], "rangeEnd");
        if (!D || !l) return { rangeStart: 0, rangeEnd: 0 };
        let p, f;
        if (Pi2(t)) {
          let d = Ii2(D, l);
          p = d, f = d;
        } else ({ startNode: p, endNode: f } = Ri2(D, l, t));
        return { rangeStart: Math.min(i(p), i(f)), rangeEnd: Math.max(o(p), o(f)) };
      }
      var nu2 = "\uFEFF", eu2 = Symbol("cursor");
      async function uu2(e, t, r = 0) {
        if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
        let { ast: n, text: u } = await fe2(e, t);
        t.cursorOffset >= 0 && (t = { ...t, ...Gn2(n, t) });
        let i = await He2(n, t);
        r > 0 && (i = et2([K2, i], r, t.tabWidth));
        let o = Ce2(i, t);
        if (r > 0) {
          let a = o.formatted.trim();
          o.cursorNodeStart !== void 0 && (o.cursorNodeStart -= o.formatted.indexOf(a), o.cursorNodeStart < 0 && (o.cursorNodeStart = 0, o.cursorNodeText = o.cursorNodeText.trimStart()), o.cursorNodeStart + o.cursorNodeText.length > a.length && (o.cursorNodeText = o.cursorNodeText.trimEnd())), o.formatted = a + be2(t.endOfLine);
        }
        let s = t[Symbol.for("comments")];
        if (t.cursorOffset >= 0) {
          let a, D, l, p;
          if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && o.cursorNodeText) if (l = o.cursorNodeStart, p = o.cursorNodeText, t.cursorNode) a = t.locStart(t.cursorNode), D = u.slice(a, t.locEnd(t.cursorNode));
          else {
            if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
            a = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
            let h = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : u.length;
            D = u.slice(a, h);
          }
          else a = 0, D = u, l = 0, p = o.formatted;
          let f = t.cursorOffset - a;
          if (D === p) return { formatted: o.formatted, cursorOffset: l + f, comments: s };
          let d = D.split("");
          d.splice(f, 0, eu2);
          let c = p.split(""), F = yr2(d, c), m = l;
          for (let h of F) if (h.removed) {
            if (h.value.includes(eu2)) break;
          } else m += h.count;
          return { formatted: o.formatted, cursorOffset: m, comments: s };
        }
        return { formatted: o.formatted, cursorOffset: -1, comments: s };
      }
      async function Hi2(e, t) {
        let { ast: r, text: n } = await fe2(e, t), { rangeStart: u, rangeEnd: i } = Zn2(n, t, r), o = n.slice(u, i), s = Math.min(u, n.lastIndexOf(`
`, u) + 1), a = n.slice(s, u).match(/^\s*/u)[0], D = ge2(a, t.tabWidth), l = await uu2(o, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > u && t.cursorOffset <= i ? t.cursorOffset - u : -1, endOfLine: "lf" }, D), p = l.formatted.trimEnd(), { cursorOffset: f } = t;
        f > i ? f += p.length - o.length : l.cursorOffset >= 0 && (f = l.cursorOffset + u);
        let d = n.slice(0, u) + p + n.slice(i);
        if (t.endOfLine !== "lf") {
          let c = be2(t.endOfLine);
          f >= 0 && c === `\r
` && (f += Nt2(d.slice(0, f), `
`)), d = ne2(false, d, `
`, c);
        }
        return { formatted: d, cursorOffset: f, comments: l.comments };
      }
      function sr2(e, t, r) {
        return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
      }
      function tu2(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t;
        return r = sr2(e, r, -1), n = sr2(e, n, 0), u = sr2(e, u, e.length), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u };
      }
      function iu2(e, t) {
        let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i } = tu2(e, t), o = e.charAt(0) === nu2;
        if (o && (e = e.slice(1), r--, n--, u--), i === "auto" && (i = Ar2(e)), e.includes("\r")) {
          let s = (a) => Nt2(e.slice(0, Math.max(a, 0)), `\r
`);
          r -= s(r), n -= s(n), u -= s(u), e = vr2(e);
        }
        return { hasBOM: o, text: e, options: tu2(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i }) };
      }
      async function ru2(e, t) {
        let r = await Ct2(t);
        return !r.hasPragma || r.hasPragma(e);
      }
      async function ar2(e, t) {
        let { hasBOM: r, text: n, options: u } = iu2(e, await se2(t));
        if (u.rangeStart >= u.rangeEnd && n !== "" || u.requirePragma && !await ru2(n, u)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
        let i;
        return u.rangeStart > 0 || u.rangeEnd < n.length ? i = await Hi2(n, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await ru2(n, u) && (n = u.printer.insertPragma(n)), i = await uu2(n, u)), r && (i.formatted = nu2 + i.formatted, i.cursorOffset >= 0 && i.cursorOffset++), i;
      }
      async function ou2(e, t, r) {
        let { text: n, options: u } = iu2(e, await se2(t)), i = await fe2(n, u);
        return r && (r.preprocessForPrint && (i.ast = await ir2(i.ast, u)), r.massage && (i.ast = Kn2(i.ast, u))), i;
      }
      async function su2(e, t) {
        t = await se2(t);
        let r = await He2(e, t);
        return Ce2(r, t);
      }
      async function au2(e, t) {
        let r = Vr2(e), { formatted: n } = await ar2(r, { ...t, parser: "__js_expression" });
        return n;
      }
      async function Du2(e, t) {
        t = await se2(t);
        let { ast: r } = await fe2(e, t);
        return He2(r, t);
      }
      async function lu2(e, t) {
        return Ce2(e, await se2(t));
      }
      var Dr2 = {};
      vt2(Dr2, { builders: () => $i2, printer: () => Mi2, utils: () => Vi2 });
      var $i2 = { join: Se2, line: Ze2, softline: $r2, hardline: K2, literalline: Qe2, group: kt2, conditionalGroup: Ir2, fill: Rr2, lineSuffix: Te2, lineSuffixBoundary: Hr2, cursor: Z2, breakParent: he2, ifBreak: Yr2, trim: Wr2, indent: le2, indentIfBreak: jr2, align: De2, addAlignmentToDoc: et2, markAsRoot: Lr2, dedentToRoot: kr2, dedent: Pr2, hardlineWithoutBreakParent: ke2, literallineWithoutBreakParent: Lt2, label: Mr2, concat: (e) => e }, Mi2 = { printDocToString: Ce2 }, Vi2 = { willBreak: xr2, traverseDoc: Fe2, findInDoc: qe2, mapDoc: Oe2, removeLines: Nr2, stripTrailingHardline: Xe2, replaceEndOfLine: Or2, canBreak: Sr2 };
      var cu2 = "3.5.3";
      var cr2 = {};
      vt2(cr2, { addDanglingComment: () => re2, addLeadingComment: () => ue2, addTrailingComment: () => ie2, getAlignmentSize: () => ge2, getIndentSize: () => fu2, getMaxContinuousCount: () => du2, getNextNonSpaceNonCommentCharacter: () => pu2, getNextNonSpaceNonCommentCharacterIndex: () => no2, getPreferredQuote: () => mu2, getStringWidth: () => Le2, hasNewline: () => V2, hasNewlineInRange: () => hu2, hasSpaces: () => Eu2, isNextLineEmpty: () => so2, isNextLineEmptyAfterIndex: () => gt2, isPreviousLineEmpty: () => io2, makeString: () => Cu2, skip: () => Ae2, skipEverythingButNewLine: () => ut2, skipInlineComment: () => Be2, skipNewline: () => W2, skipSpaces: () => S2, skipToLineEnd: () => nt2, skipTrailingComment: () => we2, skipWhitespace: () => tn2 });
      function Ui2(e, t) {
        if (t === false) return false;
        if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
          for (let r = t + 2; r < e.length; ++r) if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
        }
        return t;
      }
      var Be2 = Ui2;
      function zi2(e, t) {
        return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? ut2(e, t) : t;
      }
      var we2 = zi2;
      function Gi2(e, t) {
        let r = null, n = t;
        for (; n !== r; ) r = n, n = S2(e, n), n = Be2(e, n), n = we2(e, n), n = W2(e, n);
        return n;
      }
      var We2 = Gi2;
      function Ki2(e, t) {
        let r = null, n = t;
        for (; n !== r; ) r = n, n = nt2(e, n), n = Be2(e, n), n = S2(e, n);
        return n = we2(e, n), n = W2(e, n), n !== false && V2(e, n);
      }
      var gt2 = Ki2;
      function Ji2(e, t) {
        let r = e.lastIndexOf(`
`);
        return r === -1 ? 0 : ge2(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
      }
      var fu2 = Ji2;
      function lr2(e) {
        if (typeof e != "string") throw new TypeError("Expected a string");
        return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
      }
      function qi2(e, t) {
        let r = e.match(new RegExp(`(${lr2(t)})+`, "gu"));
        return r === null ? 0 : r.reduce((n, u) => Math.max(n, u.length / t.length), 0);
      }
      var du2 = qi2;
      function Xi2(e, t) {
        let r = We2(e, t);
        return r === false ? "" : e.charAt(r);
      }
      var pu2 = Xi2;
      var yt = "'", Fu2 = '"';
      function Qi2(e, t) {
        let r = t === true || t === yt ? yt : Fu2, n = r === yt ? Fu2 : yt, u = 0, i = 0;
        for (let o of e) o === r ? u++ : o === n && i++;
        return u > i ? n : r;
      }
      var mu2 = Qi2;
      function Zi2(e, t, r) {
        for (let n = t; n < r; ++n) if (e.charAt(n) === `
`) return true;
        return false;
      }
      var hu2 = Zi2;
      function eo2(e, t, r = {}) {
        return S2(e, r.backwards ? t - 1 : t, r) !== t;
      }
      var Eu2 = eo2;
      function to2(e, t, r) {
        let n = t === '"' ? "'" : '"', i = ne2(false, e, /\\(.)|(["'])/gsu, (o, s, a) => s === n ? s : a === t ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
        return t + i + t;
      }
      var Cu2 = to2;
      function ro2(e, t, r) {
        return We2(e, r(t));
      }
      function no2(e, t) {
        return arguments.length === 2 || typeof t == "number" ? We2(e, t) : ro2(...arguments);
      }
      function uo2(e, t, r) {
        return Ie2(e, r(t));
      }
      function io2(e, t) {
        return arguments.length === 2 || typeof t == "number" ? Ie2(e, t) : uo2(...arguments);
      }
      function oo2(e, t, r) {
        return gt2(e, r(t));
      }
      function so2(e, t) {
        return arguments.length === 2 || typeof t == "number" ? gt2(e, t) : oo2(...arguments);
      }
      function de2(e, t = 1) {
        return async (...r) => {
          let n = r[t] ?? {}, u = n.plugins ?? [];
          return r[t] = { ...n, plugins: Array.isArray(u) ? u : Object.values(u) }, e(...r);
        };
      }
      var gu2 = de2(ar2);
      async function yu2(e, t) {
        let { formatted: r } = await gu2(e, { ...t, cursorOffset: -1 });
        return r;
      }
      async function ao2(e, t) {
        return await yu2(e, t) === e;
      }
      var Do2 = de2(ot2, 0), lo2 = { parse: de2(ou2), formatAST: de2(su2), formatDoc: de2(au2), printToDoc: de2(Du2), printDocToString: de2(lu2) };
      return xu2(co);
    });
  }
});

// node_modules/prettier-plugin-solidity/dist/standalone.cjs
var require_standalone2 = __commonJS({
  "node_modules/prettier-plugin-solidity/dist/standalone.cjs"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(require_standalone()) : "function" == typeof define && define.amd ? define(["prettier/standalone"], e) : "object" == typeof exports ? exports.prettierPluginSolidity = e(require_standalone()) : (t.prettierPlugins = t.prettierPlugins || {}, t.prettierPlugins.solidity = e(t.prettier));
    }("undefined" != typeof globalThis ? globalThis : "undefined" != typeof global ? global : "undefined" != typeof self ? self : exports || {}, (t) => (() => {
      var e = { 121: function(t2, e2, i2) {
        var s2;
        "undefined" != typeof globalThis ? globalThis : void 0 !== i2.g ? i2.g : "undefined" != typeof self && self, s2 = () => {
          var t3 = (() => {
            var t4 = Object.defineProperty, e3 = Object.getOwnPropertyDescriptor, i3 = Object.getOwnPropertyNames, s3 = Object.prototype.hasOwnProperty, r2 = {};
            ((e4, i4) => {
              for (var s4 in i4) t4(e4, s4, { get: i4[s4], enumerable: true });
            })(r2, { ParserError: () => De2, default: () => He2, parse: () => Pe2, tokenize: () => Oe2, visit: () => Fe2 });
            var n = { 92: () => {
            } }, a = {};
            function o(t5) {
              var e4 = a[t5];
              if (void 0 !== e4) return e4.exports;
              var i4 = a[t5] = { exports: {} };
              return n[t5](i4, i4.exports, o), i4.exports;
            }
            o.d = (t5, e4) => {
              for (var i4 in e4) o.o(e4, i4) && !o.o(t5, i4) && Object.defineProperty(t5, i4, { enumerable: true, get: e4[i4] });
            }, o.o = (t5, e4) => Object.prototype.hasOwnProperty.call(t5, e4);
            var l = {};
            (() => {
              o.d(l, { dx: () => Y3, q2: () => At3, FO: () => ve3, xf: () => Se3, Gy: () => Ne3, s4: () => Dt3, c7: () => Oe3, _7: () => le3, tx: () => Re3, gp: () => ge3, cK: () => wt3, zs: () => fe3, AV: () => Se3, Xp: () => g2, VS: () => T3, ul: () => W3, hW: () => Ht3, x1: () => Xt3, z5: () => ee3, oN: () => pe3, TB: () => de3, u1: () => me3, _b: () => Fe3, $F: () => se3, _T: () => Me2, db: () => re3, Zx: () => te3, _x: () => Ft3, r8: () => U3, JI: () => k3, TP: () => D2, WU: () => t5, Nj: () => c2, ZP: () => Xe2 });
              class t5 {
                constructor() {
                  this.source = null, this.type = null, this.channel = null, this.start = null, this.stop = null, this.tokenIndex = null, this.line = null, this.column = null, this._text = null;
                }
                getTokenSource() {
                  return this.source[0];
                }
                getInputStream() {
                  return this.source[1];
                }
                get text() {
                  return this._text;
                }
                set text(t6) {
                  this._text = t6;
                }
              }
              function e4(t6, e5) {
                if (!Array.isArray(t6) || !Array.isArray(e5)) return false;
                if (t6 === e5) return true;
                if (t6.length !== e5.length) return false;
                for (let i5 = 0; i5 < t6.length; i5++) if (!(t6[i5] === e5[i5] || t6[i5].equals && t6[i5].equals(e5[i5]))) return false;
                return true;
              }
              t5.INVALID_TYPE = 0, t5.EPSILON = -2, t5.MIN_USER_TOKEN_TYPE = 1, t5.EOF = -1, t5.DEFAULT_CHANNEL = 0, t5.HIDDEN_CHANNEL = 1;
              const i4 = Math.round(Math.random() * Math.pow(2, 32));
              function s4(t6) {
                if (!t6) return 0;
                const e5 = typeof t6, s5 = "string" === e5 ? t6 : !("object" !== e5 || !t6.toString) && t6.toString();
                if (!s5) return 0;
                let r4, n3;
                const a3 = 3 & s5.length, o2 = s5.length - a3;
                let l2 = i4;
                const h3 = 3432918353, c3 = 461845907;
                let u3 = 0;
                for (; u3 < o2; ) n3 = 255 & s5.charCodeAt(u3) | (255 & s5.charCodeAt(++u3)) << 8 | (255 & s5.charCodeAt(++u3)) << 16 | (255 & s5.charCodeAt(++u3)) << 24, ++u3, n3 = (65535 & n3) * h3 + (((n3 >>> 16) * h3 & 65535) << 16) & 4294967295, n3 = n3 << 15 | n3 >>> 17, n3 = (65535 & n3) * c3 + (((n3 >>> 16) * c3 & 65535) << 16) & 4294967295, l2 ^= n3, l2 = l2 << 13 | l2 >>> 19, r4 = 5 * (65535 & l2) + ((5 * (l2 >>> 16) & 65535) << 16) & 4294967295, l2 = 27492 + (65535 & r4) + ((58964 + (r4 >>> 16) & 65535) << 16);
                switch (n3 = 0, a3) {
                  case 3:
                    n3 ^= (255 & s5.charCodeAt(u3 + 2)) << 16;
                  case 2:
                    n3 ^= (255 & s5.charCodeAt(u3 + 1)) << 8;
                  case 1:
                    n3 ^= 255 & s5.charCodeAt(u3), n3 = (65535 & n3) * h3 + (((n3 >>> 16) * h3 & 65535) << 16) & 4294967295, n3 = n3 << 15 | n3 >>> 17, n3 = (65535 & n3) * c3 + (((n3 >>> 16) * c3 & 65535) << 16) & 4294967295, l2 ^= n3;
                }
                return l2 ^= s5.length, l2 ^= l2 >>> 16, l2 = 2246822507 * (65535 & l2) + ((2246822507 * (l2 >>> 16) & 65535) << 16) & 4294967295, l2 ^= l2 >>> 13, l2 = 3266489909 * (65535 & l2) + ((3266489909 * (l2 >>> 16) & 65535) << 16) & 4294967295, l2 ^= l2 >>> 16, l2 >>> 0;
              }
              class r3 {
                constructor() {
                  this.count = 0, this.hash = 0;
                }
                update() {
                  for (let t6 = 0; t6 < arguments.length; t6++) {
                    const e5 = arguments[t6];
                    if (null != e5) if (Array.isArray(e5)) this.update.apply(this, e5);
                    else {
                      let t7 = 0;
                      switch (typeof e5) {
                        case "undefined":
                        case "function":
                          continue;
                        case "number":
                        case "boolean":
                          t7 = e5;
                          break;
                        case "string":
                          t7 = s4(e5);
                          break;
                        default:
                          e5.updateHashCode ? e5.updateHashCode(this) : console.log("No updateHashCode for " + e5.toString());
                          continue;
                      }
                      t7 *= 3432918353, t7 = t7 << 15 | t7 >>> 17, t7 *= 461845907, this.count = this.count + 1;
                      let i5 = this.hash ^ t7;
                      i5 = i5 << 13 | i5 >>> 19, i5 = 5 * i5 + 3864292196, this.hash = i5;
                    }
                  }
                }
                finish() {
                  let t6 = this.hash ^ 4 * this.count;
                  return t6 ^= t6 >>> 16, t6 *= 2246822507, t6 ^= t6 >>> 13, t6 *= 3266489909, t6 ^= t6 >>> 16, t6;
                }
                static hashStuff() {
                  const t6 = new r3();
                  return t6.update.apply(t6, arguments), t6.finish();
                }
              }
              function n2(t6) {
                return t6 ? "string" == typeof t6 ? s4(t6) : t6.hashCode() : -1;
              }
              function a2(t6, e5) {
                return t6 ? t6.equals(e5) : t6 === e5;
              }
              function h2(t6) {
                return null === t6 ? "null" : t6;
              }
              function c2(t6) {
                return Array.isArray(t6) ? "[" + t6.map(h2).join(", ") + "]" : "null";
              }
              const u2 = "h-";
              class p2 {
                constructor(t6, e5) {
                  this.data = {}, this.hashFunction = t6 || n2, this.equalsFunction = e5 || a2;
                }
                add(t6) {
                  const e5 = u2 + this.hashFunction(t6);
                  if (e5 in this.data) {
                    const i5 = this.data[e5];
                    for (let e6 = 0; e6 < i5.length; e6++) if (this.equalsFunction(t6, i5[e6])) return i5[e6];
                    return i5.push(t6), t6;
                  }
                  return this.data[e5] = [t6], t6;
                }
                has(t6) {
                  return null != this.get(t6);
                }
                get(t6) {
                  const e5 = u2 + this.hashFunction(t6);
                  if (e5 in this.data) {
                    const i5 = this.data[e5];
                    for (let e6 = 0; e6 < i5.length; e6++) if (this.equalsFunction(t6, i5[e6])) return i5[e6];
                  }
                  return null;
                }
                values() {
                  return Object.keys(this.data).filter((t6) => t6.startsWith(u2)).flatMap((t6) => this.data[t6], this);
                }
                toString() {
                  return c2(this.values());
                }
                get length() {
                  return Object.keys(this.data).filter((t6) => t6.startsWith(u2)).map((t6) => this.data[t6].length, this).reduce((t6, e5) => t6 + e5, 0);
                }
              }
              class d2 {
                hashCode() {
                  const t6 = new r3();
                  return this.updateHashCode(t6), t6.finish();
                }
                evaluate(t6, e5) {
                }
                evalPrecedence(t6, e5) {
                  return this;
                }
                static andContext(t6, e5) {
                  if (null === t6 || t6 === d2.NONE) return e5;
                  if (null === e5 || e5 === d2.NONE) return t6;
                  const i5 = new m2(t6, e5);
                  return 1 === i5.opnds.length ? i5.opnds[0] : i5;
                }
                static orContext(t6, e5) {
                  if (null === t6) return e5;
                  if (null === e5) return t6;
                  if (t6 === d2.NONE || e5 === d2.NONE) return d2.NONE;
                  const i5 = new _3(t6, e5);
                  return 1 === i5.opnds.length ? i5.opnds[0] : i5;
                }
              }
              class m2 extends d2 {
                constructor(t6, e5) {
                  super();
                  const i5 = new p2();
                  t6 instanceof m2 ? t6.opnds.map(function(t7) {
                    i5.add(t7);
                  }) : i5.add(t6), e5 instanceof m2 ? e5.opnds.map(function(t7) {
                    i5.add(t7);
                  }) : i5.add(e5);
                  const s5 = x3(i5);
                  if (s5.length > 0) {
                    let t7 = null;
                    s5.map(function(e6) {
                      (null === t7 || e6.precedence < t7.precedence) && (t7 = e6);
                    }), i5.add(t7);
                  }
                  this.opnds = Array.from(i5.values());
                }
                equals(t6) {
                  return this === t6 || t6 instanceof m2 && e4(this.opnds, t6.opnds);
                }
                updateHashCode(t6) {
                  t6.update(this.opnds, "AND");
                }
                evaluate(t6, e5) {
                  for (let i5 = 0; i5 < this.opnds.length; i5++) if (!this.opnds[i5].evaluate(t6, e5)) return false;
                  return true;
                }
                evalPrecedence(t6, e5) {
                  let i5 = false;
                  const s5 = [];
                  for (let r5 = 0; r5 < this.opnds.length; r5++) {
                    const n3 = this.opnds[r5], a3 = n3.evalPrecedence(t6, e5);
                    if (i5 |= a3 !== n3, null === a3) return null;
                    a3 !== d2.NONE && s5.push(a3);
                  }
                  if (!i5) return this;
                  if (0 === s5.length) return d2.NONE;
                  let r4 = null;
                  return s5.map(function(t7) {
                    r4 = null === r4 ? t7 : d2.andContext(r4, t7);
                  }), r4;
                }
                toString() {
                  const t6 = this.opnds.map((t7) => t7.toString());
                  return (t6.length > 3 ? t6.slice(3) : t6).join("&&");
                }
              }
              class _3 extends d2 {
                constructor(t6, e5) {
                  super();
                  const i5 = new p2();
                  t6 instanceof _3 ? t6.opnds.map(function(t7) {
                    i5.add(t7);
                  }) : i5.add(t6), e5 instanceof _3 ? e5.opnds.map(function(t7) {
                    i5.add(t7);
                  }) : i5.add(e5);
                  const s5 = x3(i5);
                  if (s5.length > 0) {
                    const t7 = s5.sort(function(t8, e7) {
                      return t8.compareTo(e7);
                    }), e6 = t7[t7.length - 1];
                    i5.add(e6);
                  }
                  this.opnds = Array.from(i5.values());
                }
                equals(t6) {
                  return this === t6 || t6 instanceof _3 && e4(this.opnds, t6.opnds);
                }
                updateHashCode(t6) {
                  t6.update(this.opnds, "OR");
                }
                evaluate(t6, e5) {
                  for (let i5 = 0; i5 < this.opnds.length; i5++) if (this.opnds[i5].evaluate(t6, e5)) return true;
                  return false;
                }
                evalPrecedence(t6, e5) {
                  let i5 = false;
                  for (let r4 = 0; r4 < this.opnds.length; r4++) {
                    const n3 = this.opnds[r4], a3 = n3.evalPrecedence(t6, e5);
                    if (i5 |= a3 !== n3, a3 === d2.NONE) return d2.NONE;
                  }
                  return i5 ? (null) : this;
                }
                toString() {
                  const t6 = this.opnds.map((t7) => t7.toString());
                  return (t6.length > 3 ? t6.slice(3) : t6).join("||");
                }
              }
              function x3(t6) {
                const e5 = [];
                return t6.values().map(function(t7) {
                  t7 instanceof d2.PrecedencePredicate && e5.push(t7);
                }), e5;
              }
              function f2(t6, e5) {
                if (null === t6) {
                  const t7 = { state: null, alt: null, context: null, semanticContext: null };
                  return e5 && (t7.reachesIntoOuterContext = 0), t7;
                }
                {
                  const i5 = {};
                  return i5.state = t6.state || null, i5.alt = void 0 === t6.alt ? null : t6.alt, i5.context = t6.context || null, i5.semanticContext = t6.semanticContext || null, e5 && (i5.reachesIntoOuterContext = t6.reachesIntoOuterContext || 0, i5.precedenceFilterSuppressed = t6.precedenceFilterSuppressed || false), i5;
                }
              }
              class y3 {
                constructor(t6, e5) {
                  this.checkContext(t6, e5), t6 = f2(t6), e5 = f2(e5, true), this.state = null !== t6.state ? t6.state : e5.state, this.alt = null !== t6.alt ? t6.alt : e5.alt, this.context = null !== t6.context ? t6.context : e5.context, this.semanticContext = null !== t6.semanticContext ? t6.semanticContext : null !== e5.semanticContext ? e5.semanticContext : d2.NONE, this.reachesIntoOuterContext = e5.reachesIntoOuterContext, this.precedenceFilterSuppressed = e5.precedenceFilterSuppressed;
                }
                checkContext(t6, e5) {
                  null !== t6.context && void 0 !== t6.context || null !== e5 && null !== e5.context && void 0 !== e5.context || (this.context = null);
                }
                hashCode() {
                  const t6 = new r3();
                  return this.updateHashCode(t6), t6.finish();
                }
                updateHashCode(t6) {
                  t6.update(this.state.stateNumber, this.alt, this.context, this.semanticContext);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof y3 && this.state.stateNumber === t6.state.stateNumber && this.alt === t6.alt && (null === this.context ? null === t6.context : this.context.equals(t6.context)) && this.semanticContext.equals(t6.semanticContext) && this.precedenceFilterSuppressed === t6.precedenceFilterSuppressed;
                }
                hashCodeForConfigSet() {
                  const t6 = new r3();
                  return t6.update(this.state.stateNumber, this.alt, this.semanticContext), t6.finish();
                }
                equalsForConfigSet(t6) {
                  return this === t6 || t6 instanceof y3 && this.state.stateNumber === t6.state.stateNumber && this.alt === t6.alt && this.semanticContext.equals(t6.semanticContext);
                }
                toString() {
                  return "(" + this.state + "," + this.alt + (null !== this.context ? ",[" + this.context.toString() + "]" : "") + (this.semanticContext !== d2.NONE ? "," + this.semanticContext.toString() : "") + (this.reachesIntoOuterContext > 0 ? ",up=" + this.reachesIntoOuterContext : "") + ")";
                }
              }
              class g2 {
                constructor(t6, e5) {
                  this.start = t6, this.stop = e5;
                }
                clone() {
                  return new g2(this.start, this.stop);
                }
                contains(t6) {
                  return t6 >= this.start && t6 < this.stop;
                }
                toString() {
                  return this.start === this.stop - 1 ? this.start.toString() : this.start.toString() + ".." + (this.stop - 1).toString();
                }
                get length() {
                  return this.stop - this.start;
                }
              }
              g2.INVALID_INTERVAL = new g2(-1, -2);
              class T3 {
                constructor() {
                  this.intervals = null, this.readOnly = false;
                }
                first(e5) {
                  return null === this.intervals || 0 === this.intervals.length ? t5.INVALID_TYPE : this.intervals[0].start;
                }
                addOne(t6) {
                  this.addInterval(new g2(t6, t6 + 1));
                }
                addRange(t6, e5) {
                  this.addInterval(new g2(t6, e5 + 1));
                }
                addInterval(t6) {
                  if (null === this.intervals) this.intervals = [], this.intervals.push(t6.clone());
                  else {
                    for (let e5 = 0; e5 < this.intervals.length; e5++) {
                      const i5 = this.intervals[e5];
                      if (t6.stop < i5.start) return void this.intervals.splice(e5, 0, t6);
                      if (t6.stop === i5.start) return void (this.intervals[e5] = new g2(t6.start, i5.stop));
                      if (t6.start <= i5.stop) return this.intervals[e5] = new g2(Math.min(i5.start, t6.start), Math.max(i5.stop, t6.stop)), void this.reduce(e5);
                    }
                    this.intervals.push(t6.clone());
                  }
                }
                addSet(t6) {
                  return null !== t6.intervals && t6.intervals.forEach((t7) => this.addInterval(t7), this), this;
                }
                reduce(t6) {
                  if (t6 < this.intervals.length - 1) {
                    const e5 = this.intervals[t6], i5 = this.intervals[t6 + 1];
                    e5.stop >= i5.stop ? (this.intervals.splice(t6 + 1, 1), this.reduce(t6)) : e5.stop >= i5.start && (this.intervals[t6] = new g2(e5.start, i5.stop), this.intervals.splice(t6 + 1, 1));
                  }
                }
                complement(t6, e5) {
                  const i5 = new T3();
                  return i5.addInterval(new g2(t6, e5 + 1)), null !== this.intervals && this.intervals.forEach((t7) => i5.removeRange(t7)), i5;
                }
                contains(t6) {
                  if (null === this.intervals) return false;
                  for (let e5 = 0; e5 < this.intervals.length; e5++) if (this.intervals[e5].contains(t6)) return true;
                  return false;
                }
                removeRange(t6) {
                  if (t6.start === t6.stop - 1) this.removeOne(t6.start);
                  else if (null !== this.intervals) {
                    let e5 = 0;
                    for (let i5 = 0; i5 < this.intervals.length; i5++) {
                      const i6 = this.intervals[e5];
                      if (t6.stop <= i6.start) return;
                      if (t6.start > i6.start && t6.stop < i6.stop) {
                        this.intervals[e5] = new g2(i6.start, t6.start);
                        const s5 = new g2(t6.stop, i6.stop);
                        return void this.intervals.splice(e5, 0, s5);
                      }
                      t6.start <= i6.start && t6.stop >= i6.stop ? (this.intervals.splice(e5, 1), e5 -= 1) : t6.start < i6.stop ? this.intervals[e5] = new g2(i6.start, t6.start) : t6.stop < i6.stop && (this.intervals[e5] = new g2(t6.stop, i6.stop)), e5 += 1;
                    }
                  }
                }
                removeOne(t6) {
                  if (null !== this.intervals) for (let e5 = 0; e5 < this.intervals.length; e5++) {
                    const i5 = this.intervals[e5];
                    if (t6 < i5.start) return;
                    if (t6 === i5.start && t6 === i5.stop - 1) return void this.intervals.splice(e5, 1);
                    if (t6 === i5.start) return void (this.intervals[e5] = new g2(i5.start + 1, i5.stop));
                    if (t6 === i5.stop - 1) return void (this.intervals[e5] = new g2(i5.start, i5.stop - 1));
                    if (t6 < i5.stop - 1) {
                      const s5 = new g2(i5.start, t6);
                      return i5.start = t6 + 1, void this.intervals.splice(e5, 0, s5);
                    }
                  }
                }
                toString(t6, e5, i5) {
                  return t6 = t6 || null, e5 = e5 || null, i5 = i5 || false, null === this.intervals ? "{}" : null !== t6 || null !== e5 ? this.toTokenString(t6, e5) : i5 ? this.toCharString() : this.toIndexString();
                }
                toCharString() {
                  const e5 = [];
                  for (let i5 = 0; i5 < this.intervals.length; i5++) {
                    const s5 = this.intervals[i5];
                    s5.stop === s5.start + 1 ? s5.start === t5.EOF ? e5.push("<EOF>") : e5.push("'" + String.fromCharCode(s5.start) + "'") : e5.push("'" + String.fromCharCode(s5.start) + "'..'" + String.fromCharCode(s5.stop - 1) + "'");
                  }
                  return e5.length > 1 ? "{" + e5.join(", ") + "}" : e5[0];
                }
                toIndexString() {
                  const e5 = [];
                  for (let i5 = 0; i5 < this.intervals.length; i5++) {
                    const s5 = this.intervals[i5];
                    s5.stop === s5.start + 1 ? s5.start === t5.EOF ? e5.push("<EOF>") : e5.push(s5.start.toString()) : e5.push(s5.start.toString() + ".." + (s5.stop - 1).toString());
                  }
                  return e5.length > 1 ? "{" + e5.join(", ") + "}" : e5[0];
                }
                toTokenString(t6, e5) {
                  const i5 = [];
                  for (let s5 = 0; s5 < this.intervals.length; s5++) {
                    const r4 = this.intervals[s5];
                    for (let s6 = r4.start; s6 < r4.stop; s6++) i5.push(this.elementName(t6, e5, s6));
                  }
                  return i5.length > 1 ? "{" + i5.join(", ") + "}" : i5[0];
                }
                elementName(e5, i5, s5) {
                  return s5 === t5.EOF ? "<EOF>" : s5 === t5.EPSILON ? "<EPSILON>" : e5[s5] || i5[s5];
                }
                get length() {
                  return this.intervals.map((t6) => t6.length).reduce((t6, e5) => t6 + e5);
                }
              }
              class E2 {
                constructor() {
                  this.atn = null, this.stateNumber = E2.INVALID_STATE_NUMBER, this.stateType = null, this.ruleIndex = 0, this.epsilonOnlyTransitions = false, this.transitions = [], this.nextTokenWithinRule = null;
                }
                toString() {
                  return this.stateNumber;
                }
                equals(t6) {
                  return t6 instanceof E2 && this.stateNumber === t6.stateNumber;
                }
                isNonGreedyExitState() {
                  return false;
                }
                addTransition(t6, e5) {
                  void 0 === e5 && (e5 = -1), 0 === this.transitions.length ? this.epsilonOnlyTransitions = t6.isEpsilon : this.epsilonOnlyTransitions !== t6.isEpsilon && (this.epsilonOnlyTransitions = false), -1 === e5 ? this.transitions.push(t6) : this.transitions.splice(e5, 1, t6);
                }
              }
              E2.INVALID_TYPE = 0, E2.BASIC = 1, E2.RULE_START = 2, E2.BLOCK_START = 3, E2.PLUS_BLOCK_START = 4, E2.STAR_BLOCK_START = 5, E2.TOKEN_START = 6, E2.RULE_STOP = 7, E2.BLOCK_END = 8, E2.STAR_LOOP_BACK = 9, E2.STAR_LOOP_ENTRY = 10, E2.PLUS_LOOP_BACK = 11, E2.LOOP_END = 12, E2.serializationNames = ["INVALID", "BASIC", "RULE_START", "BLOCK_START", "PLUS_BLOCK_START", "STAR_BLOCK_START", "TOKEN_START", "RULE_STOP", "BLOCK_END", "STAR_LOOP_BACK", "STAR_LOOP_ENTRY", "PLUS_LOOP_BACK", "LOOP_END"], E2.INVALID_STATE_NUMBER = -1;
              class R3 extends E2 {
                constructor() {
                  return super(), this.stateType = E2.RULE_STOP, this;
                }
              }
              class v2 {
                constructor(t6) {
                  if (null == t6) throw "target cannot be null.";
                  this.target = t6, this.isEpsilon = false, this.label = null;
                }
              }
              v2.EPSILON = 1, v2.RANGE = 2, v2.RULE = 3, v2.PREDICATE = 4, v2.ATOM = 5, v2.ACTION = 6, v2.SET = 7, v2.NOT_SET = 8, v2.WILDCARD = 9, v2.PRECEDENCE = 10, v2.serializationNames = ["INVALID", "EPSILON", "RANGE", "RULE", "PREDICATE", "ATOM", "ACTION", "SET", "NOT_SET", "WILDCARD", "PRECEDENCE"], v2.serializationTypes = { EpsilonTransition: v2.EPSILON, RangeTransition: v2.RANGE, RuleTransition: v2.RULE, PredicateTransition: v2.PREDICATE, AtomTransition: v2.ATOM, ActionTransition: v2.ACTION, SetTransition: v2.SET, NotSetTransition: v2.NOT_SET, WildcardTransition: v2.WILDCARD, PrecedencePredicateTransition: v2.PRECEDENCE };
              class b2 extends v2 {
                constructor(t6, e5, i5, s5) {
                  super(t6), this.ruleIndex = e5, this.precedence = i5, this.followState = s5, this.serializationType = v2.RULE, this.isEpsilon = true;
                }
                matches(t6, e5, i5) {
                  return false;
                }
              }
              class L3 extends v2 {
                constructor(e5, i5) {
                  super(e5), this.serializationType = v2.SET, null != i5 ? this.label = i5 : (this.label = new T3(), this.label.addOne(t5.INVALID_TYPE));
                }
                matches(t6, e5, i5) {
                  return this.label.contains(t6);
                }
                toString() {
                  return this.label.toString();
                }
              }
              class S3 extends L3 {
                constructor(t6, e5) {
                  super(t6, e5), this.serializationType = v2.NOT_SET;
                }
                matches(t6, e5, i5) {
                  return t6 >= e5 && t6 <= i5 && !super.matches(t6, e5, i5);
                }
                toString() {
                  return "~" + super.toString();
                }
              }
              class C2 extends v2 {
                constructor(t6) {
                  super(t6), this.serializationType = v2.WILDCARD;
                }
                matches(t6, e5, i5) {
                  return t6 >= e5 && t6 <= i5;
                }
                toString() {
                  return ".";
                }
              }
              class A3 extends v2 {
                constructor(t6) {
                  super(t6);
                }
              }
              class w3 {
              }
              class N3 extends w3 {
              }
              class I3 extends N3 {
              }
              class k3 extends I3 {
                get ruleContext() {
                  throw new Error("missing interface implementation");
                }
              }
              class D2 extends I3 {
              }
              class O3 extends D2 {
              }
              const P3 = { toStringTree: function(t6, e5, i5) {
                e5 = e5 || null, null !== (i5 = i5 || null) && (e5 = i5.ruleNames);
                let s5 = P3.getNodeText(t6, e5);
                s5 = s5.replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r");
                const r4 = t6.getChildCount();
                if (0 === r4) return s5;
                let n3 = "(" + s5 + " ";
                r4 > 0 && (s5 = P3.toStringTree(t6.getChild(0), e5), n3 = n3.concat(s5));
                for (let i6 = 1; i6 < r4; i6++) s5 = P3.toStringTree(t6.getChild(i6), e5), n3 = n3.concat(" " + s5);
                return n3 = n3.concat(")"), n3;
              }, getNodeText: function(e5, i5, s5) {
                if (i5 = i5 || null, null !== (s5 = s5 || null) && (i5 = s5.ruleNames), null !== i5) {
                  if (e5 instanceof k3) {
                    const t6 = e5.ruleContext.getAltNumber();
                    return 0 != t6 ? i5[e5.ruleIndex] + ":" + t6 : i5[e5.ruleIndex];
                  }
                  if (e5 instanceof O3) return e5.toString();
                  if (e5 instanceof D2 && null !== e5.symbol) return e5.symbol.text;
                }
                const r4 = e5.getPayload();
                return r4 instanceof t5 ? r4.text : e5.getPayload().toString();
              }, getChildren: function(t6) {
                const e5 = [];
                for (let i5 = 0; i5 < t6.getChildCount(); i5++) e5.push(t6.getChild(i5));
                return e5;
              }, getAncestors: function(t6) {
                let e5 = [];
                for (t6 = t6.getParent(); null !== t6; ) e5 = [t6].concat(e5), t6 = t6.getParent();
                return e5;
              }, findAllTokenNodes: function(t6, e5) {
                return P3.findAllNodes(t6, e5, true);
              }, findAllRuleNodes: function(t6, e5) {
                return P3.findAllNodes(t6, e5, false);
              }, findAllNodes: function(t6, e5, i5) {
                const s5 = [];
                return P3._findAllNodes(t6, e5, i5, s5), s5;
              }, _findAllNodes: function(t6, e5, i5, s5) {
                i5 && t6 instanceof D2 ? t6.symbol.type === e5 && s5.push(t6) : !i5 && t6 instanceof k3 && t6.ruleIndex === e5 && s5.push(t6);
                for (let r4 = 0; r4 < t6.getChildCount(); r4++) P3._findAllNodes(t6.getChild(r4), e5, i5, s5);
              }, descendants: function(t6) {
                let e5 = [t6];
                for (let i5 = 0; i5 < t6.getChildCount(); i5++) e5 = e5.concat(P3.descendants(t6.getChild(i5)));
                return e5;
              } }, F2 = P3;
              class U3 extends k3 {
                constructor(t6, e5) {
                  super(), this.parentCtx = t6 || null, this.invokingState = e5 || -1;
                }
                depth() {
                  let t6 = 0, e5 = this;
                  for (; null !== e5; ) e5 = e5.parentCtx, t6 += 1;
                  return t6;
                }
                isEmpty() {
                  return -1 === this.invokingState;
                }
                getSourceInterval() {
                  return g2.INVALID_INTERVAL;
                }
                get ruleContext() {
                  return this;
                }
                getPayload() {
                  return this;
                }
                getText() {
                  return 0 === this.getChildCount() ? "" : this.children.map(function(t6) {
                    return t6.getText();
                  }).join("");
                }
                getAltNumber() {
                  return 0;
                }
                setAltNumber(t6) {
                }
                getChild(t6) {
                  return null;
                }
                getChildCount() {
                  return 0;
                }
                accept(t6) {
                  return t6.visitChildren(this);
                }
                toStringTree(t6, e5) {
                  return F2.toStringTree(this, t6, e5);
                }
                toString(t6, e5) {
                  t6 = t6 || null, e5 = e5 || null;
                  let i5 = this, s5 = "[";
                  for (; null !== i5 && i5 !== e5; ) {
                    if (null === t6) i5.isEmpty() || (s5 += i5.invokingState);
                    else {
                      const e6 = i5.ruleIndex;
                      s5 += e6 >= 0 && e6 < t6.length ? t6[e6] : "" + e6;
                    }
                    null === i5.parentCtx || null === t6 && i5.parentCtx.isEmpty() || (s5 += " "), i5 = i5.parentCtx;
                  }
                  return s5 += "]", s5;
                }
              }
              class H3 {
                constructor(t6) {
                  this.cachedHashCode = t6;
                }
                isEmpty() {
                  return this === H3.EMPTY;
                }
                hasEmptyPath() {
                  return this.getReturnState(this.length - 1) === H3.EMPTY_RETURN_STATE;
                }
                hashCode() {
                  return this.cachedHashCode;
                }
                updateHashCode(t6) {
                  t6.update(this.cachedHashCode);
                }
              }
              H3.EMPTY = null, H3.EMPTY_RETURN_STATE = 2147483647, H3.globalNodeCount = 1, H3.id = H3.globalNodeCount, H3.trace_atn_sim = false;
              class M3 extends H3 {
                constructor(t6, e5) {
                  const i5 = new r3();
                  return i5.update(t6, e5), super(i5.finish()), this.parents = t6, this.returnStates = e5, this;
                }
                isEmpty() {
                  return this.returnStates[0] === H3.EMPTY_RETURN_STATE;
                }
                getParent(t6) {
                  return this.parents[t6];
                }
                getReturnState(t6) {
                  return this.returnStates[t6];
                }
                equals(t6) {
                  return this === t6 || t6 instanceof M3 && this.hashCode() === t6.hashCode() && e4(this.returnStates, t6.returnStates) && e4(this.parents, t6.parents);
                }
                toString() {
                  if (this.isEmpty()) return "[]";
                  {
                    let t6 = "[";
                    for (let e5 = 0; e5 < this.returnStates.length; e5++) e5 > 0 && (t6 += ", "), this.returnStates[e5] !== H3.EMPTY_RETURN_STATE ? (t6 += this.returnStates[e5], null !== this.parents[e5] ? t6 = t6 + " " + this.parents[e5] : t6 += "null") : t6 += "$";
                    return t6 + "]";
                  }
                }
                get length() {
                  return this.returnStates.length;
                }
              }
              class K3 extends H3 {
                constructor(t6, e5) {
                  let i5 = 0;
                  const s5 = new r3();
                  null !== t6 ? s5.update(t6, e5) : s5.update(1), i5 = s5.finish(), super(i5), this.parentCtx = t6, this.returnState = e5;
                }
                getParent(t6) {
                  return this.parentCtx;
                }
                getReturnState(t6) {
                  return this.returnState;
                }
                equals(t6) {
                  return this === t6 || t6 instanceof K3 && this.hashCode() === t6.hashCode() && this.returnState === t6.returnState && (null == this.parentCtx ? null == t6.parentCtx : this.parentCtx.equals(t6.parentCtx));
                }
                toString() {
                  const t6 = null === this.parentCtx ? "" : this.parentCtx.toString();
                  return 0 === t6.length ? this.returnState === H3.EMPTY_RETURN_STATE ? "$" : "" + this.returnState : this.returnState + " " + t6;
                }
                get length() {
                  return 1;
                }
                static create(t6, e5) {
                  return e5 === H3.EMPTY_RETURN_STATE && null === t6 ? H3.EMPTY : new K3(t6, e5);
                }
              }
              class V3 extends K3 {
                constructor() {
                  super(null, H3.EMPTY_RETURN_STATE);
                }
                isEmpty() {
                  return true;
                }
                getParent(t6) {
                  return null;
                }
                getReturnState(t6) {
                  return this.returnState;
                }
                equals(t6) {
                  return this === t6;
                }
                toString() {
                  return "$";
                }
              }
              H3.EMPTY = new V3();
              const B3 = "h-";
              class $3 {
                constructor(t6, e5) {
                  this.data = {}, this.hashFunction = t6 || n2, this.equalsFunction = e5 || a2;
                }
                set(t6, e5) {
                  const i5 = B3 + this.hashFunction(t6);
                  if (i5 in this.data) {
                    const s5 = this.data[i5];
                    for (let i6 = 0; i6 < s5.length; i6++) {
                      const r4 = s5[i6];
                      if (this.equalsFunction(t6, r4.key)) {
                        const t7 = r4.value;
                        return r4.value = e5, t7;
                      }
                    }
                    return s5.push({ key: t6, value: e5 }), e5;
                  }
                  return this.data[i5] = [{ key: t6, value: e5 }], e5;
                }
                containsKey(t6) {
                  const e5 = B3 + this.hashFunction(t6);
                  if (e5 in this.data) {
                    const i5 = this.data[e5];
                    for (let e6 = 0; e6 < i5.length; e6++) {
                      const s5 = i5[e6];
                      if (this.equalsFunction(t6, s5.key)) return true;
                    }
                  }
                  return false;
                }
                get(t6) {
                  const e5 = B3 + this.hashFunction(t6);
                  if (e5 in this.data) {
                    const i5 = this.data[e5];
                    for (let e6 = 0; e6 < i5.length; e6++) {
                      const s5 = i5[e6];
                      if (this.equalsFunction(t6, s5.key)) return s5.value;
                    }
                  }
                  return null;
                }
                entries() {
                  return Object.keys(this.data).filter((t6) => t6.startsWith(B3)).flatMap((t6) => this.data[t6], this);
                }
                getKeys() {
                  return this.entries().map((t6) => t6.key);
                }
                getValues() {
                  return this.entries().map((t6) => t6.value);
                }
                toString() {
                  return "[" + this.entries().map((t6) => "{" + t6.key + ":" + t6.value + "}").join(", ") + "]";
                }
                get length() {
                  return Object.keys(this.data).filter((t6) => t6.startsWith(B3)).map((t6) => this.data[t6].length, this).reduce((t6, e5) => t6 + e5, 0);
                }
              }
              function j2(t6, e5) {
                if (null == e5 && (e5 = U3.EMPTY), null === e5.parentCtx || e5 === U3.EMPTY) return H3.EMPTY;
                const i5 = j2(t6, e5.parentCtx), s5 = t6.states[e5.invokingState].transitions[0];
                return K3.create(i5, s5.followState.stateNumber);
              }
              function G3(t6, e5, i5) {
                if (t6.isEmpty()) return t6;
                let s5 = i5.get(t6) || null;
                if (null !== s5) return s5;
                if (s5 = e5.get(t6), null !== s5) return i5.set(t6, s5), s5;
                let r4 = false, n3 = [];
                for (let s6 = 0; s6 < n3.length; s6++) {
                  const a4 = G3(t6.getParent(s6), e5, i5);
                  if (r4 || a4 !== t6.getParent(s6)) {
                    if (!r4) {
                      n3 = [];
                      for (let e6 = 0; e6 < t6.length; e6++) n3[e6] = t6.getParent(e6);
                      r4 = true;
                    }
                    n3[s6] = a4;
                  }
                }
                if (!r4) return e5.add(t6), i5.set(t6, t6), t6;
                let a3 = null;
                return a3 = 0 === n3.length ? H3.EMPTY : 1 === n3.length ? K3.create(n3[0], t6.getReturnState(0)) : new M3(n3, t6.returnStates), e5.add(a3), i5.set(a3, a3), i5.set(t6, a3), a3;
              }
              function z3(t6, e5, i5, s5) {
                if (t6 === e5) return t6;
                if (t6 instanceof K3 && e5 instanceof K3) return function(t7, e6, i6, s6) {
                  if (null !== s6) {
                    let i7 = s6.get(t7, e6);
                    if (null !== i7) return i7;
                    if (i7 = s6.get(e6, t7), null !== i7) return i7;
                  }
                  const r4 = function(t8, e7, i7) {
                    if (i7) {
                      if (t8 === H3.EMPTY) return H3.EMPTY;
                      if (e7 === H3.EMPTY) return H3.EMPTY;
                    } else {
                      if (t8 === H3.EMPTY && e7 === H3.EMPTY) return H3.EMPTY;
                      if (t8 === H3.EMPTY) {
                        const t9 = [e7.returnState, H3.EMPTY_RETURN_STATE], i8 = [e7.parentCtx, null];
                        return new M3(i8, t9);
                      }
                      if (e7 === H3.EMPTY) {
                        const e8 = [t8.returnState, H3.EMPTY_RETURN_STATE], i8 = [t8.parentCtx, null];
                        return new M3(i8, e8);
                      }
                    }
                    return null;
                  }(t7, e6, i6);
                  if (null !== r4) return null !== s6 && s6.set(t7, e6, r4), r4;
                  if (t7.returnState === e6.returnState) {
                    const r5 = z3(t7.parentCtx, e6.parentCtx, i6, s6);
                    if (r5 === t7.parentCtx) return t7;
                    if (r5 === e6.parentCtx) return e6;
                    const n3 = K3.create(r5, t7.returnState);
                    return null !== s6 && s6.set(t7, e6, n3), n3;
                  }
                  {
                    let i7 = null;
                    if ((t7 === e6 || null !== t7.parentCtx && t7.parentCtx === e6.parentCtx) && (i7 = t7.parentCtx), null !== i7) {
                      const r6 = [t7.returnState, e6.returnState];
                      t7.returnState > e6.returnState && (r6[0] = e6.returnState, r6[1] = t7.returnState);
                      const n4 = new M3([i7, i7], r6);
                      return null !== s6 && s6.set(t7, e6, n4), n4;
                    }
                    const r5 = [t7.returnState, e6.returnState];
                    let n3 = [t7.parentCtx, e6.parentCtx];
                    t7.returnState > e6.returnState && (r5[0] = e6.returnState, r5[1] = t7.returnState, n3 = [e6.parentCtx, t7.parentCtx]);
                    const a3 = new M3(n3, r5);
                    return null !== s6 && s6.set(t7, e6, a3), a3;
                  }
                }(t6, e5, i5, s5);
                if (i5) {
                  if (t6 instanceof V3) return t6;
                  if (e5 instanceof V3) return e5;
                }
                return t6 instanceof K3 && (t6 = new M3([t6.getParent()], [t6.returnState])), e5 instanceof K3 && (e5 = new M3([e5.getParent()], [e5.returnState])), function(t7, e6, i6, s6) {
                  if (null !== s6) {
                    let i7 = s6.get(t7, e6);
                    if (null !== i7) return H3.trace_atn_sim && console.log("mergeArrays a=" + t7 + ",b=" + e6 + " -> previous"), i7;
                    if (i7 = s6.get(e6, t7), null !== i7) return H3.trace_atn_sim && console.log("mergeArrays a=" + t7 + ",b=" + e6 + " -> previous"), i7;
                  }
                  let r4 = 0, n3 = 0, a3 = 0, o2 = new Array(t7.returnStates.length + e6.returnStates.length).fill(0), l2 = new Array(t7.returnStates.length + e6.returnStates.length).fill(null);
                  for (; r4 < t7.returnStates.length && n3 < e6.returnStates.length; ) {
                    const h4 = t7.parents[r4], c3 = e6.parents[n3];
                    if (t7.returnStates[r4] === e6.returnStates[n3]) {
                      const e7 = t7.returnStates[r4];
                      e7 === H3.EMPTY_RETURN_STATE && null === h4 && null === c3 || null !== h4 && null !== c3 && h4 === c3 ? (l2[a3] = h4, o2[a3] = e7) : (l2[a3] = z3(h4, c3, i6, s6), o2[a3] = e7), r4 += 1, n3 += 1;
                    } else t7.returnStates[r4] < e6.returnStates[n3] ? (l2[a3] = h4, o2[a3] = t7.returnStates[r4], r4 += 1) : (l2[a3] = c3, o2[a3] = e6.returnStates[n3], n3 += 1);
                    a3 += 1;
                  }
                  if (r4 < t7.returnStates.length) for (let e7 = r4; e7 < t7.returnStates.length; e7++) l2[a3] = t7.parents[e7], o2[a3] = t7.returnStates[e7], a3 += 1;
                  else for (let t8 = n3; t8 < e6.returnStates.length; t8++) l2[a3] = e6.parents[t8], o2[a3] = e6.returnStates[t8], a3 += 1;
                  if (a3 < l2.length) {
                    if (1 === a3) {
                      const i7 = K3.create(l2[0], o2[0]);
                      return null !== s6 && s6.set(t7, e6, i7), i7;
                    }
                    l2 = l2.slice(0, a3), o2 = o2.slice(0, a3);
                  }
                  const h3 = new M3(l2, o2);
                  return h3.equals(t7) ? (null !== s6 && s6.set(t7, e6, t7), H3.trace_atn_sim && console.log("mergeArrays a=" + t7 + ",b=" + e6 + " -> a"), t7) : h3.equals(e6) ? (null !== s6 && s6.set(t7, e6, e6), H3.trace_atn_sim && console.log("mergeArrays a=" + t7 + ",b=" + e6 + " -> b"), e6) : (function(t8) {
                    const e7 = new $3();
                    for (let i7 = 0; i7 < t8.length; i7++) {
                      const s7 = t8[i7];
                      e7.containsKey(s7) || e7.set(s7, s7);
                    }
                    for (let i7 = 0; i7 < t8.length; i7++) t8[i7] = e7.get(t8[i7]);
                  }(l2), null !== s6 && s6.set(t7, e6, h3), H3.trace_atn_sim && console.log("mergeArrays a=" + t7 + ",b=" + e6 + " -> " + h3), h3);
                }(t6, e5, i5, s5);
              }
              class q3 {
                constructor() {
                  this.data = [];
                }
                add(t6) {
                  this.data[t6] = true;
                }
                or(t6) {
                  Object.keys(t6.data).map((t7) => this.add(t7), this);
                }
                remove(t6) {
                  delete this.data[t6];
                }
                has(t6) {
                  return true === this.data[t6];
                }
                values() {
                  return Object.keys(this.data);
                }
                minValue() {
                  return Math.min.apply(null, this.values());
                }
                hashCode() {
                  return r3.hashStuff(this.values());
                }
                equals(t6) {
                  return t6 instanceof q3 && e4(this.data, t6.data);
                }
                toString() {
                  return "{" + this.values().join(", ") + "}";
                }
                get length() {
                  return this.values().length;
                }
              }
              class W3 {
                constructor(t6) {
                  this.atn = t6;
                }
                getDecisionLookahead(t6) {
                  if (null === t6) return null;
                  const e5 = t6.transitions.length, i5 = [];
                  for (let s5 = 0; s5 < e5; s5++) {
                    i5[s5] = new T3();
                    const e6 = new p2(), r4 = false;
                    this._LOOK(t6.transition(s5).target, null, H3.EMPTY, i5[s5], e6, new q3(), r4, false), (0 === i5[s5].length || i5[s5].contains(W3.HIT_PRED)) && (i5[s5] = null);
                  }
                  return i5;
                }
                LOOK(t6, e5, i5) {
                  const s5 = new T3(), r4 = null !== (i5 = i5 || null) ? j2(t6.atn, i5) : null;
                  return this._LOOK(t6, e5, r4, s5, new p2(), new q3(), true, true), s5;
                }
                _LOOK(e5, i5, s5, r4, n3, a3, o2, l2) {
                  const h3 = new y3({ state: e5, alt: 0, context: s5 }, null);
                  if (!n3.has(h3)) {
                    if (n3.add(h3), e5 === i5) {
                      if (null === s5) return void r4.addOne(t5.EPSILON);
                      if (s5.isEmpty() && l2) return void r4.addOne(t5.EOF);
                    }
                    if (e5 instanceof R3) {
                      if (null === s5) return void r4.addOne(t5.EPSILON);
                      if (s5.isEmpty() && l2) return void r4.addOne(t5.EOF);
                      if (s5 !== H3.EMPTY) {
                        const t6 = a3.has(e5.ruleIndex);
                        try {
                          a3.remove(e5.ruleIndex);
                          for (let t7 = 0; t7 < s5.length; t7++) {
                            const e6 = this.atn.states[s5.getReturnState(t7)];
                            this._LOOK(e6, i5, s5.getParent(t7), r4, n3, a3, o2, l2);
                          }
                        } finally {
                          t6 && a3.add(e5.ruleIndex);
                        }
                        return;
                      }
                    }
                    for (let h4 = 0; h4 < e5.transitions.length; h4++) {
                      const c3 = e5.transitions[h4];
                      if (c3.constructor === b2) {
                        if (a3.has(c3.target.ruleIndex)) continue;
                        const t6 = K3.create(s5, c3.followState.stateNumber);
                        try {
                          a3.add(c3.target.ruleIndex), this._LOOK(c3.target, i5, t6, r4, n3, a3, o2, l2);
                        } finally {
                          a3.remove(c3.target.ruleIndex);
                        }
                      } else if (c3 instanceof A3) o2 ? this._LOOK(c3.target, i5, s5, r4, n3, a3, o2, l2) : r4.addOne(W3.HIT_PRED);
                      else if (c3.isEpsilon) this._LOOK(c3.target, i5, s5, r4, n3, a3, o2, l2);
                      else if (c3.constructor === C2) r4.addRange(t5.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType);
                      else {
                        let e6 = c3.label;
                        null !== e6 && (c3 instanceof S3 && (e6 = e6.complement(t5.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType)), r4.addSet(e6));
                      }
                    }
                  }
                }
              }
              W3.HIT_PRED = t5.INVALID_TYPE;
              class Y3 {
                constructor(t6, e5) {
                  this.grammarType = t6, this.maxTokenType = e5, this.states = [], this.decisionToState = [], this.ruleToStartState = [], this.ruleToStopState = null, this.modeNameToStartState = {}, this.ruleToTokenType = null, this.lexerActions = null, this.modeToStartState = [];
                }
                nextTokensInContext(t6, e5) {
                  return new W3(this).LOOK(t6, null, e5);
                }
                nextTokensNoContext(t6) {
                  return null !== t6.nextTokenWithinRule || (t6.nextTokenWithinRule = this.nextTokensInContext(t6, null), t6.nextTokenWithinRule.readOnly = true), t6.nextTokenWithinRule;
                }
                nextTokens(t6, e5) {
                  return void 0 === e5 ? this.nextTokensNoContext(t6) : this.nextTokensInContext(t6, e5);
                }
                addState(t6) {
                  null !== t6 && (t6.atn = this, t6.stateNumber = this.states.length), this.states.push(t6);
                }
                removeState(t6) {
                  this.states[t6.stateNumber] = null;
                }
                defineDecisionState(t6) {
                  return this.decisionToState.push(t6), t6.decision = this.decisionToState.length - 1, t6.decision;
                }
                getDecisionState(t6) {
                  return 0 === this.decisionToState.length ? null : this.decisionToState[t6];
                }
                getExpectedTokens(e5, i5) {
                  if (e5 < 0 || e5 >= this.states.length) throw "Invalid state number.";
                  const s5 = this.states[e5];
                  let r4 = this.nextTokens(s5);
                  if (!r4.contains(t5.EPSILON)) return r4;
                  const n3 = new T3();
                  for (n3.addSet(r4), n3.removeOne(t5.EPSILON); null !== i5 && i5.invokingState >= 0 && r4.contains(t5.EPSILON); ) {
                    const e6 = this.states[i5.invokingState].transitions[0];
                    r4 = this.nextTokens(e6.followState), n3.addSet(r4), n3.removeOne(t5.EPSILON), i5 = i5.parentCtx;
                  }
                  return r4.contains(t5.EPSILON) && n3.addOne(t5.EOF), n3;
                }
              }
              Y3.INVALID_ALT_NUMBER = 0;
              class X2 extends E2 {
                constructor() {
                  super(), this.stateType = E2.BASIC;
                }
              }
              class J3 extends E2 {
                constructor() {
                  return super(), this.decision = -1, this.nonGreedy = false, this;
                }
              }
              class Q3 extends J3 {
                constructor() {
                  return super(), this.endState = null, this;
                }
              }
              class Z3 extends E2 {
                constructor() {
                  return super(), this.stateType = E2.BLOCK_END, this.startState = null, this;
                }
              }
              class tt3 extends E2 {
                constructor() {
                  return super(), this.stateType = E2.LOOP_END, this.loopBackState = null, this;
                }
              }
              class et3 extends E2 {
                constructor() {
                  return super(), this.stateType = E2.RULE_START, this.stopState = null, this.isPrecedenceRule = false, this;
                }
              }
              class it3 extends J3 {
                constructor() {
                  return super(), this.stateType = E2.TOKEN_START, this;
                }
              }
              class st3 extends J3 {
                constructor() {
                  return super(), this.stateType = E2.PLUS_LOOP_BACK, this;
                }
              }
              class rt3 extends E2 {
                constructor() {
                  return super(), this.stateType = E2.STAR_LOOP_BACK, this;
                }
              }
              class nt3 extends J3 {
                constructor() {
                  return super(), this.stateType = E2.STAR_LOOP_ENTRY, this.loopBackState = null, this.isPrecedenceDecision = null, this;
                }
              }
              class at3 extends Q3 {
                constructor() {
                  return super(), this.stateType = E2.PLUS_BLOCK_START, this.loopBackState = null, this;
                }
              }
              class ot3 extends Q3 {
                constructor() {
                  return super(), this.stateType = E2.STAR_BLOCK_START, this;
                }
              }
              class lt3 extends Q3 {
                constructor() {
                  return super(), this.stateType = E2.BLOCK_START, this;
                }
              }
              class ht3 extends v2 {
                constructor(t6, e5) {
                  super(t6), this.label_ = e5, this.label = this.makeLabel(), this.serializationType = v2.ATOM;
                }
                makeLabel() {
                  const t6 = new T3();
                  return t6.addOne(this.label_), t6;
                }
                matches(t6, e5, i5) {
                  return this.label_ === t6;
                }
                toString() {
                  return this.label_;
                }
              }
              class ct3 extends v2 {
                constructor(t6, e5, i5) {
                  super(t6), this.serializationType = v2.RANGE, this.start = e5, this.stop = i5, this.label = this.makeLabel();
                }
                makeLabel() {
                  const t6 = new T3();
                  return t6.addRange(this.start, this.stop), t6;
                }
                matches(t6, e5, i5) {
                  return t6 >= this.start && t6 <= this.stop;
                }
                toString() {
                  return "'" + String.fromCharCode(this.start) + "'..'" + String.fromCharCode(this.stop) + "'";
                }
              }
              class ut3 extends v2 {
                constructor(t6, e5, i5, s5) {
                  super(t6), this.serializationType = v2.ACTION, this.ruleIndex = e5, this.actionIndex = void 0 === i5 ? -1 : i5, this.isCtxDependent = void 0 !== s5 && s5, this.isEpsilon = true;
                }
                matches(t6, e5, i5) {
                  return false;
                }
                toString() {
                  return "action_" + this.ruleIndex + ":" + this.actionIndex;
                }
              }
              class pt3 extends v2 {
                constructor(t6, e5) {
                  super(t6), this.serializationType = v2.EPSILON, this.isEpsilon = true, this.outermostPrecedenceReturn = e5;
                }
                matches(t6, e5, i5) {
                  return false;
                }
                toString() {
                  return "epsilon";
                }
              }
              class dt3 extends d2 {
                constructor(t6, e5, i5) {
                  super(), this.ruleIndex = void 0 === t6 ? -1 : t6, this.predIndex = void 0 === e5 ? -1 : e5, this.isCtxDependent = void 0 !== i5 && i5;
                }
                evaluate(t6, e5) {
                  const i5 = this.isCtxDependent ? e5 : null;
                  return t6.sempred(i5, this.ruleIndex, this.predIndex);
                }
                updateHashCode(t6) {
                  t6.update(this.ruleIndex, this.predIndex, this.isCtxDependent);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof dt3 && this.ruleIndex === t6.ruleIndex && this.predIndex === t6.predIndex && this.isCtxDependent === t6.isCtxDependent;
                }
                toString() {
                  return "{" + this.ruleIndex + ":" + this.predIndex + "}?";
                }
              }
              d2.NONE = new dt3();
              class mt3 extends A3 {
                constructor(t6, e5, i5, s5) {
                  super(t6), this.serializationType = v2.PREDICATE, this.ruleIndex = e5, this.predIndex = i5, this.isCtxDependent = s5, this.isEpsilon = true;
                }
                matches(t6, e5, i5) {
                  return false;
                }
                getPredicate() {
                  return new dt3(this.ruleIndex, this.predIndex, this.isCtxDependent);
                }
                toString() {
                  return "pred_" + this.ruleIndex + ":" + this.predIndex;
                }
              }
              class _t3 extends d2 {
                constructor(t6) {
                  super(), this.precedence = void 0 === t6 ? 0 : t6;
                }
                evaluate(t6, e5) {
                  return t6.precpred(e5, this.precedence);
                }
                evalPrecedence(t6, e5) {
                  return t6.precpred(e5, this.precedence) ? d2.NONE : null;
                }
                compareTo(t6) {
                  return this.precedence - t6.precedence;
                }
                updateHashCode(t6) {
                  t6.update(this.precedence);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof _t3 && this.precedence === t6.precedence;
                }
                toString() {
                  return "{" + this.precedence + ">=prec}?";
                }
              }
              d2.PrecedencePredicate = _t3;
              class xt3 extends A3 {
                constructor(t6, e5) {
                  super(t6), this.serializationType = v2.PRECEDENCE, this.precedence = e5, this.isEpsilon = true;
                }
                matches(t6, e5, i5) {
                  return false;
                }
                getPredicate() {
                  return new _t3(this.precedence);
                }
                toString() {
                  return this.precedence + " >= _p";
                }
              }
              class ft3 {
                constructor(t6) {
                  void 0 === t6 && (t6 = null), this.readOnly = false, this.verifyATN = null === t6 || t6.verifyATN, this.generateRuleBypassTransitions = null !== t6 && t6.generateRuleBypassTransitions;
                }
              }
              ft3.defaultOptions = new ft3(), ft3.defaultOptions.readOnly = true;
              class yt2 {
                constructor(t6) {
                  this.actionType = t6, this.isPositionDependent = false;
                }
                hashCode() {
                  const t6 = new r3();
                  return this.updateHashCode(t6), t6.finish();
                }
                updateHashCode(t6) {
                  t6.update(this.actionType);
                }
                equals(t6) {
                  return this === t6;
                }
              }
              class gt3 extends yt2 {
                constructor() {
                  super(6);
                }
                execute(t6) {
                  t6.skip();
                }
                toString() {
                  return "skip";
                }
              }
              gt3.INSTANCE = new gt3();
              class Tt3 extends yt2 {
                constructor(t6) {
                  super(0), this.channel = t6;
                }
                execute(t6) {
                  t6._channel = this.channel;
                }
                updateHashCode(t6) {
                  t6.update(this.actionType, this.channel);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof Tt3 && this.channel === t6.channel;
                }
                toString() {
                  return "channel(" + this.channel + ")";
                }
              }
              class Et3 extends yt2 {
                constructor(t6, e5) {
                  super(1), this.ruleIndex = t6, this.actionIndex = e5, this.isPositionDependent = true;
                }
                execute(t6) {
                  t6.action(null, this.ruleIndex, this.actionIndex);
                }
                updateHashCode(t6) {
                  t6.update(this.actionType, this.ruleIndex, this.actionIndex);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof Et3 && this.ruleIndex === t6.ruleIndex && this.actionIndex === t6.actionIndex;
                }
              }
              class Rt3 extends yt2 {
                constructor() {
                  super(3);
                }
                execute(t6) {
                  t6.more();
                }
                toString() {
                  return "more";
                }
              }
              Rt3.INSTANCE = new Rt3();
              class vt3 extends yt2 {
                constructor(t6) {
                  super(7), this.type = t6;
                }
                execute(t6) {
                  t6.type = this.type;
                }
                updateHashCode(t6) {
                  t6.update(this.actionType, this.type);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof vt3 && this.type === t6.type;
                }
                toString() {
                  return "type(" + this.type + ")";
                }
              }
              class bt3 extends yt2 {
                constructor(t6) {
                  super(5), this.mode = t6;
                }
                execute(t6) {
                  t6.pushMode(this.mode);
                }
                updateHashCode(t6) {
                  t6.update(this.actionType, this.mode);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof bt3 && this.mode === t6.mode;
                }
                toString() {
                  return "pushMode(" + this.mode + ")";
                }
              }
              class Lt3 extends yt2 {
                constructor() {
                  super(4);
                }
                execute(t6) {
                  t6.popMode();
                }
                toString() {
                  return "popMode";
                }
              }
              Lt3.INSTANCE = new Lt3();
              class St3 extends yt2 {
                constructor(t6) {
                  super(2), this.mode = t6;
                }
                execute(t6) {
                  t6.mode(this.mode);
                }
                updateHashCode(t6) {
                  t6.update(this.actionType, this.mode);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof St3 && this.mode === t6.mode;
                }
                toString() {
                  return "mode(" + this.mode + ")";
                }
              }
              function Ct3(t6, e5) {
                const i5 = [];
                return i5[t6 - 1] = e5, i5.map(function(t7) {
                  return e5;
                });
              }
              class At3 {
                constructor(t6) {
                  null == t6 && (t6 = ft3.defaultOptions), this.deserializationOptions = t6, this.stateFactories = null, this.actionFactories = null;
                }
                deserialize(t6) {
                  const e5 = this.reset(t6);
                  this.checkVersion(e5), e5 && this.skipUUID();
                  const i5 = this.readATN();
                  this.readStates(i5, e5), this.readRules(i5, e5), this.readModes(i5);
                  const s5 = [];
                  return this.readSets(i5, s5, this.readInt.bind(this)), e5 && this.readSets(i5, s5, this.readInt32.bind(this)), this.readEdges(i5, s5), this.readDecisions(i5), this.readLexerActions(i5, e5), this.markPrecedenceDecisions(i5), this.verifyATN(i5), this.deserializationOptions.generateRuleBypassTransitions && 1 === i5.grammarType && (this.generateRuleBypassTransitions(i5), this.verifyATN(i5)), i5;
                }
                reset(t6) {
                  if (3 === (t6.charCodeAt ? t6.charCodeAt(0) : t6[0])) {
                    const e5 = function(t7) {
                      const e6 = t7.charCodeAt(0);
                      return e6 > 1 ? e6 - 2 : e6 + 65534;
                    }, i5 = t6.split("").map(e5);
                    return i5[0] = t6.charCodeAt(0), this.data = i5, this.pos = 0, true;
                  }
                  return this.data = t6, this.pos = 0, false;
                }
                skipUUID() {
                  let t6 = 0;
                  for (; t6++ < 8; ) this.readInt();
                }
                checkVersion(t6) {
                  const e5 = this.readInt();
                  if (!t6 && 4 !== e5) throw "Could not deserialize ATN with version " + e5 + " (expected 4).";
                }
                readATN() {
                  const t6 = this.readInt(), e5 = this.readInt();
                  return new Y3(t6, e5);
                }
                readStates(t6, e5) {
                  let i5, s5, r4;
                  const n3 = [], a3 = [], o2 = this.readInt();
                  for (let i6 = 0; i6 < o2; i6++) {
                    const i7 = this.readInt();
                    if (i7 === E2.INVALID_TYPE) {
                      t6.addState(null);
                      continue;
                    }
                    let s6 = this.readInt();
                    e5 && 65535 === s6 && (s6 = -1);
                    const r5 = this.stateFactory(i7, s6);
                    if (i7 === E2.LOOP_END) {
                      const t7 = this.readInt();
                      n3.push([r5, t7]);
                    } else if (r5 instanceof Q3) {
                      const t7 = this.readInt();
                      a3.push([r5, t7]);
                    }
                    t6.addState(r5);
                  }
                  for (i5 = 0; i5 < n3.length; i5++) s5 = n3[i5], s5[0].loopBackState = t6.states[s5[1]];
                  for (i5 = 0; i5 < a3.length; i5++) s5 = a3[i5], s5[0].endState = t6.states[s5[1]];
                  let l2 = this.readInt();
                  for (i5 = 0; i5 < l2; i5++) r4 = this.readInt(), t6.states[r4].nonGreedy = true;
                  let h3 = this.readInt();
                  for (i5 = 0; i5 < h3; i5++) r4 = this.readInt(), t6.states[r4].isPrecedenceRule = true;
                }
                readRules(e5, i5) {
                  let s5;
                  const r4 = this.readInt();
                  for (0 === e5.grammarType && (e5.ruleToTokenType = Ct3(r4, 0)), e5.ruleToStartState = Ct3(r4, 0), s5 = 0; s5 < r4; s5++) {
                    const r5 = this.readInt();
                    if (e5.ruleToStartState[s5] = e5.states[r5], 0 === e5.grammarType) {
                      let r6 = this.readInt();
                      i5 && 65535 === r6 && (r6 = t5.EOF), e5.ruleToTokenType[s5] = r6;
                    }
                  }
                  for (e5.ruleToStopState = Ct3(r4, 0), s5 = 0; s5 < e5.states.length; s5++) {
                    const t6 = e5.states[s5];
                    t6 instanceof R3 && (e5.ruleToStopState[t6.ruleIndex] = t6, e5.ruleToStartState[t6.ruleIndex].stopState = t6);
                  }
                }
                readModes(t6) {
                  const e5 = this.readInt();
                  for (let i5 = 0; i5 < e5; i5++) {
                    let e6 = this.readInt();
                    t6.modeToStartState.push(t6.states[e6]);
                  }
                }
                readSets(t6, e5, i5) {
                  const s5 = this.readInt();
                  for (let t7 = 0; t7 < s5; t7++) {
                    const t8 = new T3();
                    e5.push(t8);
                    const s6 = this.readInt();
                    0 !== this.readInt() && t8.addOne(-1);
                    for (let e6 = 0; e6 < s6; e6++) {
                      const e7 = i5(), s7 = i5();
                      t8.addRange(e7, s7);
                    }
                  }
                }
                readEdges(t6, e5) {
                  let i5, s5, r4, n3, a3;
                  const o2 = this.readInt();
                  for (i5 = 0; i5 < o2; i5++) {
                    const i6 = this.readInt(), s6 = this.readInt(), r5 = this.readInt(), a4 = this.readInt(), o3 = this.readInt(), l2 = this.readInt();
                    n3 = this.edgeFactory(t6, r5, i6, s6, a4, o3, l2, e5), t6.states[i6].addTransition(n3);
                  }
                  for (i5 = 0; i5 < t6.states.length; i5++) for (r4 = t6.states[i5], s5 = 0; s5 < r4.transitions.length; s5++) {
                    const e6 = r4.transitions[s5];
                    if (!(e6 instanceof b2)) continue;
                    let i6 = -1;
                    t6.ruleToStartState[e6.target.ruleIndex].isPrecedenceRule && 0 === e6.precedence && (i6 = e6.target.ruleIndex), n3 = new pt3(e6.followState, i6), t6.ruleToStopState[e6.target.ruleIndex].addTransition(n3);
                  }
                  for (i5 = 0; i5 < t6.states.length; i5++) {
                    if (r4 = t6.states[i5], r4 instanceof Q3) {
                      if (null === r4.endState) throw "IllegalState";
                      if (null !== r4.endState.startState) throw "IllegalState";
                      r4.endState.startState = r4;
                    }
                    if (r4 instanceof st3) for (s5 = 0; s5 < r4.transitions.length; s5++) a3 = r4.transitions[s5].target, a3 instanceof at3 && (a3.loopBackState = r4);
                    else if (r4 instanceof rt3) for (s5 = 0; s5 < r4.transitions.length; s5++) a3 = r4.transitions[s5].target, a3 instanceof nt3 && (a3.loopBackState = r4);
                  }
                }
                readDecisions(t6) {
                  const e5 = this.readInt();
                  for (let i5 = 0; i5 < e5; i5++) {
                    const e6 = this.readInt(), s5 = t6.states[e6];
                    t6.decisionToState.push(s5), s5.decision = i5;
                  }
                }
                readLexerActions(t6, e5) {
                  if (0 === t6.grammarType) {
                    const i5 = this.readInt();
                    t6.lexerActions = Ct3(i5, null);
                    for (let s5 = 0; s5 < i5; s5++) {
                      const i6 = this.readInt();
                      let r4 = this.readInt();
                      e5 && 65535 === r4 && (r4 = -1);
                      let n3 = this.readInt();
                      e5 && 65535 === n3 && (n3 = -1), t6.lexerActions[s5] = this.lexerActionFactory(i6, r4, n3);
                    }
                  }
                }
                generateRuleBypassTransitions(t6) {
                  let e5;
                  const i5 = t6.ruleToStartState.length;
                  for (e5 = 0; e5 < i5; e5++) t6.ruleToTokenType[e5] = t6.maxTokenType + e5 + 1;
                  for (e5 = 0; e5 < i5; e5++) this.generateRuleBypassTransition(t6, e5);
                }
                generateRuleBypassTransition(t6, e5) {
                  let i5, s5;
                  const r4 = new lt3();
                  r4.ruleIndex = e5, t6.addState(r4);
                  const n3 = new Z3();
                  n3.ruleIndex = e5, t6.addState(n3), r4.endState = n3, t6.defineDecisionState(r4), n3.startState = r4;
                  let a3 = null, o2 = null;
                  if (t6.ruleToStartState[e5].isPrecedenceRule) {
                    for (o2 = null, i5 = 0; i5 < t6.states.length; i5++) if (s5 = t6.states[i5], this.stateIsEndStateFor(s5, e5)) {
                      o2 = s5, a3 = s5.loopBackState.transitions[0];
                      break;
                    }
                    if (null === a3) throw "Couldn't identify final state of the precedence rule prefix section.";
                  } else o2 = t6.ruleToStopState[e5];
                  for (i5 = 0; i5 < t6.states.length; i5++) {
                    s5 = t6.states[i5];
                    for (let t7 = 0; t7 < s5.transitions.length; t7++) {
                      const e6 = s5.transitions[t7];
                      e6 !== a3 && e6.target === o2 && (e6.target = n3);
                    }
                  }
                  const l2 = t6.ruleToStartState[e5], h3 = l2.transitions.length;
                  for (; h3 > 0; ) r4.addTransition(l2.transitions[h3 - 1]), l2.transitions = l2.transitions.slice(-1);
                  t6.ruleToStartState[e5].addTransition(new pt3(r4)), n3.addTransition(new pt3(o2));
                  const c3 = new X2();
                  t6.addState(c3), c3.addTransition(new ht3(n3, t6.ruleToTokenType[e5])), r4.addTransition(new pt3(c3));
                }
                stateIsEndStateFor(t6, e5) {
                  if (t6.ruleIndex !== e5) return null;
                  if (!(t6 instanceof nt3)) return null;
                  const i5 = t6.transitions[t6.transitions.length - 1].target;
                  return i5 instanceof tt3 && i5.epsilonOnlyTransitions && i5.transitions[0].target instanceof R3 ? t6 : null;
                }
                markPrecedenceDecisions(t6) {
                  for (let e5 = 0; e5 < t6.states.length; e5++) {
                    const i5 = t6.states[e5];
                    if (i5 instanceof nt3 && t6.ruleToStartState[i5.ruleIndex].isPrecedenceRule) {
                      const t7 = i5.transitions[i5.transitions.length - 1].target;
                      t7 instanceof tt3 && t7.epsilonOnlyTransitions && t7.transitions[0].target instanceof R3 && (i5.isPrecedenceDecision = true);
                    }
                  }
                }
                verifyATN(t6) {
                  if (this.deserializationOptions.verifyATN) for (let e5 = 0; e5 < t6.states.length; e5++) {
                    const i5 = t6.states[e5];
                    if (null !== i5) if (this.checkCondition(i5.epsilonOnlyTransitions || i5.transitions.length <= 1), i5 instanceof at3) this.checkCondition(null !== i5.loopBackState);
                    else if (i5 instanceof nt3) if (this.checkCondition(null !== i5.loopBackState), this.checkCondition(2 === i5.transitions.length), i5.transitions[0].target instanceof ot3) this.checkCondition(i5.transitions[1].target instanceof tt3), this.checkCondition(!i5.nonGreedy);
                    else {
                      if (!(i5.transitions[0].target instanceof tt3)) throw "IllegalState";
                      this.checkCondition(i5.transitions[1].target instanceof ot3), this.checkCondition(i5.nonGreedy);
                    }
                    else i5 instanceof rt3 ? (this.checkCondition(1 === i5.transitions.length), this.checkCondition(i5.transitions[0].target instanceof nt3)) : i5 instanceof tt3 ? this.checkCondition(null !== i5.loopBackState) : i5 instanceof et3 ? this.checkCondition(null !== i5.stopState) : i5 instanceof Q3 ? this.checkCondition(null !== i5.endState) : i5 instanceof Z3 ? this.checkCondition(null !== i5.startState) : i5 instanceof J3 ? this.checkCondition(i5.transitions.length <= 1 || i5.decision >= 0) : this.checkCondition(i5.transitions.length <= 1 || i5 instanceof R3);
                  }
                }
                checkCondition(t6, e5) {
                  if (!t6) throw null == e5 && (e5 = "IllegalState"), e5;
                }
                readInt() {
                  return this.data[this.pos++];
                }
                readInt32() {
                  return this.readInt() | this.readInt() << 16;
                }
                edgeFactory(e5, i5, s5, r4, n3, a3, o2, l2) {
                  const h3 = e5.states[r4];
                  switch (i5) {
                    case v2.EPSILON:
                      return new pt3(h3);
                    case v2.RANGE:
                      return new ct3(h3, 0 !== o2 ? t5.EOF : n3, a3);
                    case v2.RULE:
                      return new b2(e5.states[n3], a3, o2, h3);
                    case v2.PREDICATE:
                      return new mt3(h3, n3, a3, 0 !== o2);
                    case v2.PRECEDENCE:
                      return new xt3(h3, n3);
                    case v2.ATOM:
                      return new ht3(h3, 0 !== o2 ? t5.EOF : n3);
                    case v2.ACTION:
                      return new ut3(h3, n3, a3, 0 !== o2);
                    case v2.SET:
                      return new L3(h3, l2[n3]);
                    case v2.NOT_SET:
                      return new S3(h3, l2[n3]);
                    case v2.WILDCARD:
                      return new C2(h3);
                    default:
                      throw "The specified transition type: " + i5 + " is not valid.";
                  }
                }
                stateFactory(t6, e5) {
                  if (null === this.stateFactories) {
                    const t7 = [];
                    t7[E2.INVALID_TYPE] = null, t7[E2.BASIC] = () => new X2(), t7[E2.RULE_START] = () => new et3(), t7[E2.BLOCK_START] = () => new lt3(), t7[E2.PLUS_BLOCK_START] = () => new at3(), t7[E2.STAR_BLOCK_START] = () => new ot3(), t7[E2.TOKEN_START] = () => new it3(), t7[E2.RULE_STOP] = () => new R3(), t7[E2.BLOCK_END] = () => new Z3(), t7[E2.STAR_LOOP_BACK] = () => new rt3(), t7[E2.STAR_LOOP_ENTRY] = () => new nt3(), t7[E2.PLUS_LOOP_BACK] = () => new st3(), t7[E2.LOOP_END] = () => new tt3(), this.stateFactories = t7;
                  }
                  if (t6 > this.stateFactories.length || null === this.stateFactories[t6]) throw "The specified state type " + t6 + " is not valid.";
                  {
                    const i5 = this.stateFactories[t6]();
                    if (null !== i5) return i5.ruleIndex = e5, i5;
                  }
                }
                lexerActionFactory(t6, e5, i5) {
                  if (null === this.actionFactories) {
                    const t7 = [];
                    t7[0] = (t8, e6) => new Tt3(t8), t7[1] = (t8, e6) => new Et3(t8, e6), t7[2] = (t8, e6) => new St3(t8), t7[3] = (t8, e6) => Rt3.INSTANCE, t7[4] = (t8, e6) => Lt3.INSTANCE, t7[5] = (t8, e6) => new bt3(t8), t7[6] = (t8, e6) => gt3.INSTANCE, t7[7] = (t8, e6) => new vt3(t8), this.actionFactories = t7;
                  }
                  if (t6 > this.actionFactories.length || null === this.actionFactories[t6]) throw "The specified lexer action type " + t6 + " is not valid.";
                  return this.actionFactories[t6](e5, i5);
                }
              }
              class wt3 {
                syntaxError(t6, e5, i5, s5, r4, n3) {
                }
                reportAmbiguity(t6, e5, i5, s5, r4, n3, a3) {
                }
                reportAttemptingFullContext(t6, e5, i5, s5, r4, n3) {
                }
                reportContextSensitivity(t6, e5, i5, s5, r4, n3) {
                }
              }
              class Nt3 extends wt3 {
                constructor() {
                  super();
                }
                syntaxError(t6, e5, i5, s5, r4, n3) {
                  console.error("line " + i5 + ":" + s5 + " " + r4);
                }
              }
              Nt3.INSTANCE = new Nt3();
              class It3 extends wt3 {
                constructor(t6) {
                  if (super(), null === t6) throw "delegates";
                  return this.delegates = t6, this;
                }
                syntaxError(t6, e5, i5, s5, r4, n3) {
                  this.delegates.map((a3) => a3.syntaxError(t6, e5, i5, s5, r4, n3));
                }
                reportAmbiguity(t6, e5, i5, s5, r4, n3, a3) {
                  this.delegates.map((o2) => o2.reportAmbiguity(t6, e5, i5, s5, r4, n3, a3));
                }
                reportAttemptingFullContext(t6, e5, i5, s5, r4, n3) {
                  this.delegates.map((a3) => a3.reportAttemptingFullContext(t6, e5, i5, s5, r4, n3));
                }
                reportContextSensitivity(t6, e5, i5, s5, r4, n3) {
                  this.delegates.map((a3) => a3.reportContextSensitivity(t6, e5, i5, s5, r4, n3));
                }
              }
              class kt3 {
                constructor() {
                  this._listeners = [Nt3.INSTANCE], this._interp = null, this._stateNumber = -1;
                }
                checkVersion(t6) {
                  const e5 = "4.13.1";
                  e5 !== t6 && console.log("ANTLR runtime and generated code versions disagree: " + e5 + "!=" + t6);
                }
                addErrorListener(t6) {
                  this._listeners.push(t6);
                }
                removeErrorListeners() {
                  this._listeners = [];
                }
                getLiteralNames() {
                  return Object.getPrototypeOf(this).constructor.literalNames || [];
                }
                getSymbolicNames() {
                  return Object.getPrototypeOf(this).constructor.symbolicNames || [];
                }
                getTokenNames() {
                  if (!this.tokenNames) {
                    const t6 = this.getLiteralNames(), e5 = this.getSymbolicNames(), i5 = t6.length > e5.length ? t6.length : e5.length;
                    this.tokenNames = [];
                    for (let s5 = 0; s5 < i5; s5++) this.tokenNames[s5] = t6[s5] || e5[s5] || "<INVALID";
                  }
                  return this.tokenNames;
                }
                getTokenTypeMap() {
                  const e5 = this.getTokenNames();
                  if (null === e5) throw "The current recognizer does not provide a list of token names.";
                  let i5 = this.tokenTypeMapCache[e5];
                  return void 0 === i5 && (i5 = e5.reduce(function(t6, e6, i6) {
                    t6[e6] = i6;
                  }), i5.EOF = t5.EOF, this.tokenTypeMapCache[e5] = i5), i5;
                }
                getRuleIndexMap() {
                  const t6 = this.ruleNames;
                  if (null === t6) throw "The current recognizer does not provide a list of rule names.";
                  let e5 = this.ruleIndexMapCache[t6];
                  return void 0 === e5 && (e5 = t6.reduce(function(t7, e6, i5) {
                    t7[e6] = i5;
                  }), this.ruleIndexMapCache[t6] = e5), e5;
                }
                getTokenType(e5) {
                  const i5 = this.getTokenTypeMap()[e5];
                  return void 0 !== i5 ? i5 : t5.INVALID_TYPE;
                }
                getErrorHeader(t6) {
                  return "line " + t6.getOffendingToken().line + ":" + t6.getOffendingToken().column;
                }
                getTokenErrorDisplay(e5) {
                  if (null === e5) return "<no token>";
                  let i5 = e5.text;
                  return null === i5 && (i5 = e5.type === t5.EOF ? "<EOF>" : "<" + e5.type + ">"), i5 = i5.replace("\n", "\\n").replace("\r", "\\r").replace("	", "\\t"), "'" + i5 + "'";
                }
                getErrorListenerDispatch() {
                  return new It3(this._listeners);
                }
                sempred(t6, e5, i5) {
                  return true;
                }
                precpred(t6, e5) {
                  return true;
                }
                get atn() {
                  return this._interp.atn;
                }
                get state() {
                  return this._stateNumber;
                }
                set state(t6) {
                  this._stateNumber = t6;
                }
              }
              kt3.tokenTypeMapCache = {}, kt3.ruleIndexMapCache = {};
              class Dt3 extends t5 {
                constructor(e5, i5, s5, r4, n3) {
                  super(), this.source = void 0 !== e5 ? e5 : Dt3.EMPTY_SOURCE, this.type = void 0 !== i5 ? i5 : null, this.channel = void 0 !== s5 ? s5 : t5.DEFAULT_CHANNEL, this.start = void 0 !== r4 ? r4 : -1, this.stop = void 0 !== n3 ? n3 : -1, this.tokenIndex = -1, null !== this.source[0] ? (this.line = e5[0].line, this.column = e5[0].column) : this.column = -1;
                }
                clone() {
                  const t6 = new Dt3(this.source, this.type, this.channel, this.start, this.stop);
                  return t6.tokenIndex = this.tokenIndex, t6.line = this.line, t6.column = this.column, t6.text = this.text, t6;
                }
                cloneWithType(e5) {
                  const i5 = new Dt3(this.source, e5, this.channel, this.start, this.stop);
                  return i5.tokenIndex = this.tokenIndex, i5.line = this.line, i5.column = this.column, e5 === t5.EOF && (i5.text = ""), i5;
                }
                toString() {
                  let t6 = this.text;
                  return t6 = null !== t6 ? t6.replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t") : "<no text>", "[@" + this.tokenIndex + "," + this.start + ":" + this.stop + "='" + t6 + "',<" + this.type + ">" + (this.channel > 0 ? ",channel=" + this.channel : "") + "," + this.line + ":" + this.column + "]";
                }
                get text() {
                  if (null !== this._text) return this._text;
                  const t6 = this.getInputStream();
                  if (null === t6) return null;
                  const e5 = t6.size;
                  return this.start < e5 && this.stop < e5 ? t6.getText(this.start, this.stop) : "<EOF>";
                }
                set text(t6) {
                  this._text = t6;
                }
              }
              Dt3.EMPTY_SOURCE = [null, null];
              class Ot3 {
              }
              class Pt3 extends Ot3 {
                constructor(t6) {
                  super(), this.copyText = void 0 !== t6 && t6;
                }
                create(t6, e5, i5, s5, r4, n3, a3, o2) {
                  const l2 = new Dt3(t6, e5, s5, r4, n3);
                  return l2.line = a3, l2.column = o2, null !== i5 ? l2.text = i5 : this.copyText && null !== t6[1] && (l2.text = t6[1].getText(r4, n3)), l2;
                }
                createThin(t6, e5) {
                  const i5 = new Dt3(null, t6);
                  return i5.text = e5, i5;
                }
              }
              Pt3.DEFAULT = new Pt3();
              class Ft3 extends Error {
                constructor(t6) {
                  super(t6.message), Error.captureStackTrace && Error.captureStackTrace(this, Ft3), this.message = t6.message, this.recognizer = t6.recognizer, this.input = t6.input, this.ctx = t6.ctx, this.offendingToken = null, this.offendingState = -1, null !== this.recognizer && (this.offendingState = this.recognizer.state);
                }
                getExpectedTokens() {
                  return null !== this.recognizer ? this.recognizer.atn.getExpectedTokens(this.offendingState, this.ctx) : null;
                }
                toString() {
                  return this.message;
                }
              }
              class Ut3 extends Ft3 {
                constructor(t6, e5, i5, s5) {
                  super({ message: "", recognizer: t6, input: e5, ctx: null }), this.startIndex = i5, this.deadEndConfigs = s5;
                }
                toString() {
                  let t6 = "";
                  return this.startIndex >= 0 && this.startIndex < this.input.size && (t6 = this.input.getText(new g2(this.startIndex, this.startIndex))), "LexerNoViableAltException" + t6;
                }
              }
              class Ht3 extends kt3 {
                constructor(e5) {
                  super(), this._input = e5, this._factory = Pt3.DEFAULT, this._tokenFactorySourcePair = [this, e5], this._interp = null, this._token = null, this._tokenStartCharIndex = -1, this._tokenStartLine = -1, this._tokenStartColumn = -1, this._hitEOF = false, this._channel = t5.DEFAULT_CHANNEL, this._type = t5.INVALID_TYPE, this._modeStack = [], this._mode = Ht3.DEFAULT_MODE, this._text = null;
                }
                reset() {
                  null !== this._input && this._input.seek(0), this._token = null, this._type = t5.INVALID_TYPE, this._channel = t5.DEFAULT_CHANNEL, this._tokenStartCharIndex = -1, this._tokenStartColumn = -1, this._tokenStartLine = -1, this._text = null, this._hitEOF = false, this._mode = Ht3.DEFAULT_MODE, this._modeStack = [], this._interp.reset();
                }
                nextToken() {
                  if (null === this._input) throw "nextToken requires a non-null input stream.";
                  const e5 = this._input.mark();
                  try {
                    for (; ; ) {
                      if (this._hitEOF) return this.emitEOF(), this._token;
                      this._token = null, this._channel = t5.DEFAULT_CHANNEL, this._tokenStartCharIndex = this._input.index, this._tokenStartColumn = this._interp.column, this._tokenStartLine = this._interp.line, this._text = null;
                      let e6 = false;
                      for (; ; ) {
                        this._type = t5.INVALID_TYPE;
                        let i5 = Ht3.SKIP;
                        try {
                          i5 = this._interp.match(this._input, this._mode);
                        } catch (t6) {
                          if (!(t6 instanceof Ft3)) throw console.log(t6.stack), t6;
                          this.notifyListeners(t6), this.recover(t6);
                        }
                        if (this._input.LA(1) === t5.EOF && (this._hitEOF = true), this._type === t5.INVALID_TYPE && (this._type = i5), this._type === Ht3.SKIP) {
                          e6 = true;
                          break;
                        }
                        if (this._type !== Ht3.MORE) break;
                      }
                      if (!e6) return null === this._token && this.emit(), this._token;
                    }
                  } finally {
                    this._input.release(e5);
                  }
                }
                skip() {
                  this._type = Ht3.SKIP;
                }
                more() {
                  this._type = Ht3.MORE;
                }
                mode(t6) {
                  this._mode = t6;
                }
                pushMode(t6) {
                  this._interp.debug && console.log("pushMode " + t6), this._modeStack.push(this._mode), this.mode(t6);
                }
                popMode() {
                  if (0 === this._modeStack.length) throw "Empty Stack";
                  return this._interp.debug && console.log("popMode back to " + this._modeStack.slice(0, -1)), this.mode(this._modeStack.pop()), this._mode;
                }
                emitToken(t6) {
                  this._token = t6;
                }
                emit() {
                  const t6 = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.getCharIndex() - 1, this._tokenStartLine, this._tokenStartColumn);
                  return this.emitToken(t6), t6;
                }
                emitEOF() {
                  const e5 = this.column, i5 = this.line, s5 = this._factory.create(this._tokenFactorySourcePair, t5.EOF, null, t5.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, i5, e5);
                  return this.emitToken(s5), s5;
                }
                getCharIndex() {
                  return this._input.index;
                }
                getAllTokens() {
                  const e5 = [];
                  let i5 = this.nextToken();
                  for (; i5.type !== t5.EOF; ) e5.push(i5), i5 = this.nextToken();
                  return e5;
                }
                notifyListeners(t6) {
                  const e5 = this._tokenStartCharIndex, i5 = this._input.index, s5 = this._input.getText(e5, i5), r4 = "token recognition error at: '" + this.getErrorDisplay(s5) + "'";
                  this.getErrorListenerDispatch().syntaxError(this, null, this._tokenStartLine, this._tokenStartColumn, r4, t6);
                }
                getErrorDisplay(t6) {
                  const e5 = [];
                  for (let i5 = 0; i5 < t6.length; i5++) e5.push(t6[i5]);
                  return e5.join("");
                }
                getErrorDisplayForChar(e5) {
                  return e5.charCodeAt(0) === t5.EOF ? "<EOF>" : "\n" === e5 ? "\\n" : "	" === e5 ? "\\t" : "\r" === e5 ? "\\r" : e5;
                }
                getCharErrorDisplay(t6) {
                  return "'" + this.getErrorDisplayForChar(t6) + "'";
                }
                recover(e5) {
                  this._input.LA(1) !== t5.EOF && (e5 instanceof Ut3 ? this._interp.consume(this._input) : this._input.consume());
                }
                get inputStream() {
                  return this._input;
                }
                set inputStream(t6) {
                  this._input = null, this._tokenFactorySourcePair = [this, this._input], this.reset(), this._input = t6, this._tokenFactorySourcePair = [this, this._input];
                }
                get sourceName() {
                  return this._input.sourceName;
                }
                get type() {
                  return this._type;
                }
                set type(t6) {
                  this._type = t6;
                }
                get line() {
                  return this._interp.line;
                }
                set line(t6) {
                  this._interp.line = t6;
                }
                get column() {
                  return this._interp.column;
                }
                set column(t6) {
                  this._interp.column = t6;
                }
                get text() {
                  return null !== this._text ? this._text : this._interp.getText(this._input);
                }
                set text(t6) {
                  this._text = t6;
                }
              }
              function Mt3(t6) {
                return t6.hashCodeForConfigSet();
              }
              function Kt3(t6, e5) {
                return t6 === e5 || null !== t6 && null !== e5 && t6.equalsForConfigSet(e5);
              }
              Ht3.DEFAULT_MODE = 0, Ht3.MORE = -2, Ht3.SKIP = -3, Ht3.DEFAULT_TOKEN_CHANNEL = t5.DEFAULT_CHANNEL, Ht3.HIDDEN = t5.HIDDEN_CHANNEL, Ht3.MIN_CHAR_VALUE = 0, Ht3.MAX_CHAR_VALUE = 1114111;
              class Vt3 {
                constructor(t6) {
                  this.configLookup = new p2(Mt3, Kt3), this.fullCtx = void 0 === t6 || t6, this.readOnly = false, this.configs = [], this.uniqueAlt = 0, this.conflictingAlts = null, this.hasSemanticContext = false, this.dipsIntoOuterContext = false, this.cachedHashCode = -1;
                }
                add(t6, e5) {
                  if (void 0 === e5 && (e5 = null), this.readOnly) throw "This set is readonly";
                  t6.semanticContext !== d2.NONE && (this.hasSemanticContext = true), t6.reachesIntoOuterContext > 0 && (this.dipsIntoOuterContext = true);
                  const i5 = this.configLookup.add(t6);
                  if (i5 === t6) return this.cachedHashCode = -1, this.configs.push(t6), true;
                  const s5 = !this.fullCtx, r4 = z3(i5.context, t6.context, s5, e5);
                  return i5.reachesIntoOuterContext = Math.max(i5.reachesIntoOuterContext, t6.reachesIntoOuterContext), t6.precedenceFilterSuppressed && (i5.precedenceFilterSuppressed = true), i5.context = r4, true;
                }
                getStates() {
                  const t6 = new p2();
                  for (let e5 = 0; e5 < this.configs.length; e5++) t6.add(this.configs[e5].state);
                  return t6;
                }
                getPredicates() {
                  const t6 = [];
                  for (let e5 = 0; e5 < this.configs.length; e5++) {
                    const i5 = this.configs[e5].semanticContext;
                    i5 !== d2.NONE && t6.push(i5.semanticContext);
                  }
                  return t6;
                }
                optimizeConfigs(t6) {
                  if (this.readOnly) throw "This set is readonly";
                  if (0 !== this.configLookup.length) for (let e5 = 0; e5 < this.configs.length; e5++) {
                    const i5 = this.configs[e5];
                    i5.context = t6.getCachedContext(i5.context);
                  }
                }
                addAll(t6) {
                  for (let e5 = 0; e5 < t6.length; e5++) this.add(t6[e5]);
                  return false;
                }
                equals(t6) {
                  return this === t6 || t6 instanceof Vt3 && e4(this.configs, t6.configs) && this.fullCtx === t6.fullCtx && this.uniqueAlt === t6.uniqueAlt && this.conflictingAlts === t6.conflictingAlts && this.hasSemanticContext === t6.hasSemanticContext && this.dipsIntoOuterContext === t6.dipsIntoOuterContext;
                }
                hashCode() {
                  const t6 = new r3();
                  return t6.update(this.configs), t6.finish();
                }
                updateHashCode(t6) {
                  this.readOnly ? (-1 === this.cachedHashCode && (this.cachedHashCode = this.hashCode()), t6.update(this.cachedHashCode)) : t6.update(this.hashCode());
                }
                isEmpty() {
                  return 0 === this.configs.length;
                }
                contains(t6) {
                  if (null === this.configLookup) throw "This method is not implemented for readonly sets.";
                  return this.configLookup.contains(t6);
                }
                containsFast(t6) {
                  if (null === this.configLookup) throw "This method is not implemented for readonly sets.";
                  return this.configLookup.containsFast(t6);
                }
                clear() {
                  if (this.readOnly) throw "This set is readonly";
                  this.configs = [], this.cachedHashCode = -1, this.configLookup = new p2();
                }
                setReadonly(t6) {
                  this.readOnly = t6, t6 && (this.configLookup = null);
                }
                toString() {
                  return c2(this.configs) + (this.hasSemanticContext ? ",hasSemanticContext=" + this.hasSemanticContext : "") + (this.uniqueAlt !== Y3.INVALID_ALT_NUMBER ? ",uniqueAlt=" + this.uniqueAlt : "") + (null !== this.conflictingAlts ? ",conflictingAlts=" + this.conflictingAlts : "") + (this.dipsIntoOuterContext ? ",dipsIntoOuterContext" : "");
                }
                get items() {
                  return this.configs;
                }
                get length() {
                  return this.configs.length;
                }
              }
              class Bt3 {
                constructor(t6, e5) {
                  return null === t6 && (t6 = -1), null === e5 && (e5 = new Vt3()), this.stateNumber = t6, this.configs = e5, this.edges = null, this.isAcceptState = false, this.prediction = 0, this.lexerActionExecutor = null, this.requiresFullContext = false, this.predicates = null, this;
                }
                getAltSet() {
                  const t6 = new p2();
                  if (null !== this.configs) for (let e5 = 0; e5 < this.configs.length; e5++) {
                    const i5 = this.configs[e5];
                    t6.add(i5.alt);
                  }
                  return 0 === t6.length ? null : t6;
                }
                equals(t6) {
                  return this === t6 || t6 instanceof Bt3 && this.configs.equals(t6.configs);
                }
                toString() {
                  let t6 = this.stateNumber + ":" + this.configs;
                  return this.isAcceptState && (t6 += "=>", null !== this.predicates ? t6 += this.predicates : t6 += this.prediction), t6;
                }
                hashCode() {
                  const t6 = new r3();
                  return t6.update(this.configs), t6.finish();
                }
              }
              class $t3 {
                constructor(t6, e5) {
                  return this.atn = t6, this.sharedContextCache = e5, this;
                }
                getCachedContext(t6) {
                  if (null === this.sharedContextCache) return t6;
                  const e5 = new $3();
                  return G3(t6, this.sharedContextCache, e5);
                }
              }
              $t3.ERROR = new Bt3(2147483647, new Vt3());
              class jt3 extends Vt3 {
                constructor() {
                  super(), this.configLookup = new p2();
                }
              }
              class Gt3 extends y3 {
                constructor(t6, e5) {
                  super(t6, e5);
                  const i5 = t6.lexerActionExecutor || null;
                  return this.lexerActionExecutor = i5 || (null !== e5 ? e5.lexerActionExecutor : null), this.passedThroughNonGreedyDecision = null !== e5 && this.checkNonGreedyDecision(e5, this.state), this.hashCodeForConfigSet = Gt3.prototype.hashCode, this.equalsForConfigSet = Gt3.prototype.equals, this;
                }
                updateHashCode(t6) {
                  t6.update(this.state.stateNumber, this.alt, this.context, this.semanticContext, this.passedThroughNonGreedyDecision, this.lexerActionExecutor);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof Gt3 && this.passedThroughNonGreedyDecision === t6.passedThroughNonGreedyDecision && (this.lexerActionExecutor ? this.lexerActionExecutor.equals(t6.lexerActionExecutor) : !t6.lexerActionExecutor) && super.equals(t6);
                }
                checkNonGreedyDecision(t6, e5) {
                  return t6.passedThroughNonGreedyDecision || e5 instanceof J3 && e5.nonGreedy;
                }
              }
              class zt3 extends yt2 {
                constructor(t6, e5) {
                  super(e5.actionType), this.offset = t6, this.action = e5, this.isPositionDependent = true;
                }
                execute(t6) {
                  this.action.execute(t6);
                }
                updateHashCode(t6) {
                  t6.update(this.actionType, this.offset, this.action);
                }
                equals(t6) {
                  return this === t6 || t6 instanceof zt3 && this.offset === t6.offset && this.action === t6.action;
                }
              }
              class qt3 {
                constructor(t6) {
                  return this.lexerActions = null === t6 ? [] : t6, this.cachedHashCode = r3.hashStuff(t6), this;
                }
                fixOffsetBeforeMatch(t6) {
                  let e5 = null;
                  for (let i5 = 0; i5 < this.lexerActions.length; i5++) !this.lexerActions[i5].isPositionDependent || this.lexerActions[i5] instanceof zt3 || (null === e5 && (e5 = this.lexerActions.concat([])), e5[i5] = new zt3(t6, this.lexerActions[i5]));
                  return null === e5 ? this : new qt3(e5);
                }
                execute(t6, e5, i5) {
                  let s5 = false;
                  const r4 = e5.index;
                  try {
                    for (let n3 = 0; n3 < this.lexerActions.length; n3++) {
                      let a3 = this.lexerActions[n3];
                      if (a3 instanceof zt3) {
                        const t7 = a3.offset;
                        e5.seek(i5 + t7), a3 = a3.action, s5 = i5 + t7 !== r4;
                      } else a3.isPositionDependent && (e5.seek(r4), s5 = false);
                      a3.execute(t6);
                    }
                  } finally {
                    s5 && e5.seek(r4);
                  }
                }
                hashCode() {
                  return this.cachedHashCode;
                }
                updateHashCode(t6) {
                  t6.update(this.cachedHashCode);
                }
                equals(t6) {
                  if (this === t6) return true;
                  if (t6 instanceof qt3) {
                    if (this.cachedHashCode != t6.cachedHashCode) return false;
                    if (this.lexerActions.length != t6.lexerActions.length) return false;
                    {
                      const e5 = this.lexerActions.length;
                      for (let i5 = 0; i5 < e5; ++i5) if (!this.lexerActions[i5].equals(t6.lexerActions[i5])) return false;
                      return true;
                    }
                  }
                  return false;
                }
                static append(t6, e5) {
                  if (null === t6) return new qt3([e5]);
                  const i5 = t6.lexerActions.concat([e5]);
                  return new qt3(i5);
                }
              }
              function Wt3(t6) {
                t6.index = -1, t6.line = 0, t6.column = -1, t6.dfaState = null;
              }
              class Yt3 {
                constructor() {
                  Wt3(this);
                }
                reset() {
                  Wt3(this);
                }
              }
              class Xt3 extends $t3 {
                constructor(t6, e5, i5, s5) {
                  super(e5, s5), this.decisionToDFA = i5, this.recog = t6, this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Ht3.DEFAULT_MODE, this.prevAccept = new Yt3();
                }
                copyState(t6) {
                  this.column = t6.column, this.line = t6.line, this.mode = t6.mode, this.startIndex = t6.startIndex;
                }
                match(t6, e5) {
                  this.mode = e5;
                  const i5 = t6.mark();
                  try {
                    this.startIndex = t6.index, this.prevAccept.reset();
                    const i6 = this.decisionToDFA[e5];
                    return null === i6.s0 ? this.matchATN(t6) : this.execATN(t6, i6.s0);
                  } finally {
                    t6.release(i5);
                  }
                }
                reset() {
                  this.prevAccept.reset(), this.startIndex = -1, this.line = 1, this.column = 0, this.mode = Ht3.DEFAULT_MODE;
                }
                matchATN(t6) {
                  const e5 = this.atn.modeToStartState[this.mode];
                  Xt3.debug && console.log("matchATN mode " + this.mode + " start: " + e5);
                  const i5 = this.mode, s5 = this.computeStartState(t6, e5), r4 = s5.hasSemanticContext;
                  s5.hasSemanticContext = false;
                  const n3 = this.addDFAState(s5);
                  r4 || (this.decisionToDFA[this.mode].s0 = n3);
                  const a3 = this.execATN(t6, n3);
                  return Xt3.debug && console.log("DFA after matchATN: " + this.decisionToDFA[i5].toLexerString()), a3;
                }
                execATN(e5, i5) {
                  Xt3.debug && console.log("start state closure=" + i5.configs), i5.isAcceptState && this.captureSimState(this.prevAccept, e5, i5);
                  let s5 = e5.LA(1), r4 = i5;
                  for (; ; ) {
                    Xt3.debug && console.log("execATN loop starting closure: " + r4.configs);
                    let i6 = this.getExistingTargetState(r4, s5);
                    if (null === i6 && (i6 = this.computeTargetState(e5, r4, s5)), i6 === $t3.ERROR) break;
                    if (s5 !== t5.EOF && this.consume(e5), i6.isAcceptState && (this.captureSimState(this.prevAccept, e5, i6), s5 === t5.EOF)) break;
                    s5 = e5.LA(1), r4 = i6;
                  }
                  return this.failOrAccept(this.prevAccept, e5, r4.configs, s5);
                }
                getExistingTargetState(t6, e5) {
                  if (null === t6.edges || e5 < Xt3.MIN_DFA_EDGE || e5 > Xt3.MAX_DFA_EDGE) return null;
                  let i5 = t6.edges[e5 - Xt3.MIN_DFA_EDGE];
                  return void 0 === i5 && (i5 = null), Xt3.debug && null !== i5 && console.log("reuse state " + t6.stateNumber + " edge to " + i5.stateNumber), i5;
                }
                computeTargetState(t6, e5, i5) {
                  const s5 = new jt3();
                  return this.getReachableConfigSet(t6, e5.configs, s5, i5), 0 === s5.items.length ? (s5.hasSemanticContext || this.addDFAEdge(e5, i5, $t3.ERROR), $t3.ERROR) : this.addDFAEdge(e5, i5, null, s5);
                }
                failOrAccept(e5, i5, s5, r4) {
                  if (null !== this.prevAccept.dfaState) {
                    const t6 = e5.dfaState.lexerActionExecutor;
                    return this.accept(i5, t6, this.startIndex, e5.index, e5.line, e5.column), e5.dfaState.prediction;
                  }
                  if (r4 === t5.EOF && i5.index === this.startIndex) return t5.EOF;
                  throw new Ut3(this.recog, i5, this.startIndex, s5);
                }
                getReachableConfigSet(e5, i5, s5, r4) {
                  let n3 = Y3.INVALID_ALT_NUMBER;
                  for (let a3 = 0; a3 < i5.items.length; a3++) {
                    const o2 = i5.items[a3], l2 = o2.alt === n3;
                    if (!l2 || !o2.passedThroughNonGreedyDecision) {
                      Xt3.debug && console.log("testing %s at %s\n", this.getTokenName(r4), o2.toString(this.recog, true));
                      for (let i6 = 0; i6 < o2.state.transitions.length; i6++) {
                        const a4 = o2.state.transitions[i6], h3 = this.getReachableTarget(a4, r4);
                        if (null !== h3) {
                          let i7 = o2.lexerActionExecutor;
                          null !== i7 && (i7 = i7.fixOffsetBeforeMatch(e5.index - this.startIndex));
                          const a5 = r4 === t5.EOF, c3 = new Gt3({ state: h3, lexerActionExecutor: i7 }, o2);
                          this.closure(e5, c3, s5, l2, true, a5) && (n3 = o2.alt);
                        }
                      }
                    }
                  }
                }
                accept(t6, e5, i5, s5, r4, n3) {
                  Xt3.debug && console.log("ACTION %s\n", e5), t6.seek(s5), this.line = r4, this.column = n3, null !== e5 && null !== this.recog && e5.execute(this.recog, t6, i5);
                }
                getReachableTarget(t6, e5) {
                  return t6.matches(e5, 0, Ht3.MAX_CHAR_VALUE) ? t6.target : null;
                }
                computeStartState(t6, e5) {
                  const i5 = H3.EMPTY, s5 = new jt3();
                  for (let r4 = 0; r4 < e5.transitions.length; r4++) {
                    const n3 = e5.transitions[r4].target, a3 = new Gt3({ state: n3, alt: r4 + 1, context: i5 }, null);
                    this.closure(t6, a3, s5, false, false, false);
                  }
                  return s5;
                }
                closure(t6, e5, i5, s5, r4, n3) {
                  let a3 = null;
                  if (Xt3.debug && console.log("closure(" + e5.toString(this.recog, true) + ")"), e5.state instanceof R3) {
                    if (Xt3.debug && (null !== this.recog ? console.log("closure at %s rule stop %s\n", this.recog.ruleNames[e5.state.ruleIndex], e5) : console.log("closure at rule stop %s\n", e5)), null === e5.context || e5.context.hasEmptyPath()) {
                      if (null === e5.context || e5.context.isEmpty()) return i5.add(e5), true;
                      i5.add(new Gt3({ state: e5.state, context: H3.EMPTY }, e5)), s5 = true;
                    }
                    if (null !== e5.context && !e5.context.isEmpty()) {
                      for (let o2 = 0; o2 < e5.context.length; o2++) if (e5.context.getReturnState(o2) !== H3.EMPTY_RETURN_STATE) {
                        const l2 = e5.context.getParent(o2), h3 = this.atn.states[e5.context.getReturnState(o2)];
                        a3 = new Gt3({ state: h3, context: l2 }, e5), s5 = this.closure(t6, a3, i5, s5, r4, n3);
                      }
                    }
                    return s5;
                  }
                  e5.state.epsilonOnlyTransitions || s5 && e5.passedThroughNonGreedyDecision || i5.add(e5);
                  for (let o2 = 0; o2 < e5.state.transitions.length; o2++) {
                    const l2 = e5.state.transitions[o2];
                    a3 = this.getEpsilonTarget(t6, e5, l2, i5, r4, n3), null !== a3 && (s5 = this.closure(t6, a3, i5, s5, r4, n3));
                  }
                  return s5;
                }
                getEpsilonTarget(e5, i5, s5, r4, n3, a3) {
                  let o2 = null;
                  if (s5.serializationType === v2.RULE) {
                    const t6 = K3.create(i5.context, s5.followState.stateNumber);
                    o2 = new Gt3({ state: s5.target, context: t6 }, i5);
                  } else {
                    if (s5.serializationType === v2.PRECEDENCE) throw "Precedence predicates are not supported in lexers.";
                    if (s5.serializationType === v2.PREDICATE) Xt3.debug && console.log("EVAL rule " + s5.ruleIndex + ":" + s5.predIndex), r4.hasSemanticContext = true, this.evaluatePredicate(e5, s5.ruleIndex, s5.predIndex, n3) && (o2 = new Gt3({ state: s5.target }, i5));
                    else if (s5.serializationType === v2.ACTION) if (null === i5.context || i5.context.hasEmptyPath()) {
                      const t6 = qt3.append(i5.lexerActionExecutor, this.atn.lexerActions[s5.actionIndex]);
                      o2 = new Gt3({ state: s5.target, lexerActionExecutor: t6 }, i5);
                    } else o2 = new Gt3({ state: s5.target }, i5);
                    else s5.serializationType === v2.EPSILON ? o2 = new Gt3({ state: s5.target }, i5) : s5.serializationType !== v2.ATOM && s5.serializationType !== v2.RANGE && s5.serializationType !== v2.SET || a3 && s5.matches(t5.EOF, 0, Ht3.MAX_CHAR_VALUE) && (o2 = new Gt3({ state: s5.target }, i5));
                  }
                  return o2;
                }
                evaluatePredicate(t6, e5, i5, s5) {
                  if (null === this.recog) return true;
                  if (!s5) return this.recog.sempred(null, e5, i5);
                  const r4 = this.column, n3 = this.line, a3 = t6.index, o2 = t6.mark();
                  try {
                    return this.consume(t6), this.recog.sempred(null, e5, i5);
                  } finally {
                    this.column = r4, this.line = n3, t6.seek(a3), t6.release(o2);
                  }
                }
                captureSimState(t6, e5, i5) {
                  t6.index = e5.index, t6.line = this.line, t6.column = this.column, t6.dfaState = i5;
                }
                addDFAEdge(t6, e5, i5, s5) {
                  if (void 0 === i5 && (i5 = null), void 0 === s5 && (s5 = null), null === i5 && null !== s5) {
                    const t7 = s5.hasSemanticContext;
                    if (s5.hasSemanticContext = false, i5 = this.addDFAState(s5), t7) return i5;
                  }
                  return e5 < Xt3.MIN_DFA_EDGE || e5 > Xt3.MAX_DFA_EDGE || (Xt3.debug && console.log("EDGE " + t6 + " -> " + i5 + " upon " + e5), null === t6.edges && (t6.edges = []), t6.edges[e5 - Xt3.MIN_DFA_EDGE] = i5), i5;
                }
                addDFAState(t6) {
                  const e5 = new Bt3(null, t6);
                  let i5 = null;
                  for (let e6 = 0; e6 < t6.items.length; e6++) {
                    const s6 = t6.items[e6];
                    if (s6.state instanceof R3) {
                      i5 = s6;
                      break;
                    }
                  }
                  null !== i5 && (e5.isAcceptState = true, e5.lexerActionExecutor = i5.lexerActionExecutor, e5.prediction = this.atn.ruleToTokenType[i5.state.ruleIndex]);
                  const s5 = this.decisionToDFA[this.mode], r4 = s5.states.get(e5);
                  if (null !== r4) return r4;
                  const n3 = e5;
                  return n3.stateNumber = s5.states.length, t6.setReadonly(true), n3.configs = t6, s5.states.add(n3), n3;
                }
                getDFA(t6) {
                  return this.decisionToDFA[t6];
                }
                getText(t6) {
                  return t6.getText(this.startIndex, t6.index - 1);
                }
                consume(t6) {
                  t6.LA(1) === "\n".charCodeAt(0) ? (this.line += 1, this.column = 0) : this.column += 1, t6.consume();
                }
                getTokenName(t6) {
                  return -1 === t6 ? "EOF" : "'" + String.fromCharCode(t6) + "'";
                }
              }
              Xt3.debug = false, Xt3.dfa_debug = false, Xt3.MIN_DFA_EDGE = 0, Xt3.MAX_DFA_EDGE = 127;
              class Jt3 {
                constructor(t6, e5) {
                  this.alt = e5, this.pred = t6;
                }
                toString() {
                  return "(" + this.pred + ", " + this.alt + ")";
                }
              }
              class Qt3 {
                constructor() {
                  this.data = {};
                }
                get(t6) {
                  return this.data["k-" + t6] || null;
                }
                set(t6, e5) {
                  this.data["k-" + t6] = e5;
                }
                values() {
                  return Object.keys(this.data).filter((t6) => t6.startsWith("k-")).map((t6) => this.data[t6], this);
                }
              }
              const Zt3 = { SLL: 0, LL: 1, LL_EXACT_AMBIG_DETECTION: 2, hasSLLConflictTerminatingPrediction: function(t6, e5) {
                if (Zt3.allConfigsInRuleStopStates(e5)) return true;
                if (t6 === Zt3.SLL && e5.hasSemanticContext) {
                  const t7 = new Vt3();
                  for (let i6 = 0; i6 < e5.items.length; i6++) {
                    let s5 = e5.items[i6];
                    s5 = new y3({ semanticContext: d2.NONE }, s5), t7.add(s5);
                  }
                  e5 = t7;
                }
                const i5 = Zt3.getConflictingAltSubsets(e5);
                return Zt3.hasConflictingAltSet(i5) && !Zt3.hasStateAssociatedWithOneAlt(e5);
              }, hasConfigInRuleStopState: function(t6) {
                for (let e5 = 0; e5 < t6.items.length; e5++) if (t6.items[e5].state instanceof R3) return true;
                return false;
              }, allConfigsInRuleStopStates: function(t6) {
                for (let e5 = 0; e5 < t6.items.length; e5++) if (!(t6.items[e5].state instanceof R3)) return false;
                return true;
              }, resolvesToJustOneViableAlt: function(t6) {
                return Zt3.getSingleViableAlt(t6);
              }, allSubsetsConflict: function(t6) {
                return !Zt3.hasNonConflictingAltSet(t6);
              }, hasNonConflictingAltSet: function(t6) {
                for (let e5 = 0; e5 < t6.length; e5++) if (1 === t6[e5].length) return true;
                return false;
              }, hasConflictingAltSet: function(t6) {
                for (let e5 = 0; e5 < t6.length; e5++) if (t6[e5].length > 1) return true;
                return false;
              }, allSubsetsEqual: function(t6) {
                let e5 = null;
                for (let i5 = 0; i5 < t6.length; i5++) {
                  const s5 = t6[i5];
                  if (null === e5) e5 = s5;
                  else if (s5 !== e5) return false;
                }
                return true;
              }, getUniqueAlt: function(t6) {
                const e5 = Zt3.getAlts(t6);
                return 1 === e5.length ? e5.minValue() : Y3.INVALID_ALT_NUMBER;
              }, getAlts: function(t6) {
                const e5 = new q3();
                return t6.map(function(t7) {
                  e5.or(t7);
                }), e5;
              }, getConflictingAltSubsets: function(t6) {
                const e5 = new $3();
                return e5.hashFunction = function(t7) {
                  r3.hashStuff(t7.state.stateNumber, t7.context);
                }, e5.equalsFunction = function(t7, e6) {
                  return t7.state.stateNumber === e6.state.stateNumber && t7.context.equals(e6.context);
                }, t6.items.map(function(t7) {
                  let i5 = e5.get(t7);
                  null === i5 && (i5 = new q3(), e5.set(t7, i5)), i5.add(t7.alt);
                }), e5.getValues();
              }, getStateToAltMap: function(t6) {
                const e5 = new Qt3();
                return t6.items.map(function(t7) {
                  let i5 = e5.get(t7.state);
                  null === i5 && (i5 = new q3(), e5.set(t7.state, i5)), i5.add(t7.alt);
                }), e5;
              }, hasStateAssociatedWithOneAlt: function(t6) {
                const e5 = Zt3.getStateToAltMap(t6).values();
                for (let t7 = 0; t7 < e5.length; t7++) if (1 === e5[t7].length) return true;
                return false;
              }, getSingleViableAlt: function(t6) {
                let e5 = null;
                for (let i5 = 0; i5 < t6.length; i5++) {
                  const s5 = t6[i5].minValue();
                  if (null === e5) e5 = s5;
                  else if (e5 !== s5) return Y3.INVALID_ALT_NUMBER;
                }
                return e5;
              } }, te3 = Zt3;
              class ee3 extends Ft3 {
                constructor(t6, e5, i5, s5, r4, n3) {
                  n3 = n3 || t6._ctx, s5 = s5 || t6.getCurrentToken(), i5 = i5 || t6.getCurrentToken(), e5 = e5 || t6.getInputStream(), super({ message: "", recognizer: t6, input: e5, ctx: n3 }), this.deadEndConfigs = r4, this.startToken = i5, this.offendingToken = s5;
                }
              }
              class ie3 {
                constructor(t6) {
                  this.defaultMapCtor = t6 || $3, this.cacheMap = new this.defaultMapCtor();
                }
                get(t6, e5) {
                  const i5 = this.cacheMap.get(t6) || null;
                  return null === i5 ? null : i5.get(e5) || null;
                }
                set(t6, e5, i5) {
                  let s5 = this.cacheMap.get(t6) || null;
                  null === s5 && (s5 = new this.defaultMapCtor(), this.cacheMap.set(t6, s5)), s5.set(e5, i5);
                }
              }
              class se3 extends $t3 {
                constructor(t6, e5, i5, s5) {
                  super(e5, s5), this.parser = t6, this.decisionToDFA = i5, this.predictionMode = te3.LL, this._input = null, this._startIndex = 0, this._outerContext = null, this._dfa = null, this.mergeCache = null, this.debug = false, this.debug_closure = false, this.debug_add = false, this.trace_atn_sim = false, this.dfa_debug = false, this.retry_debug = false;
                }
                reset() {
                }
                adaptivePredict(t6, e5, i5) {
                  (this.debug || this.trace_atn_sim) && console.log("adaptivePredict decision " + e5 + " exec LA(1)==" + this.getLookaheadName(t6) + " line " + t6.LT(1).line + ":" + t6.LT(1).column), this._input = t6, this._startIndex = t6.index, this._outerContext = i5;
                  const s5 = this.decisionToDFA[e5];
                  this._dfa = s5;
                  const r4 = t6.mark(), n3 = t6.index;
                  try {
                    let e6;
                    if (e6 = s5.precedenceDfa ? s5.getPrecedenceStartState(this.parser.getPrecedence()) : s5.s0, null === e6) {
                      null === i5 && (i5 = U3.EMPTY), this.debug && console.log("predictATN decision " + s5.decision + " exec LA(1)==" + this.getLookaheadName(t6) + ", outerContext=" + i5.toString(this.parser.ruleNames));
                      const r6 = false;
                      let n4 = this.computeStartState(s5.atnStartState, U3.EMPTY, r6);
                      s5.precedenceDfa ? (s5.s0.configs = n4, n4 = this.applyPrecedenceFilter(n4), e6 = this.addDFAState(s5, new Bt3(null, n4)), s5.setPrecedenceStartState(this.parser.getPrecedence(), e6)) : (e6 = this.addDFAState(s5, new Bt3(null, n4)), s5.s0 = e6);
                    }
                    const r5 = this.execATN(s5, e6, t6, n3, i5);
                    return this.debug && console.log("DFA after predictATN: " + s5.toString(this.parser.literalNames, this.parser.symbolicNames)), r5;
                  } finally {
                    this._dfa = null, this.mergeCache = null, t6.seek(n3), t6.release(r4);
                  }
                }
                execATN(e5, i5, s5, r4, n3) {
                  let a3;
                  (this.debug || this.trace_atn_sim) && console.log("execATN decision " + e5.decision + ", DFA state " + i5 + ", LA(1)==" + this.getLookaheadName(s5) + " line " + s5.LT(1).line + ":" + s5.LT(1).column);
                  let o2 = i5;
                  this.debug && console.log("s0 = " + i5);
                  let l2 = s5.LA(1);
                  for (; ; ) {
                    let i6 = this.getExistingTargetState(o2, l2);
                    if (null === i6 && (i6 = this.computeTargetState(e5, o2, l2)), i6 === $t3.ERROR) {
                      const t6 = this.noViableAlt(s5, n3, o2.configs, r4);
                      if (s5.seek(r4), a3 = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(o2.configs, n3), a3 !== Y3.INVALID_ALT_NUMBER) return a3;
                      throw t6;
                    }
                    if (i6.requiresFullContext && this.predictionMode !== te3.SLL) {
                      let t6 = null;
                      if (null !== i6.predicates) {
                        this.debug && console.log("DFA state has preds in DFA sim LL failover");
                        const e6 = s5.index;
                        if (e6 !== r4 && s5.seek(r4), t6 = this.evalSemanticContext(i6.predicates, n3, true), 1 === t6.length) return this.debug && console.log("Full LL avoided"), t6.minValue();
                        e6 !== r4 && s5.seek(e6);
                      }
                      this.dfa_debug && console.log("ctx sensitive state " + n3 + " in " + i6);
                      const o3 = true, l3 = this.computeStartState(e5.atnStartState, n3, o3);
                      return this.reportAttemptingFullContext(e5, t6, i6.configs, r4, s5.index), a3 = this.execATNWithFullContext(e5, i6, l3, s5, r4, n3), a3;
                    }
                    if (i6.isAcceptState) {
                      if (null === i6.predicates) return i6.prediction;
                      const t6 = s5.index;
                      s5.seek(r4);
                      const a4 = this.evalSemanticContext(i6.predicates, n3, true);
                      if (0 === a4.length) throw this.noViableAlt(s5, n3, i6.configs, r4);
                      return 1 === a4.length || this.reportAmbiguity(e5, i6, r4, t6, false, a4, i6.configs), a4.minValue();
                    }
                    o2 = i6, l2 !== t5.EOF && (s5.consume(), l2 = s5.LA(1));
                  }
                }
                getExistingTargetState(t6, e5) {
                  const i5 = t6.edges;
                  return null === i5 ? null : i5[e5 + 1] || null;
                }
                computeTargetState(t6, e5, i5) {
                  const s5 = this.computeReachSet(e5.configs, i5, false);
                  if (null === s5) return this.addDFAEdge(t6, e5, i5, $t3.ERROR), $t3.ERROR;
                  let r4 = new Bt3(null, s5);
                  const n3 = this.getUniqueAlt(s5);
                  if (this.debug) {
                    const t7 = te3.getConflictingAltSubsets(s5);
                    console.log("SLL altSubSets=" + c2(t7) + ", configs=" + s5 + ", predict=" + n3 + ", allSubsetsConflict=" + te3.allSubsetsConflict(t7) + ", conflictingAlts=" + this.getConflictingAlts(s5));
                  }
                  return n3 !== Y3.INVALID_ALT_NUMBER ? (r4.isAcceptState = true, r4.configs.uniqueAlt = n3, r4.prediction = n3) : te3.hasSLLConflictTerminatingPrediction(this.predictionMode, s5) && (r4.configs.conflictingAlts = this.getConflictingAlts(s5), r4.requiresFullContext = true, r4.isAcceptState = true, r4.prediction = r4.configs.conflictingAlts.minValue()), r4.isAcceptState && r4.configs.hasSemanticContext && (this.predicateDFAState(r4, this.atn.getDecisionState(t6.decision)), null !== r4.predicates && (r4.prediction = Y3.INVALID_ALT_NUMBER)), r4 = this.addDFAEdge(t6, e5, i5, r4), r4;
                }
                predicateDFAState(t6, e5) {
                  const i5 = e5.transitions.length, s5 = this.getConflictingAltsOrUniqueAlt(t6.configs), r4 = this.getPredsForAmbigAlts(s5, t6.configs, i5);
                  null !== r4 ? (t6.predicates = this.getPredicatePredictions(s5, r4), t6.prediction = Y3.INVALID_ALT_NUMBER) : t6.prediction = s5.minValue();
                }
                execATNWithFullContext(e5, i5, s5, r4, n3, a3) {
                  (this.debug || this.trace_atn_sim) && console.log("execATNWithFullContext " + s5);
                  let o2, l2 = false, h3 = s5;
                  r4.seek(n3);
                  let c3 = r4.LA(1), u3 = -1;
                  for (; ; ) {
                    if (o2 = this.computeReachSet(h3, c3, true), null === o2) {
                      const t6 = this.noViableAlt(r4, a3, h3, n3);
                      r4.seek(n3);
                      const e7 = this.getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(h3, a3);
                      if (e7 !== Y3.INVALID_ALT_NUMBER) return e7;
                      throw t6;
                    }
                    const e6 = te3.getConflictingAltSubsets(o2);
                    if (this.debug && console.log("LL altSubSets=" + e6 + ", predict=" + te3.getUniqueAlt(e6) + ", resolvesToJustOneViableAlt=" + te3.resolvesToJustOneViableAlt(e6)), o2.uniqueAlt = this.getUniqueAlt(o2), o2.uniqueAlt !== Y3.INVALID_ALT_NUMBER) {
                      u3 = o2.uniqueAlt;
                      break;
                    }
                    if (this.predictionMode !== te3.LL_EXACT_AMBIG_DETECTION) {
                      if (u3 = te3.resolvesToJustOneViableAlt(e6), u3 !== Y3.INVALID_ALT_NUMBER) break;
                    } else if (te3.allSubsetsConflict(e6) && te3.allSubsetsEqual(e6)) {
                      l2 = true, u3 = te3.getSingleViableAlt(e6);
                      break;
                    }
                    h3 = o2, c3 !== t5.EOF && (r4.consume(), c3 = r4.LA(1));
                  }
                  return o2.uniqueAlt !== Y3.INVALID_ALT_NUMBER ? (this.reportContextSensitivity(e5, u3, o2, n3, r4.index), u3) : (this.reportAmbiguity(e5, i5, n3, r4.index, l2, null, o2), u3);
                }
                computeReachSet(e5, i5, s5) {
                  this.debug && console.log("in computeReachSet, starting closure: " + e5), null === this.mergeCache && (this.mergeCache = new ie3());
                  const r4 = new Vt3(s5);
                  let n3 = null;
                  for (let a4 = 0; a4 < e5.items.length; a4++) {
                    const o2 = e5.items[a4];
                    if (this.debug && console.log("testing " + this.getTokenName(i5) + " at " + o2), o2.state instanceof R3) (s5 || i5 === t5.EOF) && (null === n3 && (n3 = []), n3.push(o2), this.debug_add && console.log("added " + o2 + " to skippedStopStates"));
                    else for (let t6 = 0; t6 < o2.state.transitions.length; t6++) {
                      const e6 = o2.state.transitions[t6], s6 = this.getReachableTarget(e6, i5);
                      if (null !== s6) {
                        const t7 = new y3({ state: s6 }, o2);
                        r4.add(t7, this.mergeCache), this.debug_add && console.log("added " + t7 + " to intermediate");
                      }
                    }
                  }
                  let a3 = null;
                  if (null === n3 && i5 !== t5.EOF && (1 === r4.items.length || this.getUniqueAlt(r4) !== Y3.INVALID_ALT_NUMBER) && (a3 = r4), null === a3) {
                    a3 = new Vt3(s5);
                    const e6 = new p2(), n4 = i5 === t5.EOF;
                    for (let t6 = 0; t6 < r4.items.length; t6++) this.closure(r4.items[t6], a3, e6, false, s5, n4);
                  }
                  if (i5 === t5.EOF && (a3 = this.removeAllConfigsNotInRuleStopState(a3, a3 === r4)), !(null === n3 || s5 && te3.hasConfigInRuleStopState(a3))) for (let t6 = 0; t6 < n3.length; t6++) a3.add(n3[t6], this.mergeCache);
                  return this.trace_atn_sim && console.log("computeReachSet " + e5 + " -> " + a3), 0 === a3.items.length ? null : a3;
                }
                removeAllConfigsNotInRuleStopState(e5, i5) {
                  if (te3.allConfigsInRuleStopStates(e5)) return e5;
                  const s5 = new Vt3(e5.fullCtx);
                  for (let r4 = 0; r4 < e5.items.length; r4++) {
                    const n3 = e5.items[r4];
                    if (n3.state instanceof R3) s5.add(n3, this.mergeCache);
                    else if (i5 && n3.state.epsilonOnlyTransitions && this.atn.nextTokens(n3.state).contains(t5.EPSILON)) {
                      const t6 = this.atn.ruleToStopState[n3.state.ruleIndex];
                      s5.add(new y3({ state: t6 }, n3), this.mergeCache);
                    }
                  }
                  return s5;
                }
                computeStartState(t6, e5, i5) {
                  const s5 = j2(this.atn, e5), r4 = new Vt3(i5);
                  this.trace_atn_sim && console.log("computeStartState from ATN state " + t6 + " initialContext=" + s5.toString(this.parser));
                  for (let e6 = 0; e6 < t6.transitions.length; e6++) {
                    const n3 = t6.transitions[e6].target, a3 = new y3({ state: n3, alt: e6 + 1, context: s5 }, null), o2 = new p2();
                    this.closure(a3, r4, o2, true, i5, false);
                  }
                  return r4;
                }
                applyPrecedenceFilter(t6) {
                  let e5;
                  const i5 = [], s5 = new Vt3(t6.fullCtx);
                  for (let r4 = 0; r4 < t6.items.length; r4++) {
                    if (e5 = t6.items[r4], 1 !== e5.alt) continue;
                    const n3 = e5.semanticContext.evalPrecedence(this.parser, this._outerContext);
                    null !== n3 && (i5[e5.state.stateNumber] = e5.context, n3 !== e5.semanticContext ? s5.add(new y3({ semanticContext: n3 }, e5), this.mergeCache) : s5.add(e5, this.mergeCache));
                  }
                  for (let r4 = 0; r4 < t6.items.length; r4++) if (e5 = t6.items[r4], 1 !== e5.alt) {
                    if (!e5.precedenceFilterSuppressed) {
                      const t7 = i5[e5.state.stateNumber] || null;
                      if (null !== t7 && t7.equals(e5.context)) continue;
                    }
                    s5.add(e5, this.mergeCache);
                  }
                  return s5;
                }
                getReachableTarget(t6, e5) {
                  return t6.matches(e5, 0, this.atn.maxTokenType) ? t6.target : null;
                }
                getPredsForAmbigAlts(t6, e5, i5) {
                  let s5 = [];
                  for (let i6 = 0; i6 < e5.items.length; i6++) {
                    const r5 = e5.items[i6];
                    t6.has(r5.alt) && (s5[r5.alt] = d2.orContext(s5[r5.alt] || null, r5.semanticContext));
                  }
                  let r4 = 0;
                  for (let t7 = 1; t7 < i5 + 1; t7++) {
                    const e6 = s5[t7] || null;
                    null === e6 ? s5[t7] = d2.NONE : e6 !== d2.NONE && (r4 += 1);
                  }
                  return 0 === r4 && (s5 = null), this.debug && console.log("getPredsForAmbigAlts result " + c2(s5)), s5;
                }
                getPredicatePredictions(t6, e5) {
                  const i5 = [];
                  let s5 = false;
                  for (let r4 = 1; r4 < e5.length; r4++) {
                    const n3 = e5[r4];
                    null !== t6 && t6.has(r4) && i5.push(new Jt3(n3, r4)), n3 !== d2.NONE && (s5 = true);
                  }
                  return s5 ? i5 : null;
                }
                getSynValidOrSemInvalidAltThatFinishedDecisionEntryRule(t6, e5) {
                  const i5 = this.splitAccordingToSemanticValidity(t6, e5), s5 = i5[0], r4 = i5[1];
                  let n3 = this.getAltThatFinishedDecisionEntryRule(s5);
                  return n3 !== Y3.INVALID_ALT_NUMBER || r4.items.length > 0 && (n3 = this.getAltThatFinishedDecisionEntryRule(r4), n3 !== Y3.INVALID_ALT_NUMBER) ? n3 : Y3.INVALID_ALT_NUMBER;
                }
                getAltThatFinishedDecisionEntryRule(t6) {
                  const e5 = [];
                  for (let i5 = 0; i5 < t6.items.length; i5++) {
                    const s5 = t6.items[i5];
                    (s5.reachesIntoOuterContext > 0 || s5.state instanceof R3 && s5.context.hasEmptyPath()) && e5.indexOf(s5.alt) < 0 && e5.push(s5.alt);
                  }
                  return 0 === e5.length ? Y3.INVALID_ALT_NUMBER : Math.min.apply(null, e5);
                }
                splitAccordingToSemanticValidity(t6, e5) {
                  const i5 = new Vt3(t6.fullCtx), s5 = new Vt3(t6.fullCtx);
                  for (let r4 = 0; r4 < t6.items.length; r4++) {
                    const n3 = t6.items[r4];
                    n3.semanticContext !== d2.NONE ? n3.semanticContext.evaluate(this.parser, e5) ? i5.add(n3) : s5.add(n3) : i5.add(n3);
                  }
                  return [i5, s5];
                }
                evalSemanticContext(t6, e5, i5) {
                  const s5 = new q3();
                  for (let r4 = 0; r4 < t6.length; r4++) {
                    const n3 = t6[r4];
                    if (n3.pred === d2.NONE) {
                      if (s5.add(n3.alt), !i5) break;
                      continue;
                    }
                    const a3 = n3.pred.evaluate(this.parser, e5);
                    if ((this.debug || this.dfa_debug) && console.log("eval pred " + n3 + "=" + a3), a3 && ((this.debug || this.dfa_debug) && console.log("PREDICT " + n3.alt), s5.add(n3.alt), !i5)) break;
                  }
                  return s5;
                }
                closure(t6, e5, i5, s5, r4, n3) {
                  this.closureCheckingStopState(t6, e5, i5, s5, r4, 0, n3);
                }
                closureCheckingStopState(t6, e5, i5, s5, r4, n3, a3) {
                  if ((this.trace_atn_sim || this.debug_closure) && console.log("closure(" + t6.toString(this.parser, true) + ")"), t6.state instanceof R3) {
                    if (!t6.context.isEmpty()) {
                      for (let o2 = 0; o2 < t6.context.length; o2++) {
                        if (t6.context.getReturnState(o2) === H3.EMPTY_RETURN_STATE) {
                          if (r4) {
                            e5.add(new y3({ state: t6.state, context: H3.EMPTY }, t6), this.mergeCache);
                            continue;
                          }
                          this.debug && console.log("FALLING off rule " + this.getRuleName(t6.state.ruleIndex)), this.closure_(t6, e5, i5, s5, r4, n3, a3);
                          continue;
                        }
                        const l2 = this.atn.states[t6.context.getReturnState(o2)], h3 = t6.context.getParent(o2), c3 = { state: l2, alt: t6.alt, context: h3, semanticContext: t6.semanticContext }, u3 = new y3(c3, null);
                        u3.reachesIntoOuterContext = t6.reachesIntoOuterContext, this.closureCheckingStopState(u3, e5, i5, s5, r4, n3 - 1, a3);
                      }
                      return;
                    }
                    if (r4) return void e5.add(t6, this.mergeCache);
                    this.debug && console.log("FALLING off rule " + this.getRuleName(t6.state.ruleIndex));
                  }
                  this.closure_(t6, e5, i5, s5, r4, n3, a3);
                }
                closure_(t6, e5, i5, s5, r4, n3, a3) {
                  const o2 = t6.state;
                  o2.epsilonOnlyTransitions || e5.add(t6, this.mergeCache);
                  for (let l2 = 0; l2 < o2.transitions.length; l2++) {
                    if (0 === l2 && this.canDropLoopEntryEdgeInLeftRecursiveRule(t6)) continue;
                    const h3 = o2.transitions[l2], c3 = s5 && !(h3 instanceof ut3), u3 = this.getEpsilonTarget(t6, h3, c3, 0 === n3, r4, a3);
                    if (null !== u3) {
                      let s6 = n3;
                      if (t6.state instanceof R3) {
                        if (null !== this._dfa && this._dfa.precedenceDfa && h3.outermostPrecedenceReturn === this._dfa.atnStartState.ruleIndex && (u3.precedenceFilterSuppressed = true), u3.reachesIntoOuterContext += 1, i5.add(u3) !== u3) continue;
                        e5.dipsIntoOuterContext = true, s6 -= 1, this.debug && console.log("dips into outer ctx: " + u3);
                      } else {
                        if (!h3.isEpsilon && i5.add(u3) !== u3) continue;
                        h3 instanceof b2 && s6 >= 0 && (s6 += 1);
                      }
                      this.closureCheckingStopState(u3, e5, i5, c3, r4, s6, a3);
                    }
                  }
                }
                canDropLoopEntryEdgeInLeftRecursiveRule(t6) {
                  const e5 = t6.state;
                  if (e5.stateType !== E2.STAR_LOOP_ENTRY) return false;
                  if (e5.stateType !== E2.STAR_LOOP_ENTRY || !e5.isPrecedenceDecision || t6.context.isEmpty() || t6.context.hasEmptyPath()) return false;
                  const i5 = t6.context.length;
                  for (let s6 = 0; s6 < i5; s6++) if (this.atn.states[t6.context.getReturnState(s6)].ruleIndex !== e5.ruleIndex) return false;
                  const s5 = e5.transitions[0].target.endState.stateNumber, r4 = this.atn.states[s5];
                  for (let s6 = 0; s6 < i5; s6++) {
                    const i6 = t6.context.getReturnState(s6), n3 = this.atn.states[i6];
                    if (1 !== n3.transitions.length || !n3.transitions[0].isEpsilon) return false;
                    const a3 = n3.transitions[0].target;
                    if (!(n3.stateType === E2.BLOCK_END && a3 === e5 || n3 === r4 || a3 === r4 || a3.stateType === E2.BLOCK_END && 1 === a3.transitions.length && a3.transitions[0].isEpsilon && a3.transitions[0].target === e5)) return false;
                  }
                  return true;
                }
                getRuleName(t6) {
                  return null !== this.parser && t6 >= 0 ? this.parser.ruleNames[t6] : "<rule " + t6 + ">";
                }
                getEpsilonTarget(e5, i5, s5, r4, n3, a3) {
                  switch (i5.serializationType) {
                    case v2.RULE:
                      return this.ruleTransition(e5, i5);
                    case v2.PRECEDENCE:
                      return this.precedenceTransition(e5, i5, s5, r4, n3);
                    case v2.PREDICATE:
                      return this.predTransition(e5, i5, s5, r4, n3);
                    case v2.ACTION:
                      return this.actionTransition(e5, i5);
                    case v2.EPSILON:
                      return new y3({ state: i5.target }, e5);
                    case v2.ATOM:
                    case v2.RANGE:
                    case v2.SET:
                      return a3 && i5.matches(t5.EOF, 0, 1) ? new y3({ state: i5.target }, e5) : null;
                    default:
                      return null;
                  }
                }
                actionTransition(t6, e5) {
                  if (this.debug) {
                    const t7 = -1 === e5.actionIndex ? 65535 : e5.actionIndex;
                    console.log("ACTION edge " + e5.ruleIndex + ":" + t7);
                  }
                  return new y3({ state: e5.target }, t6);
                }
                precedenceTransition(t6, e5, i5, s5, r4) {
                  this.debug && (console.log("PRED (collectPredicates=" + i5 + ") " + e5.precedence + ">=_p, ctx dependent=true"), null !== this.parser && console.log("context surrounding pred is " + c2(this.parser.getRuleInvocationStack())));
                  let n3 = null;
                  if (i5 && s5) if (r4) {
                    const i6 = this._input.index;
                    this._input.seek(this._startIndex);
                    const s6 = e5.getPredicate().evaluate(this.parser, this._outerContext);
                    this._input.seek(i6), s6 && (n3 = new y3({ state: e5.target }, t6));
                  } else {
                    const i6 = d2.andContext(t6.semanticContext, e5.getPredicate());
                    n3 = new y3({ state: e5.target, semanticContext: i6 }, t6);
                  }
                  else n3 = new y3({ state: e5.target }, t6);
                  return this.debug && console.log("config from pred transition=" + n3), n3;
                }
                predTransition(t6, e5, i5, s5, r4) {
                  this.debug && (console.log("PRED (collectPredicates=" + i5 + ") " + e5.ruleIndex + ":" + e5.predIndex + ", ctx dependent=" + e5.isCtxDependent), null !== this.parser && console.log("context surrounding pred is " + c2(this.parser.getRuleInvocationStack())));
                  let n3 = null;
                  if (i5 && (e5.isCtxDependent && s5 || !e5.isCtxDependent)) if (r4) {
                    const i6 = this._input.index;
                    this._input.seek(this._startIndex);
                    const s6 = e5.getPredicate().evaluate(this.parser, this._outerContext);
                    this._input.seek(i6), s6 && (n3 = new y3({ state: e5.target }, t6));
                  } else {
                    const i6 = d2.andContext(t6.semanticContext, e5.getPredicate());
                    n3 = new y3({ state: e5.target, semanticContext: i6 }, t6);
                  }
                  else n3 = new y3({ state: e5.target }, t6);
                  return this.debug && console.log("config from pred transition=" + n3), n3;
                }
                ruleTransition(t6, e5) {
                  this.debug && console.log("CALL rule " + this.getRuleName(e5.target.ruleIndex) + ", ctx=" + t6.context);
                  const i5 = e5.followState, s5 = K3.create(t6.context, i5.stateNumber);
                  return new y3({ state: e5.target, context: s5 }, t6);
                }
                getConflictingAlts(t6) {
                  const e5 = te3.getConflictingAltSubsets(t6);
                  return te3.getAlts(e5);
                }
                getConflictingAltsOrUniqueAlt(t6) {
                  let e5 = null;
                  return t6.uniqueAlt !== Y3.INVALID_ALT_NUMBER ? (e5 = new q3(), e5.add(t6.uniqueAlt)) : e5 = t6.conflictingAlts, e5;
                }
                getTokenName(e5) {
                  if (e5 === t5.EOF) return "EOF";
                  if (null !== this.parser && null !== this.parser.literalNames) {
                    if (!(e5 >= this.parser.literalNames.length && e5 >= this.parser.symbolicNames.length)) return (this.parser.literalNames[e5] || this.parser.symbolicNames[e5]) + "<" + e5 + ">";
                    console.log(e5 + " ttype out of range: " + this.parser.literalNames), console.log("" + this.parser.getInputStream().getTokens());
                  }
                  return "" + e5;
                }
                getLookaheadName(t6) {
                  return this.getTokenName(t6.LA(1));
                }
                dumpDeadEndConfigs(t6) {
                  console.log("dead end configs: ");
                  const e5 = t6.getDeadEndConfigs();
                  for (let t7 = 0; t7 < e5.length; t7++) {
                    const i5 = e5[t7];
                    let s5 = "no edges";
                    if (i5.state.transitions.length > 0) {
                      const t8 = i5.state.transitions[0];
                      t8 instanceof ht3 ? s5 = "Atom " + this.getTokenName(t8.label) : t8 instanceof L3 && (s5 = (t8 instanceof S3 ? "~" : "") + "Set " + t8.set);
                    }
                    console.error(i5.toString(this.parser, true) + ":" + s5);
                  }
                }
                noViableAlt(t6, e5, i5, s5) {
                  return new ee3(this.parser, t6, t6.get(s5), t6.LT(1), i5, e5);
                }
                getUniqueAlt(t6) {
                  let e5 = Y3.INVALID_ALT_NUMBER;
                  for (let i5 = 0; i5 < t6.items.length; i5++) {
                    const s5 = t6.items[i5];
                    if (e5 === Y3.INVALID_ALT_NUMBER) e5 = s5.alt;
                    else if (s5.alt !== e5) return Y3.INVALID_ALT_NUMBER;
                  }
                  return e5;
                }
                addDFAEdge(t6, e5, i5, s5) {
                  if (this.debug && console.log("EDGE " + e5 + " -> " + s5 + " upon " + this.getTokenName(i5)), null === s5) return null;
                  if (s5 = this.addDFAState(t6, s5), null === e5 || i5 < -1 || i5 > this.atn.maxTokenType) return s5;
                  if (null === e5.edges && (e5.edges = []), e5.edges[i5 + 1] = s5, this.debug) {
                    const e6 = null === this.parser ? null : this.parser.literalNames, i6 = null === this.parser ? null : this.parser.symbolicNames;
                    console.log("DFA=\n" + t6.toString(e6, i6));
                  }
                  return s5;
                }
                addDFAState(t6, e5) {
                  if (e5 === $t3.ERROR) return e5;
                  const i5 = t6.states.get(e5);
                  return null !== i5 ? (this.trace_atn_sim && console.log("addDFAState " + e5 + " exists"), i5) : (e5.stateNumber = t6.states.length, e5.configs.readOnly || (e5.configs.optimizeConfigs(this), e5.configs.setReadonly(true)), this.trace_atn_sim && console.log("addDFAState new " + e5), t6.states.add(e5), this.debug && console.log("adding new DFA state: " + e5), e5);
                }
                reportAttemptingFullContext(t6, e5, i5, s5, r4) {
                  if (this.debug || this.retry_debug) {
                    const e6 = new g2(s5, r4 + 1);
                    console.log("reportAttemptingFullContext decision=" + t6.decision + ":" + i5 + ", input=" + this.parser.getTokenStream().getText(e6));
                  }
                  null !== this.parser && this.parser.getErrorListenerDispatch().reportAttemptingFullContext(this.parser, t6, s5, r4, e5, i5);
                }
                reportContextSensitivity(t6, e5, i5, s5, r4) {
                  if (this.debug || this.retry_debug) {
                    const e6 = new g2(s5, r4 + 1);
                    console.log("reportContextSensitivity decision=" + t6.decision + ":" + i5 + ", input=" + this.parser.getTokenStream().getText(e6));
                  }
                  null !== this.parser && this.parser.getErrorListenerDispatch().reportContextSensitivity(this.parser, t6, s5, r4, e5, i5);
                }
                reportAmbiguity(t6, e5, i5, s5, r4, n3, a3) {
                  if (this.debug || this.retry_debug) {
                    const t7 = new g2(i5, s5 + 1);
                    console.log("reportAmbiguity " + n3 + ":" + a3 + ", input=" + this.parser.getTokenStream().getText(t7));
                  }
                  null !== this.parser && this.parser.getErrorListenerDispatch().reportAmbiguity(this.parser, t6, i5, s5, r4, n3, a3);
                }
              }
              class re3 {
                constructor() {
                  this.cache = new $3();
                }
                add(t6) {
                  if (t6 === H3.EMPTY) return H3.EMPTY;
                  const e5 = this.cache.get(t6) || null;
                  return null !== e5 ? e5 : (this.cache.set(t6, t6), t6);
                }
                get(t6) {
                  return this.cache.get(t6) || null;
                }
                get length() {
                  return this.cache.length;
                }
              }
              const ne3 = { ATN: Y3, ATNDeserializer: At3, LexerATNSimulator: Xt3, ParserATNSimulator: se3, PredictionMode: te3, PredictionContextCache: re3 };
              class ae2 {
                constructor(t6, e5, i5) {
                  this.dfa = t6, this.literalNames = e5 || [], this.symbolicNames = i5 || [];
                }
                toString() {
                  if (null === this.dfa.s0) return null;
                  let t6 = "";
                  const e5 = this.dfa.sortedStates();
                  for (let i5 = 0; i5 < e5.length; i5++) {
                    const s5 = e5[i5];
                    if (null !== s5.edges) {
                      const e6 = s5.edges.length;
                      for (let i6 = 0; i6 < e6; i6++) {
                        const e7 = s5.edges[i6] || null;
                        null !== e7 && 2147483647 !== e7.stateNumber && (t6 = t6.concat(this.getStateString(s5)), t6 = t6.concat("-"), t6 = t6.concat(this.getEdgeLabel(i6)), t6 = t6.concat("->"), t6 = t6.concat(this.getStateString(e7)), t6 = t6.concat("\n"));
                      }
                    }
                  }
                  return 0 === t6.length ? null : t6;
                }
                getEdgeLabel(t6) {
                  return 0 === t6 ? "EOF" : null !== this.literalNames || null !== this.symbolicNames ? this.literalNames[t6 - 1] || this.symbolicNames[t6 - 1] : String.fromCharCode(t6 - 1);
                }
                getStateString(t6) {
                  const e5 = (t6.isAcceptState ? ":" : "") + "s" + t6.stateNumber + (t6.requiresFullContext ? "^" : "");
                  return t6.isAcceptState ? null !== t6.predicates ? e5 + "=>" + c2(t6.predicates) : e5 + "=>" + t6.prediction.toString() : e5;
                }
              }
              class oe3 extends ae2 {
                constructor(t6) {
                  super(t6, null);
                }
                getEdgeLabel(t6) {
                  return "'" + String.fromCharCode(t6) + "'";
                }
              }
              class le3 {
                constructor(t6, e5) {
                  if (void 0 === e5 && (e5 = 0), this.atnStartState = t6, this.decision = e5, this._states = new p2(), this.s0 = null, this.precedenceDfa = false, t6 instanceof nt3 && t6.isPrecedenceDecision) {
                    this.precedenceDfa = true;
                    const t7 = new Bt3(null, new Vt3());
                    t7.edges = [], t7.isAcceptState = false, t7.requiresFullContext = false, this.s0 = t7;
                  }
                }
                getPrecedenceStartState(t6) {
                  if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
                  return t6 < 0 || t6 >= this.s0.edges.length ? null : this.s0.edges[t6] || null;
                }
                setPrecedenceStartState(t6, e5) {
                  if (!this.precedenceDfa) throw "Only precedence DFAs may contain a precedence start state.";
                  t6 < 0 || (this.s0.edges[t6] = e5);
                }
                setPrecedenceDfa(t6) {
                  if (this.precedenceDfa !== t6) {
                    if (this._states = new p2(), t6) {
                      const t7 = new Bt3(null, new Vt3());
                      t7.edges = [], t7.isAcceptState = false, t7.requiresFullContext = false, this.s0 = t7;
                    } else this.s0 = null;
                    this.precedenceDfa = t6;
                  }
                }
                sortedStates() {
                  return this._states.values().sort(function(t6, e5) {
                    return t6.stateNumber - e5.stateNumber;
                  });
                }
                toString(t6, e5) {
                  return t6 = t6 || null, e5 = e5 || null, null === this.s0 ? "" : new ae2(this, t6, e5).toString();
                }
                toLexerString() {
                  return null === this.s0 ? "" : new oe3(this).toString();
                }
                get states() {
                  return this._states;
                }
              }
              const he3 = { DFA: le3, DFASerializer: ae2, LexerDFASerializer: oe3, PredPrediction: Jt3 }, ce3 = { PredictionContext: H3 }, ue3 = { Interval: g2, IntervalSet: T3 };
              class pe3 {
                visitTerminal(t6) {
                }
                visitErrorNode(t6) {
                }
                enterEveryRule(t6) {
                }
                exitEveryRule(t6) {
                }
              }
              class de3 {
                visit(t6) {
                  return Array.isArray(t6) ? t6.map(function(t7) {
                    return t7.accept(this);
                  }, this) : t6.accept(this);
                }
                visitChildren(t6) {
                  return t6.children ? this.visit(t6.children) : null;
                }
                visitTerminal(t6) {
                }
                visitErrorNode(t6) {
                }
              }
              class me3 {
                walk(t6, e5) {
                  if (e5 instanceof O3 || void 0 !== e5.isErrorNode && e5.isErrorNode()) t6.visitErrorNode(e5);
                  else if (e5 instanceof D2) t6.visitTerminal(e5);
                  else {
                    this.enterRule(t6, e5);
                    for (let i5 = 0; i5 < e5.getChildCount(); i5++) {
                      const s5 = e5.getChild(i5);
                      this.walk(t6, s5);
                    }
                    this.exitRule(t6, e5);
                  }
                }
                enterRule(t6, e5) {
                  const i5 = e5.ruleContext;
                  t6.enterEveryRule(i5), i5.enterRule(t6);
                }
                exitRule(t6, e5) {
                  const i5 = e5.ruleContext;
                  i5.exitRule(t6), t6.exitEveryRule(i5);
                }
              }
              me3.DEFAULT = new me3();
              const _e3 = { Trees: F2, RuleNode: k3, ErrorNode: O3, TerminalNode: D2, ParseTreeListener: pe3, ParseTreeVisitor: de3, ParseTreeWalker: me3 };
              class xe3 extends Ft3 {
                constructor(t6) {
                  super({ message: "", recognizer: t6, input: t6.getInputStream(), ctx: t6._ctx }), this.offendingToken = t6.getCurrentToken();
                }
              }
              class fe3 extends Ft3 {
                constructor(t6, e5, i5) {
                  super({ message: ye3(e5, i5 || null), recognizer: t6, input: t6.getInputStream(), ctx: t6._ctx });
                  const s5 = t6._interp.atn.states[t6.state].transitions[0];
                  s5 instanceof mt3 ? (this.ruleIndex = s5.ruleIndex, this.predicateIndex = s5.predIndex) : (this.ruleIndex = 0, this.predicateIndex = 0), this.predicate = e5, this.offendingToken = t6.getCurrentToken();
                }
              }
              function ye3(t6, e5) {
                return null !== e5 ? e5 : "failed predicate: {" + t6 + "}?";
              }
              class ge3 extends wt3 {
                constructor(t6) {
                  super(), t6 = t6 || true, this.exactOnly = t6;
                }
                reportAmbiguity(t6, e5, i5, s5, r4, n3, a3) {
                  if (this.exactOnly && !r4) return;
                  const o2 = "reportAmbiguity d=" + this.getDecisionDescription(t6, e5) + ": ambigAlts=" + this.getConflictingAlts(n3, a3) + ", input='" + t6.getTokenStream().getText(new g2(i5, s5)) + "'";
                  t6.notifyErrorListeners(o2);
                }
                reportAttemptingFullContext(t6, e5, i5, s5, r4, n3) {
                  const a3 = "reportAttemptingFullContext d=" + this.getDecisionDescription(t6, e5) + ", input='" + t6.getTokenStream().getText(new g2(i5, s5)) + "'";
                  t6.notifyErrorListeners(a3);
                }
                reportContextSensitivity(t6, e5, i5, s5, r4, n3) {
                  const a3 = "reportContextSensitivity d=" + this.getDecisionDescription(t6, e5) + ", input='" + t6.getTokenStream().getText(new g2(i5, s5)) + "'";
                  t6.notifyErrorListeners(a3);
                }
                getDecisionDescription(t6, e5) {
                  const i5 = e5.decision, s5 = e5.atnStartState.ruleIndex, r4 = t6.ruleNames;
                  if (s5 < 0 || s5 >= r4.length) return "" + i5;
                  const n3 = r4[s5] || null;
                  return null === n3 || 0 === n3.length ? "" + i5 : `${i5} (${n3})`;
                }
                getConflictingAlts(t6, e5) {
                  if (null !== t6) return t6;
                  const i5 = new q3();
                  for (let t7 = 0; t7 < e5.items.length; t7++) i5.add(e5.items[t7].alt);
                  return `{${i5.values().join(", ")}}`;
                }
              }
              class Te3 extends Error {
                constructor() {
                  super(), Error.captureStackTrace(this, Te3);
                }
              }
              class Ee3 {
                reset(t6) {
                }
                recoverInline(t6) {
                }
                recover(t6, e5) {
                }
                sync(t6) {
                }
                inErrorRecoveryMode(t6) {
                }
                reportError(t6) {
                }
              }
              class Re3 extends Ee3 {
                constructor() {
                  super(), this.errorRecoveryMode = false, this.lastErrorIndex = -1, this.lastErrorStates = null, this.nextTokensContext = null, this.nextTokenState = 0;
                }
                reset(t6) {
                  this.endErrorCondition(t6);
                }
                beginErrorCondition(t6) {
                  this.errorRecoveryMode = true;
                }
                inErrorRecoveryMode(t6) {
                  return this.errorRecoveryMode;
                }
                endErrorCondition(t6) {
                  this.errorRecoveryMode = false, this.lastErrorStates = null, this.lastErrorIndex = -1;
                }
                reportMatch(t6) {
                  this.endErrorCondition(t6);
                }
                reportError(t6, e5) {
                  this.inErrorRecoveryMode(t6) || (this.beginErrorCondition(t6), e5 instanceof ee3 ? this.reportNoViableAlternative(t6, e5) : e5 instanceof xe3 ? this.reportInputMismatch(t6, e5) : e5 instanceof fe3 ? this.reportFailedPredicate(t6, e5) : (console.log("unknown recognition error type: " + e5.constructor.name), console.log(e5.stack), t6.notifyErrorListeners(e5.getOffendingToken(), e5.getMessage(), e5)));
                }
                recover(t6, e5) {
                  this.lastErrorIndex === t6.getInputStream().index && null !== this.lastErrorStates && this.lastErrorStates.indexOf(t6.state) >= 0 && t6.consume(), this.lastErrorIndex = t6._input.index, null === this.lastErrorStates && (this.lastErrorStates = []), this.lastErrorStates.push(t6.state);
                  const i5 = this.getErrorRecoverySet(t6);
                  this.consumeUntil(t6, i5);
                }
                sync(e5) {
                  if (this.inErrorRecoveryMode(e5)) return;
                  const i5 = e5._interp.atn.states[e5.state], s5 = e5.getTokenStream().LA(1), r4 = e5.atn.nextTokens(i5);
                  if (r4.contains(s5)) return this.nextTokensContext = null, void (this.nextTokenState = E2.INVALID_STATE_NUMBER);
                  if (r4.contains(t5.EPSILON)) null === this.nextTokensContext && (this.nextTokensContext = e5._ctx, this.nextTokensState = e5._stateNumber);
                  else switch (i5.stateType) {
                    case E2.BLOCK_START:
                    case E2.STAR_BLOCK_START:
                    case E2.PLUS_BLOCK_START:
                    case E2.STAR_LOOP_ENTRY:
                      if (null !== this.singleTokenDeletion(e5)) return;
                      throw new xe3(e5);
                    case E2.PLUS_LOOP_BACK:
                    case E2.STAR_LOOP_BACK: {
                      this.reportUnwantedToken(e5);
                      const t6 = new T3();
                      t6.addSet(e5.getExpectedTokens());
                      const i6 = t6.addSet(this.getErrorRecoverySet(e5));
                      this.consumeUntil(e5, i6);
                    }
                  }
                }
                reportNoViableAlternative(e5, i5) {
                  const s5 = e5.getTokenStream();
                  let r4;
                  r4 = null !== s5 ? i5.startToken.type === t5.EOF ? "<EOF>" : s5.getText(new g2(i5.startToken.tokenIndex, i5.offendingToken.tokenIndex)) : "<unknown input>";
                  const n3 = "no viable alternative at input " + this.escapeWSAndQuote(r4);
                  e5.notifyErrorListeners(n3, i5.offendingToken, i5);
                }
                reportInputMismatch(t6, e5) {
                  const i5 = "mismatched input " + this.getTokenErrorDisplay(e5.offendingToken) + " expecting " + e5.getExpectedTokens().toString(t6.literalNames, t6.symbolicNames);
                  t6.notifyErrorListeners(i5, e5.offendingToken, e5);
                }
                reportFailedPredicate(t6, e5) {
                  const i5 = "rule " + t6.ruleNames[t6._ctx.ruleIndex] + " " + e5.message;
                  t6.notifyErrorListeners(i5, e5.offendingToken, e5);
                }
                reportUnwantedToken(t6) {
                  if (this.inErrorRecoveryMode(t6)) return;
                  this.beginErrorCondition(t6);
                  const e5 = t6.getCurrentToken(), i5 = "extraneous input " + this.getTokenErrorDisplay(e5) + " expecting " + this.getExpectedTokens(t6).toString(t6.literalNames, t6.symbolicNames);
                  t6.notifyErrorListeners(i5, e5, null);
                }
                reportMissingToken(t6) {
                  if (this.inErrorRecoveryMode(t6)) return;
                  this.beginErrorCondition(t6);
                  const e5 = t6.getCurrentToken(), i5 = "missing " + this.getExpectedTokens(t6).toString(t6.literalNames, t6.symbolicNames) + " at " + this.getTokenErrorDisplay(e5);
                  t6.notifyErrorListeners(i5, e5, null);
                }
                recoverInline(t6) {
                  const e5 = this.singleTokenDeletion(t6);
                  if (null !== e5) return t6.consume(), e5;
                  if (this.singleTokenInsertion(t6)) return this.getMissingSymbol(t6);
                  throw new xe3(t6);
                }
                singleTokenInsertion(t6) {
                  const e5 = t6.getTokenStream().LA(1), i5 = t6._interp.atn, s5 = i5.states[t6.state].transitions[0].target;
                  return !!i5.nextTokens(s5, t6._ctx).contains(e5) && (this.reportMissingToken(t6), true);
                }
                singleTokenDeletion(t6) {
                  const e5 = t6.getTokenStream().LA(2);
                  if (this.getExpectedTokens(t6).contains(e5)) {
                    this.reportUnwantedToken(t6), t6.consume();
                    const e6 = t6.getCurrentToken();
                    return this.reportMatch(t6), e6;
                  }
                  return null;
                }
                getMissingSymbol(e5) {
                  const i5 = e5.getCurrentToken(), s5 = this.getExpectedTokens(e5).first();
                  let r4;
                  r4 = s5 === t5.EOF ? "<missing EOF>" : "<missing " + e5.literalNames[s5] + ">";
                  let n3 = i5;
                  const a3 = e5.getTokenStream().LT(-1);
                  return n3.type === t5.EOF && null !== a3 && (n3 = a3), e5.getTokenFactory().create(n3.source, s5, r4, t5.DEFAULT_CHANNEL, -1, -1, n3.line, n3.column);
                }
                getExpectedTokens(t6) {
                  return t6.getExpectedTokens();
                }
                getTokenErrorDisplay(e5) {
                  if (null === e5) return "<no token>";
                  let i5 = e5.text;
                  return null === i5 && (i5 = e5.type === t5.EOF ? "<EOF>" : "<" + e5.type + ">"), this.escapeWSAndQuote(i5);
                }
                escapeWSAndQuote(t6) {
                  return "'" + (t6 = (t6 = (t6 = t6.replace(/\n/g, "\\n")).replace(/\r/g, "\\r")).replace(/\t/g, "\\t")) + "'";
                }
                getErrorRecoverySet(e5) {
                  const i5 = e5._interp.atn;
                  let s5 = e5._ctx;
                  const r4 = new T3();
                  for (; null !== s5 && s5.invokingState >= 0; ) {
                    const t6 = i5.states[s5.invokingState].transitions[0], e6 = i5.nextTokens(t6.followState);
                    r4.addSet(e6), s5 = s5.parentCtx;
                  }
                  return r4.removeOne(t5.EPSILON), r4;
                }
                consumeUntil(e5, i5) {
                  let s5 = e5.getTokenStream().LA(1);
                  for (; s5 !== t5.EOF && !i5.contains(s5); ) e5.consume(), s5 = e5.getTokenStream().LA(1);
                }
              }
              class ve3 extends Re3 {
                constructor() {
                  super();
                }
                recover(t6, e5) {
                  let i5 = t6._ctx;
                  for (; null !== i5; ) i5.exception = e5, i5 = i5.parentCtx;
                  throw new Te3(e5);
                }
                recoverInline(t6) {
                  this.recover(t6, new xe3(t6));
                }
                sync(t6) {
                }
              }
              const be3 = { RecognitionException: Ft3, NoViableAltException: ee3, LexerNoViableAltException: Ut3, InputMismatchException: xe3, FailedPredicateException: fe3, DiagnosticErrorListener: ge3, BailErrorStrategy: ve3, DefaultErrorStrategy: Re3, ErrorListener: wt3 };
              class Le3 {
                constructor(t6, e5) {
                  if (this.name = "<empty>", this.strdata = t6, this.decodeToUnicodeCodePoints = e5 || false, this._index = 0, this.data = [], this.decodeToUnicodeCodePoints) for (let t7 = 0; t7 < this.strdata.length; ) {
                    const e6 = this.strdata.codePointAt(t7);
                    this.data.push(e6), t7 += e6 <= 65535 ? 1 : 2;
                  }
                  else {
                    this.data = new Array(this.strdata.length);
                    for (let t7 = 0; t7 < this.strdata.length; t7++) this.data[t7] = this.strdata.charCodeAt(t7);
                  }
                  this._size = this.data.length;
                }
                reset() {
                  this._index = 0;
                }
                consume() {
                  if (this._index >= this._size) throw "cannot consume EOF";
                  this._index += 1;
                }
                LA(e5) {
                  if (0 === e5) return 0;
                  e5 < 0 && (e5 += 1);
                  const i5 = this._index + e5 - 1;
                  return i5 < 0 || i5 >= this._size ? t5.EOF : this.data[i5];
                }
                LT(t6) {
                  return this.LA(t6);
                }
                mark() {
                  return -1;
                }
                release(t6) {
                }
                seek(t6) {
                  t6 <= this._index ? this._index = t6 : this._index = Math.min(t6, this._size);
                }
                getText(t6, e5) {
                  if (e5 >= this._size && (e5 = this._size - 1), t6 >= this._size) return "";
                  if (this.decodeToUnicodeCodePoints) {
                    let i5 = "";
                    for (let s5 = t6; s5 <= e5; s5++) i5 += String.fromCodePoint(this.data[s5]);
                    return i5;
                  }
                  return this.strdata.slice(t6, e5 + 1);
                }
                toString() {
                  return this.strdata;
                }
                get index() {
                  return this._index;
                }
                get size() {
                  return this._size;
                }
              }
              class Se3 extends Le3 {
                constructor(t6, e5) {
                  super(t6, e5);
                }
              }
              var Ce3 = o(92);
              const Ae3 = "undefined" != typeof process && null != process.versions && null != process.versions.node;
              class we3 extends Se3 {
                static fromPath(t6, e5, i5) {
                  if (!Ae3) throw new Error("FileStream is only available when running in Node!");
                  Ce3.readFile(t6, e5, function(t7, e6) {
                    let s5 = null;
                    null !== e6 && (s5 = new Le3(e6, true)), i5(t7, s5);
                  });
                }
                constructor(t6, e5, i5) {
                  if (!Ae3) throw new Error("FileStream is only available when running in Node!");
                  super(Ce3.readFileSync(t6, e5 || "utf-8"), i5), this.fileName = t6;
                }
              }
              const Ne3 = { fromString: function(t6) {
                return new Le3(t6, true);
              }, fromBlob: function(t6, e5, i5, s5) {
                const r4 = new window.FileReader();
                r4.onload = function(t7) {
                  const e6 = new Le3(t7.target.result, true);
                  i5(e6);
                }, r4.onerror = s5, r4.readAsText(t6, e5);
              }, fromBuffer: function(t6, e5) {
                return new Le3(t6.toString(e5), true);
              }, fromPath: function(t6, e5, i5) {
                we3.fromPath(t6, e5, i5);
              }, fromPathSync: function(t6, e5) {
                return new we3(t6, e5);
              } }, Ie3 = { arrayToString: c2, stringToCharArray: function(t6) {
                let e5 = new Uint16Array(t6.length);
                for (let i5 = 0; i5 < t6.length; i5++) e5[i5] = t6.charCodeAt(i5);
                return e5;
              } };
              class ke3 {
              }
              class De3 extends ke3 {
                constructor(t6) {
                  super(), this.tokenSource = t6, this.tokens = [], this.index = -1, this.fetchedEOF = false;
                }
                mark() {
                  return 0;
                }
                release(t6) {
                }
                reset() {
                  this.seek(0);
                }
                seek(t6) {
                  this.lazyInit(), this.index = this.adjustSeekIndex(t6);
                }
                get size() {
                  return this.tokens.length;
                }
                get(t6) {
                  return this.lazyInit(), this.tokens[t6];
                }
                consume() {
                  let e5 = false;
                  if (e5 = this.index >= 0 && (this.fetchedEOF ? this.index < this.tokens.length - 1 : this.index < this.tokens.length), !e5 && this.LA(1) === t5.EOF) throw "cannot consume EOF";
                  this.sync(this.index + 1) && (this.index = this.adjustSeekIndex(this.index + 1));
                }
                sync(t6) {
                  const e5 = t6 - this.tokens.length + 1;
                  return !(e5 > 0) || this.fetch(e5) >= e5;
                }
                fetch(e5) {
                  if (this.fetchedEOF) return 0;
                  for (let i5 = 0; i5 < e5; i5++) {
                    const e6 = this.tokenSource.nextToken();
                    if (e6.tokenIndex = this.tokens.length, this.tokens.push(e6), e6.type === t5.EOF) return this.fetchedEOF = true, i5 + 1;
                  }
                  return e5;
                }
                getTokens(e5, i5, s5) {
                  if (void 0 === s5 && (s5 = null), e5 < 0 || i5 < 0) return null;
                  this.lazyInit();
                  const r4 = [];
                  i5 >= this.tokens.length && (i5 = this.tokens.length - 1);
                  for (let n3 = e5; n3 < i5; n3++) {
                    const e6 = this.tokens[n3];
                    if (e6.type === t5.EOF) break;
                    (null === s5 || s5.contains(e6.type)) && r4.push(e6);
                  }
                  return r4;
                }
                LA(t6) {
                  return this.LT(t6).type;
                }
                LB(t6) {
                  return this.index - t6 < 0 ? null : this.tokens[this.index - t6];
                }
                LT(t6) {
                  if (this.lazyInit(), 0 === t6) return null;
                  if (t6 < 0) return this.LB(-t6);
                  const e5 = this.index + t6 - 1;
                  return this.sync(e5), e5 >= this.tokens.length ? this.tokens[this.tokens.length - 1] : this.tokens[e5];
                }
                adjustSeekIndex(t6) {
                  return t6;
                }
                lazyInit() {
                  -1 === this.index && this.setup();
                }
                setup() {
                  this.sync(0), this.index = this.adjustSeekIndex(0);
                }
                setTokenSource(t6) {
                  this.tokenSource = t6, this.tokens = [], this.index = -1, this.fetchedEOF = false;
                }
                nextTokenOnChannel(e5, i5) {
                  if (this.sync(e5), e5 >= this.tokens.length) return -1;
                  let s5 = this.tokens[e5];
                  for (; s5.channel !== this.channel; ) {
                    if (s5.type === t5.EOF) return -1;
                    e5 += 1, this.sync(e5), s5 = this.tokens[e5];
                  }
                  return e5;
                }
                previousTokenOnChannel(t6, e5) {
                  for (; t6 >= 0 && this.tokens[t6].channel !== e5; ) t6 -= 1;
                  return t6;
                }
                getHiddenTokensToRight(t6, e5) {
                  if (void 0 === e5 && (e5 = -1), this.lazyInit(), t6 < 0 || t6 >= this.tokens.length) throw t6 + " not in 0.." + this.tokens.length - 1;
                  const i5 = this.nextTokenOnChannel(t6 + 1, Ht3.DEFAULT_TOKEN_CHANNEL), s5 = t6 + 1, r4 = -1 === i5 ? this.tokens.length - 1 : i5;
                  return this.filterForChannel(s5, r4, e5);
                }
                getHiddenTokensToLeft(t6, e5) {
                  if (void 0 === e5 && (e5 = -1), this.lazyInit(), t6 < 0 || t6 >= this.tokens.length) throw t6 + " not in 0.." + this.tokens.length - 1;
                  const i5 = this.previousTokenOnChannel(t6 - 1, Ht3.DEFAULT_TOKEN_CHANNEL);
                  if (i5 === t6 - 1) return null;
                  const s5 = i5 + 1, r4 = t6 - 1;
                  return this.filterForChannel(s5, r4, e5);
                }
                filterForChannel(t6, e5, i5) {
                  const s5 = [];
                  for (let r4 = t6; r4 < e5 + 1; r4++) {
                    const t7 = this.tokens[r4];
                    -1 === i5 ? t7.channel !== Ht3.DEFAULT_TOKEN_CHANNEL && s5.push(t7) : t7.channel === i5 && s5.push(t7);
                  }
                  return 0 === s5.length ? null : s5;
                }
                getSourceName() {
                  return this.tokenSource.getSourceName();
                }
                getText(e5) {
                  this.lazyInit(), this.fill(), e5 || (e5 = new g2(0, this.tokens.length - 1));
                  let i5 = e5.start;
                  i5 instanceof t5 && (i5 = i5.tokenIndex);
                  let s5 = e5.stop;
                  if (s5 instanceof t5 && (s5 = s5.tokenIndex), null === i5 || null === s5 || i5 < 0 || s5 < 0) return "";
                  s5 >= this.tokens.length && (s5 = this.tokens.length - 1);
                  let r4 = "";
                  for (let e6 = i5; e6 < s5 + 1; e6++) {
                    const i6 = this.tokens[e6];
                    if (i6.type === t5.EOF) break;
                    r4 += i6.text;
                  }
                  return r4;
                }
                fill() {
                  for (this.lazyInit(); 1e3 === this.fetch(1e3); ) ;
                }
              }
              Object.defineProperty(De3, "size", { get: function() {
                return this.tokens.length;
              } });
              class Oe3 extends De3 {
                constructor(e5, i5) {
                  super(e5), this.channel = void 0 === i5 ? t5.DEFAULT_CHANNEL : i5;
                }
                adjustSeekIndex(t6) {
                  return this.nextTokenOnChannel(t6, this.channel);
                }
                LB(t6) {
                  if (0 === t6 || this.index - t6 < 0) return null;
                  let e5 = this.index, i5 = 1;
                  for (; i5 <= t6; ) e5 = this.previousTokenOnChannel(e5 - 1, this.channel), i5 += 1;
                  return e5 < 0 ? null : this.tokens[e5];
                }
                LT(t6) {
                  if (this.lazyInit(), 0 === t6) return null;
                  if (t6 < 0) return this.LB(-t6);
                  let e5 = this.index, i5 = 1;
                  for (; i5 < t6; ) this.sync(e5 + 1) && (e5 = this.nextTokenOnChannel(e5 + 1, this.channel)), i5 += 1;
                  return this.tokens[e5];
                }
                getNumberOfOnChannelTokens() {
                  let e5 = 0;
                  this.fill();
                  for (let i5 = 0; i5 < this.tokens.length; i5++) {
                    const s5 = this.tokens[i5];
                    if (s5.channel === this.channel && (e5 += 1), s5.type === t5.EOF) break;
                  }
                  return e5;
                }
              }
              class Pe3 extends pe3 {
                constructor(t6) {
                  super(), this.parser = t6;
                }
                enterEveryRule(t6) {
                  console.log("enter   " + this.parser.ruleNames[t6.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
                }
                visitTerminal(t6) {
                  console.log("consume " + t6.symbol + " rule " + this.parser.ruleNames[this.parser._ctx.ruleIndex]);
                }
                exitEveryRule(t6) {
                  console.log("exit    " + this.parser.ruleNames[t6.ruleIndex] + ", LT(1)=" + this.parser._input.LT(1).text);
                }
              }
              class Fe3 extends kt3 {
                constructor(t6) {
                  super(), this._input = null, this._errHandler = new Re3(), this._precedenceStack = [], this._precedenceStack.push(0), this._ctx = null, this.buildParseTrees = true, this._tracer = null, this._parseListeners = null, this._syntaxErrors = 0, this.setInputStream(t6);
                }
                reset() {
                  null !== this._input && this._input.seek(0), this._errHandler.reset(this), this._ctx = null, this._syntaxErrors = 0, this.setTrace(false), this._precedenceStack = [], this._precedenceStack.push(0), null !== this._interp && this._interp.reset();
                }
                match(t6) {
                  let e5 = this.getCurrentToken();
                  return e5.type === t6 ? (this._errHandler.reportMatch(this), this.consume()) : (e5 = this._errHandler.recoverInline(this), this.buildParseTrees && -1 === e5.tokenIndex && this._ctx.addErrorNode(e5)), e5;
                }
                matchWildcard() {
                  let t6 = this.getCurrentToken();
                  return t6.type > 0 ? (this._errHandler.reportMatch(this), this.consume()) : (t6 = this._errHandler.recoverInline(this), this.buildParseTrees && -1 === t6.tokenIndex && this._ctx.addErrorNode(t6)), t6;
                }
                getParseListeners() {
                  return this._parseListeners || [];
                }
                addParseListener(t6) {
                  if (null === t6) throw "listener";
                  null === this._parseListeners && (this._parseListeners = []), this._parseListeners.push(t6);
                }
                removeParseListener(t6) {
                  if (null !== this._parseListeners) {
                    const e5 = this._parseListeners.indexOf(t6);
                    e5 >= 0 && this._parseListeners.splice(e5, 1), 0 === this._parseListeners.length && (this._parseListeners = null);
                  }
                }
                removeParseListeners() {
                  this._parseListeners = null;
                }
                triggerEnterRuleEvent() {
                  if (null !== this._parseListeners) {
                    const t6 = this._ctx;
                    this._parseListeners.forEach(function(e5) {
                      e5.enterEveryRule(t6), t6.enterRule(e5);
                    });
                  }
                }
                triggerExitRuleEvent() {
                  if (null !== this._parseListeners) {
                    const t6 = this._ctx;
                    this._parseListeners.slice(0).reverse().forEach(function(e5) {
                      t6.exitRule(e5), e5.exitEveryRule(t6);
                    });
                  }
                }
                getTokenFactory() {
                  return this._input.tokenSource._factory;
                }
                setTokenFactory(t6) {
                  this._input.tokenSource._factory = t6;
                }
                getATNWithBypassAlts() {
                  const t6 = this.getSerializedATN();
                  if (null === t6) throw "The current parser does not support an ATN with bypass alternatives.";
                  let e5 = this.bypassAltsAtnCache[t6];
                  if (null === e5) {
                    const i5 = new ft3();
                    i5.generateRuleBypassTransitions = true, e5 = new At3(i5).deserialize(t6), this.bypassAltsAtnCache[t6] = e5;
                  }
                  return e5;
                }
                getInputStream() {
                  return this.getTokenStream();
                }
                setInputStream(t6) {
                  this.setTokenStream(t6);
                }
                getTokenStream() {
                  return this._input;
                }
                setTokenStream(t6) {
                  this._input = null, this.reset(), this._input = t6;
                }
                get syntaxErrorsCount() {
                  return this._syntaxErrors;
                }
                getCurrentToken() {
                  return this._input.LT(1);
                }
                notifyErrorListeners(t6, e5, i5) {
                  i5 = i5 || null, null === (e5 = e5 || null) && (e5 = this.getCurrentToken()), this._syntaxErrors += 1;
                  const s5 = e5.line, r4 = e5.column;
                  this.getErrorListenerDispatch().syntaxError(this, e5, s5, r4, t6, i5);
                }
                consume() {
                  const e5 = this.getCurrentToken();
                  e5.type !== t5.EOF && this.getInputStream().consume();
                  const i5 = null !== this._parseListeners && this._parseListeners.length > 0;
                  if (this.buildParseTrees || i5) {
                    let t6;
                    t6 = this._errHandler.inErrorRecoveryMode(this) ? this._ctx.addErrorNode(e5) : this._ctx.addTokenNode(e5), t6.invokingState = this.state, i5 && this._parseListeners.forEach(function(e6) {
                      t6 instanceof O3 || void 0 !== t6.isErrorNode && t6.isErrorNode() ? e6.visitErrorNode(t6) : t6 instanceof D2 && e6.visitTerminal(t6);
                    });
                  }
                  return e5;
                }
                addContextToParseTree() {
                  null !== this._ctx.parentCtx && this._ctx.parentCtx.addChild(this._ctx);
                }
                enterRule(t6, e5, i5) {
                  this.state = e5, this._ctx = t6, this._ctx.start = this._input.LT(1), this.buildParseTrees && this.addContextToParseTree(), this.triggerEnterRuleEvent();
                }
                exitRule() {
                  this._ctx.stop = this._input.LT(-1), this.triggerExitRuleEvent(), this.state = this._ctx.invokingState, this._ctx = this._ctx.parentCtx;
                }
                enterOuterAlt(t6, e5) {
                  t6.setAltNumber(e5), this.buildParseTrees && this._ctx !== t6 && null !== this._ctx.parentCtx && (this._ctx.parentCtx.removeLastChild(), this._ctx.parentCtx.addChild(t6)), this._ctx = t6;
                }
                getPrecedence() {
                  return 0 === this._precedenceStack.length ? -1 : this._precedenceStack[this._precedenceStack.length - 1];
                }
                enterRecursionRule(t6, e5, i5, s5) {
                  this.state = e5, this._precedenceStack.push(s5), this._ctx = t6, this._ctx.start = this._input.LT(1), this.triggerEnterRuleEvent();
                }
                pushNewRecursionContext(t6, e5, i5) {
                  const s5 = this._ctx;
                  s5.parentCtx = t6, s5.invokingState = e5, s5.stop = this._input.LT(-1), this._ctx = t6, this._ctx.start = s5.start, this.buildParseTrees && this._ctx.addChild(s5), this.triggerEnterRuleEvent();
                }
                unrollRecursionContexts(t6) {
                  this._precedenceStack.pop(), this._ctx.stop = this._input.LT(-1);
                  const e5 = this._ctx, i5 = this.getParseListeners();
                  if (null !== i5 && i5.length > 0) for (; this._ctx !== t6; ) this.triggerExitRuleEvent(), this._ctx = this._ctx.parentCtx;
                  else this._ctx = t6;
                  e5.parentCtx = t6, this.buildParseTrees && null !== t6 && t6.addChild(e5);
                }
                getInvokingContext(t6) {
                  let e5 = this._ctx;
                  for (; null !== e5; ) {
                    if (e5.ruleIndex === t6) return e5;
                    e5 = e5.parentCtx;
                  }
                  return null;
                }
                precpred(t6, e5) {
                  return e5 >= this._precedenceStack[this._precedenceStack.length - 1];
                }
                inContext(t6) {
                  return false;
                }
                isExpectedToken(e5) {
                  const i5 = this._interp.atn;
                  let s5 = this._ctx;
                  const r4 = i5.states[this.state];
                  let n3 = i5.nextTokens(r4);
                  if (n3.contains(e5)) return true;
                  if (!n3.contains(t5.EPSILON)) return false;
                  for (; null !== s5 && s5.invokingState >= 0 && n3.contains(t5.EPSILON); ) {
                    const t6 = i5.states[s5.invokingState].transitions[0];
                    if (n3 = i5.nextTokens(t6.followState), n3.contains(e5)) return true;
                    s5 = s5.parentCtx;
                  }
                  return !(!n3.contains(t5.EPSILON) || e5 !== t5.EOF);
                }
                getExpectedTokens() {
                  return this._interp.atn.getExpectedTokens(this.state, this._ctx);
                }
                getExpectedTokensWithinCurrentRule() {
                  const t6 = this._interp.atn, e5 = t6.states[this.state];
                  return t6.nextTokens(e5);
                }
                getRuleIndex(t6) {
                  const e5 = this.getRuleIndexMap()[t6];
                  return null !== e5 ? e5 : -1;
                }
                getRuleInvocationStack(t6) {
                  null === (t6 = t6 || null) && (t6 = this._ctx);
                  const e5 = [];
                  for (; null !== t6; ) {
                    const i5 = t6.ruleIndex;
                    i5 < 0 ? e5.push("n/a") : e5.push(this.ruleNames[i5]), t6 = t6.parentCtx;
                  }
                  return e5;
                }
                getDFAStrings() {
                  return this._interp.decisionToDFA.toString();
                }
                dumpDFA() {
                  let t6 = false;
                  for (let e5 = 0; e5 < this._interp.decisionToDFA.length; e5++) {
                    const i5 = this._interp.decisionToDFA[e5];
                    i5.states.length > 0 && (t6 && console.log(), this.printer.println("Decision " + i5.decision + ":"), this.printer.print(i5.toString(this.literalNames, this.symbolicNames)), t6 = true);
                  }
                }
                getSourceName() {
                  return this._input.sourceName;
                }
                setTrace(t6) {
                  t6 ? (null !== this._tracer && this.removeParseListener(this._tracer), this._tracer = new Pe3(this), this.addParseListener(this._tracer)) : (this.removeParseListener(this._tracer), this._tracer = null);
                }
              }
              Fe3.bypassAltsAtnCache = {};
              class Ue3 extends D2 {
                constructor(t6) {
                  super(), this.parentCtx = null, this.symbol = t6;
                }
                getChild(t6) {
                  return null;
                }
                getSymbol() {
                  return this.symbol;
                }
                getParent() {
                  return this.parentCtx;
                }
                getPayload() {
                  return this.symbol;
                }
                getSourceInterval() {
                  if (null === this.symbol) return g2.INVALID_INTERVAL;
                  const t6 = this.symbol.tokenIndex;
                  return new g2(t6, t6);
                }
                getChildCount() {
                  return 0;
                }
                accept(t6) {
                  return t6.visitTerminal(this);
                }
                getText() {
                  return this.symbol.text;
                }
                toString() {
                  return this.symbol.type === t5.EOF ? "<EOF>" : this.symbol.text;
                }
              }
              class He3 extends Ue3 {
                constructor(t6) {
                  super(t6);
                }
                isErrorNode() {
                  return true;
                }
                accept(t6) {
                  return t6.visitErrorNode(this);
                }
              }
              class Me2 extends U3 {
                constructor(t6, e5) {
                  super(t6, e5), this.children = null, this.start = null, this.stop = null, this.exception = null;
                }
                copyFrom(t6) {
                  this.parentCtx = t6.parentCtx, this.invokingState = t6.invokingState, this.children = null, this.start = t6.start, this.stop = t6.stop, t6.children && (this.children = [], t6.children.map(function(t7) {
                    t7 instanceof He3 && (this.children.push(t7), t7.parentCtx = this);
                  }, this));
                }
                enterRule(t6) {
                }
                exitRule(t6) {
                }
                addChild(t6) {
                  return null === this.children && (this.children = []), this.children.push(t6), t6;
                }
                removeLastChild() {
                  null !== this.children && this.children.pop();
                }
                addTokenNode(t6) {
                  const e5 = new Ue3(t6);
                  return this.addChild(e5), e5.parentCtx = this, e5;
                }
                addErrorNode(t6) {
                  const e5 = new He3(t6);
                  return this.addChild(e5), e5.parentCtx = this, e5;
                }
                getChild(t6, e5) {
                  if (e5 = e5 || null, null === this.children || t6 < 0 || t6 >= this.children.length) return null;
                  if (null === e5) return this.children[t6];
                  for (let i5 = 0; i5 < this.children.length; i5++) {
                    const s5 = this.children[i5];
                    if (s5 instanceof e5) {
                      if (0 === t6) return s5;
                      t6 -= 1;
                    }
                  }
                  return null;
                }
                getToken(t6, e5) {
                  if (null === this.children || e5 < 0 || e5 >= this.children.length) return null;
                  for (let i5 = 0; i5 < this.children.length; i5++) {
                    const s5 = this.children[i5];
                    if (s5 instanceof D2 && s5.symbol.type === t6) {
                      if (0 === e5) return s5;
                      e5 -= 1;
                    }
                  }
                  return null;
                }
                getTokens(t6) {
                  if (null === this.children) return [];
                  {
                    const e5 = [];
                    for (let i5 = 0; i5 < this.children.length; i5++) {
                      const s5 = this.children[i5];
                      s5 instanceof D2 && s5.symbol.type === t6 && e5.push(s5);
                    }
                    return e5;
                  }
                }
                getTypedRuleContext(t6, e5) {
                  return this.getChild(e5, t6);
                }
                getTypedRuleContexts(t6) {
                  if (null === this.children) return [];
                  {
                    const e5 = [];
                    for (let i5 = 0; i5 < this.children.length; i5++) {
                      const s5 = this.children[i5];
                      s5 instanceof t6 && e5.push(s5);
                    }
                    return e5;
                  }
                }
                getChildCount() {
                  return null === this.children ? 0 : this.children.length;
                }
                getSourceInterval() {
                  return null === this.start || null === this.stop ? g2.INVALID_INTERVAL : new g2(this.start.tokenIndex, this.stop.tokenIndex);
                }
              }
              U3.EMPTY = new Me2();
              class Ke2 {
                constructor(t6) {
                  this.tokens = t6, this.programs = /* @__PURE__ */ new Map();
                }
                getTokenStream() {
                  return this.tokens;
                }
                insertAfter(t6, e5) {
                  let i5, s5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ke2.DEFAULT_PROGRAM_NAME;
                  i5 = "number" == typeof t6 ? t6 : t6.tokenIndex;
                  let r4 = this.getProgram(s5), n3 = new We2(this.tokens, i5, r4.length, e5);
                  r4.push(n3);
                }
                insertBefore(t6, e5) {
                  let i5, s5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ke2.DEFAULT_PROGRAM_NAME;
                  i5 = "number" == typeof t6 ? t6 : t6.tokenIndex;
                  const r4 = this.getProgram(s5), n3 = new qe2(this.tokens, i5, r4.length, e5);
                  r4.push(n3);
                }
                replaceSingle(t6, e5) {
                  let i5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ke2.DEFAULT_PROGRAM_NAME;
                  this.replace(t6, t6, e5, i5);
                }
                replace(t6, e5, i5) {
                  let s5 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ke2.DEFAULT_PROGRAM_NAME;
                  if ("number" != typeof t6 && (t6 = t6.tokenIndex), "number" != typeof e5 && (e5 = e5.tokenIndex), t6 > e5 || t6 < 0 || e5 < 0 || e5 >= this.tokens.size) throw new RangeError(`replace: range invalid: ${t6}..${e5}(size=${this.tokens.size})`);
                  let r4 = this.getProgram(s5), n3 = new Ye2(this.tokens, t6, e5, r4.length, i5);
                  r4.push(n3);
                }
                delete(t6, e5) {
                  let i5 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ke2.DEFAULT_PROGRAM_NAME;
                  void 0 === e5 && (e5 = t6), this.replace(t6, e5, null, i5);
                }
                getProgram(t6) {
                  let e5 = this.programs.get(t6);
                  return null == e5 && (e5 = this.initializeProgram(t6)), e5;
                }
                initializeProgram(t6) {
                  const e5 = [];
                  return this.programs.set(t6, e5), e5;
                }
                getText(e5) {
                  let i5, s5 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Ke2.DEFAULT_PROGRAM_NAME;
                  i5 = e5 instanceof g2 ? e5 : new g2(0, this.tokens.size - 1), "string" == typeof e5 && (s5 = e5);
                  const r4 = this.programs.get(s5);
                  let n3 = i5.start, a3 = i5.stop;
                  if (a3 > this.tokens.size - 1 && (a3 = this.tokens.size - 1), n3 < 0 && (n3 = 0), null == r4 || 0 === r4.length) return this.tokens.getText(new g2(n3, a3));
                  let o2 = [], l2 = this.reduceToSingleOperationPerIndex(r4), h3 = n3;
                  for (; h3 <= a3 && h3 < this.tokens.size; ) {
                    let e6 = l2.get(h3);
                    l2.delete(h3);
                    let i6 = this.tokens.get(h3);
                    null == e6 ? (i6.type !== t5.EOF && o2.push(String(i6.text)), h3++) : h3 = e6.execute(o2);
                  }
                  if (a3 === this.tokens.size - 1) for (const t6 of l2.values()) t6.index >= this.tokens.size - 1 && o2.push(t6.text.toString());
                  return o2.join("");
                }
                reduceToSingleOperationPerIndex(t6) {
                  for (let e6 = 0; e6 < t6.length; e6++) {
                    let i5 = t6[e6];
                    if (null == i5) continue;
                    if (!(i5 instanceof Ye2)) continue;
                    let s5 = i5, r4 = this.getKindOfOps(t6, qe2, e6);
                    for (let e7 of r4) e7.index === s5.index ? (t6[e7.instructionIndex] = void 0, s5.text = e7.text.toString() + (null != s5.text ? s5.text.toString() : "")) : e7.index > s5.index && e7.index <= s5.lastIndex && (t6[e7.instructionIndex] = void 0);
                    let n3 = this.getKindOfOps(t6, Ye2, e6);
                    for (let e7 of n3) {
                      if (e7.index >= s5.index && e7.lastIndex <= s5.lastIndex) {
                        t6[e7.instructionIndex] = void 0;
                        continue;
                      }
                      let i6 = e7.lastIndex < s5.index || e7.index > s5.lastIndex;
                      if (null != e7.text || null != s5.text || i6) {
                        if (!i6) throw new Error(`replace op boundaries of ${s5} overlap with previous ${e7}`);
                      } else t6[e7.instructionIndex] = void 0, s5.index = Math.min(e7.index, s5.index), s5.lastIndex = Math.max(e7.lastIndex, s5.lastIndex);
                    }
                  }
                  for (let e6 = 0; e6 < t6.length; e6++) {
                    let i5 = t6[e6];
                    if (null == i5) continue;
                    if (!(i5 instanceof qe2)) continue;
                    let s5 = i5, r4 = this.getKindOfOps(t6, qe2, e6);
                    for (let e7 of r4) e7.index === s5.index && (e7 instanceof We2 ? (s5.text = this.catOpText(e7.text, s5.text), t6[e7.instructionIndex] = void 0) : e7 instanceof qe2 && (s5.text = this.catOpText(s5.text, e7.text), t6[e7.instructionIndex] = void 0));
                    let n3 = this.getKindOfOps(t6, Ye2, e6);
                    for (let i6 of n3) if (s5.index !== i6.index) {
                      if (s5.index >= i6.index && s5.index <= i6.lastIndex) throw new Error(`insert op ${s5} within boundaries of previous ${i6}`);
                    } else i6.text = this.catOpText(s5.text, i6.text), t6[e6] = void 0;
                  }
                  let e5 = /* @__PURE__ */ new Map();
                  for (let i5 of t6) if (null != i5) {
                    if (null != e5.get(i5.index)) throw new Error("should only be one op per index");
                    e5.set(i5.index, i5);
                  }
                  return e5;
                }
                catOpText(t6, e5) {
                  let i5 = "", s5 = "";
                  return null != t6 && (i5 = t6.toString()), null != e5 && (s5 = e5.toString()), i5 + s5;
                }
                getKindOfOps(t6, e5, i5) {
                  return t6.slice(0, i5).filter((t7) => t7 && t7 instanceof e5);
                }
              }
              var Ve2, Be2, $e, je2, Ge2;
              Ve2 = Ke2, $e = "default", je2 = "DEFAULT_PROGRAM_NAME", (Be2 = "symbol" == typeof (Ge2 = function(t6, e5) {
                if ("object" != typeof t6 || null === t6) return t6;
                var i5 = t6[Symbol.toPrimitive];
                if (void 0 !== i5) {
                  var s5 = i5.call(t6, "string");
                  if ("object" != typeof s5) return s5;
                  throw new TypeError("@@toPrimitive must return a primitive value.");
                }
                return String(t6);
              }(je2)) ? Ge2 : String(Ge2)) in Ve2 ? Object.defineProperty(Ve2, Be2, { value: $e, enumerable: true, configurable: true, writable: true }) : Ve2[Be2] = $e;
              class ze2 {
                constructor(t6, e5, i5, s5) {
                  this.tokens = t6, this.instructionIndex = i5, this.index = e5, this.text = void 0 === s5 ? "" : s5;
                }
                toString() {
                  let t6 = this.constructor.name;
                  const e5 = t6.indexOf("$");
                  return t6 = t6.substring(e5 + 1, t6.length), "<" + t6 + "@" + this.tokens.get(this.index) + ':"' + this.text + '">';
                }
              }
              class qe2 extends ze2 {
                constructor(t6, e5, i5, s5) {
                  super(t6, e5, i5, s5);
                }
                execute(e5) {
                  return this.text && e5.push(this.text.toString()), this.tokens.get(this.index).type !== t5.EOF && e5.push(String(this.tokens.get(this.index).text)), this.index + 1;
                }
              }
              class We2 extends qe2 {
                constructor(t6, e5, i5, s5) {
                  super(t6, e5 + 1, i5, s5);
                }
              }
              class Ye2 extends ze2 {
                constructor(t6, e5, i5, s5, r4) {
                  super(t6, e5, s5, r4), this.lastIndex = i5;
                }
                execute(t6) {
                  return this.text && t6.push(this.text.toString()), this.lastIndex + 1;
                }
                toString() {
                  return null == this.text ? "<DeleteOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ">" : "<ReplaceOp@" + this.tokens.get(this.index) + ".." + this.tokens.get(this.lastIndex) + ':"' + this.text + '">';
                }
              }
              const Xe2 = { atn: ne3, dfa: he3, context: ce3, misc: ue3, tree: _e3, error: be3, Token: t5, CommonToken: Dt3, CharStreams: Ne3, CharStream: Se3, InputStream: Se3, CommonTokenStream: Oe3, Lexer: Ht3, Parser: Fe3, ParserRuleContext: Me2, Interval: g2, IntervalSet: T3, LL1Analyzer: W3, Utils: Ie3, TokenStreamRewriter: Ke2 };
            })();
            var h = l.dx, c = l.q2, u = l.xf, p = l.c7, d = l._7, m = l.cK, _2 = l.zs, x2 = l.hW, f = l.x1, y2 = l.z5, g = l.TB, T2 = l._b, E = l.$F, R2 = l._T, v = l.db, b = l._x, L2 = l.WU, S2 = class t5 extends x2 {
              constructor(e4) {
                super(e4), this._interp = new f(this, t5._ATN, t5.DecisionsToDFA, new v());
              }
              get grammarFileName() {
                return "Solidity.g4";
              }
              get literalNames() {
                return t5.literalNames;
              }
              get symbolicNames() {
                return t5.symbolicNames;
              }
              get ruleNames() {
                return t5.ruleNames;
              }
              get serializedATN() {
                return t5._serializedATN;
              }
              get channelNames() {
                return t5.channelNames;
              }
              get modeNames() {
                return t5.modeNames;
              }
              static get _ATN() {
                return t5.__ATN || (t5.__ATN = new c().deserialize(t5._serializedATN)), t5.__ATN;
              }
            };
            S2.T__0 = 1, S2.T__1 = 2, S2.T__2 = 3, S2.T__3 = 4, S2.T__4 = 5, S2.T__5 = 6, S2.T__6 = 7, S2.T__7 = 8, S2.T__8 = 9, S2.T__9 = 10, S2.T__10 = 11, S2.T__11 = 12, S2.T__12 = 13, S2.T__13 = 14, S2.T__14 = 15, S2.T__15 = 16, S2.T__16 = 17, S2.T__17 = 18, S2.T__18 = 19, S2.T__19 = 20, S2.T__20 = 21, S2.T__21 = 22, S2.T__22 = 23, S2.T__23 = 24, S2.T__24 = 25, S2.T__25 = 26, S2.T__26 = 27, S2.T__27 = 28, S2.T__28 = 29, S2.T__29 = 30, S2.T__30 = 31, S2.T__31 = 32, S2.T__32 = 33, S2.T__33 = 34, S2.T__34 = 35, S2.T__35 = 36, S2.T__36 = 37, S2.T__37 = 38, S2.T__38 = 39, S2.T__39 = 40, S2.T__40 = 41, S2.T__41 = 42, S2.T__42 = 43, S2.T__43 = 44, S2.T__44 = 45, S2.T__45 = 46, S2.T__46 = 47, S2.T__47 = 48, S2.T__48 = 49, S2.T__49 = 50, S2.T__50 = 51, S2.T__51 = 52, S2.T__52 = 53, S2.T__53 = 54, S2.T__54 = 55, S2.T__55 = 56, S2.T__56 = 57, S2.T__57 = 58, S2.T__58 = 59, S2.T__59 = 60, S2.T__60 = 61, S2.T__61 = 62, S2.T__62 = 63, S2.T__63 = 64, S2.T__64 = 65, S2.T__65 = 66, S2.T__66 = 67, S2.T__67 = 68, S2.T__68 = 69, S2.T__69 = 70, S2.T__70 = 71, S2.T__71 = 72, S2.T__72 = 73, S2.T__73 = 74, S2.T__74 = 75, S2.T__75 = 76, S2.T__76 = 77, S2.T__77 = 78, S2.T__78 = 79, S2.T__79 = 80, S2.T__80 = 81, S2.T__81 = 82, S2.T__82 = 83, S2.T__83 = 84, S2.T__84 = 85, S2.T__85 = 86, S2.T__86 = 87, S2.T__87 = 88, S2.T__88 = 89, S2.T__89 = 90, S2.T__90 = 91, S2.T__91 = 92, S2.T__92 = 93, S2.T__93 = 94, S2.T__94 = 95, S2.T__95 = 96, S2.Int = 97, S2.Uint = 98, S2.Byte = 99, S2.Fixed = 100, S2.Ufixed = 101, S2.BooleanLiteral = 102, S2.DecimalNumber = 103, S2.HexNumber = 104, S2.NumberUnit = 105, S2.HexLiteralFragment = 106, S2.ReservedKeyword = 107, S2.AnonymousKeyword = 108, S2.BreakKeyword = 109, S2.ConstantKeyword = 110, S2.TransientKeyword = 111, S2.ImmutableKeyword = 112, S2.ContinueKeyword = 113, S2.LeaveKeyword = 114, S2.ExternalKeyword = 115, S2.IndexedKeyword = 116, S2.InternalKeyword = 117, S2.PayableKeyword = 118, S2.PrivateKeyword = 119, S2.PublicKeyword = 120, S2.VirtualKeyword = 121, S2.PureKeyword = 122, S2.TypeKeyword = 123, S2.ViewKeyword = 124, S2.GlobalKeyword = 125, S2.ConstructorKeyword = 126, S2.FallbackKeyword = 127, S2.ReceiveKeyword = 128, S2.Identifier = 129, S2.StringLiteralFragment = 130, S2.VersionLiteral = 131, S2.WS = 132, S2.COMMENT = 133, S2.LINE_COMMENT = 134, S2.EOF = L2.EOF, S2.channelNames = ["DEFAULT_TOKEN_CHANNEL", "HIDDEN"], S2.literalNames = [null, "'pragma'", "';'", "'*'", "'||'", "'^'", "'~'", "'>='", "'>'", "'<'", "'<='", "'='", "'as'", "'import'", "'from'", "'{'", "','", "'}'", "'abstract'", "'contract'", "'interface'", "'library'", "'is'", "'('", "')'", "'error'", "'using'", "'for'", "'|'", "'&'", "'+'", "'-'", "'/'", "'%'", "'=='", "'!='", "'struct'", "'modifier'", "'function'", "'returns'", "'event'", "'enum'", "'['", "']'", "'address'", "'.'", "'mapping'", "'=>'", "'memory'", "'storage'", "'calldata'", "'if'", "'else'", "'try'", "'catch'", "'while'", "'unchecked'", "'assembly'", "'do'", "'return'", "'throw'", "'emit'", "'revert'", "'var'", "'bool'", "'string'", "'byte'", "'++'", "'--'", "'new'", "':'", "'delete'", "'!'", "'**'", "'<<'", "'>>'", "'&&'", "'?'", "'|='", "'^='", "'&='", "'<<='", "'>>='", "'+='", "'-='", "'*='", "'/='", "'%='", "'let'", "':='", "'=:'", "'switch'", "'case'", "'default'", "'->'", "'callback'", "'override'", null, null, null, null, null, null, null, null, null, null, null, "'anonymous'", "'break'", "'constant'", "'transient'", "'immutable'", "'continue'", "'leave'", "'external'", "'indexed'", "'internal'", "'payable'", "'private'", "'public'", "'virtual'", "'pure'", "'type'", "'view'", "'global'", "'constructor'", "'fallback'", "'receive'"], S2.symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "Int", "Uint", "Byte", "Fixed", "Ufixed", "BooleanLiteral", "DecimalNumber", "HexNumber", "NumberUnit", "HexLiteralFragment", "ReservedKeyword", "AnonymousKeyword", "BreakKeyword", "ConstantKeyword", "TransientKeyword", "ImmutableKeyword", "ContinueKeyword", "LeaveKeyword", "ExternalKeyword", "IndexedKeyword", "InternalKeyword", "PayableKeyword", "PrivateKeyword", "PublicKeyword", "VirtualKeyword", "PureKeyword", "TypeKeyword", "ViewKeyword", "GlobalKeyword", "ConstructorKeyword", "FallbackKeyword", "ReceiveKeyword", "Identifier", "StringLiteralFragment", "VersionLiteral", "WS", "COMMENT", "LINE_COMMENT"], S2.modeNames = ["DEFAULT_MODE"], S2.ruleNames = ["T__0", "T__1", "T__2", "T__3", "T__4", "T__5", "T__6", "T__7", "T__8", "T__9", "T__10", "T__11", "T__12", "T__13", "T__14", "T__15", "T__16", "T__17", "T__18", "T__19", "T__20", "T__21", "T__22", "T__23", "T__24", "T__25", "T__26", "T__27", "T__28", "T__29", "T__30", "T__31", "T__32", "T__33", "T__34", "T__35", "T__36", "T__37", "T__38", "T__39", "T__40", "T__41", "T__42", "T__43", "T__44", "T__45", "T__46", "T__47", "T__48", "T__49", "T__50", "T__51", "T__52", "T__53", "T__54", "T__55", "T__56", "T__57", "T__58", "T__59", "T__60", "T__61", "T__62", "T__63", "T__64", "T__65", "T__66", "T__67", "T__68", "T__69", "T__70", "T__71", "T__72", "T__73", "T__74", "T__75", "T__76", "T__77", "T__78", "T__79", "T__80", "T__81", "T__82", "T__83", "T__84", "T__85", "T__86", "T__87", "T__88", "T__89", "T__90", "T__91", "T__92", "T__93", "T__94", "T__95", "Int", "Uint", "Byte", "Fixed", "Ufixed", "NumberOfBits", "NumberOfBytes", "BooleanLiteral", "DecimalNumber", "DecimalDigits", "HexNumber", "HexDigits", "NumberUnit", "HexLiteralFragment", "HexCharacter", "ReservedKeyword", "AnonymousKeyword", "BreakKeyword", "ConstantKeyword", "TransientKeyword", "ImmutableKeyword", "ContinueKeyword", "LeaveKeyword", "ExternalKeyword", "IndexedKeyword", "InternalKeyword", "PayableKeyword", "PrivateKeyword", "PublicKeyword", "VirtualKeyword", "PureKeyword", "TypeKeyword", "ViewKeyword", "GlobalKeyword", "ConstructorKeyword", "FallbackKeyword", "ReceiveKeyword", "Identifier", "IdentifierStart", "IdentifierPart", "StringLiteralFragment", "DoubleQuotedStringCharacter", "SingleQuotedStringCharacter", "VersionLiteral", "WS", "COMMENT", "LINE_COMMENT"], S2._serializedATN = [4, 0, 134, 1348, 6, -1, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7, 108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2, 113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7, 117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2, 122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7, 126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2, 131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7, 135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2, 140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 6, 1, 7, 1, 7, 1, 8, 1, 8, 1, 9, 1, 9, 1, 9, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15, 1, 15, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 31, 1, 31, 1, 32, 1, 32, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 43, 1, 44, 1, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 46, 1, 46, 1, 46, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 51, 1, 51, 1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 72, 1, 73, 1, 73, 1, 73, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 1, 75, 1, 76, 1, 76, 1, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1, 82, 1, 82, 1, 82, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96, 724, 8, 96, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 1, 97, 3, 97, 732, 8, 97, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 741, 8, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 4, 99, 752, 8, 99, 11, 99, 12, 99, 753, 3, 99, 756, 8, 99, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 1, 100, 4, 100, 768, 8, 100, 11, 100, 12, 100, 769, 3, 100, 772, 8, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 3, 101, 857, 8, 101, 1, 102, 1, 102, 1, 102, 1, 102, 1, 102, 3, 102, 864, 8, 102, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 1, 103, 3, 103, 875, 8, 103, 1, 104, 1, 104, 3, 104, 879, 8, 104, 1, 104, 1, 104, 3, 104, 883, 8, 104, 1, 104, 1, 104, 3, 104, 887, 8, 104, 1, 104, 3, 104, 890, 8, 104, 1, 105, 1, 105, 3, 105, 894, 8, 105, 1, 105, 5, 105, 897, 8, 105, 10, 105, 12, 105, 900, 9, 105, 1, 106, 1, 106, 1, 106, 1, 106, 1, 107, 1, 107, 3, 107, 908, 8, 107, 1, 107, 5, 107, 911, 8, 107, 10, 107, 12, 107, 914, 9, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 972, 8, 108, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 1, 109, 3, 109, 980, 8, 109, 1, 109, 1, 109, 1, 109, 3, 109, 985, 8, 109, 1, 109, 3, 109, 988, 8, 109, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 3, 111, 1080, 8, 111, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 114, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 116, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 118, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 121, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 124, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 130, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 131, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 132, 1, 133, 1, 133, 5, 133, 1252, 8, 133, 10, 133, 12, 133, 1255, 9, 133, 1, 134, 1, 134, 1, 135, 1, 135, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 1, 136, 3, 136, 1268, 8, 136, 1, 136, 1, 136, 5, 136, 1272, 8, 136, 10, 136, 12, 136, 1275, 9, 136, 1, 136, 1, 136, 1, 136, 5, 136, 1280, 8, 136, 10, 136, 12, 136, 1283, 9, 136, 1, 136, 3, 136, 1286, 8, 136, 1, 137, 1, 137, 1, 137, 3, 137, 1291, 8, 137, 1, 138, 1, 138, 1, 138, 3, 138, 1296, 8, 138, 1, 139, 4, 139, 1299, 8, 139, 11, 139, 12, 139, 1300, 1, 139, 1, 139, 4, 139, 1305, 8, 139, 11, 139, 12, 139, 1306, 1, 139, 1, 139, 4, 139, 1311, 8, 139, 11, 139, 12, 139, 1312, 3, 139, 1315, 8, 139, 1, 140, 4, 140, 1318, 8, 140, 11, 140, 12, 140, 1319, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1, 141, 5, 141, 1328, 8, 141, 10, 141, 12, 141, 1331, 9, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 1, 142, 1, 142, 1, 142, 1, 142, 5, 142, 1342, 8, 142, 10, 142, 12, 142, 1345, 9, 142, 1, 142, 1, 142, 1, 1329, 0, 143, 1, 1, 3, 2, 5, 3, 7, 4, 9, 5, 11, 6, 13, 7, 15, 8, 17, 9, 19, 10, 21, 11, 23, 12, 25, 13, 27, 14, 29, 15, 31, 16, 33, 17, 35, 18, 37, 19, 39, 20, 41, 21, 43, 22, 45, 23, 47, 24, 49, 25, 51, 26, 53, 27, 55, 28, 57, 29, 59, 30, 61, 31, 63, 32, 65, 33, 67, 34, 69, 35, 71, 36, 73, 37, 75, 38, 77, 39, 79, 40, 81, 41, 83, 42, 85, 43, 87, 44, 89, 45, 91, 46, 93, 47, 95, 48, 97, 49, 99, 50, 101, 51, 103, 52, 105, 53, 107, 54, 109, 55, 111, 56, 113, 57, 115, 58, 117, 59, 119, 60, 121, 61, 123, 62, 125, 63, 127, 64, 129, 65, 131, 66, 133, 67, 135, 68, 137, 69, 139, 70, 141, 71, 143, 72, 145, 73, 147, 74, 149, 75, 151, 76, 153, 77, 155, 78, 157, 79, 159, 80, 161, 81, 163, 82, 165, 83, 167, 84, 169, 85, 171, 86, 173, 87, 175, 88, 177, 89, 179, 90, 181, 91, 183, 92, 185, 93, 187, 94, 189, 95, 191, 96, 193, 97, 195, 98, 197, 99, 199, 100, 201, 101, 203, 0, 205, 0, 207, 102, 209, 103, 211, 0, 213, 104, 215, 0, 217, 105, 219, 106, 221, 0, 223, 107, 225, 108, 227, 109, 229, 110, 231, 111, 233, 112, 235, 113, 237, 114, 239, 115, 241, 116, 243, 117, 245, 118, 247, 119, 249, 120, 251, 121, 253, 122, 255, 123, 257, 124, 259, 125, 261, 126, 263, 127, 265, 128, 267, 129, 269, 0, 271, 0, 273, 130, 275, 0, 277, 0, 279, 131, 281, 132, 283, 133, 285, 134, 1, 0, 13, 1, 0, 48, 57, 1, 0, 49, 57, 1, 0, 49, 50, 1, 0, 48, 50, 2, 0, 69, 69, 101, 101, 2, 0, 88, 88, 120, 120, 3, 0, 48, 57, 65, 70, 97, 102, 4, 0, 36, 36, 65, 90, 95, 95, 97, 122, 5, 0, 36, 36, 48, 57, 65, 90, 95, 95, 97, 122, 4, 0, 10, 10, 13, 13, 34, 34, 92, 92, 4, 0, 10, 10, 13, 13, 39, 39, 92, 92, 3, 0, 9, 10, 12, 13, 32, 32, 2, 0, 10, 10, 13, 13, 1430, 0, 1, 1, 0, 0, 0, 0, 3, 1, 0, 0, 0, 0, 5, 1, 0, 0, 0, 0, 7, 1, 0, 0, 0, 0, 9, 1, 0, 0, 0, 0, 11, 1, 0, 0, 0, 0, 13, 1, 0, 0, 0, 0, 15, 1, 0, 0, 0, 0, 17, 1, 0, 0, 0, 0, 19, 1, 0, 0, 0, 0, 21, 1, 0, 0, 0, 0, 23, 1, 0, 0, 0, 0, 25, 1, 0, 0, 0, 0, 27, 1, 0, 0, 0, 0, 29, 1, 0, 0, 0, 0, 31, 1, 0, 0, 0, 0, 33, 1, 0, 0, 0, 0, 35, 1, 0, 0, 0, 0, 37, 1, 0, 0, 0, 0, 39, 1, 0, 0, 0, 0, 41, 1, 0, 0, 0, 0, 43, 1, 0, 0, 0, 0, 45, 1, 0, 0, 0, 0, 47, 1, 0, 0, 0, 0, 49, 1, 0, 0, 0, 0, 51, 1, 0, 0, 0, 0, 53, 1, 0, 0, 0, 0, 55, 1, 0, 0, 0, 0, 57, 1, 0, 0, 0, 0, 59, 1, 0, 0, 0, 0, 61, 1, 0, 0, 0, 0, 63, 1, 0, 0, 0, 0, 65, 1, 0, 0, 0, 0, 67, 1, 0, 0, 0, 0, 69, 1, 0, 0, 0, 0, 71, 1, 0, 0, 0, 0, 73, 1, 0, 0, 0, 0, 75, 1, 0, 0, 0, 0, 77, 1, 0, 0, 0, 0, 79, 1, 0, 0, 0, 0, 81, 1, 0, 0, 0, 0, 83, 1, 0, 0, 0, 0, 85, 1, 0, 0, 0, 0, 87, 1, 0, 0, 0, 0, 89, 1, 0, 0, 0, 0, 91, 1, 0, 0, 0, 0, 93, 1, 0, 0, 0, 0, 95, 1, 0, 0, 0, 0, 97, 1, 0, 0, 0, 0, 99, 1, 0, 0, 0, 0, 101, 1, 0, 0, 0, 0, 103, 1, 0, 0, 0, 0, 105, 1, 0, 0, 0, 0, 107, 1, 0, 0, 0, 0, 109, 1, 0, 0, 0, 0, 111, 1, 0, 0, 0, 0, 113, 1, 0, 0, 0, 0, 115, 1, 0, 0, 0, 0, 117, 1, 0, 0, 0, 0, 119, 1, 0, 0, 0, 0, 121, 1, 0, 0, 0, 0, 123, 1, 0, 0, 0, 0, 125, 1, 0, 0, 0, 0, 127, 1, 0, 0, 0, 0, 129, 1, 0, 0, 0, 0, 131, 1, 0, 0, 0, 0, 133, 1, 0, 0, 0, 0, 135, 1, 0, 0, 0, 0, 137, 1, 0, 0, 0, 0, 139, 1, 0, 0, 0, 0, 141, 1, 0, 0, 0, 0, 143, 1, 0, 0, 0, 0, 145, 1, 0, 0, 0, 0, 147, 1, 0, 0, 0, 0, 149, 1, 0, 0, 0, 0, 151, 1, 0, 0, 0, 0, 153, 1, 0, 0, 0, 0, 155, 1, 0, 0, 0, 0, 157, 1, 0, 0, 0, 0, 159, 1, 0, 0, 0, 0, 161, 1, 0, 0, 0, 0, 163, 1, 0, 0, 0, 0, 165, 1, 0, 0, 0, 0, 167, 1, 0, 0, 0, 0, 169, 1, 0, 0, 0, 0, 171, 1, 0, 0, 0, 0, 173, 1, 0, 0, 0, 0, 175, 1, 0, 0, 0, 0, 177, 1, 0, 0, 0, 0, 179, 1, 0, 0, 0, 0, 181, 1, 0, 0, 0, 0, 183, 1, 0, 0, 0, 0, 185, 1, 0, 0, 0, 0, 187, 1, 0, 0, 0, 0, 189, 1, 0, 0, 0, 0, 191, 1, 0, 0, 0, 0, 193, 1, 0, 0, 0, 0, 195, 1, 0, 0, 0, 0, 197, 1, 0, 0, 0, 0, 199, 1, 0, 0, 0, 0, 201, 1, 0, 0, 0, 0, 207, 1, 0, 0, 0, 0, 209, 1, 0, 0, 0, 0, 213, 1, 0, 0, 0, 0, 217, 1, 0, 0, 0, 0, 219, 1, 0, 0, 0, 0, 223, 1, 0, 0, 0, 0, 225, 1, 0, 0, 0, 0, 227, 1, 0, 0, 0, 0, 229, 1, 0, 0, 0, 0, 231, 1, 0, 0, 0, 0, 233, 1, 0, 0, 0, 0, 235, 1, 0, 0, 0, 0, 237, 1, 0, 0, 0, 0, 239, 1, 0, 0, 0, 0, 241, 1, 0, 0, 0, 0, 243, 1, 0, 0, 0, 0, 245, 1, 0, 0, 0, 0, 247, 1, 0, 0, 0, 0, 249, 1, 0, 0, 0, 0, 251, 1, 0, 0, 0, 0, 253, 1, 0, 0, 0, 0, 255, 1, 0, 0, 0, 0, 257, 1, 0, 0, 0, 0, 259, 1, 0, 0, 0, 0, 261, 1, 0, 0, 0, 0, 263, 1, 0, 0, 0, 0, 265, 1, 0, 0, 0, 0, 267, 1, 0, 0, 0, 0, 273, 1, 0, 0, 0, 0, 279, 1, 0, 0, 0, 0, 281, 1, 0, 0, 0, 0, 283, 1, 0, 0, 0, 0, 285, 1, 0, 0, 0, 1, 287, 1, 0, 0, 0, 3, 294, 1, 0, 0, 0, 5, 296, 1, 0, 0, 0, 7, 298, 1, 0, 0, 0, 9, 301, 1, 0, 0, 0, 11, 303, 1, 0, 0, 0, 13, 305, 1, 0, 0, 0, 15, 308, 1, 0, 0, 0, 17, 310, 1, 0, 0, 0, 19, 312, 1, 0, 0, 0, 21, 315, 1, 0, 0, 0, 23, 317, 1, 0, 0, 0, 25, 320, 1, 0, 0, 0, 27, 327, 1, 0, 0, 0, 29, 332, 1, 0, 0, 0, 31, 334, 1, 0, 0, 0, 33, 336, 1, 0, 0, 0, 35, 338, 1, 0, 0, 0, 37, 347, 1, 0, 0, 0, 39, 356, 1, 0, 0, 0, 41, 366, 1, 0, 0, 0, 43, 374, 1, 0, 0, 0, 45, 377, 1, 0, 0, 0, 47, 379, 1, 0, 0, 0, 49, 381, 1, 0, 0, 0, 51, 387, 1, 0, 0, 0, 53, 393, 1, 0, 0, 0, 55, 397, 1, 0, 0, 0, 57, 399, 1, 0, 0, 0, 59, 401, 1, 0, 0, 0, 61, 403, 1, 0, 0, 0, 63, 405, 1, 0, 0, 0, 65, 407, 1, 0, 0, 0, 67, 409, 1, 0, 0, 0, 69, 412, 1, 0, 0, 0, 71, 415, 1, 0, 0, 0, 73, 422, 1, 0, 0, 0, 75, 431, 1, 0, 0, 0, 77, 440, 1, 0, 0, 0, 79, 448, 1, 0, 0, 0, 81, 454, 1, 0, 0, 0, 83, 459, 1, 0, 0, 0, 85, 461, 1, 0, 0, 0, 87, 463, 1, 0, 0, 0, 89, 471, 1, 0, 0, 0, 91, 473, 1, 0, 0, 0, 93, 481, 1, 0, 0, 0, 95, 484, 1, 0, 0, 0, 97, 491, 1, 0, 0, 0, 99, 499, 1, 0, 0, 0, 101, 508, 1, 0, 0, 0, 103, 511, 1, 0, 0, 0, 105, 516, 1, 0, 0, 0, 107, 520, 1, 0, 0, 0, 109, 526, 1, 0, 0, 0, 111, 532, 1, 0, 0, 0, 113, 542, 1, 0, 0, 0, 115, 551, 1, 0, 0, 0, 117, 554, 1, 0, 0, 0, 119, 561, 1, 0, 0, 0, 121, 567, 1, 0, 0, 0, 123, 572, 1, 0, 0, 0, 125, 579, 1, 0, 0, 0, 127, 583, 1, 0, 0, 0, 129, 588, 1, 0, 0, 0, 131, 595, 1, 0, 0, 0, 133, 600, 1, 0, 0, 0, 135, 603, 1, 0, 0, 0, 137, 606, 1, 0, 0, 0, 139, 610, 1, 0, 0, 0, 141, 612, 1, 0, 0, 0, 143, 619, 1, 0, 0, 0, 145, 621, 1, 0, 0, 0, 147, 624, 1, 0, 0, 0, 149, 627, 1, 0, 0, 0, 151, 630, 1, 0, 0, 0, 153, 633, 1, 0, 0, 0, 155, 635, 1, 0, 0, 0, 157, 638, 1, 0, 0, 0, 159, 641, 1, 0, 0, 0, 161, 644, 1, 0, 0, 0, 163, 648, 1, 0, 0, 0, 165, 652, 1, 0, 0, 0, 167, 655, 1, 0, 0, 0, 169, 658, 1, 0, 0, 0, 171, 661, 1, 0, 0, 0, 173, 664, 1, 0, 0, 0, 175, 667, 1, 0, 0, 0, 177, 671, 1, 0, 0, 0, 179, 674, 1, 0, 0, 0, 181, 677, 1, 0, 0, 0, 183, 684, 1, 0, 0, 0, 185, 689, 1, 0, 0, 0, 187, 697, 1, 0, 0, 0, 189, 700, 1, 0, 0, 0, 191, 709, 1, 0, 0, 0, 193, 718, 1, 0, 0, 0, 195, 725, 1, 0, 0, 0, 197, 733, 1, 0, 0, 0, 199, 742, 1, 0, 0, 0, 201, 757, 1, 0, 0, 0, 203, 856, 1, 0, 0, 0, 205, 863, 1, 0, 0, 0, 207, 874, 1, 0, 0, 0, 209, 882, 1, 0, 0, 0, 211, 891, 1, 0, 0, 0, 213, 901, 1, 0, 0, 0, 215, 905, 1, 0, 0, 0, 217, 971, 1, 0, 0, 0, 219, 973, 1, 0, 0, 0, 221, 989, 1, 0, 0, 0, 223, 1079, 1, 0, 0, 0, 225, 1081, 1, 0, 0, 0, 227, 1091, 1, 0, 0, 0, 229, 1097, 1, 0, 0, 0, 231, 1106, 1, 0, 0, 0, 233, 1116, 1, 0, 0, 0, 235, 1126, 1, 0, 0, 0, 237, 1135, 1, 0, 0, 0, 239, 1141, 1, 0, 0, 0, 241, 1150, 1, 0, 0, 0, 243, 1158, 1, 0, 0, 0, 245, 1167, 1, 0, 0, 0, 247, 1175, 1, 0, 0, 0, 249, 1183, 1, 0, 0, 0, 251, 1190, 1, 0, 0, 0, 253, 1198, 1, 0, 0, 0, 255, 1203, 1, 0, 0, 0, 257, 1208, 1, 0, 0, 0, 259, 1213, 1, 0, 0, 0, 261, 1220, 1, 0, 0, 0, 263, 1232, 1, 0, 0, 0, 265, 1241, 1, 0, 0, 0, 267, 1249, 1, 0, 0, 0, 269, 1256, 1, 0, 0, 0, 271, 1258, 1, 0, 0, 0, 273, 1267, 1, 0, 0, 0, 275, 1290, 1, 0, 0, 0, 277, 1295, 1, 0, 0, 0, 279, 1298, 1, 0, 0, 0, 281, 1317, 1, 0, 0, 0, 283, 1323, 1, 0, 0, 0, 285, 1337, 1, 0, 0, 0, 287, 288, 5, 112, 0, 0, 288, 289, 5, 114, 0, 0, 289, 290, 5, 97, 0, 0, 290, 291, 5, 103, 0, 0, 291, 292, 5, 109, 0, 0, 292, 293, 5, 97, 0, 0, 293, 2, 1, 0, 0, 0, 294, 295, 5, 59, 0, 0, 295, 4, 1, 0, 0, 0, 296, 297, 5, 42, 0, 0, 297, 6, 1, 0, 0, 0, 298, 299, 5, 124, 0, 0, 299, 300, 5, 124, 0, 0, 300, 8, 1, 0, 0, 0, 301, 302, 5, 94, 0, 0, 302, 10, 1, 0, 0, 0, 303, 304, 5, 126, 0, 0, 304, 12, 1, 0, 0, 0, 305, 306, 5, 62, 0, 0, 306, 307, 5, 61, 0, 0, 307, 14, 1, 0, 0, 0, 308, 309, 5, 62, 0, 0, 309, 16, 1, 0, 0, 0, 310, 311, 5, 60, 0, 0, 311, 18, 1, 0, 0, 0, 312, 313, 5, 60, 0, 0, 313, 314, 5, 61, 0, 0, 314, 20, 1, 0, 0, 0, 315, 316, 5, 61, 0, 0, 316, 22, 1, 0, 0, 0, 317, 318, 5, 97, 0, 0, 318, 319, 5, 115, 0, 0, 319, 24, 1, 0, 0, 0, 320, 321, 5, 105, 0, 0, 321, 322, 5, 109, 0, 0, 322, 323, 5, 112, 0, 0, 323, 324, 5, 111, 0, 0, 324, 325, 5, 114, 0, 0, 325, 326, 5, 116, 0, 0, 326, 26, 1, 0, 0, 0, 327, 328, 5, 102, 0, 0, 328, 329, 5, 114, 0, 0, 329, 330, 5, 111, 0, 0, 330, 331, 5, 109, 0, 0, 331, 28, 1, 0, 0, 0, 332, 333, 5, 123, 0, 0, 333, 30, 1, 0, 0, 0, 334, 335, 5, 44, 0, 0, 335, 32, 1, 0, 0, 0, 336, 337, 5, 125, 0, 0, 337, 34, 1, 0, 0, 0, 338, 339, 5, 97, 0, 0, 339, 340, 5, 98, 0, 0, 340, 341, 5, 115, 0, 0, 341, 342, 5, 116, 0, 0, 342, 343, 5, 114, 0, 0, 343, 344, 5, 97, 0, 0, 344, 345, 5, 99, 0, 0, 345, 346, 5, 116, 0, 0, 346, 36, 1, 0, 0, 0, 347, 348, 5, 99, 0, 0, 348, 349, 5, 111, 0, 0, 349, 350, 5, 110, 0, 0, 350, 351, 5, 116, 0, 0, 351, 352, 5, 114, 0, 0, 352, 353, 5, 97, 0, 0, 353, 354, 5, 99, 0, 0, 354, 355, 5, 116, 0, 0, 355, 38, 1, 0, 0, 0, 356, 357, 5, 105, 0, 0, 357, 358, 5, 110, 0, 0, 358, 359, 5, 116, 0, 0, 359, 360, 5, 101, 0, 0, 360, 361, 5, 114, 0, 0, 361, 362, 5, 102, 0, 0, 362, 363, 5, 97, 0, 0, 363, 364, 5, 99, 0, 0, 364, 365, 5, 101, 0, 0, 365, 40, 1, 0, 0, 0, 366, 367, 5, 108, 0, 0, 367, 368, 5, 105, 0, 0, 368, 369, 5, 98, 0, 0, 369, 370, 5, 114, 0, 0, 370, 371, 5, 97, 0, 0, 371, 372, 5, 114, 0, 0, 372, 373, 5, 121, 0, 0, 373, 42, 1, 0, 0, 0, 374, 375, 5, 105, 0, 0, 375, 376, 5, 115, 0, 0, 376, 44, 1, 0, 0, 0, 377, 378, 5, 40, 0, 0, 378, 46, 1, 0, 0, 0, 379, 380, 5, 41, 0, 0, 380, 48, 1, 0, 0, 0, 381, 382, 5, 101, 0, 0, 382, 383, 5, 114, 0, 0, 383, 384, 5, 114, 0, 0, 384, 385, 5, 111, 0, 0, 385, 386, 5, 114, 0, 0, 386, 50, 1, 0, 0, 0, 387, 388, 5, 117, 0, 0, 388, 389, 5, 115, 0, 0, 389, 390, 5, 105, 0, 0, 390, 391, 5, 110, 0, 0, 391, 392, 5, 103, 0, 0, 392, 52, 1, 0, 0, 0, 393, 394, 5, 102, 0, 0, 394, 395, 5, 111, 0, 0, 395, 396, 5, 114, 0, 0, 396, 54, 1, 0, 0, 0, 397, 398, 5, 124, 0, 0, 398, 56, 1, 0, 0, 0, 399, 400, 5, 38, 0, 0, 400, 58, 1, 0, 0, 0, 401, 402, 5, 43, 0, 0, 402, 60, 1, 0, 0, 0, 403, 404, 5, 45, 0, 0, 404, 62, 1, 0, 0, 0, 405, 406, 5, 47, 0, 0, 406, 64, 1, 0, 0, 0, 407, 408, 5, 37, 0, 0, 408, 66, 1, 0, 0, 0, 409, 410, 5, 61, 0, 0, 410, 411, 5, 61, 0, 0, 411, 68, 1, 0, 0, 0, 412, 413, 5, 33, 0, 0, 413, 414, 5, 61, 0, 0, 414, 70, 1, 0, 0, 0, 415, 416, 5, 115, 0, 0, 416, 417, 5, 116, 0, 0, 417, 418, 5, 114, 0, 0, 418, 419, 5, 117, 0, 0, 419, 420, 5, 99, 0, 0, 420, 421, 5, 116, 0, 0, 421, 72, 1, 0, 0, 0, 422, 423, 5, 109, 0, 0, 423, 424, 5, 111, 0, 0, 424, 425, 5, 100, 0, 0, 425, 426, 5, 105, 0, 0, 426, 427, 5, 102, 0, 0, 427, 428, 5, 105, 0, 0, 428, 429, 5, 101, 0, 0, 429, 430, 5, 114, 0, 0, 430, 74, 1, 0, 0, 0, 431, 432, 5, 102, 0, 0, 432, 433, 5, 117, 0, 0, 433, 434, 5, 110, 0, 0, 434, 435, 5, 99, 0, 0, 435, 436, 5, 116, 0, 0, 436, 437, 5, 105, 0, 0, 437, 438, 5, 111, 0, 0, 438, 439, 5, 110, 0, 0, 439, 76, 1, 0, 0, 0, 440, 441, 5, 114, 0, 0, 441, 442, 5, 101, 0, 0, 442, 443, 5, 116, 0, 0, 443, 444, 5, 117, 0, 0, 444, 445, 5, 114, 0, 0, 445, 446, 5, 110, 0, 0, 446, 447, 5, 115, 0, 0, 447, 78, 1, 0, 0, 0, 448, 449, 5, 101, 0, 0, 449, 450, 5, 118, 0, 0, 450, 451, 5, 101, 0, 0, 451, 452, 5, 110, 0, 0, 452, 453, 5, 116, 0, 0, 453, 80, 1, 0, 0, 0, 454, 455, 5, 101, 0, 0, 455, 456, 5, 110, 0, 0, 456, 457, 5, 117, 0, 0, 457, 458, 5, 109, 0, 0, 458, 82, 1, 0, 0, 0, 459, 460, 5, 91, 0, 0, 460, 84, 1, 0, 0, 0, 461, 462, 5, 93, 0, 0, 462, 86, 1, 0, 0, 0, 463, 464, 5, 97, 0, 0, 464, 465, 5, 100, 0, 0, 465, 466, 5, 100, 0, 0, 466, 467, 5, 114, 0, 0, 467, 468, 5, 101, 0, 0, 468, 469, 5, 115, 0, 0, 469, 470, 5, 115, 0, 0, 470, 88, 1, 0, 0, 0, 471, 472, 5, 46, 0, 0, 472, 90, 1, 0, 0, 0, 473, 474, 5, 109, 0, 0, 474, 475, 5, 97, 0, 0, 475, 476, 5, 112, 0, 0, 476, 477, 5, 112, 0, 0, 477, 478, 5, 105, 0, 0, 478, 479, 5, 110, 0, 0, 479, 480, 5, 103, 0, 0, 480, 92, 1, 0, 0, 0, 481, 482, 5, 61, 0, 0, 482, 483, 5, 62, 0, 0, 483, 94, 1, 0, 0, 0, 484, 485, 5, 109, 0, 0, 485, 486, 5, 101, 0, 0, 486, 487, 5, 109, 0, 0, 487, 488, 5, 111, 0, 0, 488, 489, 5, 114, 0, 0, 489, 490, 5, 121, 0, 0, 490, 96, 1, 0, 0, 0, 491, 492, 5, 115, 0, 0, 492, 493, 5, 116, 0, 0, 493, 494, 5, 111, 0, 0, 494, 495, 5, 114, 0, 0, 495, 496, 5, 97, 0, 0, 496, 497, 5, 103, 0, 0, 497, 498, 5, 101, 0, 0, 498, 98, 1, 0, 0, 0, 499, 500, 5, 99, 0, 0, 500, 501, 5, 97, 0, 0, 501, 502, 5, 108, 0, 0, 502, 503, 5, 108, 0, 0, 503, 504, 5, 100, 0, 0, 504, 505, 5, 97, 0, 0, 505, 506, 5, 116, 0, 0, 506, 507, 5, 97, 0, 0, 507, 100, 1, 0, 0, 0, 508, 509, 5, 105, 0, 0, 509, 510, 5, 102, 0, 0, 510, 102, 1, 0, 0, 0, 511, 512, 5, 101, 0, 0, 512, 513, 5, 108, 0, 0, 513, 514, 5, 115, 0, 0, 514, 515, 5, 101, 0, 0, 515, 104, 1, 0, 0, 0, 516, 517, 5, 116, 0, 0, 517, 518, 5, 114, 0, 0, 518, 519, 5, 121, 0, 0, 519, 106, 1, 0, 0, 0, 520, 521, 5, 99, 0, 0, 521, 522, 5, 97, 0, 0, 522, 523, 5, 116, 0, 0, 523, 524, 5, 99, 0, 0, 524, 525, 5, 104, 0, 0, 525, 108, 1, 0, 0, 0, 526, 527, 5, 119, 0, 0, 527, 528, 5, 104, 0, 0, 528, 529, 5, 105, 0, 0, 529, 530, 5, 108, 0, 0, 530, 531, 5, 101, 0, 0, 531, 110, 1, 0, 0, 0, 532, 533, 5, 117, 0, 0, 533, 534, 5, 110, 0, 0, 534, 535, 5, 99, 0, 0, 535, 536, 5, 104, 0, 0, 536, 537, 5, 101, 0, 0, 537, 538, 5, 99, 0, 0, 538, 539, 5, 107, 0, 0, 539, 540, 5, 101, 0, 0, 540, 541, 5, 100, 0, 0, 541, 112, 1, 0, 0, 0, 542, 543, 5, 97, 0, 0, 543, 544, 5, 115, 0, 0, 544, 545, 5, 115, 0, 0, 545, 546, 5, 101, 0, 0, 546, 547, 5, 109, 0, 0, 547, 548, 5, 98, 0, 0, 548, 549, 5, 108, 0, 0, 549, 550, 5, 121, 0, 0, 550, 114, 1, 0, 0, 0, 551, 552, 5, 100, 0, 0, 552, 553, 5, 111, 0, 0, 553, 116, 1, 0, 0, 0, 554, 555, 5, 114, 0, 0, 555, 556, 5, 101, 0, 0, 556, 557, 5, 116, 0, 0, 557, 558, 5, 117, 0, 0, 558, 559, 5, 114, 0, 0, 559, 560, 5, 110, 0, 0, 560, 118, 1, 0, 0, 0, 561, 562, 5, 116, 0, 0, 562, 563, 5, 104, 0, 0, 563, 564, 5, 114, 0, 0, 564, 565, 5, 111, 0, 0, 565, 566, 5, 119, 0, 0, 566, 120, 1, 0, 0, 0, 567, 568, 5, 101, 0, 0, 568, 569, 5, 109, 0, 0, 569, 570, 5, 105, 0, 0, 570, 571, 5, 116, 0, 0, 571, 122, 1, 0, 0, 0, 572, 573, 5, 114, 0, 0, 573, 574, 5, 101, 0, 0, 574, 575, 5, 118, 0, 0, 575, 576, 5, 101, 0, 0, 576, 577, 5, 114, 0, 0, 577, 578, 5, 116, 0, 0, 578, 124, 1, 0, 0, 0, 579, 580, 5, 118, 0, 0, 580, 581, 5, 97, 0, 0, 581, 582, 5, 114, 0, 0, 582, 126, 1, 0, 0, 0, 583, 584, 5, 98, 0, 0, 584, 585, 5, 111, 0, 0, 585, 586, 5, 111, 0, 0, 586, 587, 5, 108, 0, 0, 587, 128, 1, 0, 0, 0, 588, 589, 5, 115, 0, 0, 589, 590, 5, 116, 0, 0, 590, 591, 5, 114, 0, 0, 591, 592, 5, 105, 0, 0, 592, 593, 5, 110, 0, 0, 593, 594, 5, 103, 0, 0, 594, 130, 1, 0, 0, 0, 595, 596, 5, 98, 0, 0, 596, 597, 5, 121, 0, 0, 597, 598, 5, 116, 0, 0, 598, 599, 5, 101, 0, 0, 599, 132, 1, 0, 0, 0, 600, 601, 5, 43, 0, 0, 601, 602, 5, 43, 0, 0, 602, 134, 1, 0, 0, 0, 603, 604, 5, 45, 0, 0, 604, 605, 5, 45, 0, 0, 605, 136, 1, 0, 0, 0, 606, 607, 5, 110, 0, 0, 607, 608, 5, 101, 0, 0, 608, 609, 5, 119, 0, 0, 609, 138, 1, 0, 0, 0, 610, 611, 5, 58, 0, 0, 611, 140, 1, 0, 0, 0, 612, 613, 5, 100, 0, 0, 613, 614, 5, 101, 0, 0, 614, 615, 5, 108, 0, 0, 615, 616, 5, 101, 0, 0, 616, 617, 5, 116, 0, 0, 617, 618, 5, 101, 0, 0, 618, 142, 1, 0, 0, 0, 619, 620, 5, 33, 0, 0, 620, 144, 1, 0, 0, 0, 621, 622, 5, 42, 0, 0, 622, 623, 5, 42, 0, 0, 623, 146, 1, 0, 0, 0, 624, 625, 5, 60, 0, 0, 625, 626, 5, 60, 0, 0, 626, 148, 1, 0, 0, 0, 627, 628, 5, 62, 0, 0, 628, 629, 5, 62, 0, 0, 629, 150, 1, 0, 0, 0, 630, 631, 5, 38, 0, 0, 631, 632, 5, 38, 0, 0, 632, 152, 1, 0, 0, 0, 633, 634, 5, 63, 0, 0, 634, 154, 1, 0, 0, 0, 635, 636, 5, 124, 0, 0, 636, 637, 5, 61, 0, 0, 637, 156, 1, 0, 0, 0, 638, 639, 5, 94, 0, 0, 639, 640, 5, 61, 0, 0, 640, 158, 1, 0, 0, 0, 641, 642, 5, 38, 0, 0, 642, 643, 5, 61, 0, 0, 643, 160, 1, 0, 0, 0, 644, 645, 5, 60, 0, 0, 645, 646, 5, 60, 0, 0, 646, 647, 5, 61, 0, 0, 647, 162, 1, 0, 0, 0, 648, 649, 5, 62, 0, 0, 649, 650, 5, 62, 0, 0, 650, 651, 5, 61, 0, 0, 651, 164, 1, 0, 0, 0, 652, 653, 5, 43, 0, 0, 653, 654, 5, 61, 0, 0, 654, 166, 1, 0, 0, 0, 655, 656, 5, 45, 0, 0, 656, 657, 5, 61, 0, 0, 657, 168, 1, 0, 0, 0, 658, 659, 5, 42, 0, 0, 659, 660, 5, 61, 0, 0, 660, 170, 1, 0, 0, 0, 661, 662, 5, 47, 0, 0, 662, 663, 5, 61, 0, 0, 663, 172, 1, 0, 0, 0, 664, 665, 5, 37, 0, 0, 665, 666, 5, 61, 0, 0, 666, 174, 1, 0, 0, 0, 667, 668, 5, 108, 0, 0, 668, 669, 5, 101, 0, 0, 669, 670, 5, 116, 0, 0, 670, 176, 1, 0, 0, 0, 671, 672, 5, 58, 0, 0, 672, 673, 5, 61, 0, 0, 673, 178, 1, 0, 0, 0, 674, 675, 5, 61, 0, 0, 675, 676, 5, 58, 0, 0, 676, 180, 1, 0, 0, 0, 677, 678, 5, 115, 0, 0, 678, 679, 5, 119, 0, 0, 679, 680, 5, 105, 0, 0, 680, 681, 5, 116, 0, 0, 681, 682, 5, 99, 0, 0, 682, 683, 5, 104, 0, 0, 683, 182, 1, 0, 0, 0, 684, 685, 5, 99, 0, 0, 685, 686, 5, 97, 0, 0, 686, 687, 5, 115, 0, 0, 687, 688, 5, 101, 0, 0, 688, 184, 1, 0, 0, 0, 689, 690, 5, 100, 0, 0, 690, 691, 5, 101, 0, 0, 691, 692, 5, 102, 0, 0, 692, 693, 5, 97, 0, 0, 693, 694, 5, 117, 0, 0, 694, 695, 5, 108, 0, 0, 695, 696, 5, 116, 0, 0, 696, 186, 1, 0, 0, 0, 697, 698, 5, 45, 0, 0, 698, 699, 5, 62, 0, 0, 699, 188, 1, 0, 0, 0, 700, 701, 5, 99, 0, 0, 701, 702, 5, 97, 0, 0, 702, 703, 5, 108, 0, 0, 703, 704, 5, 108, 0, 0, 704, 705, 5, 98, 0, 0, 705, 706, 5, 97, 0, 0, 706, 707, 5, 99, 0, 0, 707, 708, 5, 107, 0, 0, 708, 190, 1, 0, 0, 0, 709, 710, 5, 111, 0, 0, 710, 711, 5, 118, 0, 0, 711, 712, 5, 101, 0, 0, 712, 713, 5, 114, 0, 0, 713, 714, 5, 114, 0, 0, 714, 715, 5, 105, 0, 0, 715, 716, 5, 100, 0, 0, 716, 717, 5, 101, 0, 0, 717, 192, 1, 0, 0, 0, 718, 719, 5, 105, 0, 0, 719, 720, 5, 110, 0, 0, 720, 721, 5, 116, 0, 0, 721, 723, 1, 0, 0, 0, 722, 724, 3, 203, 101, 0, 723, 722, 1, 0, 0, 0, 723, 724, 1, 0, 0, 0, 724, 194, 1, 0, 0, 0, 725, 726, 5, 117, 0, 0, 726, 727, 5, 105, 0, 0, 727, 728, 5, 110, 0, 0, 728, 729, 5, 116, 0, 0, 729, 731, 1, 0, 0, 0, 730, 732, 3, 203, 101, 0, 731, 730, 1, 0, 0, 0, 731, 732, 1, 0, 0, 0, 732, 196, 1, 0, 0, 0, 733, 734, 5, 98, 0, 0, 734, 735, 5, 121, 0, 0, 735, 736, 5, 116, 0, 0, 736, 737, 5, 101, 0, 0, 737, 738, 5, 115, 0, 0, 738, 740, 1, 0, 0, 0, 739, 741, 3, 205, 102, 0, 740, 739, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 198, 1, 0, 0, 0, 742, 743, 5, 102, 0, 0, 743, 744, 5, 105, 0, 0, 744, 745, 5, 120, 0, 0, 745, 746, 5, 101, 0, 0, 746, 747, 5, 100, 0, 0, 747, 755, 1, 0, 0, 0, 748, 749, 3, 203, 101, 0, 749, 751, 5, 120, 0, 0, 750, 752, 7, 0, 0, 0, 751, 750, 1, 0, 0, 0, 752, 753, 1, 0, 0, 0, 753, 751, 1, 0, 0, 0, 753, 754, 1, 0, 0, 0, 754, 756, 1, 0, 0, 0, 755, 748, 1, 0, 0, 0, 755, 756, 1, 0, 0, 0, 756, 200, 1, 0, 0, 0, 757, 758, 5, 117, 0, 0, 758, 759, 5, 102, 0, 0, 759, 760, 5, 105, 0, 0, 760, 761, 5, 120, 0, 0, 761, 762, 5, 101, 0, 0, 762, 763, 5, 100, 0, 0, 763, 771, 1, 0, 0, 0, 764, 765, 3, 203, 101, 0, 765, 767, 5, 120, 0, 0, 766, 768, 7, 0, 0, 0, 767, 766, 1, 0, 0, 0, 768, 769, 1, 0, 0, 0, 769, 767, 1, 0, 0, 0, 769, 770, 1, 0, 0, 0, 770, 772, 1, 0, 0, 0, 771, 764, 1, 0, 0, 0, 771, 772, 1, 0, 0, 0, 772, 202, 1, 0, 0, 0, 773, 857, 5, 56, 0, 0, 774, 775, 5, 49, 0, 0, 775, 857, 5, 54, 0, 0, 776, 777, 5, 50, 0, 0, 777, 857, 5, 52, 0, 0, 778, 779, 5, 51, 0, 0, 779, 857, 5, 50, 0, 0, 780, 781, 5, 52, 0, 0, 781, 857, 5, 48, 0, 0, 782, 783, 5, 52, 0, 0, 783, 857, 5, 56, 0, 0, 784, 785, 5, 53, 0, 0, 785, 857, 5, 54, 0, 0, 786, 787, 5, 54, 0, 0, 787, 857, 5, 52, 0, 0, 788, 789, 5, 55, 0, 0, 789, 857, 5, 50, 0, 0, 790, 791, 5, 56, 0, 0, 791, 857, 5, 48, 0, 0, 792, 793, 5, 56, 0, 0, 793, 857, 5, 56, 0, 0, 794, 795, 5, 57, 0, 0, 795, 857, 5, 54, 0, 0, 796, 797, 5, 49, 0, 0, 797, 798, 5, 48, 0, 0, 798, 857, 5, 52, 0, 0, 799, 800, 5, 49, 0, 0, 800, 801, 5, 49, 0, 0, 801, 857, 5, 50, 0, 0, 802, 803, 5, 49, 0, 0, 803, 804, 5, 50, 0, 0, 804, 857, 5, 48, 0, 0, 805, 806, 5, 49, 0, 0, 806, 807, 5, 50, 0, 0, 807, 857, 5, 56, 0, 0, 808, 809, 5, 49, 0, 0, 809, 810, 5, 51, 0, 0, 810, 857, 5, 54, 0, 0, 811, 812, 5, 49, 0, 0, 812, 813, 5, 52, 0, 0, 813, 857, 5, 52, 0, 0, 814, 815, 5, 49, 0, 0, 815, 816, 5, 53, 0, 0, 816, 857, 5, 50, 0, 0, 817, 818, 5, 49, 0, 0, 818, 819, 5, 54, 0, 0, 819, 857, 5, 48, 0, 0, 820, 821, 5, 49, 0, 0, 821, 822, 5, 54, 0, 0, 822, 857, 5, 56, 0, 0, 823, 824, 5, 49, 0, 0, 824, 825, 5, 55, 0, 0, 825, 857, 5, 54, 0, 0, 826, 827, 5, 49, 0, 0, 827, 828, 5, 56, 0, 0, 828, 857, 5, 52, 0, 0, 829, 830, 5, 49, 0, 0, 830, 831, 5, 57, 0, 0, 831, 857, 5, 50, 0, 0, 832, 833, 5, 50, 0, 0, 833, 834, 5, 48, 0, 0, 834, 857, 5, 48, 0, 0, 835, 836, 5, 50, 0, 0, 836, 837, 5, 48, 0, 0, 837, 857, 5, 56, 0, 0, 838, 839, 5, 50, 0, 0, 839, 840, 5, 49, 0, 0, 840, 857, 5, 54, 0, 0, 841, 842, 5, 50, 0, 0, 842, 843, 5, 50, 0, 0, 843, 857, 5, 52, 0, 0, 844, 845, 5, 50, 0, 0, 845, 846, 5, 51, 0, 0, 846, 857, 5, 50, 0, 0, 847, 848, 5, 50, 0, 0, 848, 849, 5, 52, 0, 0, 849, 857, 5, 48, 0, 0, 850, 851, 5, 50, 0, 0, 851, 852, 5, 52, 0, 0, 852, 857, 5, 56, 0, 0, 853, 854, 5, 50, 0, 0, 854, 855, 5, 53, 0, 0, 855, 857, 5, 54, 0, 0, 856, 773, 1, 0, 0, 0, 856, 774, 1, 0, 0, 0, 856, 776, 1, 0, 0, 0, 856, 778, 1, 0, 0, 0, 856, 780, 1, 0, 0, 0, 856, 782, 1, 0, 0, 0, 856, 784, 1, 0, 0, 0, 856, 786, 1, 0, 0, 0, 856, 788, 1, 0, 0, 0, 856, 790, 1, 0, 0, 0, 856, 792, 1, 0, 0, 0, 856, 794, 1, 0, 0, 0, 856, 796, 1, 0, 0, 0, 856, 799, 1, 0, 0, 0, 856, 802, 1, 0, 0, 0, 856, 805, 1, 0, 0, 0, 856, 808, 1, 0, 0, 0, 856, 811, 1, 0, 0, 0, 856, 814, 1, 0, 0, 0, 856, 817, 1, 0, 0, 0, 856, 820, 1, 0, 0, 0, 856, 823, 1, 0, 0, 0, 856, 826, 1, 0, 0, 0, 856, 829, 1, 0, 0, 0, 856, 832, 1, 0, 0, 0, 856, 835, 1, 0, 0, 0, 856, 838, 1, 0, 0, 0, 856, 841, 1, 0, 0, 0, 856, 844, 1, 0, 0, 0, 856, 847, 1, 0, 0, 0, 856, 850, 1, 0, 0, 0, 856, 853, 1, 0, 0, 0, 857, 204, 1, 0, 0, 0, 858, 864, 7, 1, 0, 0, 859, 860, 7, 2, 0, 0, 860, 864, 7, 0, 0, 0, 861, 862, 5, 51, 0, 0, 862, 864, 7, 3, 0, 0, 863, 858, 1, 0, 0, 0, 863, 859, 1, 0, 0, 0, 863, 861, 1, 0, 0, 0, 864, 206, 1, 0, 0, 0, 865, 866, 5, 116, 0, 0, 866, 867, 5, 114, 0, 0, 867, 868, 5, 117, 0, 0, 868, 875, 5, 101, 0, 0, 869, 870, 5, 102, 0, 0, 870, 871, 5, 97, 0, 0, 871, 872, 5, 108, 0, 0, 872, 873, 5, 115, 0, 0, 873, 875, 5, 101, 0, 0, 874, 865, 1, 0, 0, 0, 874, 869, 1, 0, 0, 0, 875, 208, 1, 0, 0, 0, 876, 883, 3, 211, 105, 0, 877, 879, 3, 211, 105, 0, 878, 877, 1, 0, 0, 0, 878, 879, 1, 0, 0, 0, 879, 880, 1, 0, 0, 0, 880, 881, 5, 46, 0, 0, 881, 883, 3, 211, 105, 0, 882, 876, 1, 0, 0, 0, 882, 878, 1, 0, 0, 0, 883, 889, 1, 0, 0, 0, 884, 886, 7, 4, 0, 0, 885, 887, 5, 45, 0, 0, 886, 885, 1, 0, 0, 0, 886, 887, 1, 0, 0, 0, 887, 888, 1, 0, 0, 0, 888, 890, 3, 211, 105, 0, 889, 884, 1, 0, 0, 0, 889, 890, 1, 0, 0, 0, 890, 210, 1, 0, 0, 0, 891, 898, 7, 0, 0, 0, 892, 894, 5, 95, 0, 0, 893, 892, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 897, 7, 0, 0, 0, 896, 893, 1, 0, 0, 0, 897, 900, 1, 0, 0, 0, 898, 896, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 212, 1, 0, 0, 0, 900, 898, 1, 0, 0, 0, 901, 902, 5, 48, 0, 0, 902, 903, 7, 5, 0, 0, 903, 904, 3, 215, 107, 0, 904, 214, 1, 0, 0, 0, 905, 912, 3, 221, 110, 0, 906, 908, 5, 95, 0, 0, 907, 906, 1, 0, 0, 0, 907, 908, 1, 0, 0, 0, 908, 909, 1, 0, 0, 0, 909, 911, 3, 221, 110, 0, 910, 907, 1, 0, 0, 0, 911, 914, 1, 0, 0, 0, 912, 910, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 216, 1, 0, 0, 0, 914, 912, 1, 0, 0, 0, 915, 916, 5, 119, 0, 0, 916, 917, 5, 101, 0, 0, 917, 972, 5, 105, 0, 0, 918, 919, 5, 103, 0, 0, 919, 920, 5, 119, 0, 0, 920, 921, 5, 101, 0, 0, 921, 972, 5, 105, 0, 0, 922, 923, 5, 115, 0, 0, 923, 924, 5, 122, 0, 0, 924, 925, 5, 97, 0, 0, 925, 926, 5, 98, 0, 0, 926, 972, 5, 111, 0, 0, 927, 928, 5, 102, 0, 0, 928, 929, 5, 105, 0, 0, 929, 930, 5, 110, 0, 0, 930, 931, 5, 110, 0, 0, 931, 932, 5, 101, 0, 0, 932, 972, 5, 121, 0, 0, 933, 934, 5, 101, 0, 0, 934, 935, 5, 116, 0, 0, 935, 936, 5, 104, 0, 0, 936, 937, 5, 101, 0, 0, 937, 972, 5, 114, 0, 0, 938, 939, 5, 115, 0, 0, 939, 940, 5, 101, 0, 0, 940, 941, 5, 99, 0, 0, 941, 942, 5, 111, 0, 0, 942, 943, 5, 110, 0, 0, 943, 944, 5, 100, 0, 0, 944, 972, 5, 115, 0, 0, 945, 946, 5, 109, 0, 0, 946, 947, 5, 105, 0, 0, 947, 948, 5, 110, 0, 0, 948, 949, 5, 117, 0, 0, 949, 950, 5, 116, 0, 0, 950, 951, 5, 101, 0, 0, 951, 972, 5, 115, 0, 0, 952, 953, 5, 104, 0, 0, 953, 954, 5, 111, 0, 0, 954, 955, 5, 117, 0, 0, 955, 956, 5, 114, 0, 0, 956, 972, 5, 115, 0, 0, 957, 958, 5, 100, 0, 0, 958, 959, 5, 97, 0, 0, 959, 960, 5, 121, 0, 0, 960, 972, 5, 115, 0, 0, 961, 962, 5, 119, 0, 0, 962, 963, 5, 101, 0, 0, 963, 964, 5, 101, 0, 0, 964, 965, 5, 107, 0, 0, 965, 972, 5, 115, 0, 0, 966, 967, 5, 121, 0, 0, 967, 968, 5, 101, 0, 0, 968, 969, 5, 97, 0, 0, 969, 970, 5, 114, 0, 0, 970, 972, 5, 115, 0, 0, 971, 915, 1, 0, 0, 0, 971, 918, 1, 0, 0, 0, 971, 922, 1, 0, 0, 0, 971, 927, 1, 0, 0, 0, 971, 933, 1, 0, 0, 0, 971, 938, 1, 0, 0, 0, 971, 945, 1, 0, 0, 0, 971, 952, 1, 0, 0, 0, 971, 957, 1, 0, 0, 0, 971, 961, 1, 0, 0, 0, 971, 966, 1, 0, 0, 0, 972, 218, 1, 0, 0, 0, 973, 974, 5, 104, 0, 0, 974, 975, 5, 101, 0, 0, 975, 976, 5, 120, 0, 0, 976, 987, 1, 0, 0, 0, 977, 979, 5, 34, 0, 0, 978, 980, 3, 215, 107, 0, 979, 978, 1, 0, 0, 0, 979, 980, 1, 0, 0, 0, 980, 981, 1, 0, 0, 0, 981, 988, 5, 34, 0, 0, 982, 984, 5, 39, 0, 0, 983, 985, 3, 215, 107, 0, 984, 983, 1, 0, 0, 0, 984, 985, 1, 0, 0, 0, 985, 986, 1, 0, 0, 0, 986, 988, 5, 39, 0, 0, 987, 977, 1, 0, 0, 0, 987, 982, 1, 0, 0, 0, 988, 220, 1, 0, 0, 0, 989, 990, 7, 6, 0, 0, 990, 222, 1, 0, 0, 0, 991, 992, 5, 97, 0, 0, 992, 993, 5, 98, 0, 0, 993, 994, 5, 115, 0, 0, 994, 995, 5, 116, 0, 0, 995, 996, 5, 114, 0, 0, 996, 997, 5, 97, 0, 0, 997, 998, 5, 99, 0, 0, 998, 1080, 5, 116, 0, 0, 999, 1e3, 5, 97, 0, 0, 1e3, 1001, 5, 102, 0, 0, 1001, 1002, 5, 116, 0, 0, 1002, 1003, 5, 101, 0, 0, 1003, 1080, 5, 114, 0, 0, 1004, 1005, 5, 99, 0, 0, 1005, 1006, 5, 97, 0, 0, 1006, 1007, 5, 115, 0, 0, 1007, 1080, 5, 101, 0, 0, 1008, 1009, 5, 99, 0, 0, 1009, 1010, 5, 97, 0, 0, 1010, 1011, 5, 116, 0, 0, 1011, 1012, 5, 99, 0, 0, 1012, 1080, 5, 104, 0, 0, 1013, 1014, 5, 100, 0, 0, 1014, 1015, 5, 101, 0, 0, 1015, 1016, 5, 102, 0, 0, 1016, 1017, 5, 97, 0, 0, 1017, 1018, 5, 117, 0, 0, 1018, 1019, 5, 108, 0, 0, 1019, 1080, 5, 116, 0, 0, 1020, 1021, 5, 102, 0, 0, 1021, 1022, 5, 105, 0, 0, 1022, 1023, 5, 110, 0, 0, 1023, 1024, 5, 97, 0, 0, 1024, 1080, 5, 108, 0, 0, 1025, 1026, 5, 105, 0, 0, 1026, 1080, 5, 110, 0, 0, 1027, 1028, 5, 105, 0, 0, 1028, 1029, 5, 110, 0, 0, 1029, 1030, 5, 108, 0, 0, 1030, 1031, 5, 105, 0, 0, 1031, 1032, 5, 110, 0, 0, 1032, 1080, 5, 101, 0, 0, 1033, 1034, 5, 108, 0, 0, 1034, 1035, 5, 101, 0, 0, 1035, 1080, 5, 116, 0, 0, 1036, 1037, 5, 109, 0, 0, 1037, 1038, 5, 97, 0, 0, 1038, 1039, 5, 116, 0, 0, 1039, 1040, 5, 99, 0, 0, 1040, 1080, 5, 104, 0, 0, 1041, 1042, 5, 110, 0, 0, 1042, 1043, 5, 117, 0, 0, 1043, 1044, 5, 108, 0, 0, 1044, 1080, 5, 108, 0, 0, 1045, 1046, 5, 111, 0, 0, 1046, 1080, 5, 102, 0, 0, 1047, 1048, 5, 114, 0, 0, 1048, 1049, 5, 101, 0, 0, 1049, 1050, 5, 108, 0, 0, 1050, 1051, 5, 111, 0, 0, 1051, 1052, 5, 99, 0, 0, 1052, 1053, 5, 97, 0, 0, 1053, 1054, 5, 116, 0, 0, 1054, 1055, 5, 97, 0, 0, 1055, 1056, 5, 98, 0, 0, 1056, 1057, 5, 108, 0, 0, 1057, 1080, 5, 101, 0, 0, 1058, 1059, 5, 115, 0, 0, 1059, 1060, 5, 116, 0, 0, 1060, 1061, 5, 97, 0, 0, 1061, 1062, 5, 116, 0, 0, 1062, 1063, 5, 105, 0, 0, 1063, 1080, 5, 99, 0, 0, 1064, 1065, 5, 115, 0, 0, 1065, 1066, 5, 119, 0, 0, 1066, 1067, 5, 105, 0, 0, 1067, 1068, 5, 116, 0, 0, 1068, 1069, 5, 99, 0, 0, 1069, 1080, 5, 104, 0, 0, 1070, 1071, 5, 116, 0, 0, 1071, 1072, 5, 114, 0, 0, 1072, 1080, 5, 121, 0, 0, 1073, 1074, 5, 116, 0, 0, 1074, 1075, 5, 121, 0, 0, 1075, 1076, 5, 112, 0, 0, 1076, 1077, 5, 101, 0, 0, 1077, 1078, 5, 111, 0, 0, 1078, 1080, 5, 102, 0, 0, 1079, 991, 1, 0, 0, 0, 1079, 999, 1, 0, 0, 0, 1079, 1004, 1, 0, 0, 0, 1079, 1008, 1, 0, 0, 0, 1079, 1013, 1, 0, 0, 0, 1079, 1020, 1, 0, 0, 0, 1079, 1025, 1, 0, 0, 0, 1079, 1027, 1, 0, 0, 0, 1079, 1033, 1, 0, 0, 0, 1079, 1036, 1, 0, 0, 0, 1079, 1041, 1, 0, 0, 0, 1079, 1045, 1, 0, 0, 0, 1079, 1047, 1, 0, 0, 0, 1079, 1058, 1, 0, 0, 0, 1079, 1064, 1, 0, 0, 0, 1079, 1070, 1, 0, 0, 0, 1079, 1073, 1, 0, 0, 0, 1080, 224, 1, 0, 0, 0, 1081, 1082, 5, 97, 0, 0, 1082, 1083, 5, 110, 0, 0, 1083, 1084, 5, 111, 0, 0, 1084, 1085, 5, 110, 0, 0, 1085, 1086, 5, 121, 0, 0, 1086, 1087, 5, 109, 0, 0, 1087, 1088, 5, 111, 0, 0, 1088, 1089, 5, 117, 0, 0, 1089, 1090, 5, 115, 0, 0, 1090, 226, 1, 0, 0, 0, 1091, 1092, 5, 98, 0, 0, 1092, 1093, 5, 114, 0, 0, 1093, 1094, 5, 101, 0, 0, 1094, 1095, 5, 97, 0, 0, 1095, 1096, 5, 107, 0, 0, 1096, 228, 1, 0, 0, 0, 1097, 1098, 5, 99, 0, 0, 1098, 1099, 5, 111, 0, 0, 1099, 1100, 5, 110, 0, 0, 1100, 1101, 5, 115, 0, 0, 1101, 1102, 5, 116, 0, 0, 1102, 1103, 5, 97, 0, 0, 1103, 1104, 5, 110, 0, 0, 1104, 1105, 5, 116, 0, 0, 1105, 230, 1, 0, 0, 0, 1106, 1107, 5, 116, 0, 0, 1107, 1108, 5, 114, 0, 0, 1108, 1109, 5, 97, 0, 0, 1109, 1110, 5, 110, 0, 0, 1110, 1111, 5, 115, 0, 0, 1111, 1112, 5, 105, 0, 0, 1112, 1113, 5, 101, 0, 0, 1113, 1114, 5, 110, 0, 0, 1114, 1115, 5, 116, 0, 0, 1115, 232, 1, 0, 0, 0, 1116, 1117, 5, 105, 0, 0, 1117, 1118, 5, 109, 0, 0, 1118, 1119, 5, 109, 0, 0, 1119, 1120, 5, 117, 0, 0, 1120, 1121, 5, 116, 0, 0, 1121, 1122, 5, 97, 0, 0, 1122, 1123, 5, 98, 0, 0, 1123, 1124, 5, 108, 0, 0, 1124, 1125, 5, 101, 0, 0, 1125, 234, 1, 0, 0, 0, 1126, 1127, 5, 99, 0, 0, 1127, 1128, 5, 111, 0, 0, 1128, 1129, 5, 110, 0, 0, 1129, 1130, 5, 116, 0, 0, 1130, 1131, 5, 105, 0, 0, 1131, 1132, 5, 110, 0, 0, 1132, 1133, 5, 117, 0, 0, 1133, 1134, 5, 101, 0, 0, 1134, 236, 1, 0, 0, 0, 1135, 1136, 5, 108, 0, 0, 1136, 1137, 5, 101, 0, 0, 1137, 1138, 5, 97, 0, 0, 1138, 1139, 5, 118, 0, 0, 1139, 1140, 5, 101, 0, 0, 1140, 238, 1, 0, 0, 0, 1141, 1142, 5, 101, 0, 0, 1142, 1143, 5, 120, 0, 0, 1143, 1144, 5, 116, 0, 0, 1144, 1145, 5, 101, 0, 0, 1145, 1146, 5, 114, 0, 0, 1146, 1147, 5, 110, 0, 0, 1147, 1148, 5, 97, 0, 0, 1148, 1149, 5, 108, 0, 0, 1149, 240, 1, 0, 0, 0, 1150, 1151, 5, 105, 0, 0, 1151, 1152, 5, 110, 0, 0, 1152, 1153, 5, 100, 0, 0, 1153, 1154, 5, 101, 0, 0, 1154, 1155, 5, 120, 0, 0, 1155, 1156, 5, 101, 0, 0, 1156, 1157, 5, 100, 0, 0, 1157, 242, 1, 0, 0, 0, 1158, 1159, 5, 105, 0, 0, 1159, 1160, 5, 110, 0, 0, 1160, 1161, 5, 116, 0, 0, 1161, 1162, 5, 101, 0, 0, 1162, 1163, 5, 114, 0, 0, 1163, 1164, 5, 110, 0, 0, 1164, 1165, 5, 97, 0, 0, 1165, 1166, 5, 108, 0, 0, 1166, 244, 1, 0, 0, 0, 1167, 1168, 5, 112, 0, 0, 1168, 1169, 5, 97, 0, 0, 1169, 1170, 5, 121, 0, 0, 1170, 1171, 5, 97, 0, 0, 1171, 1172, 5, 98, 0, 0, 1172, 1173, 5, 108, 0, 0, 1173, 1174, 5, 101, 0, 0, 1174, 246, 1, 0, 0, 0, 1175, 1176, 5, 112, 0, 0, 1176, 1177, 5, 114, 0, 0, 1177, 1178, 5, 105, 0, 0, 1178, 1179, 5, 118, 0, 0, 1179, 1180, 5, 97, 0, 0, 1180, 1181, 5, 116, 0, 0, 1181, 1182, 5, 101, 0, 0, 1182, 248, 1, 0, 0, 0, 1183, 1184, 5, 112, 0, 0, 1184, 1185, 5, 117, 0, 0, 1185, 1186, 5, 98, 0, 0, 1186, 1187, 5, 108, 0, 0, 1187, 1188, 5, 105, 0, 0, 1188, 1189, 5, 99, 0, 0, 1189, 250, 1, 0, 0, 0, 1190, 1191, 5, 118, 0, 0, 1191, 1192, 5, 105, 0, 0, 1192, 1193, 5, 114, 0, 0, 1193, 1194, 5, 116, 0, 0, 1194, 1195, 5, 117, 0, 0, 1195, 1196, 5, 97, 0, 0, 1196, 1197, 5, 108, 0, 0, 1197, 252, 1, 0, 0, 0, 1198, 1199, 5, 112, 0, 0, 1199, 1200, 5, 117, 0, 0, 1200, 1201, 5, 114, 0, 0, 1201, 1202, 5, 101, 0, 0, 1202, 254, 1, 0, 0, 0, 1203, 1204, 5, 116, 0, 0, 1204, 1205, 5, 121, 0, 0, 1205, 1206, 5, 112, 0, 0, 1206, 1207, 5, 101, 0, 0, 1207, 256, 1, 0, 0, 0, 1208, 1209, 5, 118, 0, 0, 1209, 1210, 5, 105, 0, 0, 1210, 1211, 5, 101, 0, 0, 1211, 1212, 5, 119, 0, 0, 1212, 258, 1, 0, 0, 0, 1213, 1214, 5, 103, 0, 0, 1214, 1215, 5, 108, 0, 0, 1215, 1216, 5, 111, 0, 0, 1216, 1217, 5, 98, 0, 0, 1217, 1218, 5, 97, 0, 0, 1218, 1219, 5, 108, 0, 0, 1219, 260, 1, 0, 0, 0, 1220, 1221, 5, 99, 0, 0, 1221, 1222, 5, 111, 0, 0, 1222, 1223, 5, 110, 0, 0, 1223, 1224, 5, 115, 0, 0, 1224, 1225, 5, 116, 0, 0, 1225, 1226, 5, 114, 0, 0, 1226, 1227, 5, 117, 0, 0, 1227, 1228, 5, 99, 0, 0, 1228, 1229, 5, 116, 0, 0, 1229, 1230, 5, 111, 0, 0, 1230, 1231, 5, 114, 0, 0, 1231, 262, 1, 0, 0, 0, 1232, 1233, 5, 102, 0, 0, 1233, 1234, 5, 97, 0, 0, 1234, 1235, 5, 108, 0, 0, 1235, 1236, 5, 108, 0, 0, 1236, 1237, 5, 98, 0, 0, 1237, 1238, 5, 97, 0, 0, 1238, 1239, 5, 99, 0, 0, 1239, 1240, 5, 107, 0, 0, 1240, 264, 1, 0, 0, 0, 1241, 1242, 5, 114, 0, 0, 1242, 1243, 5, 101, 0, 0, 1243, 1244, 5, 99, 0, 0, 1244, 1245, 5, 101, 0, 0, 1245, 1246, 5, 105, 0, 0, 1246, 1247, 5, 118, 0, 0, 1247, 1248, 5, 101, 0, 0, 1248, 266, 1, 0, 0, 0, 1249, 1253, 3, 269, 134, 0, 1250, 1252, 3, 271, 135, 0, 1251, 1250, 1, 0, 0, 0, 1252, 1255, 1, 0, 0, 0, 1253, 1251, 1, 0, 0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 268, 1, 0, 0, 0, 1255, 1253, 1, 0, 0, 0, 1256, 1257, 7, 7, 0, 0, 1257, 270, 1, 0, 0, 0, 1258, 1259, 7, 8, 0, 0, 1259, 272, 1, 0, 0, 0, 1260, 1261, 5, 117, 0, 0, 1261, 1262, 5, 110, 0, 0, 1262, 1263, 5, 105, 0, 0, 1263, 1264, 5, 99, 0, 0, 1264, 1265, 5, 111, 0, 0, 1265, 1266, 5, 100, 0, 0, 1266, 1268, 5, 101, 0, 0, 1267, 1260, 1, 0, 0, 0, 1267, 1268, 1, 0, 0, 0, 1268, 1285, 1, 0, 0, 0, 1269, 1273, 5, 34, 0, 0, 1270, 1272, 3, 275, 137, 0, 1271, 1270, 1, 0, 0, 0, 1272, 1275, 1, 0, 0, 0, 1273, 1271, 1, 0, 0, 0, 1273, 1274, 1, 0, 0, 0, 1274, 1276, 1, 0, 0, 0, 1275, 1273, 1, 0, 0, 0, 1276, 1286, 5, 34, 0, 0, 1277, 1281, 5, 39, 0, 0, 1278, 1280, 3, 277, 138, 0, 1279, 1278, 1, 0, 0, 0, 1280, 1283, 1, 0, 0, 0, 1281, 1279, 1, 0, 0, 0, 1281, 1282, 1, 0, 0, 0, 1282, 1284, 1, 0, 0, 0, 1283, 1281, 1, 0, 0, 0, 1284, 1286, 5, 39, 0, 0, 1285, 1269, 1, 0, 0, 0, 1285, 1277, 1, 0, 0, 0, 1286, 274, 1, 0, 0, 0, 1287, 1291, 8, 9, 0, 0, 1288, 1289, 5, 92, 0, 0, 1289, 1291, 9, 0, 0, 0, 1290, 1287, 1, 0, 0, 0, 1290, 1288, 1, 0, 0, 0, 1291, 276, 1, 0, 0, 0, 1292, 1296, 8, 10, 0, 0, 1293, 1294, 5, 92, 0, 0, 1294, 1296, 9, 0, 0, 0, 1295, 1292, 1, 0, 0, 0, 1295, 1293, 1, 0, 0, 0, 1296, 278, 1, 0, 0, 0, 1297, 1299, 7, 0, 0, 0, 1298, 1297, 1, 0, 0, 0, 1299, 1300, 1, 0, 0, 0, 1300, 1298, 1, 0, 0, 0, 1300, 1301, 1, 0, 0, 0, 1301, 1302, 1, 0, 0, 0, 1302, 1304, 5, 46, 0, 0, 1303, 1305, 7, 0, 0, 0, 1304, 1303, 1, 0, 0, 0, 1305, 1306, 1, 0, 0, 0, 1306, 1304, 1, 0, 0, 0, 1306, 1307, 1, 0, 0, 0, 1307, 1314, 1, 0, 0, 0, 1308, 1310, 5, 46, 0, 0, 1309, 1311, 7, 0, 0, 0, 1310, 1309, 1, 0, 0, 0, 1311, 1312, 1, 0, 0, 0, 1312, 1310, 1, 0, 0, 0, 1312, 1313, 1, 0, 0, 0, 1313, 1315, 1, 0, 0, 0, 1314, 1308, 1, 0, 0, 0, 1314, 1315, 1, 0, 0, 0, 1315, 280, 1, 0, 0, 0, 1316, 1318, 7, 11, 0, 0, 1317, 1316, 1, 0, 0, 0, 1318, 1319, 1, 0, 0, 0, 1319, 1317, 1, 0, 0, 0, 1319, 1320, 1, 0, 0, 0, 1320, 1321, 1, 0, 0, 0, 1321, 1322, 6, 140, 0, 0, 1322, 282, 1, 0, 0, 0, 1323, 1324, 5, 47, 0, 0, 1324, 1325, 5, 42, 0, 0, 1325, 1329, 1, 0, 0, 0, 1326, 1328, 9, 0, 0, 0, 1327, 1326, 1, 0, 0, 0, 1328, 1331, 1, 0, 0, 0, 1329, 1330, 1, 0, 0, 0, 1329, 1327, 1, 0, 0, 0, 1330, 1332, 1, 0, 0, 0, 1331, 1329, 1, 0, 0, 0, 1332, 1333, 5, 42, 0, 0, 1333, 1334, 5, 47, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 1336, 6, 141, 1, 0, 1336, 284, 1, 0, 0, 0, 1337, 1338, 5, 47, 0, 0, 1338, 1339, 5, 47, 0, 0, 1339, 1343, 1, 0, 0, 0, 1340, 1342, 8, 12, 0, 0, 1341, 1340, 1, 0, 0, 0, 1342, 1345, 1, 0, 0, 0, 1343, 1341, 1, 0, 0, 0, 1343, 1344, 1, 0, 0, 0, 1344, 1346, 1, 0, 0, 0, 1345, 1343, 1, 0, 0, 0, 1346, 1347, 6, 142, 1, 0, 1347, 286, 1, 0, 0, 0, 38, 0, 723, 731, 740, 753, 755, 769, 771, 856, 863, 874, 878, 882, 886, 889, 893, 898, 907, 912, 971, 979, 984, 987, 1079, 1253, 1267, 1273, 1281, 1285, 1290, 1295, 1300, 1306, 1312, 1314, 1319, 1329, 1343, 2, 6, 0, 0, 0, 1, 0], S2.DecisionsToDFA = S2._ATN.decisionToState.map((t5, e4) => new d(t5, e4));
            var C = S2, A2 = class t5 extends T2 {
              get grammarFileName() {
                return "Solidity.g4";
              }
              get literalNames() {
                return t5.literalNames;
              }
              get symbolicNames() {
                return t5.symbolicNames;
              }
              get ruleNames() {
                return t5.ruleNames;
              }
              get serializedATN() {
                return t5._serializedATN;
              }
              createFailedPredicateException(t6, e4) {
                return new _2(this, t6, e4);
              }
              constructor(e4) {
                super(e4), this._interp = new E(this, t5._ATN, t5.DecisionsToDFA, new v());
              }
              sourceUnit() {
                let e4, i4 = new N2(this, this._ctx, this.state);
                this.enterRule(i4, 0, t5.RULE_sourceUnit);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 215, this._errHandler.sync(this), e4 = this._input.LA(1); 0 == (-32 & e4) && 0 != (1 << e4 & 104620034) || 0 == (e4 - 36 & -32) && 0 != (1 << e4 - 36 & 2080392501) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3498573949) || 0 == (e4 - 127 & -32) && 0 != (1 << e4 - 127 & 7); ) {
                    switch (this.state = 213, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 0, this._ctx)) {
                      case 1:
                        this.state = 202, this.pragmaDirective();
                        break;
                      case 2:
                        this.state = 203, this.importDirective();
                        break;
                      case 3:
                        this.state = 204, this.contractDefinition();
                        break;
                      case 4:
                        this.state = 205, this.enumDefinition();
                        break;
                      case 5:
                        this.state = 206, this.eventDefinition();
                        break;
                      case 6:
                        this.state = 207, this.structDefinition();
                        break;
                      case 7:
                        this.state = 208, this.functionDefinition();
                        break;
                      case 8:
                        this.state = 209, this.fileLevelConstant();
                        break;
                      case 9:
                        this.state = 210, this.customErrorDefinition();
                        break;
                      case 10:
                        this.state = 211, this.typeDefinition();
                        break;
                      case 11:
                        this.state = 212, this.usingForDeclaration();
                    }
                    this.state = 217, this._errHandler.sync(this), e4 = this._input.LA(1);
                  }
                  this.state = 218, this.match(t5.EOF);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              pragmaDirective() {
                let e4 = new I2(this, this._ctx, this.state);
                this.enterRule(e4, 2, t5.RULE_pragmaDirective);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 220, this.match(t5.T__0), this.state = 221, this.pragmaName(), this.state = 222, this.pragmaValue(), this.state = 223, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              pragmaName() {
                let e4 = new k2(this, this._ctx, this.state);
                this.enterRule(e4, 4, t5.RULE_pragmaName);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 225, this.identifier();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              pragmaValue() {
                let e4 = new D(this, this._ctx, this.state);
                this.enterRule(e4, 6, t5.RULE_pragmaValue);
                try {
                  switch (this.state = 230, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 2, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 227, this.match(t5.T__2);
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 228, this.version();
                      break;
                    case 3:
                      this.enterOuterAlt(e4, 3), this.state = 229, this.expression(0);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              version() {
                let e4, i4 = new O2(this, this._ctx, this.state);
                this.enterRule(i4, 8, t5.RULE_version);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 232, this.versionConstraint(), this.state = 239, this._errHandler.sync(this), e4 = this._input.LA(1); 0 == (-32 & e4) && 0 != (1 << e4 & 4080) || 103 === e4 || 131 === e4; ) this.state = 234, this._errHandler.sync(this), e4 = this._input.LA(1), 4 === e4 && (this.state = 233, this.match(t5.T__3)), this.state = 236, this.versionConstraint(), this.state = 241, this._errHandler.sync(this), e4 = this._input.LA(1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              versionOperator() {
                let e4, i4 = new P2(this, this._ctx, this.state);
                this.enterRule(i4, 10, t5.RULE_versionOperator);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 242, e4 = this._input.LA(1), 0 != (-32 & e4) || 0 == (1 << e4 & 4064) ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              versionConstraint() {
                let e4, i4 = new F(this, this._ctx, this.state);
                this.enterRule(i4, 12, t5.RULE_versionConstraint);
                try {
                  switch (this.state = 252, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 7, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(i4, 1), this.state = 245, this._errHandler.sync(this), e4 = this._input.LA(1), 0 == (-32 & e4) && 0 != (1 << e4 & 4064) && (this.state = 244, this.versionOperator()), this.state = 247, this.match(t5.VersionLiteral);
                      break;
                    case 2:
                      this.enterOuterAlt(i4, 2), this.state = 249, this._errHandler.sync(this), e4 = this._input.LA(1), 0 == (-32 & e4) && 0 != (1 << e4 & 4064) && (this.state = 248, this.versionOperator()), this.state = 251, this.match(t5.DecimalNumber);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              importDeclaration() {
                let e4, i4 = new U2(this, this._ctx, this.state);
                this.enterRule(i4, 14, t5.RULE_importDeclaration);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 254, this.identifier(), this.state = 257, this._errHandler.sync(this), e4 = this._input.LA(1), 12 === e4 && (this.state = 255, this.match(t5.T__11), this.state = 256, this.identifier());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              importDirective() {
                let e4, i4 = new H2(this, this._ctx, this.state);
                this.enterRule(i4, 16, t5.RULE_importDirective);
                try {
                  switch (this.state = 295, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 13, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(i4, 1), this.state = 259, this.match(t5.T__12), this.state = 260, this.importPath(), this.state = 263, this._errHandler.sync(this), e4 = this._input.LA(1), 12 === e4 && (this.state = 261, this.match(t5.T__11), this.state = 262, this.identifier()), this.state = 265, this.match(t5.T__1);
                      break;
                    case 2:
                      switch (this.enterOuterAlt(i4, 2), this.state = 267, this.match(t5.T__12), this.state = 270, this._errHandler.sync(this), this._input.LA(1)) {
                        case 3:
                          this.state = 268, this.match(t5.T__2);
                          break;
                        case 14:
                        case 25:
                        case 44:
                        case 50:
                        case 62:
                        case 95:
                        case 114:
                        case 118:
                        case 125:
                        case 126:
                        case 128:
                        case 129:
                          this.state = 269, this.identifier();
                          break;
                        default:
                          throw new y2(this);
                      }
                      this.state = 274, this._errHandler.sync(this), e4 = this._input.LA(1), 12 === e4 && (this.state = 272, this.match(t5.T__11), this.state = 273, this.identifier()), this.state = 276, this.match(t5.T__13), this.state = 277, this.importPath(), this.state = 278, this.match(t5.T__1);
                      break;
                    case 3:
                      for (this.enterOuterAlt(i4, 3), this.state = 280, this.match(t5.T__12), this.state = 281, this.match(t5.T__14), this.state = 282, this.importDeclaration(), this.state = 287, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 283, this.match(t5.T__15), this.state = 284, this.importDeclaration(), this.state = 289, this._errHandler.sync(this), e4 = this._input.LA(1);
                      this.state = 290, this.match(t5.T__16), this.state = 291, this.match(t5.T__13), this.state = 292, this.importPath(), this.state = 293, this.match(t5.T__1);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              importPath() {
                let e4 = new M2(this, this._ctx, this.state);
                this.enterRule(e4, 18, t5.RULE_importPath);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 297, this.match(t5.StringLiteralFragment);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              contractDefinition() {
                let e4, i4 = new K2(this, this._ctx, this.state);
                this.enterRule(i4, 20, t5.RULE_contractDefinition);
                try {
                  if (this.enterOuterAlt(i4, 1), this.state = 300, this._errHandler.sync(this), e4 = this._input.LA(1), 18 === e4 && (this.state = 299, this.match(t5.T__17)), this.state = 302, e4 = this._input.LA(1), 0 != (-32 & e4) || 0 == (1 << e4 & 3670016) ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 303, this.identifier(), this.state = 313, this._errHandler.sync(this), e4 = this._input.LA(1), 22 === e4) for (this.state = 304, this.match(t5.T__21), this.state = 305, this.inheritanceSpecifier(), this.state = 310, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 306, this.match(t5.T__15), this.state = 307, this.inheritanceSpecifier(), this.state = 312, this._errHandler.sync(this), e4 = this._input.LA(1);
                  for (this.state = 315, this.match(t5.T__14), this.state = 319, this._errHandler.sync(this), e4 = this._input.LA(1); 0 == (-32 & e4) && 0 != (1 << e4 & 100679680) || 0 == (e4 - 36 & -32) && 0 != (1 << e4 - 36 & 2080392503) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3498573949) || 0 == (e4 - 127 & -32) && 0 != (1 << e4 - 127 & 7); ) this.state = 316, this.contractPart(), this.state = 321, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 322, this.match(t5.T__16);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              inheritanceSpecifier() {
                let e4, i4 = new V2(this, this._ctx, this.state);
                this.enterRule(i4, 22, t5.RULE_inheritanceSpecifier);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 324, this.userDefinedTypeName(), this.state = 330, this._errHandler.sync(this), e4 = this._input.LA(1), 23 === e4 && (this.state = 325, this.match(t5.T__22), this.state = 327, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) && (this.state = 326, this.expressionList()), this.state = 329, this.match(t5.T__23));
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              contractPart() {
                let e4 = new B2(this, this._ctx, this.state);
                this.enterRule(e4, 24, t5.RULE_contractPart);
                try {
                  switch (this.state = 341, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 20, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 332, this.stateVariableDeclaration();
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 333, this.usingForDeclaration();
                      break;
                    case 3:
                      this.enterOuterAlt(e4, 3), this.state = 334, this.structDefinition();
                      break;
                    case 4:
                      this.enterOuterAlt(e4, 4), this.state = 335, this.modifierDefinition();
                      break;
                    case 5:
                      this.enterOuterAlt(e4, 5), this.state = 336, this.functionDefinition();
                      break;
                    case 6:
                      this.enterOuterAlt(e4, 6), this.state = 337, this.eventDefinition();
                      break;
                    case 7:
                      this.enterOuterAlt(e4, 7), this.state = 338, this.enumDefinition();
                      break;
                    case 8:
                      this.enterOuterAlt(e4, 8), this.state = 339, this.customErrorDefinition();
                      break;
                    case 9:
                      this.enterOuterAlt(e4, 9), this.state = 340, this.typeDefinition();
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              stateVariableDeclaration() {
                let e4, i4 = new $2(this, this._ctx, this.state);
                this.enterRule(i4, 26, t5.RULE_stateVariableDeclaration);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 343, this.typeName(0), this.state = 353, this._errHandler.sync(this), e4 = this._input.LA(1); 0 == (e4 - 96 & -32) && 0 != (1 << e4 - 96 & 27377665); ) {
                    switch (this.state = 351, this._errHandler.sync(this), this._input.LA(1)) {
                      case 120:
                        this.state = 344, this.match(t5.PublicKeyword);
                        break;
                      case 117:
                        this.state = 345, this.match(t5.InternalKeyword);
                        break;
                      case 119:
                        this.state = 346, this.match(t5.PrivateKeyword);
                        break;
                      case 110:
                        this.state = 347, this.match(t5.ConstantKeyword);
                        break;
                      case 111:
                        this.state = 348, this.match(t5.TransientKeyword);
                        break;
                      case 112:
                        this.state = 349, this.match(t5.ImmutableKeyword);
                        break;
                      case 96:
                        this.state = 350, this.overrideSpecifier();
                        break;
                      default:
                        throw new y2(this);
                    }
                    this.state = 355, this._errHandler.sync(this), e4 = this._input.LA(1);
                  }
                  this.state = 356, this.identifier(), this.state = 359, this._errHandler.sync(this), e4 = this._input.LA(1), 11 === e4 && (this.state = 357, this.match(t5.T__10), this.state = 358, this.expression(0)), this.state = 361, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              fileLevelConstant() {
                let e4 = new j(this, this._ctx, this.state);
                this.enterRule(e4, 28, t5.RULE_fileLevelConstant);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 363, this.typeName(0), this.state = 364, this.match(t5.ConstantKeyword), this.state = 365, this.identifier(), this.state = 366, this.match(t5.T__10), this.state = 367, this.expression(0), this.state = 368, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              customErrorDefinition() {
                let e4 = new G2(this, this._ctx, this.state);
                this.enterRule(e4, 30, t5.RULE_customErrorDefinition);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 370, this.match(t5.T__24), this.state = 371, this.identifier(), this.state = 372, this.parameterList(), this.state = 373, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              typeDefinition() {
                let e4 = new z2(this, this._ctx, this.state);
                this.enterRule(e4, 32, t5.RULE_typeDefinition);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 375, this.match(t5.TypeKeyword), this.state = 376, this.identifier(), this.state = 377, this.match(t5.T__21), this.state = 378, this.elementaryTypeName(), this.state = 379, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              usingForDeclaration() {
                let e4, i4 = new q2(this, this._ctx, this.state);
                this.enterRule(i4, 34, t5.RULE_usingForDeclaration);
                try {
                  switch (this.enterOuterAlt(i4, 1), this.state = 381, this.match(t5.T__25), this.state = 382, this.usingForObject(), this.state = 383, this.match(t5.T__26), this.state = 386, this._errHandler.sync(this), this._input.LA(1)) {
                    case 3:
                      this.state = 384, this.match(t5.T__2);
                      break;
                    case 14:
                    case 25:
                    case 38:
                    case 44:
                    case 46:
                    case 50:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 95:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 114:
                    case 118:
                    case 125:
                    case 126:
                    case 128:
                    case 129:
                      this.state = 385, this.typeName(0);
                      break;
                    default:
                      throw new y2(this);
                  }
                  this.state = 389, this._errHandler.sync(this), e4 = this._input.LA(1), 125 === e4 && (this.state = 388, this.match(t5.GlobalKeyword)), this.state = 391, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              usingForObject() {
                let e4, i4 = new W2(this, this._ctx, this.state);
                this.enterRule(i4, 36, t5.RULE_usingForObject);
                try {
                  switch (this.state = 405, this._errHandler.sync(this), this._input.LA(1)) {
                    case 14:
                    case 25:
                    case 44:
                    case 50:
                    case 62:
                    case 95:
                    case 114:
                    case 118:
                    case 125:
                    case 126:
                    case 128:
                    case 129:
                      this.enterOuterAlt(i4, 1), this.state = 393, this.userDefinedTypeName();
                      break;
                    case 15:
                      for (this.enterOuterAlt(i4, 2), this.state = 394, this.match(t5.T__14), this.state = 395, this.usingForObjectDirective(), this.state = 400, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 396, this.match(t5.T__15), this.state = 397, this.usingForObjectDirective(), this.state = 402, this._errHandler.sync(this), e4 = this._input.LA(1);
                      this.state = 403, this.match(t5.T__16);
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              usingForObjectDirective() {
                let e4, i4 = new Y2(this, this._ctx, this.state);
                this.enterRule(i4, 38, t5.RULE_usingForObjectDirective);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 407, this.userDefinedTypeName(), this.state = 410, this._errHandler.sync(this), e4 = this._input.LA(1), 12 === e4 && (this.state = 408, this.match(t5.T__11), this.state = 409, this.userDefinableOperators());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              userDefinableOperators() {
                let e4, i4 = new X(this, this._ctx, this.state);
                this.enterRule(i4, 40, t5.RULE_userDefinableOperators);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 412, e4 = this._input.LA(1), 0 == (-32 & e4) && 0 != (1 << e4 & 4026533864) || 0 == (e4 - 32 & -32) && 0 != (1 << e4 - 32 & 15) ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              structDefinition() {
                let e4, i4 = new J2(this, this._ctx, this.state);
                this.enterRule(i4, 42, t5.RULE_structDefinition);
                try {
                  if (this.enterOuterAlt(i4, 1), this.state = 414, this.match(t5.T__35), this.state = 415, this.identifier(), this.state = 416, this.match(t5.T__14), this.state = 427, this._errHandler.sync(this), e4 = this._input.LA(1), 14 === e4 || 25 === e4 || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 520098113) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138493) || 128 === e4 || 129 === e4) for (this.state = 417, this.variableDeclaration(), this.state = 418, this.match(t5.T__1), this.state = 424, this._errHandler.sync(this), e4 = this._input.LA(1); 14 === e4 || 25 === e4 || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 520098113) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138493) || 128 === e4 || 129 === e4; ) this.state = 419, this.variableDeclaration(), this.state = 420, this.match(t5.T__1), this.state = 426, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 429, this.match(t5.T__16);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              modifierDefinition() {
                let e4, i4 = new Q2(this, this._ctx, this.state);
                this.enterRule(i4, 44, t5.RULE_modifierDefinition);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 431, this.match(t5.T__36), this.state = 432, this.identifier(), this.state = 434, this._errHandler.sync(this), e4 = this._input.LA(1), 23 === e4 && (this.state = 433, this.parameterList()), this.state = 440, this._errHandler.sync(this), e4 = this._input.LA(1); 96 === e4 || 121 === e4; ) {
                    switch (this.state = 438, this._errHandler.sync(this), this._input.LA(1)) {
                      case 121:
                        this.state = 436, this.match(t5.VirtualKeyword);
                        break;
                      case 96:
                        this.state = 437, this.overrideSpecifier();
                        break;
                      default:
                        throw new y2(this);
                    }
                    this.state = 442, this._errHandler.sync(this), e4 = this._input.LA(1);
                  }
                  switch (this.state = 445, this._errHandler.sync(this), this._input.LA(1)) {
                    case 2:
                      this.state = 443, this.match(t5.T__1);
                      break;
                    case 15:
                      this.state = 444, this.block();
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              modifierInvocation() {
                let e4, i4 = new Z2(this, this._ctx, this.state);
                this.enterRule(i4, 46, t5.RULE_modifierInvocation);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 447, this.identifier(), this.state = 453, this._errHandler.sync(this), e4 = this._input.LA(1), 23 === e4 && (this.state = 448, this.match(t5.T__22), this.state = 450, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) && (this.state = 449, this.expressionList()), this.state = 452, this.match(t5.T__23));
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              functionDefinition() {
                let e4, i4 = new tt2(this, this._ctx, this.state);
                this.enterRule(i4, 48, t5.RULE_functionDefinition);
                try {
                  switch (this.enterOuterAlt(i4, 1), this.state = 455, this.functionDescriptor(), this.state = 456, this.parameterList(), this.state = 457, this.modifierList(), this.state = 459, this._errHandler.sync(this), e4 = this._input.LA(1), 39 === e4 && (this.state = 458, this.returnParameters()), this.state = 463, this._errHandler.sync(this), this._input.LA(1)) {
                    case 2:
                      this.state = 461, this.match(t5.T__1);
                      break;
                    case 15:
                      this.state = 462, this.block();
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              functionDescriptor() {
                let e4, i4 = new et2(this, this._ctx, this.state);
                this.enterRule(i4, 50, t5.RULE_functionDescriptor);
                try {
                  switch (this.state = 472, this._errHandler.sync(this), this._input.LA(1)) {
                    case 38:
                      this.enterOuterAlt(i4, 1), this.state = 465, this.match(t5.T__37), this.state = 467, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 466, this.identifier());
                      break;
                    case 126:
                      this.enterOuterAlt(i4, 2), this.state = 469, this.match(t5.ConstructorKeyword);
                      break;
                    case 127:
                      this.enterOuterAlt(i4, 3), this.state = 470, this.match(t5.FallbackKeyword);
                      break;
                    case 128:
                      this.enterOuterAlt(i4, 4), this.state = 471, this.match(t5.ReceiveKeyword);
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              returnParameters() {
                let e4 = new it2(this, this._ctx, this.state);
                this.enterRule(e4, 52, t5.RULE_returnParameters);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 474, this.match(t5.T__38), this.state = 475, this.parameterList();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              modifierList() {
                let e4, i4 = new st2(this, this._ctx, this.state);
                this.enterRule(i4, 54, t5.RULE_modifierList);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 487, this._errHandler.sync(this), e4 = this._input.LA(1); 14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 4023943171) || 128 === e4 || 129 === e4; ) {
                    switch (this.state = 485, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 41, this._ctx)) {
                      case 1:
                        this.state = 477, this.match(t5.ExternalKeyword);
                        break;
                      case 2:
                        this.state = 478, this.match(t5.PublicKeyword);
                        break;
                      case 3:
                        this.state = 479, this.match(t5.InternalKeyword);
                        break;
                      case 4:
                        this.state = 480, this.match(t5.PrivateKeyword);
                        break;
                      case 5:
                        this.state = 481, this.match(t5.VirtualKeyword);
                        break;
                      case 6:
                        this.state = 482, this.stateMutability();
                        break;
                      case 7:
                        this.state = 483, this.modifierInvocation();
                        break;
                      case 8:
                        this.state = 484, this.overrideSpecifier();
                    }
                    this.state = 489, this._errHandler.sync(this), e4 = this._input.LA(1);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              eventDefinition() {
                let e4, i4 = new rt2(this, this._ctx, this.state);
                this.enterRule(i4, 56, t5.RULE_eventDefinition);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 490, this.match(t5.T__39), this.state = 491, this.identifier(), this.state = 492, this.eventParameterList(), this.state = 494, this._errHandler.sync(this), e4 = this._input.LA(1), 108 === e4 && (this.state = 493, this.match(t5.AnonymousKeyword)), this.state = 496, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              enumValue() {
                let e4 = new nt2(this, this._ctx, this.state);
                this.enterRule(e4, 58, t5.RULE_enumValue);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 498, this.identifier();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              enumDefinition() {
                let e4, i4 = new at2(this, this._ctx, this.state);
                this.enterRule(i4, 60, t5.RULE_enumDefinition);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 500, this.match(t5.T__40), this.state = 501, this.identifier(), this.state = 502, this.match(t5.T__14), this.state = 504, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 503, this.enumValue()), this.state = 510, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 506, this.match(t5.T__15), this.state = 507, this.enumValue(), this.state = 512, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 513, this.match(t5.T__16);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              parameterList() {
                let e4, i4 = new ot2(this, this._ctx, this.state);
                this.enterRule(i4, 62, t5.RULE_parameterList);
                try {
                  if (this.enterOuterAlt(i4, 1), this.state = 515, this.match(t5.T__22), this.state = 524, this._errHandler.sync(this), e4 = this._input.LA(1), 14 === e4 || 25 === e4 || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 520098113) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138493) || 128 === e4 || 129 === e4) for (this.state = 516, this.parameter(), this.state = 521, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 517, this.match(t5.T__15), this.state = 518, this.parameter(), this.state = 523, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 526, this.match(t5.T__23);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              parameter() {
                let e4, i4 = new lt2(this, this._ctx, this.state);
                this.enterRule(i4, 64, t5.RULE_parameter);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 528, this.typeName(0), this.state = 530, this._errHandler.sync(this), 1 === this._interp.adaptivePredict(this._input, 48, this._ctx) && (this.state = 529, this.storageLocation()), this.state = 533, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 532, this.identifier());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              eventParameterList() {
                let e4, i4 = new ht2(this, this._ctx, this.state);
                this.enterRule(i4, 66, t5.RULE_eventParameterList);
                try {
                  if (this.enterOuterAlt(i4, 1), this.state = 535, this.match(t5.T__22), this.state = 544, this._errHandler.sync(this), e4 = this._input.LA(1), 14 === e4 || 25 === e4 || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 520098113) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138493) || 128 === e4 || 129 === e4) for (this.state = 536, this.eventParameter(), this.state = 541, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 537, this.match(t5.T__15), this.state = 538, this.eventParameter(), this.state = 543, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 546, this.match(t5.T__23);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              eventParameter() {
                let e4, i4 = new ct2(this, this._ctx, this.state);
                this.enterRule(i4, 68, t5.RULE_eventParameter);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 548, this.typeName(0), this.state = 550, this._errHandler.sync(this), e4 = this._input.LA(1), 116 === e4 && (this.state = 549, this.match(t5.IndexedKeyword)), this.state = 553, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 552, this.identifier());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              functionTypeParameterList() {
                let e4, i4 = new ut2(this, this._ctx, this.state);
                this.enterRule(i4, 70, t5.RULE_functionTypeParameterList);
                try {
                  if (this.enterOuterAlt(i4, 1), this.state = 555, this.match(t5.T__22), this.state = 564, this._errHandler.sync(this), e4 = this._input.LA(1), 14 === e4 || 25 === e4 || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 520098113) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138493) || 128 === e4 || 129 === e4) for (this.state = 556, this.functionTypeParameter(), this.state = 561, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 557, this.match(t5.T__15), this.state = 558, this.functionTypeParameter(), this.state = 563, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 566, this.match(t5.T__23);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              functionTypeParameter() {
                let e4, i4 = new pt2(this, this._ctx, this.state);
                this.enterRule(i4, 72, t5.RULE_functionTypeParameter);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 568, this.typeName(0), this.state = 570, this._errHandler.sync(this), e4 = this._input.LA(1), 0 == (e4 - 48 & -32) && 0 != (1 << e4 - 48 & 7) && (this.state = 569, this.storageLocation());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              variableDeclaration() {
                let e4 = new dt2(this, this._ctx, this.state);
                this.enterRule(e4, 74, t5.RULE_variableDeclaration);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 572, this.typeName(0), this.state = 574, this._errHandler.sync(this), 1 === this._interp.adaptivePredict(this._input, 57, this._ctx) && (this.state = 573, this.storageLocation()), this.state = 576, this.identifier();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              typeName(e4) {
                void 0 === e4 && (e4 = 0);
                let i4, s4 = this._ctx, r3 = this.state, n2 = new mt2(this, this._ctx, r3), a2 = n2;
                this.enterRecursionRule(n2, 76, t5.RULE_typeName, e4);
                try {
                  let e5;
                  switch (this.enterOuterAlt(n2, 1), this.state = 585, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 58, this._ctx)) {
                    case 1:
                      this.state = 579, this.elementaryTypeName();
                      break;
                    case 2:
                      this.state = 580, this.userDefinedTypeName();
                      break;
                    case 3:
                      this.state = 581, this.mapping();
                      break;
                    case 4:
                      this.state = 582, this.functionTypeName();
                      break;
                    case 5:
                      this.state = 583, this.match(t5.T__43), this.state = 584, this.match(t5.PayableKeyword);
                  }
                  for (this._ctx.stop = this._input.LT(-1), this.state = 595, this._errHandler.sync(this), e5 = this._interp.adaptivePredict(this._input, 60, this._ctx); 2 !== e5 && e5 !== h.INVALID_ALT_NUMBER; ) {
                    if (1 === e5) {
                      if (null != this._parseListeners && this.triggerExitRuleEvent(), a2 = n2, n2 = new mt2(this, s4, r3), this.pushNewRecursionContext(n2, 76, t5.RULE_typeName), this.state = 587, !this.precpred(this._ctx, 3)) throw this.createFailedPredicateException("this.precpred(this._ctx, 3)");
                      this.state = 588, this.match(t5.T__41), this.state = 590, this._errHandler.sync(this), i4 = this._input.LA(1), (0 == (-32 & i4) && 0 != (1 << i4 & 3263184960) || 0 == (i4 - 38 & -32) && 0 != (1 << i4 - 38 & 4278194513) || 0 == (i4 - 71 & -32) && 0 != (1 << i4 - 71 & 4244635651) || 0 == (i4 - 103 & -32) && 0 != (1 << i4 - 103 & 248547339)) && (this.state = 589, this.expression(0)), this.state = 592, this.match(t5.T__42);
                    }
                    this.state = 597, this._errHandler.sync(this), e5 = this._interp.adaptivePredict(this._input, 60, this._ctx);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  n2.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.unrollRecursionContexts(s4);
                }
                return n2;
              }
              userDefinedTypeName() {
                let e4 = new _t2(this, this._ctx, this.state);
                this.enterRule(e4, 78, t5.RULE_userDefinedTypeName);
                try {
                  let i4;
                  for (this.enterOuterAlt(e4, 1), this.state = 598, this.identifier(), this.state = 603, this._errHandler.sync(this), i4 = this._interp.adaptivePredict(this._input, 61, this._ctx); 2 !== i4 && i4 !== h.INVALID_ALT_NUMBER; ) 1 === i4 && (this.state = 599, this.match(t5.T__44), this.state = 600, this.identifier()), this.state = 605, this._errHandler.sync(this), i4 = this._interp.adaptivePredict(this._input, 61, this._ctx);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              mappingKey() {
                let e4 = new xt2(this, this._ctx, this.state);
                this.enterRule(e4, 80, t5.RULE_mappingKey);
                try {
                  switch (this.state = 608, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 62, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 606, this.elementaryTypeName();
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 607, this.userDefinedTypeName();
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              mapping() {
                let e4, i4 = new ft2(this, this._ctx, this.state);
                this.enterRule(i4, 82, t5.RULE_mapping);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 610, this.match(t5.T__45), this.state = 611, this.match(t5.T__22), this.state = 612, this.mappingKey(), this.state = 614, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 613, this.mappingKeyName()), this.state = 616, this.match(t5.T__46), this.state = 617, this.typeName(0), this.state = 619, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 618, this.mappingValueName()), this.state = 621, this.match(t5.T__23);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              mappingKeyName() {
                let e4 = new yt(this, this._ctx, this.state);
                this.enterRule(e4, 84, t5.RULE_mappingKeyName);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 623, this.identifier();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              mappingValueName() {
                let e4 = new gt2(this, this._ctx, this.state);
                this.enterRule(e4, 86, t5.RULE_mappingValueName);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 625, this.identifier();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              functionTypeName() {
                let e4 = new Tt2(this, this._ctx, this.state);
                this.enterRule(e4, 88, t5.RULE_functionTypeName);
                try {
                  let i4;
                  for (this.enterOuterAlt(e4, 1), this.state = 627, this.match(t5.T__37), this.state = 628, this.functionTypeParameterList(), this.state = 634, this._errHandler.sync(this), i4 = this._interp.adaptivePredict(this._input, 66, this._ctx); 2 !== i4 && i4 !== h.INVALID_ALT_NUMBER; ) {
                    if (1 === i4) switch (this.state = 632, this._errHandler.sync(this), this._input.LA(1)) {
                      case 117:
                        this.state = 629, this.match(t5.InternalKeyword);
                        break;
                      case 115:
                        this.state = 630, this.match(t5.ExternalKeyword);
                        break;
                      case 110:
                      case 118:
                      case 122:
                      case 124:
                        this.state = 631, this.stateMutability();
                        break;
                      default:
                        throw new y2(this);
                    }
                    this.state = 636, this._errHandler.sync(this), i4 = this._interp.adaptivePredict(this._input, 66, this._ctx);
                  }
                  this.state = 639, this._errHandler.sync(this), 1 === this._interp.adaptivePredict(this._input, 67, this._ctx) && (this.state = 637, this.match(t5.T__38), this.state = 638, this.functionTypeParameterList());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              storageLocation() {
                let e4, i4 = new Et2(this, this._ctx, this.state);
                this.enterRule(i4, 90, t5.RULE_storageLocation);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 641, e4 = this._input.LA(1), 0 != (e4 - 48 & -32) || 0 == (1 << e4 - 48 & 7) ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              stateMutability() {
                let e4, i4 = new Rt2(this, this._ctx, this.state);
                this.enterRule(i4, 92, t5.RULE_stateMutability);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 643, e4 = this._input.LA(1), 0 != (e4 - 110 & -32) || 0 == (1 << e4 - 110 & 20737) ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              block() {
                let e4, i4 = new vt2(this, this._ctx, this.state);
                this.enterRule(i4, 94, t5.RULE_block);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 645, this.match(t5.T__14), this.state = 649, this._errHandler.sync(this), e4 = this._input.LA(1); 0 == (-32 & e4) && 0 != (1 << e4 & 3397435456) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4294881617) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248548427); ) this.state = 646, this.statement(), this.state = 651, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 652, this.match(t5.T__16);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              statement() {
                let e4 = new bt2(this, this._ctx, this.state);
                this.enterRule(e4, 96, t5.RULE_statement);
                try {
                  switch (this.state = 669, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 69, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 654, this.ifStatement();
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 655, this.tryStatement();
                      break;
                    case 3:
                      this.enterOuterAlt(e4, 3), this.state = 656, this.whileStatement();
                      break;
                    case 4:
                      this.enterOuterAlt(e4, 4), this.state = 657, this.forStatement();
                      break;
                    case 5:
                      this.enterOuterAlt(e4, 5), this.state = 658, this.block();
                      break;
                    case 6:
                      this.enterOuterAlt(e4, 6), this.state = 659, this.inlineAssemblyStatement();
                      break;
                    case 7:
                      this.enterOuterAlt(e4, 7), this.state = 660, this.doWhileStatement();
                      break;
                    case 8:
                      this.enterOuterAlt(e4, 8), this.state = 661, this.continueStatement();
                      break;
                    case 9:
                      this.enterOuterAlt(e4, 9), this.state = 662, this.breakStatement();
                      break;
                    case 10:
                      this.enterOuterAlt(e4, 10), this.state = 663, this.returnStatement();
                      break;
                    case 11:
                      this.enterOuterAlt(e4, 11), this.state = 664, this.throwStatement();
                      break;
                    case 12:
                      this.enterOuterAlt(e4, 12), this.state = 665, this.emitStatement();
                      break;
                    case 13:
                      this.enterOuterAlt(e4, 13), this.state = 666, this.simpleStatement();
                      break;
                    case 14:
                      this.enterOuterAlt(e4, 14), this.state = 667, this.uncheckedStatement();
                      break;
                    case 15:
                      this.enterOuterAlt(e4, 15), this.state = 668, this.revertStatement();
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              expressionStatement() {
                let e4 = new Lt2(this, this._ctx, this.state);
                this.enterRule(e4, 98, t5.RULE_expressionStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 671, this.expression(0), this.state = 672, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              ifStatement() {
                let e4 = new St2(this, this._ctx, this.state);
                this.enterRule(e4, 100, t5.RULE_ifStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 674, this.match(t5.T__50), this.state = 675, this.match(t5.T__22), this.state = 676, this.expression(0), this.state = 677, this.match(t5.T__23), this.state = 678, this.statement(), this.state = 681, this._errHandler.sync(this), 1 === this._interp.adaptivePredict(this._input, 70, this._ctx) && (this.state = 679, this.match(t5.T__51), this.state = 680, this.statement());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              tryStatement() {
                let e4, i4 = new Ct2(this, this._ctx, this.state);
                this.enterRule(i4, 102, t5.RULE_tryStatement);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 683, this.match(t5.T__52), this.state = 684, this.expression(0), this.state = 686, this._errHandler.sync(this), e4 = this._input.LA(1), 39 === e4 && (this.state = 685, this.returnParameters()), this.state = 688, this.block(), this.state = 690, this._errHandler.sync(this), e4 = this._input.LA(1);
                  do {
                    this.state = 689, this.catchClause(), this.state = 692, this._errHandler.sync(this), e4 = this._input.LA(1);
                  } while (54 === e4);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              catchClause() {
                let e4, i4 = new At2(this, this._ctx, this.state);
                this.enterRule(i4, 104, t5.RULE_catchClause);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 694, this.match(t5.T__53), this.state = 699, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 41959424) || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 696, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 695, this.identifier()), this.state = 698, this.parameterList()), this.state = 701, this.block();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              whileStatement() {
                let e4 = new wt2(this, this._ctx, this.state);
                this.enterRule(e4, 106, t5.RULE_whileStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 703, this.match(t5.T__54), this.state = 704, this.match(t5.T__22), this.state = 705, this.expression(0), this.state = 706, this.match(t5.T__23), this.state = 707, this.statement();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              simpleStatement() {
                let e4 = new Nt2(this, this._ctx, this.state);
                this.enterRule(e4, 108, t5.RULE_simpleStatement);
                try {
                  switch (this.enterOuterAlt(e4, 1), this.state = 711, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 75, this._ctx)) {
                    case 1:
                      this.state = 709, this.variableDeclarationStatement();
                      break;
                    case 2:
                      this.state = 710, this.expressionStatement();
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              uncheckedStatement() {
                let e4 = new It2(this, this._ctx, this.state);
                this.enterRule(e4, 110, t5.RULE_uncheckedStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 713, this.match(t5.T__55), this.state = 714, this.block();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              forStatement() {
                let e4, i4 = new kt2(this, this._ctx, this.state);
                this.enterRule(i4, 112, t5.RULE_forStatement);
                try {
                  switch (this.enterOuterAlt(i4, 1), this.state = 716, this.match(t5.T__26), this.state = 717, this.match(t5.T__22), this.state = 720, this._errHandler.sync(this), this._input.LA(1)) {
                    case 6:
                    case 14:
                    case 23:
                    case 25:
                    case 30:
                    case 31:
                    case 38:
                    case 42:
                    case 44:
                    case 46:
                    case 50:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 71:
                    case 72:
                    case 95:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 106:
                    case 114:
                    case 118:
                    case 123:
                    case 125:
                    case 126:
                    case 128:
                    case 129:
                    case 130:
                      this.state = 718, this.simpleStatement();
                      break;
                    case 2:
                      this.state = 719, this.match(t5.T__1);
                      break;
                    default:
                      throw new y2(this);
                  }
                  switch (this.state = 724, this._errHandler.sync(this), this._input.LA(1)) {
                    case 6:
                    case 14:
                    case 23:
                    case 25:
                    case 30:
                    case 31:
                    case 38:
                    case 42:
                    case 44:
                    case 46:
                    case 50:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 71:
                    case 72:
                    case 95:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 106:
                    case 114:
                    case 118:
                    case 123:
                    case 125:
                    case 126:
                    case 128:
                    case 129:
                    case 130:
                      this.state = 722, this.expressionStatement();
                      break;
                    case 2:
                      this.state = 723, this.match(t5.T__1);
                      break;
                    default:
                      throw new y2(this);
                  }
                  this.state = 727, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) && (this.state = 726, this.expression(0)), this.state = 729, this.match(t5.T__23), this.state = 730, this.statement();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              inlineAssemblyStatement() {
                let e4, i4 = new Dt2(this, this._ctx, this.state);
                this.enterRule(i4, 114, t5.RULE_inlineAssemblyStatement);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 732, this.match(t5.T__56), this.state = 734, this._errHandler.sync(this), e4 = this._input.LA(1), 130 === e4 && (this.state = 733, this.match(t5.StringLiteralFragment)), this.state = 740, this._errHandler.sync(this), e4 = this._input.LA(1), 23 === e4 && (this.state = 736, this.match(t5.T__22), this.state = 737, this.inlineAssemblyStatementFlag(), this.state = 738, this.match(t5.T__23)), this.state = 742, this.assemblyBlock();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              inlineAssemblyStatementFlag() {
                let e4 = new Ot2(this, this._ctx, this.state);
                this.enterRule(e4, 116, t5.RULE_inlineAssemblyStatementFlag);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 744, this.stringLiteral();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              doWhileStatement() {
                let e4 = new Pt2(this, this._ctx, this.state);
                this.enterRule(e4, 118, t5.RULE_doWhileStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 746, this.match(t5.T__57), this.state = 747, this.statement(), this.state = 748, this.match(t5.T__54), this.state = 749, this.match(t5.T__22), this.state = 750, this.expression(0), this.state = 751, this.match(t5.T__23), this.state = 752, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              continueStatement() {
                let e4 = new Ft2(this, this._ctx, this.state);
                this.enterRule(e4, 120, t5.RULE_continueStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 754, this.match(t5.ContinueKeyword), this.state = 755, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              breakStatement() {
                let e4 = new Ut2(this, this._ctx, this.state);
                this.enterRule(e4, 122, t5.RULE_breakStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 757, this.match(t5.BreakKeyword), this.state = 758, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              returnStatement() {
                let e4, i4 = new Ht2(this, this._ctx, this.state);
                this.enterRule(i4, 124, t5.RULE_returnStatement);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 760, this.match(t5.T__58), this.state = 762, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) && (this.state = 761, this.expression(0)), this.state = 764, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              throwStatement() {
                let e4 = new Mt2(this, this._ctx, this.state);
                this.enterRule(e4, 126, t5.RULE_throwStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 766, this.match(t5.T__59), this.state = 767, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              emitStatement() {
                let e4 = new Kt2(this, this._ctx, this.state);
                this.enterRule(e4, 128, t5.RULE_emitStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 769, this.match(t5.T__60), this.state = 770, this.functionCall(), this.state = 771, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              revertStatement() {
                let e4 = new Vt2(this, this._ctx, this.state);
                this.enterRule(e4, 130, t5.RULE_revertStatement);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 773, this.match(t5.T__61), this.state = 774, this.functionCall(), this.state = 775, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              variableDeclarationStatement() {
                let e4, i4 = new Bt2(this, this._ctx, this.state);
                this.enterRule(i4, 132, t5.RULE_variableDeclarationStatement);
                try {
                  switch (this.enterOuterAlt(i4, 1), this.state = 784, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 82, this._ctx)) {
                    case 1:
                      this.state = 777, this.match(t5.T__62), this.state = 778, this.identifierList();
                      break;
                    case 2:
                      this.state = 779, this.variableDeclaration();
                      break;
                    case 3:
                      this.state = 780, this.match(t5.T__22), this.state = 781, this.variableDeclarationList(), this.state = 782, this.match(t5.T__23);
                  }
                  this.state = 788, this._errHandler.sync(this), e4 = this._input.LA(1), 11 === e4 && (this.state = 786, this.match(t5.T__10), this.state = 787, this.expression(0)), this.state = 790, this.match(t5.T__1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              variableDeclarationList() {
                let e4, i4 = new $t2(this, this._ctx, this.state);
                this.enterRule(i4, 134, t5.RULE_variableDeclarationList);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 793, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 520098113) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138493) || 128 === e4 || 129 === e4) && (this.state = 792, this.variableDeclaration()), this.state = 801, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 795, this.match(t5.T__15), this.state = 797, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 520098113) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138493) || 128 === e4 || 129 === e4) && (this.state = 796, this.variableDeclaration()), this.state = 803, this._errHandler.sync(this), e4 = this._input.LA(1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              identifierList() {
                let e4, i4 = new jt2(this, this._ctx, this.state);
                this.enterRule(i4, 136, t5.RULE_identifierList);
                try {
                  let s4;
                  for (this.enterOuterAlt(i4, 1), this.state = 804, this.match(t5.T__22), this.state = 811, this._errHandler.sync(this), s4 = this._interp.adaptivePredict(this._input, 88, this._ctx); 2 !== s4 && s4 !== h.INVALID_ALT_NUMBER; ) 1 === s4 && (this.state = 806, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 805, this.identifier()), this.state = 808, this.match(t5.T__15)), this.state = 813, this._errHandler.sync(this), s4 = this._interp.adaptivePredict(this._input, 88, this._ctx);
                  this.state = 815, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 814, this.identifier()), this.state = 817, this.match(t5.T__23);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              elementaryTypeName() {
                let e4, i4 = new Gt2(this, this._ctx, this.state);
                this.enterRule(i4, 138, t5.RULE_elementaryTypeName);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 819, e4 = this._input.LA(1), 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 7864321) || 0 == (e4 - 97 & -32) && 0 != (1 << e4 - 97 & 31) ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              expression(e4) {
                void 0 === e4 && (e4 = 0);
                let i4, s4 = this._ctx, r3 = this.state, n2 = new zt2(this, this._ctx, r3), a2 = n2, o2 = 140;
                this.enterRecursionRule(n2, 140, t5.RULE_expression, e4);
                try {
                  let e5;
                  switch (this.enterOuterAlt(n2, 1), this.state = 839, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 90, this._ctx)) {
                    case 1:
                      this.state = 822, this.match(t5.T__68), this.state = 823, this.typeName(0);
                      break;
                    case 2:
                      this.state = 824, this.match(t5.T__22), this.state = 825, this.expression(0), this.state = 826, this.match(t5.T__23);
                      break;
                    case 3:
                      this.state = 828, i4 = this._input.LA(1), 67 !== i4 && 68 !== i4 ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 829, this.expression(19);
                      break;
                    case 4:
                      this.state = 830, i4 = this._input.LA(1), 30 !== i4 && 31 !== i4 ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 831, this.expression(18);
                      break;
                    case 5:
                      this.state = 832, this.match(t5.T__70), this.state = 833, this.expression(17);
                      break;
                    case 6:
                      this.state = 834, this.match(t5.T__71), this.state = 835, this.expression(16);
                      break;
                    case 7:
                      this.state = 836, this.match(t5.T__5), this.state = 837, this.expression(15);
                      break;
                    case 8:
                      this.state = 838, this.primaryExpression();
                  }
                  for (this._ctx.stop = this._input.LT(-1), this.state = 915, this._errHandler.sync(this), e5 = this._interp.adaptivePredict(this._input, 94, this._ctx); 2 !== e5 && e5 !== h.INVALID_ALT_NUMBER; ) {
                    if (1 === e5) switch (null != this._parseListeners && this.triggerExitRuleEvent(), a2 = n2, this.state = 913, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 93, this._ctx)) {
                      case 1:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 841, !this.precpred(this._ctx, 14)) throw this.createFailedPredicateException("this.precpred(this._ctx, 14)");
                        this.state = 842, this.match(t5.T__72), this.state = 843, this.expression(14);
                        break;
                      case 2:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 844, !this.precpred(this._ctx, 13)) throw this.createFailedPredicateException("this.precpred(this._ctx, 13)");
                        this.state = 845, i4 = this._input.LA(1), 0 != (i4 - 3 & -32) || 0 == (1 << i4 - 3 & 1610612737) ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 846, this.expression(14);
                        break;
                      case 3:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 847, !this.precpred(this._ctx, 12)) throw this.createFailedPredicateException("this.precpred(this._ctx, 12)");
                        this.state = 848, i4 = this._input.LA(1), 30 !== i4 && 31 !== i4 ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 849, this.expression(13);
                        break;
                      case 4:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 850, !this.precpred(this._ctx, 11)) throw this.createFailedPredicateException("this.precpred(this._ctx, 11)");
                        this.state = 851, i4 = this._input.LA(1), 74 !== i4 && 75 !== i4 ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 852, this.expression(12);
                        break;
                      case 5:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 853, !this.precpred(this._ctx, 10)) throw this.createFailedPredicateException("this.precpred(this._ctx, 10)");
                        this.state = 854, this.match(t5.T__28), this.state = 855, this.expression(11);
                        break;
                      case 6:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 856, !this.precpred(this._ctx, 9)) throw this.createFailedPredicateException("this.precpred(this._ctx, 9)");
                        this.state = 857, this.match(t5.T__4), this.state = 858, this.expression(10);
                        break;
                      case 7:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 859, !this.precpred(this._ctx, 8)) throw this.createFailedPredicateException("this.precpred(this._ctx, 8)");
                        this.state = 860, this.match(t5.T__27), this.state = 861, this.expression(9);
                        break;
                      case 8:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 862, !this.precpred(this._ctx, 7)) throw this.createFailedPredicateException("this.precpred(this._ctx, 7)");
                        this.state = 863, i4 = this._input.LA(1), 0 != (-32 & i4) || 0 == (1 << i4 & 1920) ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 864, this.expression(8);
                        break;
                      case 9:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 865, !this.precpred(this._ctx, 6)) throw this.createFailedPredicateException("this.precpred(this._ctx, 6)");
                        this.state = 866, i4 = this._input.LA(1), 34 !== i4 && 35 !== i4 ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 867, this.expression(7);
                        break;
                      case 10:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 868, !this.precpred(this._ctx, 5)) throw this.createFailedPredicateException("this.precpred(this._ctx, 5)");
                        this.state = 869, this.match(t5.T__75), this.state = 870, this.expression(6);
                        break;
                      case 11:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 871, !this.precpred(this._ctx, 4)) throw this.createFailedPredicateException("this.precpred(this._ctx, 4)");
                        this.state = 872, this.match(t5.T__3), this.state = 873, this.expression(5);
                        break;
                      case 12:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 874, !this.precpred(this._ctx, 3)) throw this.createFailedPredicateException("this.precpred(this._ctx, 3)");
                        this.state = 875, this.match(t5.T__76), this.state = 876, this.expression(0), this.state = 877, this.match(t5.T__69), this.state = 878, this.expression(3);
                        break;
                      case 13:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 880, !this.precpred(this._ctx, 2)) throw this.createFailedPredicateException("this.precpred(this._ctx, 2)");
                        this.state = 881, i4 = this._input.LA(1), 11 === i4 || 0 == (i4 - 78 & -32) && 0 != (1 << i4 - 78 & 1023) ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this), this.state = 882, this.expression(3);
                        break;
                      case 14:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 883, !this.precpred(this._ctx, 27)) throw this.createFailedPredicateException("this.precpred(this._ctx, 27)");
                        this.state = 884, i4 = this._input.LA(1), 67 !== i4 && 68 !== i4 ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume());
                        break;
                      case 15:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 885, !this.precpred(this._ctx, 25)) throw this.createFailedPredicateException("this.precpred(this._ctx, 25)");
                        this.state = 886, this.match(t5.T__41), this.state = 887, this.expression(0), this.state = 888, this.match(t5.T__42);
                        break;
                      case 16:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 890, !this.precpred(this._ctx, 24)) throw this.createFailedPredicateException("this.precpred(this._ctx, 24)");
                        this.state = 891, this.match(t5.T__41), this.state = 893, this._errHandler.sync(this), i4 = this._input.LA(1), (0 == (-32 & i4) && 0 != (1 << i4 & 3263184960) || 0 == (i4 - 38 & -32) && 0 != (1 << i4 - 38 & 4278194513) || 0 == (i4 - 71 & -32) && 0 != (1 << i4 - 71 & 4244635651) || 0 == (i4 - 103 & -32) && 0 != (1 << i4 - 103 & 248547339)) && (this.state = 892, this.expression(0)), this.state = 895, this.match(t5.T__69), this.state = 897, this._errHandler.sync(this), i4 = this._input.LA(1), (0 == (-32 & i4) && 0 != (1 << i4 & 3263184960) || 0 == (i4 - 38 & -32) && 0 != (1 << i4 - 38 & 4278194513) || 0 == (i4 - 71 & -32) && 0 != (1 << i4 - 71 & 4244635651) || 0 == (i4 - 103 & -32) && 0 != (1 << i4 - 103 & 248547339)) && (this.state = 896, this.expression(0)), this.state = 899, this.match(t5.T__42);
                        break;
                      case 17:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 900, !this.precpred(this._ctx, 23)) throw this.createFailedPredicateException("this.precpred(this._ctx, 23)");
                        this.state = 901, this.match(t5.T__44), this.state = 902, this.identifier();
                        break;
                      case 18:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 903, !this.precpred(this._ctx, 22)) throw this.createFailedPredicateException("this.precpred(this._ctx, 22)");
                        this.state = 904, this.match(t5.T__14), this.state = 905, this.nameValueList(), this.state = 906, this.match(t5.T__16);
                        break;
                      case 19:
                        if (n2 = new zt2(this, s4, r3), this.pushNewRecursionContext(n2, o2, t5.RULE_expression), this.state = 908, !this.precpred(this._ctx, 21)) throw this.createFailedPredicateException("this.precpred(this._ctx, 21)");
                        this.state = 909, this.match(t5.T__22), this.state = 910, this.functionCallArguments(), this.state = 911, this.match(t5.T__23);
                    }
                    this.state = 917, this._errHandler.sync(this), e5 = this._interp.adaptivePredict(this._input, 94, this._ctx);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  n2.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.unrollRecursionContexts(s4);
                }
                return n2;
              }
              primaryExpression() {
                let e4 = new qt2(this, this._ctx, this.state);
                this.enterRule(e4, 142, t5.RULE_primaryExpression);
                try {
                  switch (this.state = 927, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 95, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 918, this.match(t5.BooleanLiteral);
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 919, this.numberLiteral();
                      break;
                    case 3:
                      this.enterOuterAlt(e4, 3), this.state = 920, this.hexLiteral();
                      break;
                    case 4:
                      this.enterOuterAlt(e4, 4), this.state = 921, this.stringLiteral();
                      break;
                    case 5:
                      this.enterOuterAlt(e4, 5), this.state = 922, this.identifier();
                      break;
                    case 6:
                      this.enterOuterAlt(e4, 6), this.state = 923, this.match(t5.TypeKeyword);
                      break;
                    case 7:
                      this.enterOuterAlt(e4, 7), this.state = 924, this.match(t5.PayableKeyword);
                      break;
                    case 8:
                      this.enterOuterAlt(e4, 8), this.state = 925, this.tupleExpression();
                      break;
                    case 9:
                      this.enterOuterAlt(e4, 9), this.state = 926, this.typeName(0);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              expressionList() {
                let e4, i4 = new Wt2(this, this._ctx, this.state);
                this.enterRule(i4, 144, t5.RULE_expressionList);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 929, this.expression(0), this.state = 934, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 930, this.match(t5.T__15), this.state = 931, this.expression(0), this.state = 936, this._errHandler.sync(this), e4 = this._input.LA(1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              nameValueList() {
                let e4, i4 = new Yt2(this, this._ctx, this.state);
                this.enterRule(i4, 146, t5.RULE_nameValueList);
                try {
                  let s4;
                  for (this.enterOuterAlt(i4, 1), this.state = 937, this.nameValue(), this.state = 942, this._errHandler.sync(this), s4 = this._interp.adaptivePredict(this._input, 97, this._ctx); 2 !== s4 && s4 !== h.INVALID_ALT_NUMBER; ) 1 === s4 && (this.state = 938, this.match(t5.T__15), this.state = 939, this.nameValue()), this.state = 944, this._errHandler.sync(this), s4 = this._interp.adaptivePredict(this._input, 97, this._ctx);
                  this.state = 946, this._errHandler.sync(this), e4 = this._input.LA(1), 16 === e4 && (this.state = 945, this.match(t5.T__15));
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              nameValue() {
                let e4 = new Xt2(this, this._ctx, this.state);
                this.enterRule(e4, 148, t5.RULE_nameValue);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 948, this.identifier(), this.state = 949, this.match(t5.T__69), this.state = 950, this.expression(0);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              functionCallArguments() {
                let e4, i4 = new Jt2(this, this._ctx, this.state);
                this.enterRule(i4, 150, t5.RULE_functionCallArguments);
                try {
                  switch (this.state = 960, this._errHandler.sync(this), this._input.LA(1)) {
                    case 15:
                      this.enterOuterAlt(i4, 1), this.state = 952, this.match(t5.T__14), this.state = 954, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 953, this.nameValueList()), this.state = 956, this.match(t5.T__16);
                      break;
                    case 6:
                    case 14:
                    case 23:
                    case 24:
                    case 25:
                    case 30:
                    case 31:
                    case 38:
                    case 42:
                    case 44:
                    case 46:
                    case 50:
                    case 62:
                    case 63:
                    case 64:
                    case 65:
                    case 66:
                    case 67:
                    case 68:
                    case 69:
                    case 71:
                    case 72:
                    case 95:
                    case 97:
                    case 98:
                    case 99:
                    case 100:
                    case 101:
                    case 102:
                    case 103:
                    case 104:
                    case 106:
                    case 114:
                    case 118:
                    case 123:
                    case 125:
                    case 126:
                    case 128:
                    case 129:
                    case 130:
                      this.enterOuterAlt(i4, 2), this.state = 958, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) && (this.state = 957, this.expressionList());
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              functionCall() {
                let e4 = new Qt2(this, this._ctx, this.state);
                this.enterRule(e4, 152, t5.RULE_functionCall);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 962, this.expression(0), this.state = 963, this.match(t5.T__22), this.state = 964, this.functionCallArguments(), this.state = 965, this.match(t5.T__23);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyBlock() {
                let e4, i4 = new Zt2(this, this._ctx, this.state);
                this.enterRule(i4, 154, t5.RULE_assemblyBlock);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 967, this.match(t5.T__14), this.state = 971, this._errHandler.sync(this), e4 = this._input.LA(1); 0 == (-32 & e4) && 0 != (1 << e4 & 176209920) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 287322177) || 0 == (e4 - 88 & -32) && 0 != (1 << e4 - 88 & 1176879241) || 0 == (e4 - 125 & -32) && 0 != (1 << e4 - 125 & 59); ) this.state = 968, this.assemblyItem(), this.state = 973, this._errHandler.sync(this), e4 = this._input.LA(1);
                  this.state = 974, this.match(t5.T__16);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              assemblyItem() {
                let e4 = new te2(this, this._ctx, this.state);
                this.enterRule(e4, 156, t5.RULE_assemblyItem);
                try {
                  switch (this.state = 993, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 103, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 976, this.identifier();
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 977, this.assemblyBlock();
                      break;
                    case 3:
                      this.enterOuterAlt(e4, 3), this.state = 978, this.assemblyExpression();
                      break;
                    case 4:
                      this.enterOuterAlt(e4, 4), this.state = 979, this.assemblyLocalDefinition();
                      break;
                    case 5:
                      this.enterOuterAlt(e4, 5), this.state = 980, this.assemblyAssignment();
                      break;
                    case 6:
                      this.enterOuterAlt(e4, 6), this.state = 981, this.assemblyStackAssignment();
                      break;
                    case 7:
                      this.enterOuterAlt(e4, 7), this.state = 982, this.labelDefinition();
                      break;
                    case 8:
                      this.enterOuterAlt(e4, 8), this.state = 983, this.assemblySwitch();
                      break;
                    case 9:
                      this.enterOuterAlt(e4, 9), this.state = 984, this.assemblyFunctionDefinition();
                      break;
                    case 10:
                      this.enterOuterAlt(e4, 10), this.state = 985, this.assemblyFor();
                      break;
                    case 11:
                      this.enterOuterAlt(e4, 11), this.state = 986, this.assemblyIf();
                      break;
                    case 12:
                      this.enterOuterAlt(e4, 12), this.state = 987, this.match(t5.BreakKeyword);
                      break;
                    case 13:
                      this.enterOuterAlt(e4, 13), this.state = 988, this.match(t5.ContinueKeyword);
                      break;
                    case 14:
                      this.enterOuterAlt(e4, 14), this.state = 989, this.match(t5.LeaveKeyword);
                      break;
                    case 15:
                      this.enterOuterAlt(e4, 15), this.state = 990, this.numberLiteral();
                      break;
                    case 16:
                      this.enterOuterAlt(e4, 16), this.state = 991, this.stringLiteral();
                      break;
                    case 17:
                      this.enterOuterAlt(e4, 17), this.state = 992, this.hexLiteral();
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyExpression() {
                let e4 = new ee2(this, this._ctx, this.state);
                this.enterRule(e4, 158, t5.RULE_assemblyExpression);
                try {
                  switch (this.state = 998, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 104, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 995, this.assemblyCall();
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 996, this.assemblyLiteral();
                      break;
                    case 3:
                      this.enterOuterAlt(e4, 3), this.state = 997, this.assemblyMember();
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyMember() {
                let e4 = new ie2(this, this._ctx, this.state);
                this.enterRule(e4, 160, t5.RULE_assemblyMember);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 1e3, this.identifier(), this.state = 1001, this.match(t5.T__44), this.state = 1002, this.identifier();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyCall() {
                let e4, i4 = new se2(this, this._ctx, this.state);
                this.enterRule(i4, 162, t5.RULE_assemblyCall);
                try {
                  switch (this.enterOuterAlt(i4, 1), this.state = 1008, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 105, this._ctx)) {
                    case 1:
                      this.state = 1004, this.match(t5.T__58);
                      break;
                    case 2:
                      this.state = 1005, this.match(t5.T__43);
                      break;
                    case 3:
                      this.state = 1006, this.match(t5.T__65);
                      break;
                    case 4:
                      this.state = 1007, this.identifier();
                  }
                  if (this.state = 1022, this._errHandler.sync(this), 1 === this._interp.adaptivePredict(this._input, 108, this._ctx)) {
                    for (this.state = 1010, this.match(t5.T__22), this.state = 1012, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 4489281) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230141313) || 0 == (e4 - 128 & -32) && 0 != (1 << e4 - 128 & 7)) && (this.state = 1011, this.assemblyExpression()), this.state = 1018, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 1014, this.match(t5.T__15), this.state = 1015, this.assemblyExpression(), this.state = 1020, this._errHandler.sync(this), e4 = this._input.LA(1);
                    this.state = 1021, this.match(t5.T__23);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              assemblyLocalDefinition() {
                let e4, i4 = new re2(this, this._ctx, this.state);
                this.enterRule(i4, 164, t5.RULE_assemblyLocalDefinition);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 1024, this.match(t5.T__87), this.state = 1025, this.assemblyIdentifierOrList(), this.state = 1028, this._errHandler.sync(this), e4 = this._input.LA(1), 89 === e4 && (this.state = 1026, this.match(t5.T__88), this.state = 1027, this.assemblyExpression());
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              assemblyAssignment() {
                let e4 = new ne2(this, this._ctx, this.state);
                this.enterRule(e4, 166, t5.RULE_assemblyAssignment);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 1030, this.assemblyIdentifierOrList(), this.state = 1031, this.match(t5.T__88), this.state = 1032, this.assemblyExpression();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyIdentifierOrList() {
                let e4 = new ae(this, this._ctx, this.state);
                this.enterRule(e4, 168, t5.RULE_assemblyIdentifierOrList);
                try {
                  switch (this.state = 1041, this._errHandler.sync(this), this._interp.adaptivePredict(this._input, 110, this._ctx)) {
                    case 1:
                      this.enterOuterAlt(e4, 1), this.state = 1034, this.identifier();
                      break;
                    case 2:
                      this.enterOuterAlt(e4, 2), this.state = 1035, this.assemblyMember();
                      break;
                    case 3:
                      this.enterOuterAlt(e4, 3), this.state = 1036, this.assemblyIdentifierList();
                      break;
                    case 4:
                      this.enterOuterAlt(e4, 4), this.state = 1037, this.match(t5.T__22), this.state = 1038, this.assemblyIdentifierList(), this.state = 1039, this.match(t5.T__23);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyIdentifierList() {
                let e4, i4 = new oe2(this, this._ctx, this.state);
                this.enterRule(i4, 170, t5.RULE_assemblyIdentifierList);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 1043, this.identifier(), this.state = 1048, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 1044, this.match(t5.T__15), this.state = 1045, this.identifier(), this.state = 1050, this._errHandler.sync(this), e4 = this._input.LA(1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              assemblyStackAssignment() {
                let e4 = new le2(this, this._ctx, this.state);
                this.enterRule(e4, 172, t5.RULE_assemblyStackAssignment);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 1051, this.assemblyExpression(), this.state = 1052, this.match(t5.T__89), this.state = 1053, this.identifier();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              labelDefinition() {
                let e4 = new he2(this, this._ctx, this.state);
                this.enterRule(e4, 174, t5.RULE_labelDefinition);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 1055, this.identifier(), this.state = 1056, this.match(t5.T__69);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblySwitch() {
                let e4, i4 = new ce2(this, this._ctx, this.state);
                this.enterRule(i4, 176, t5.RULE_assemblySwitch);
                try {
                  for (this.enterOuterAlt(i4, 1), this.state = 1058, this.match(t5.T__90), this.state = 1059, this.assemblyExpression(), this.state = 1063, this._errHandler.sync(this), e4 = this._input.LA(1); 92 === e4 || 93 === e4; ) this.state = 1060, this.assemblyCase(), this.state = 1065, this._errHandler.sync(this), e4 = this._input.LA(1);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              assemblyCase() {
                let e4 = new ue2(this, this._ctx, this.state);
                this.enterRule(e4, 178, t5.RULE_assemblyCase);
                try {
                  switch (this.state = 1072, this._errHandler.sync(this), this._input.LA(1)) {
                    case 92:
                      this.enterOuterAlt(e4, 1), this.state = 1066, this.match(t5.T__91), this.state = 1067, this.assemblyLiteral(), this.state = 1068, this.assemblyBlock();
                      break;
                    case 93:
                      this.enterOuterAlt(e4, 2), this.state = 1070, this.match(t5.T__92), this.state = 1071, this.assemblyBlock();
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyFunctionDefinition() {
                let e4, i4 = new pe2(this, this._ctx, this.state);
                this.enterRule(i4, 180, t5.RULE_assemblyFunctionDefinition);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 1074, this.match(t5.T__37), this.state = 1075, this.identifier(), this.state = 1076, this.match(t5.T__22), this.state = 1078, this._errHandler.sync(this), e4 = this._input.LA(1), (14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4) && (this.state = 1077, this.assemblyIdentifierList()), this.state = 1080, this.match(t5.T__23), this.state = 1082, this._errHandler.sync(this), e4 = this._input.LA(1), 94 === e4 && (this.state = 1081, this.assemblyFunctionReturns()), this.state = 1084, this.assemblyBlock();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              assemblyFunctionReturns() {
                let e4 = new de2(this, this._ctx, this.state);
                this.enterRule(e4, 182, t5.RULE_assemblyFunctionReturns);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 1086, this.match(t5.T__93), this.state = 1087, this.assemblyIdentifierList();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyFor() {
                let e4 = new me2(this, this._ctx, this.state);
                this.enterRule(e4, 184, t5.RULE_assemblyFor);
                try {
                  switch (this.enterOuterAlt(e4, 1), this.state = 1089, this.match(t5.T__26), this.state = 1092, this._errHandler.sync(this), this._input.LA(1)) {
                    case 15:
                      this.state = 1090, this.assemblyBlock();
                      break;
                    case 14:
                    case 25:
                    case 44:
                    case 50:
                    case 59:
                    case 62:
                    case 66:
                    case 95:
                    case 102:
                    case 103:
                    case 104:
                    case 106:
                    case 114:
                    case 118:
                    case 125:
                    case 126:
                    case 128:
                    case 129:
                    case 130:
                      this.state = 1091, this.assemblyExpression();
                      break;
                    default:
                      throw new y2(this);
                  }
                  switch (this.state = 1094, this.assemblyExpression(), this.state = 1097, this._errHandler.sync(this), this._input.LA(1)) {
                    case 15:
                      this.state = 1095, this.assemblyBlock();
                      break;
                    case 14:
                    case 25:
                    case 44:
                    case 50:
                    case 59:
                    case 62:
                    case 66:
                    case 95:
                    case 102:
                    case 103:
                    case 104:
                    case 106:
                    case 114:
                    case 118:
                    case 125:
                    case 126:
                    case 128:
                    case 129:
                    case 130:
                      this.state = 1096, this.assemblyExpression();
                      break;
                    default:
                      throw new y2(this);
                  }
                  this.state = 1099, this.assemblyBlock();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyIf() {
                let e4 = new _e2(this, this._ctx, this.state);
                this.enterRule(e4, 186, t5.RULE_assemblyIf);
                try {
                  this.enterOuterAlt(e4, 1), this.state = 1101, this.match(t5.T__50), this.state = 1102, this.assemblyExpression(), this.state = 1103, this.assemblyBlock();
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              assemblyLiteral() {
                let e4 = new xe2(this, this._ctx, this.state);
                this.enterRule(e4, 188, t5.RULE_assemblyLiteral);
                try {
                  switch (this.state = 1110, this._errHandler.sync(this), this._input.LA(1)) {
                    case 130:
                      this.enterOuterAlt(e4, 1), this.state = 1105, this.stringLiteral();
                      break;
                    case 103:
                      this.enterOuterAlt(e4, 2), this.state = 1106, this.match(t5.DecimalNumber);
                      break;
                    case 104:
                      this.enterOuterAlt(e4, 3), this.state = 1107, this.match(t5.HexNumber);
                      break;
                    case 106:
                      this.enterOuterAlt(e4, 4), this.state = 1108, this.hexLiteral();
                      break;
                    case 102:
                      this.enterOuterAlt(e4, 5), this.state = 1109, this.match(t5.BooleanLiteral);
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              tupleExpression() {
                let e4, i4 = new fe2(this, this._ctx, this.state);
                this.enterRule(i4, 190, t5.RULE_tupleExpression);
                try {
                  switch (this.state = 1138, this._errHandler.sync(this), this._input.LA(1)) {
                    case 23:
                      for (this.enterOuterAlt(i4, 1), this.state = 1112, this.match(t5.T__22), this.state = 1114, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) && (this.state = 1113, this.expression(0)), this.state = 1122, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 1116, this.match(t5.T__15), this.state = 1118, this._errHandler.sync(this), e4 = this._input.LA(1), (0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) && (this.state = 1117, this.expression(0)), this.state = 1124, this._errHandler.sync(this), e4 = this._input.LA(1);
                      this.state = 1125, this.match(t5.T__23);
                      break;
                    case 42:
                      if (this.enterOuterAlt(i4, 2), this.state = 1126, this.match(t5.T__41), this.state = 1135, this._errHandler.sync(this), e4 = this._input.LA(1), 0 == (-32 & e4) && 0 != (1 << e4 & 3263184960) || 0 == (e4 - 38 & -32) && 0 != (1 << e4 - 38 & 4278194513) || 0 == (e4 - 71 & -32) && 0 != (1 << e4 - 71 & 4244635651) || 0 == (e4 - 103 & -32) && 0 != (1 << e4 - 103 & 248547339)) for (this.state = 1127, this.expression(0), this.state = 1132, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 1128, this.match(t5.T__15), this.state = 1129, this.expression(0), this.state = 1134, this._errHandler.sync(this), e4 = this._input.LA(1);
                      this.state = 1137, this.match(t5.T__42);
                      break;
                    default:
                      throw new y2(this);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              numberLiteral() {
                let e4, i4 = new ye2(this, this._ctx, this.state);
                this.enterRule(i4, 192, t5.RULE_numberLiteral);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 1140, e4 = this._input.LA(1), 103 !== e4 && 104 !== e4 ? this._errHandler.recoverInline(this) : (this._errHandler.reportMatch(this), this.consume()), this.state = 1142, this._errHandler.sync(this), 1 === this._interp.adaptivePredict(this._input, 125, this._ctx) && (this.state = 1141, this.match(t5.NumberUnit));
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              identifier() {
                let e4, i4 = new ge2(this, this._ctx, this.state);
                this.enterRule(i4, 194, t5.RULE_identifier);
                try {
                  this.enterOuterAlt(i4, 1), this.state = 1144, e4 = this._input.LA(1), 14 === e4 || 25 === e4 || 0 == (e4 - 44 & -32) && 0 != (1 << e4 - 44 & 262209) || 0 == (e4 - 95 & -32) && 0 != (1 << e4 - 95 & 3230138369) || 128 === e4 || 129 === e4 ? (this._errHandler.reportMatch(this), this.consume()) : this._errHandler.recoverInline(this);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              hexLiteral() {
                let e4 = new Te2(this, this._ctx, this.state);
                this.enterRule(e4, 196, t5.RULE_hexLiteral);
                try {
                  let i4;
                  this.enterOuterAlt(e4, 1), this.state = 1147, this._errHandler.sync(this), i4 = 1;
                  do {
                    if (1 !== i4) throw new y2(this);
                    this.state = 1146, this.match(t5.HexLiteralFragment), this.state = 1149, this._errHandler.sync(this), i4 = this._interp.adaptivePredict(this._input, 126, this._ctx);
                  } while (2 !== i4 && i4 !== h.INVALID_ALT_NUMBER);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              overrideSpecifier() {
                let e4, i4 = new Ee2(this, this._ctx, this.state);
                this.enterRule(i4, 198, t5.RULE_overrideSpecifier);
                try {
                  if (this.enterOuterAlt(i4, 1), this.state = 1151, this.match(t5.T__95), this.state = 1163, this._errHandler.sync(this), e4 = this._input.LA(1), 23 === e4) {
                    for (this.state = 1152, this.match(t5.T__22), this.state = 1153, this.userDefinedTypeName(), this.state = 1158, this._errHandler.sync(this), e4 = this._input.LA(1); 16 === e4; ) this.state = 1154, this.match(t5.T__15), this.state = 1155, this.userDefinedTypeName(), this.state = 1160, this._errHandler.sync(this), e4 = this._input.LA(1);
                    this.state = 1161, this.match(t5.T__23);
                  }
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  i4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return i4;
              }
              stringLiteral() {
                let e4 = new Re2(this, this._ctx, this.state);
                this.enterRule(e4, 200, t5.RULE_stringLiteral);
                try {
                  let i4;
                  this.enterOuterAlt(e4, 1), this.state = 1166, this._errHandler.sync(this), i4 = 1;
                  do {
                    if (1 !== i4) throw new y2(this);
                    this.state = 1165, this.match(t5.StringLiteralFragment), this.state = 1168, this._errHandler.sync(this), i4 = this._interp.adaptivePredict(this._input, 129, this._ctx);
                  } while (2 !== i4 && i4 !== h.INVALID_ALT_NUMBER);
                } catch (t6) {
                  if (!(t6 instanceof b)) throw t6;
                  e4.exception = t6, this._errHandler.reportError(this, t6), this._errHandler.recover(this, t6);
                } finally {
                  this.exitRule();
                }
                return e4;
              }
              sempred(t6, e4, i4) {
                switch (e4) {
                  case 38:
                    return this.typeName_sempred(t6, i4);
                  case 70:
                    return this.expression_sempred(t6, i4);
                }
                return true;
              }
              typeName_sempred(t6, e4) {
                return 0 !== e4 || this.precpred(this._ctx, 3);
              }
              expression_sempred(t6, e4) {
                switch (e4) {
                  case 1:
                    return this.precpred(this._ctx, 14);
                  case 2:
                    return this.precpred(this._ctx, 13);
                  case 3:
                    return this.precpred(this._ctx, 12);
                  case 4:
                    return this.precpred(this._ctx, 11);
                  case 5:
                    return this.precpred(this._ctx, 10);
                  case 6:
                    return this.precpred(this._ctx, 9);
                  case 7:
                    return this.precpred(this._ctx, 8);
                  case 8:
                    return this.precpred(this._ctx, 7);
                  case 9:
                    return this.precpred(this._ctx, 6);
                  case 10:
                    return this.precpred(this._ctx, 5);
                  case 11:
                    return this.precpred(this._ctx, 4);
                  case 12:
                    return this.precpred(this._ctx, 3);
                  case 13:
                    return this.precpred(this._ctx, 2);
                  case 14:
                    return this.precpred(this._ctx, 27);
                  case 15:
                    return this.precpred(this._ctx, 25);
                  case 16:
                    return this.precpred(this._ctx, 24);
                  case 17:
                    return this.precpred(this._ctx, 23);
                  case 18:
                    return this.precpred(this._ctx, 22);
                  case 19:
                    return this.precpred(this._ctx, 21);
                }
                return true;
              }
              static get _ATN() {
                return t5.__ATN || (t5.__ATN = new c().deserialize(t5._serializedATN)), t5.__ATN;
              }
            };
            A2.T__0 = 1, A2.T__1 = 2, A2.T__2 = 3, A2.T__3 = 4, A2.T__4 = 5, A2.T__5 = 6, A2.T__6 = 7, A2.T__7 = 8, A2.T__8 = 9, A2.T__9 = 10, A2.T__10 = 11, A2.T__11 = 12, A2.T__12 = 13, A2.T__13 = 14, A2.T__14 = 15, A2.T__15 = 16, A2.T__16 = 17, A2.T__17 = 18, A2.T__18 = 19, A2.T__19 = 20, A2.T__20 = 21, A2.T__21 = 22, A2.T__22 = 23, A2.T__23 = 24, A2.T__24 = 25, A2.T__25 = 26, A2.T__26 = 27, A2.T__27 = 28, A2.T__28 = 29, A2.T__29 = 30, A2.T__30 = 31, A2.T__31 = 32, A2.T__32 = 33, A2.T__33 = 34, A2.T__34 = 35, A2.T__35 = 36, A2.T__36 = 37, A2.T__37 = 38, A2.T__38 = 39, A2.T__39 = 40, A2.T__40 = 41, A2.T__41 = 42, A2.T__42 = 43, A2.T__43 = 44, A2.T__44 = 45, A2.T__45 = 46, A2.T__46 = 47, A2.T__47 = 48, A2.T__48 = 49, A2.T__49 = 50, A2.T__50 = 51, A2.T__51 = 52, A2.T__52 = 53, A2.T__53 = 54, A2.T__54 = 55, A2.T__55 = 56, A2.T__56 = 57, A2.T__57 = 58, A2.T__58 = 59, A2.T__59 = 60, A2.T__60 = 61, A2.T__61 = 62, A2.T__62 = 63, A2.T__63 = 64, A2.T__64 = 65, A2.T__65 = 66, A2.T__66 = 67, A2.T__67 = 68, A2.T__68 = 69, A2.T__69 = 70, A2.T__70 = 71, A2.T__71 = 72, A2.T__72 = 73, A2.T__73 = 74, A2.T__74 = 75, A2.T__75 = 76, A2.T__76 = 77, A2.T__77 = 78, A2.T__78 = 79, A2.T__79 = 80, A2.T__80 = 81, A2.T__81 = 82, A2.T__82 = 83, A2.T__83 = 84, A2.T__84 = 85, A2.T__85 = 86, A2.T__86 = 87, A2.T__87 = 88, A2.T__88 = 89, A2.T__89 = 90, A2.T__90 = 91, A2.T__91 = 92, A2.T__92 = 93, A2.T__93 = 94, A2.T__94 = 95, A2.T__95 = 96, A2.Int = 97, A2.Uint = 98, A2.Byte = 99, A2.Fixed = 100, A2.Ufixed = 101, A2.BooleanLiteral = 102, A2.DecimalNumber = 103, A2.HexNumber = 104, A2.NumberUnit = 105, A2.HexLiteralFragment = 106, A2.ReservedKeyword = 107, A2.AnonymousKeyword = 108, A2.BreakKeyword = 109, A2.ConstantKeyword = 110, A2.TransientKeyword = 111, A2.ImmutableKeyword = 112, A2.ContinueKeyword = 113, A2.LeaveKeyword = 114, A2.ExternalKeyword = 115, A2.IndexedKeyword = 116, A2.InternalKeyword = 117, A2.PayableKeyword = 118, A2.PrivateKeyword = 119, A2.PublicKeyword = 120, A2.VirtualKeyword = 121, A2.PureKeyword = 122, A2.TypeKeyword = 123, A2.ViewKeyword = 124, A2.GlobalKeyword = 125, A2.ConstructorKeyword = 126, A2.FallbackKeyword = 127, A2.ReceiveKeyword = 128, A2.Identifier = 129, A2.StringLiteralFragment = 130, A2.VersionLiteral = 131, A2.WS = 132, A2.COMMENT = 133, A2.LINE_COMMENT = 134, A2.EOF = L2.EOF, A2.RULE_sourceUnit = 0, A2.RULE_pragmaDirective = 1, A2.RULE_pragmaName = 2, A2.RULE_pragmaValue = 3, A2.RULE_version = 4, A2.RULE_versionOperator = 5, A2.RULE_versionConstraint = 6, A2.RULE_importDeclaration = 7, A2.RULE_importDirective = 8, A2.RULE_importPath = 9, A2.RULE_contractDefinition = 10, A2.RULE_inheritanceSpecifier = 11, A2.RULE_contractPart = 12, A2.RULE_stateVariableDeclaration = 13, A2.RULE_fileLevelConstant = 14, A2.RULE_customErrorDefinition = 15, A2.RULE_typeDefinition = 16, A2.RULE_usingForDeclaration = 17, A2.RULE_usingForObject = 18, A2.RULE_usingForObjectDirective = 19, A2.RULE_userDefinableOperators = 20, A2.RULE_structDefinition = 21, A2.RULE_modifierDefinition = 22, A2.RULE_modifierInvocation = 23, A2.RULE_functionDefinition = 24, A2.RULE_functionDescriptor = 25, A2.RULE_returnParameters = 26, A2.RULE_modifierList = 27, A2.RULE_eventDefinition = 28, A2.RULE_enumValue = 29, A2.RULE_enumDefinition = 30, A2.RULE_parameterList = 31, A2.RULE_parameter = 32, A2.RULE_eventParameterList = 33, A2.RULE_eventParameter = 34, A2.RULE_functionTypeParameterList = 35, A2.RULE_functionTypeParameter = 36, A2.RULE_variableDeclaration = 37, A2.RULE_typeName = 38, A2.RULE_userDefinedTypeName = 39, A2.RULE_mappingKey = 40, A2.RULE_mapping = 41, A2.RULE_mappingKeyName = 42, A2.RULE_mappingValueName = 43, A2.RULE_functionTypeName = 44, A2.RULE_storageLocation = 45, A2.RULE_stateMutability = 46, A2.RULE_block = 47, A2.RULE_statement = 48, A2.RULE_expressionStatement = 49, A2.RULE_ifStatement = 50, A2.RULE_tryStatement = 51, A2.RULE_catchClause = 52, A2.RULE_whileStatement = 53, A2.RULE_simpleStatement = 54, A2.RULE_uncheckedStatement = 55, A2.RULE_forStatement = 56, A2.RULE_inlineAssemblyStatement = 57, A2.RULE_inlineAssemblyStatementFlag = 58, A2.RULE_doWhileStatement = 59, A2.RULE_continueStatement = 60, A2.RULE_breakStatement = 61, A2.RULE_returnStatement = 62, A2.RULE_throwStatement = 63, A2.RULE_emitStatement = 64, A2.RULE_revertStatement = 65, A2.RULE_variableDeclarationStatement = 66, A2.RULE_variableDeclarationList = 67, A2.RULE_identifierList = 68, A2.RULE_elementaryTypeName = 69, A2.RULE_expression = 70, A2.RULE_primaryExpression = 71, A2.RULE_expressionList = 72, A2.RULE_nameValueList = 73, A2.RULE_nameValue = 74, A2.RULE_functionCallArguments = 75, A2.RULE_functionCall = 76, A2.RULE_assemblyBlock = 77, A2.RULE_assemblyItem = 78, A2.RULE_assemblyExpression = 79, A2.RULE_assemblyMember = 80, A2.RULE_assemblyCall = 81, A2.RULE_assemblyLocalDefinition = 82, A2.RULE_assemblyAssignment = 83, A2.RULE_assemblyIdentifierOrList = 84, A2.RULE_assemblyIdentifierList = 85, A2.RULE_assemblyStackAssignment = 86, A2.RULE_labelDefinition = 87, A2.RULE_assemblySwitch = 88, A2.RULE_assemblyCase = 89, A2.RULE_assemblyFunctionDefinition = 90, A2.RULE_assemblyFunctionReturns = 91, A2.RULE_assemblyFor = 92, A2.RULE_assemblyIf = 93, A2.RULE_assemblyLiteral = 94, A2.RULE_tupleExpression = 95, A2.RULE_numberLiteral = 96, A2.RULE_identifier = 97, A2.RULE_hexLiteral = 98, A2.RULE_overrideSpecifier = 99, A2.RULE_stringLiteral = 100, A2.literalNames = [null, "'pragma'", "';'", "'*'", "'||'", "'^'", "'~'", "'>='", "'>'", "'<'", "'<='", "'='", "'as'", "'import'", "'from'", "'{'", "','", "'}'", "'abstract'", "'contract'", "'interface'", "'library'", "'is'", "'('", "')'", "'error'", "'using'", "'for'", "'|'", "'&'", "'+'", "'-'", "'/'", "'%'", "'=='", "'!='", "'struct'", "'modifier'", "'function'", "'returns'", "'event'", "'enum'", "'['", "']'", "'address'", "'.'", "'mapping'", "'=>'", "'memory'", "'storage'", "'calldata'", "'if'", "'else'", "'try'", "'catch'", "'while'", "'unchecked'", "'assembly'", "'do'", "'return'", "'throw'", "'emit'", "'revert'", "'var'", "'bool'", "'string'", "'byte'", "'++'", "'--'", "'new'", "':'", "'delete'", "'!'", "'**'", "'<<'", "'>>'", "'&&'", "'?'", "'|='", "'^='", "'&='", "'<<='", "'>>='", "'+='", "'-='", "'*='", "'/='", "'%='", "'let'", "':='", "'=:'", "'switch'", "'case'", "'default'", "'->'", "'callback'", "'override'", null, null, null, null, null, null, null, null, null, null, null, "'anonymous'", "'break'", "'constant'", "'transient'", "'immutable'", "'continue'", "'leave'", "'external'", "'indexed'", "'internal'", "'payable'", "'private'", "'public'", "'virtual'", "'pure'", "'type'", "'view'", "'global'", "'constructor'", "'fallback'", "'receive'"], A2.symbolicNames = [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "Int", "Uint", "Byte", "Fixed", "Ufixed", "BooleanLiteral", "DecimalNumber", "HexNumber", "NumberUnit", "HexLiteralFragment", "ReservedKeyword", "AnonymousKeyword", "BreakKeyword", "ConstantKeyword", "TransientKeyword", "ImmutableKeyword", "ContinueKeyword", "LeaveKeyword", "ExternalKeyword", "IndexedKeyword", "InternalKeyword", "PayableKeyword", "PrivateKeyword", "PublicKeyword", "VirtualKeyword", "PureKeyword", "TypeKeyword", "ViewKeyword", "GlobalKeyword", "ConstructorKeyword", "FallbackKeyword", "ReceiveKeyword", "Identifier", "StringLiteralFragment", "VersionLiteral", "WS", "COMMENT", "LINE_COMMENT"], A2.ruleNames = ["sourceUnit", "pragmaDirective", "pragmaName", "pragmaValue", "version", "versionOperator", "versionConstraint", "importDeclaration", "importDirective", "importPath", "contractDefinition", "inheritanceSpecifier", "contractPart", "stateVariableDeclaration", "fileLevelConstant", "customErrorDefinition", "typeDefinition", "usingForDeclaration", "usingForObject", "usingForObjectDirective", "userDefinableOperators", "structDefinition", "modifierDefinition", "modifierInvocation", "functionDefinition", "functionDescriptor", "returnParameters", "modifierList", "eventDefinition", "enumValue", "enumDefinition", "parameterList", "parameter", "eventParameterList", "eventParameter", "functionTypeParameterList", "functionTypeParameter", "variableDeclaration", "typeName", "userDefinedTypeName", "mappingKey", "mapping", "mappingKeyName", "mappingValueName", "functionTypeName", "storageLocation", "stateMutability", "block", "statement", "expressionStatement", "ifStatement", "tryStatement", "catchClause", "whileStatement", "simpleStatement", "uncheckedStatement", "forStatement", "inlineAssemblyStatement", "inlineAssemblyStatementFlag", "doWhileStatement", "continueStatement", "breakStatement", "returnStatement", "throwStatement", "emitStatement", "revertStatement", "variableDeclarationStatement", "variableDeclarationList", "identifierList", "elementaryTypeName", "expression", "primaryExpression", "expressionList", "nameValueList", "nameValue", "functionCallArguments", "functionCall", "assemblyBlock", "assemblyItem", "assemblyExpression", "assemblyMember", "assemblyCall", "assemblyLocalDefinition", "assemblyAssignment", "assemblyIdentifierOrList", "assemblyIdentifierList", "assemblyStackAssignment", "labelDefinition", "assemblySwitch", "assemblyCase", "assemblyFunctionDefinition", "assemblyFunctionReturns", "assemblyFor", "assemblyIf", "assemblyLiteral", "tupleExpression", "numberLiteral", "identifier", "hexLiteral", "overrideSpecifier", "stringLiteral"], A2._serializedATN = [4, 1, 134, 1171, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 99, 2, 100, 7, 100, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 0, 214, 8, 0, 10, 0, 12, 0, 217, 9, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 3, 1, 3, 1, 3, 3, 3, 231, 8, 3, 1, 4, 1, 4, 3, 4, 235, 8, 4, 1, 4, 5, 4, 238, 8, 4, 10, 4, 12, 4, 241, 9, 4, 1, 5, 1, 5, 1, 6, 3, 6, 246, 8, 6, 1, 6, 1, 6, 3, 6, 250, 8, 6, 1, 6, 3, 6, 253, 8, 6, 1, 7, 1, 7, 1, 7, 3, 7, 258, 8, 7, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 264, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 271, 8, 8, 1, 8, 1, 8, 3, 8, 275, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 5, 8, 286, 8, 8, 10, 8, 12, 8, 289, 9, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 296, 8, 8, 1, 9, 1, 9, 1, 10, 3, 10, 301, 8, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 5, 10, 309, 8, 10, 10, 10, 12, 10, 312, 9, 10, 3, 10, 314, 8, 10, 1, 10, 1, 10, 5, 10, 318, 8, 10, 10, 10, 12, 10, 321, 9, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3, 11, 328, 8, 11, 1, 11, 3, 11, 331, 8, 11, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 1, 12, 3, 12, 342, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 352, 8, 13, 10, 13, 12, 13, 355, 9, 13, 1, 13, 1, 13, 1, 13, 3, 13, 360, 8, 13, 1, 13, 1, 13, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 15, 1, 15, 1, 15, 1, 15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 387, 8, 17, 1, 17, 3, 17, 390, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1, 18, 1, 18, 1, 18, 5, 18, 399, 8, 18, 10, 18, 12, 18, 402, 9, 18, 1, 18, 1, 18, 3, 18, 406, 8, 18, 1, 19, 1, 19, 1, 19, 3, 19, 411, 8, 19, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 1, 21, 5, 21, 423, 8, 21, 10, 21, 12, 21, 426, 9, 21, 3, 21, 428, 8, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 3, 22, 435, 8, 22, 1, 22, 1, 22, 5, 22, 439, 8, 22, 10, 22, 12, 22, 442, 9, 22, 1, 22, 1, 22, 3, 22, 446, 8, 22, 1, 23, 1, 23, 1, 23, 3, 23, 451, 8, 23, 1, 23, 3, 23, 454, 8, 23, 1, 24, 1, 24, 1, 24, 1, 24, 3, 24, 460, 8, 24, 1, 24, 1, 24, 3, 24, 464, 8, 24, 1, 25, 1, 25, 3, 25, 468, 8, 25, 1, 25, 1, 25, 1, 25, 3, 25, 473, 8, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 5, 27, 486, 8, 27, 10, 27, 12, 27, 489, 9, 27, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28, 495, 8, 28, 1, 28, 1, 28, 1, 29, 1, 29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 505, 8, 30, 1, 30, 1, 30, 5, 30, 509, 8, 30, 10, 30, 12, 30, 512, 9, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 5, 31, 520, 8, 31, 10, 31, 12, 31, 523, 9, 31, 3, 31, 525, 8, 31, 1, 31, 1, 31, 1, 32, 1, 32, 3, 32, 531, 8, 32, 1, 32, 3, 32, 534, 8, 32, 1, 33, 1, 33, 1, 33, 1, 33, 5, 33, 540, 8, 33, 10, 33, 12, 33, 543, 9, 33, 3, 33, 545, 8, 33, 1, 33, 1, 33, 1, 34, 1, 34, 3, 34, 551, 8, 34, 1, 34, 3, 34, 554, 8, 34, 1, 35, 1, 35, 1, 35, 1, 35, 5, 35, 560, 8, 35, 10, 35, 12, 35, 563, 9, 35, 3, 35, 565, 8, 35, 1, 35, 1, 35, 1, 36, 1, 36, 3, 36, 571, 8, 36, 1, 37, 1, 37, 3, 37, 575, 8, 37, 1, 37, 1, 37, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 1, 38, 3, 38, 586, 8, 38, 1, 38, 1, 38, 1, 38, 3, 38, 591, 8, 38, 1, 38, 5, 38, 594, 8, 38, 10, 38, 12, 38, 597, 9, 38, 1, 39, 1, 39, 1, 39, 5, 39, 602, 8, 39, 10, 39, 12, 39, 605, 9, 39, 1, 40, 1, 40, 3, 40, 609, 8, 40, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 615, 8, 41, 1, 41, 1, 41, 1, 41, 3, 41, 620, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 43, 1, 44, 1, 44, 1, 44, 1, 44, 1, 44, 5, 44, 633, 8, 44, 10, 44, 12, 44, 636, 9, 44, 1, 44, 1, 44, 3, 44, 640, 8, 44, 1, 45, 1, 45, 1, 46, 1, 46, 1, 47, 1, 47, 5, 47, 648, 8, 47, 10, 47, 12, 47, 651, 9, 47, 1, 47, 1, 47, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 1, 48, 3, 48, 670, 8, 48, 1, 49, 1, 49, 1, 49, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 1, 50, 3, 50, 682, 8, 50, 1, 51, 1, 51, 1, 51, 3, 51, 687, 8, 51, 1, 51, 1, 51, 4, 51, 691, 8, 51, 11, 51, 12, 51, 692, 1, 52, 1, 52, 3, 52, 697, 8, 52, 1, 52, 3, 52, 700, 8, 52, 1, 52, 1, 52, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 3, 54, 712, 8, 54, 1, 55, 1, 55, 1, 55, 1, 56, 1, 56, 1, 56, 1, 56, 3, 56, 721, 8, 56, 1, 56, 1, 56, 3, 56, 725, 8, 56, 1, 56, 3, 56, 728, 8, 56, 1, 56, 1, 56, 1, 56, 1, 57, 1, 57, 3, 57, 735, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 741, 8, 57, 1, 57, 1, 57, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 1, 62, 1, 62, 3, 62, 763, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 1, 63, 1, 64, 1, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66, 3, 66, 785, 8, 66, 1, 66, 1, 66, 3, 66, 789, 8, 66, 1, 66, 1, 66, 1, 67, 3, 67, 794, 8, 67, 1, 67, 1, 67, 3, 67, 798, 8, 67, 5, 67, 800, 8, 67, 10, 67, 12, 67, 803, 9, 67, 1, 68, 1, 68, 3, 68, 807, 8, 68, 1, 68, 5, 68, 810, 8, 68, 10, 68, 12, 68, 813, 9, 68, 1, 68, 3, 68, 816, 8, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 840, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 3, 70, 894, 8, 70, 1, 70, 1, 70, 3, 70, 898, 8, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 1, 70, 5, 70, 914, 8, 70, 10, 70, 12, 70, 917, 9, 70, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71, 928, 8, 71, 1, 72, 1, 72, 1, 72, 5, 72, 933, 8, 72, 10, 72, 12, 72, 936, 9, 72, 1, 73, 1, 73, 1, 73, 5, 73, 941, 8, 73, 10, 73, 12, 73, 944, 9, 73, 1, 73, 3, 73, 947, 8, 73, 1, 74, 1, 74, 1, 74, 1, 74, 1, 75, 1, 75, 3, 75, 955, 8, 75, 1, 75, 1, 75, 3, 75, 959, 8, 75, 3, 75, 961, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 77, 1, 77, 5, 77, 970, 8, 77, 10, 77, 12, 77, 973, 9, 77, 1, 77, 1, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 3, 78, 994, 8, 78, 1, 79, 1, 79, 1, 79, 3, 79, 999, 8, 79, 1, 80, 1, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 1009, 8, 81, 1, 81, 1, 81, 3, 81, 1013, 8, 81, 1, 81, 1, 81, 5, 81, 1017, 8, 81, 10, 81, 12, 81, 1020, 9, 81, 1, 81, 3, 81, 1023, 8, 81, 1, 82, 1, 82, 1, 82, 1, 82, 3, 82, 1029, 8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 3, 84, 1042, 8, 84, 1, 85, 1, 85, 1, 85, 5, 85, 1047, 8, 85, 10, 85, 12, 85, 1050, 9, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 5, 88, 1062, 8, 88, 10, 88, 12, 88, 1065, 9, 88, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1073, 8, 89, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1079, 8, 90, 1, 90, 1, 90, 3, 90, 1083, 8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 1, 91, 1, 92, 1, 92, 1, 92, 3, 92, 1093, 8, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1098, 8, 92, 1, 92, 1, 92, 1, 93, 1, 93, 1, 93, 1, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3, 94, 1111, 8, 94, 1, 95, 1, 95, 3, 95, 1115, 8, 95, 1, 95, 1, 95, 3, 95, 1119, 8, 95, 5, 95, 1121, 8, 95, 10, 95, 12, 95, 1124, 9, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 5, 95, 1131, 8, 95, 10, 95, 12, 95, 1134, 9, 95, 3, 95, 1136, 8, 95, 1, 95, 3, 95, 1139, 8, 95, 1, 96, 1, 96, 3, 96, 1143, 8, 96, 1, 97, 1, 97, 1, 98, 4, 98, 1148, 8, 98, 11, 98, 12, 98, 1149, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 5, 99, 1157, 8, 99, 10, 99, 12, 99, 1160, 9, 99, 1, 99, 1, 99, 3, 99, 1164, 8, 99, 1, 100, 4, 100, 1167, 8, 100, 11, 100, 12, 100, 1168, 1, 100, 0, 2, 76, 140, 101, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 0, 15, 1, 0, 5, 11, 1, 0, 19, 21, 3, 0, 3, 3, 5, 10, 28, 35, 1, 0, 48, 50, 4, 0, 110, 110, 118, 118, 122, 122, 124, 124, 3, 0, 44, 44, 63, 66, 97, 101, 1, 0, 67, 68, 1, 0, 30, 31, 2, 0, 3, 3, 32, 33, 1, 0, 74, 75, 1, 0, 7, 10, 1, 0, 34, 35, 2, 0, 11, 11, 78, 87, 1, 0, 103, 104, 10, 0, 14, 14, 25, 25, 44, 44, 50, 50, 62, 62, 95, 95, 114, 114, 118, 118, 125, 126, 128, 129, 1301, 0, 215, 1, 0, 0, 0, 2, 220, 1, 0, 0, 0, 4, 225, 1, 0, 0, 0, 6, 230, 1, 0, 0, 0, 8, 232, 1, 0, 0, 0, 10, 242, 1, 0, 0, 0, 12, 252, 1, 0, 0, 0, 14, 254, 1, 0, 0, 0, 16, 295, 1, 0, 0, 0, 18, 297, 1, 0, 0, 0, 20, 300, 1, 0, 0, 0, 22, 324, 1, 0, 0, 0, 24, 341, 1, 0, 0, 0, 26, 343, 1, 0, 0, 0, 28, 363, 1, 0, 0, 0, 30, 370, 1, 0, 0, 0, 32, 375, 1, 0, 0, 0, 34, 381, 1, 0, 0, 0, 36, 405, 1, 0, 0, 0, 38, 407, 1, 0, 0, 0, 40, 412, 1, 0, 0, 0, 42, 414, 1, 0, 0, 0, 44, 431, 1, 0, 0, 0, 46, 447, 1, 0, 0, 0, 48, 455, 1, 0, 0, 0, 50, 472, 1, 0, 0, 0, 52, 474, 1, 0, 0, 0, 54, 487, 1, 0, 0, 0, 56, 490, 1, 0, 0, 0, 58, 498, 1, 0, 0, 0, 60, 500, 1, 0, 0, 0, 62, 515, 1, 0, 0, 0, 64, 528, 1, 0, 0, 0, 66, 535, 1, 0, 0, 0, 68, 548, 1, 0, 0, 0, 70, 555, 1, 0, 0, 0, 72, 568, 1, 0, 0, 0, 74, 572, 1, 0, 0, 0, 76, 585, 1, 0, 0, 0, 78, 598, 1, 0, 0, 0, 80, 608, 1, 0, 0, 0, 82, 610, 1, 0, 0, 0, 84, 623, 1, 0, 0, 0, 86, 625, 1, 0, 0, 0, 88, 627, 1, 0, 0, 0, 90, 641, 1, 0, 0, 0, 92, 643, 1, 0, 0, 0, 94, 645, 1, 0, 0, 0, 96, 669, 1, 0, 0, 0, 98, 671, 1, 0, 0, 0, 100, 674, 1, 0, 0, 0, 102, 683, 1, 0, 0, 0, 104, 694, 1, 0, 0, 0, 106, 703, 1, 0, 0, 0, 108, 711, 1, 0, 0, 0, 110, 713, 1, 0, 0, 0, 112, 716, 1, 0, 0, 0, 114, 732, 1, 0, 0, 0, 116, 744, 1, 0, 0, 0, 118, 746, 1, 0, 0, 0, 120, 754, 1, 0, 0, 0, 122, 757, 1, 0, 0, 0, 124, 760, 1, 0, 0, 0, 126, 766, 1, 0, 0, 0, 128, 769, 1, 0, 0, 0, 130, 773, 1, 0, 0, 0, 132, 784, 1, 0, 0, 0, 134, 793, 1, 0, 0, 0, 136, 804, 1, 0, 0, 0, 138, 819, 1, 0, 0, 0, 140, 839, 1, 0, 0, 0, 142, 927, 1, 0, 0, 0, 144, 929, 1, 0, 0, 0, 146, 937, 1, 0, 0, 0, 148, 948, 1, 0, 0, 0, 150, 960, 1, 0, 0, 0, 152, 962, 1, 0, 0, 0, 154, 967, 1, 0, 0, 0, 156, 993, 1, 0, 0, 0, 158, 998, 1, 0, 0, 0, 160, 1e3, 1, 0, 0, 0, 162, 1008, 1, 0, 0, 0, 164, 1024, 1, 0, 0, 0, 166, 1030, 1, 0, 0, 0, 168, 1041, 1, 0, 0, 0, 170, 1043, 1, 0, 0, 0, 172, 1051, 1, 0, 0, 0, 174, 1055, 1, 0, 0, 0, 176, 1058, 1, 0, 0, 0, 178, 1072, 1, 0, 0, 0, 180, 1074, 1, 0, 0, 0, 182, 1086, 1, 0, 0, 0, 184, 1089, 1, 0, 0, 0, 186, 1101, 1, 0, 0, 0, 188, 1110, 1, 0, 0, 0, 190, 1138, 1, 0, 0, 0, 192, 1140, 1, 0, 0, 0, 194, 1144, 1, 0, 0, 0, 196, 1147, 1, 0, 0, 0, 198, 1151, 1, 0, 0, 0, 200, 1166, 1, 0, 0, 0, 202, 214, 3, 2, 1, 0, 203, 214, 3, 16, 8, 0, 204, 214, 3, 20, 10, 0, 205, 214, 3, 60, 30, 0, 206, 214, 3, 56, 28, 0, 207, 214, 3, 42, 21, 0, 208, 214, 3, 48, 24, 0, 209, 214, 3, 28, 14, 0, 210, 214, 3, 30, 15, 0, 211, 214, 3, 32, 16, 0, 212, 214, 3, 34, 17, 0, 213, 202, 1, 0, 0, 0, 213, 203, 1, 0, 0, 0, 213, 204, 1, 0, 0, 0, 213, 205, 1, 0, 0, 0, 213, 206, 1, 0, 0, 0, 213, 207, 1, 0, 0, 0, 213, 208, 1, 0, 0, 0, 213, 209, 1, 0, 0, 0, 213, 210, 1, 0, 0, 0, 213, 211, 1, 0, 0, 0, 213, 212, 1, 0, 0, 0, 214, 217, 1, 0, 0, 0, 215, 213, 1, 0, 0, 0, 215, 216, 1, 0, 0, 0, 216, 218, 1, 0, 0, 0, 217, 215, 1, 0, 0, 0, 218, 219, 5, 0, 0, 1, 219, 1, 1, 0, 0, 0, 220, 221, 5, 1, 0, 0, 221, 222, 3, 4, 2, 0, 222, 223, 3, 6, 3, 0, 223, 224, 5, 2, 0, 0, 224, 3, 1, 0, 0, 0, 225, 226, 3, 194, 97, 0, 226, 5, 1, 0, 0, 0, 227, 231, 5, 3, 0, 0, 228, 231, 3, 8, 4, 0, 229, 231, 3, 140, 70, 0, 230, 227, 1, 0, 0, 0, 230, 228, 1, 0, 0, 0, 230, 229, 1, 0, 0, 0, 231, 7, 1, 0, 0, 0, 232, 239, 3, 12, 6, 0, 233, 235, 5, 4, 0, 0, 234, 233, 1, 0, 0, 0, 234, 235, 1, 0, 0, 0, 235, 236, 1, 0, 0, 0, 236, 238, 3, 12, 6, 0, 237, 234, 1, 0, 0, 0, 238, 241, 1, 0, 0, 0, 239, 237, 1, 0, 0, 0, 239, 240, 1, 0, 0, 0, 240, 9, 1, 0, 0, 0, 241, 239, 1, 0, 0, 0, 242, 243, 7, 0, 0, 0, 243, 11, 1, 0, 0, 0, 244, 246, 3, 10, 5, 0, 245, 244, 1, 0, 0, 0, 245, 246, 1, 0, 0, 0, 246, 247, 1, 0, 0, 0, 247, 253, 5, 131, 0, 0, 248, 250, 3, 10, 5, 0, 249, 248, 1, 0, 0, 0, 249, 250, 1, 0, 0, 0, 250, 251, 1, 0, 0, 0, 251, 253, 5, 103, 0, 0, 252, 245, 1, 0, 0, 0, 252, 249, 1, 0, 0, 0, 253, 13, 1, 0, 0, 0, 254, 257, 3, 194, 97, 0, 255, 256, 5, 12, 0, 0, 256, 258, 3, 194, 97, 0, 257, 255, 1, 0, 0, 0, 257, 258, 1, 0, 0, 0, 258, 15, 1, 0, 0, 0, 259, 260, 5, 13, 0, 0, 260, 263, 3, 18, 9, 0, 261, 262, 5, 12, 0, 0, 262, 264, 3, 194, 97, 0, 263, 261, 1, 0, 0, 0, 263, 264, 1, 0, 0, 0, 264, 265, 1, 0, 0, 0, 265, 266, 5, 2, 0, 0, 266, 296, 1, 0, 0, 0, 267, 270, 5, 13, 0, 0, 268, 271, 5, 3, 0, 0, 269, 271, 3, 194, 97, 0, 270, 268, 1, 0, 0, 0, 270, 269, 1, 0, 0, 0, 271, 274, 1, 0, 0, 0, 272, 273, 5, 12, 0, 0, 273, 275, 3, 194, 97, 0, 274, 272, 1, 0, 0, 0, 274, 275, 1, 0, 0, 0, 275, 276, 1, 0, 0, 0, 276, 277, 5, 14, 0, 0, 277, 278, 3, 18, 9, 0, 278, 279, 5, 2, 0, 0, 279, 296, 1, 0, 0, 0, 280, 281, 5, 13, 0, 0, 281, 282, 5, 15, 0, 0, 282, 287, 3, 14, 7, 0, 283, 284, 5, 16, 0, 0, 284, 286, 3, 14, 7, 0, 285, 283, 1, 0, 0, 0, 286, 289, 1, 0, 0, 0, 287, 285, 1, 0, 0, 0, 287, 288, 1, 0, 0, 0, 288, 290, 1, 0, 0, 0, 289, 287, 1, 0, 0, 0, 290, 291, 5, 17, 0, 0, 291, 292, 5, 14, 0, 0, 292, 293, 3, 18, 9, 0, 293, 294, 5, 2, 0, 0, 294, 296, 1, 0, 0, 0, 295, 259, 1, 0, 0, 0, 295, 267, 1, 0, 0, 0, 295, 280, 1, 0, 0, 0, 296, 17, 1, 0, 0, 0, 297, 298, 5, 130, 0, 0, 298, 19, 1, 0, 0, 0, 299, 301, 5, 18, 0, 0, 300, 299, 1, 0, 0, 0, 300, 301, 1, 0, 0, 0, 301, 302, 1, 0, 0, 0, 302, 303, 7, 1, 0, 0, 303, 313, 3, 194, 97, 0, 304, 305, 5, 22, 0, 0, 305, 310, 3, 22, 11, 0, 306, 307, 5, 16, 0, 0, 307, 309, 3, 22, 11, 0, 308, 306, 1, 0, 0, 0, 309, 312, 1, 0, 0, 0, 310, 308, 1, 0, 0, 0, 310, 311, 1, 0, 0, 0, 311, 314, 1, 0, 0, 0, 312, 310, 1, 0, 0, 0, 313, 304, 1, 0, 0, 0, 313, 314, 1, 0, 0, 0, 314, 315, 1, 0, 0, 0, 315, 319, 5, 15, 0, 0, 316, 318, 3, 24, 12, 0, 317, 316, 1, 0, 0, 0, 318, 321, 1, 0, 0, 0, 319, 317, 1, 0, 0, 0, 319, 320, 1, 0, 0, 0, 320, 322, 1, 0, 0, 0, 321, 319, 1, 0, 0, 0, 322, 323, 5, 17, 0, 0, 323, 21, 1, 0, 0, 0, 324, 330, 3, 78, 39, 0, 325, 327, 5, 23, 0, 0, 326, 328, 3, 144, 72, 0, 327, 326, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 329, 1, 0, 0, 0, 329, 331, 5, 24, 0, 0, 330, 325, 1, 0, 0, 0, 330, 331, 1, 0, 0, 0, 331, 23, 1, 0, 0, 0, 332, 342, 3, 26, 13, 0, 333, 342, 3, 34, 17, 0, 334, 342, 3, 42, 21, 0, 335, 342, 3, 44, 22, 0, 336, 342, 3, 48, 24, 0, 337, 342, 3, 56, 28, 0, 338, 342, 3, 60, 30, 0, 339, 342, 3, 30, 15, 0, 340, 342, 3, 32, 16, 0, 341, 332, 1, 0, 0, 0, 341, 333, 1, 0, 0, 0, 341, 334, 1, 0, 0, 0, 341, 335, 1, 0, 0, 0, 341, 336, 1, 0, 0, 0, 341, 337, 1, 0, 0, 0, 341, 338, 1, 0, 0, 0, 341, 339, 1, 0, 0, 0, 341, 340, 1, 0, 0, 0, 342, 25, 1, 0, 0, 0, 343, 353, 3, 76, 38, 0, 344, 352, 5, 120, 0, 0, 345, 352, 5, 117, 0, 0, 346, 352, 5, 119, 0, 0, 347, 352, 5, 110, 0, 0, 348, 352, 5, 111, 0, 0, 349, 352, 5, 112, 0, 0, 350, 352, 3, 198, 99, 0, 351, 344, 1, 0, 0, 0, 351, 345, 1, 0, 0, 0, 351, 346, 1, 0, 0, 0, 351, 347, 1, 0, 0, 0, 351, 348, 1, 0, 0, 0, 351, 349, 1, 0, 0, 0, 351, 350, 1, 0, 0, 0, 352, 355, 1, 0, 0, 0, 353, 351, 1, 0, 0, 0, 353, 354, 1, 0, 0, 0, 354, 356, 1, 0, 0, 0, 355, 353, 1, 0, 0, 0, 356, 359, 3, 194, 97, 0, 357, 358, 5, 11, 0, 0, 358, 360, 3, 140, 70, 0, 359, 357, 1, 0, 0, 0, 359, 360, 1, 0, 0, 0, 360, 361, 1, 0, 0, 0, 361, 362, 5, 2, 0, 0, 362, 27, 1, 0, 0, 0, 363, 364, 3, 76, 38, 0, 364, 365, 5, 110, 0, 0, 365, 366, 3, 194, 97, 0, 366, 367, 5, 11, 0, 0, 367, 368, 3, 140, 70, 0, 368, 369, 5, 2, 0, 0, 369, 29, 1, 0, 0, 0, 370, 371, 5, 25, 0, 0, 371, 372, 3, 194, 97, 0, 372, 373, 3, 62, 31, 0, 373, 374, 5, 2, 0, 0, 374, 31, 1, 0, 0, 0, 375, 376, 5, 123, 0, 0, 376, 377, 3, 194, 97, 0, 377, 378, 5, 22, 0, 0, 378, 379, 3, 138, 69, 0, 379, 380, 5, 2, 0, 0, 380, 33, 1, 0, 0, 0, 381, 382, 5, 26, 0, 0, 382, 383, 3, 36, 18, 0, 383, 386, 5, 27, 0, 0, 384, 387, 5, 3, 0, 0, 385, 387, 3, 76, 38, 0, 386, 384, 1, 0, 0, 0, 386, 385, 1, 0, 0, 0, 387, 389, 1, 0, 0, 0, 388, 390, 5, 125, 0, 0, 389, 388, 1, 0, 0, 0, 389, 390, 1, 0, 0, 0, 390, 391, 1, 0, 0, 0, 391, 392, 5, 2, 0, 0, 392, 35, 1, 0, 0, 0, 393, 406, 3, 78, 39, 0, 394, 395, 5, 15, 0, 0, 395, 400, 3, 38, 19, 0, 396, 397, 5, 16, 0, 0, 397, 399, 3, 38, 19, 0, 398, 396, 1, 0, 0, 0, 399, 402, 1, 0, 0, 0, 400, 398, 1, 0, 0, 0, 400, 401, 1, 0, 0, 0, 401, 403, 1, 0, 0, 0, 402, 400, 1, 0, 0, 0, 403, 404, 5, 17, 0, 0, 404, 406, 1, 0, 0, 0, 405, 393, 1, 0, 0, 0, 405, 394, 1, 0, 0, 0, 406, 37, 1, 0, 0, 0, 407, 410, 3, 78, 39, 0, 408, 409, 5, 12, 0, 0, 409, 411, 3, 40, 20, 0, 410, 408, 1, 0, 0, 0, 410, 411, 1, 0, 0, 0, 411, 39, 1, 0, 0, 0, 412, 413, 7, 2, 0, 0, 413, 41, 1, 0, 0, 0, 414, 415, 5, 36, 0, 0, 415, 416, 3, 194, 97, 0, 416, 427, 5, 15, 0, 0, 417, 418, 3, 74, 37, 0, 418, 424, 5, 2, 0, 0, 419, 420, 3, 74, 37, 0, 420, 421, 5, 2, 0, 0, 421, 423, 1, 0, 0, 0, 422, 419, 1, 0, 0, 0, 423, 426, 1, 0, 0, 0, 424, 422, 1, 0, 0, 0, 424, 425, 1, 0, 0, 0, 425, 428, 1, 0, 0, 0, 426, 424, 1, 0, 0, 0, 427, 417, 1, 0, 0, 0, 427, 428, 1, 0, 0, 0, 428, 429, 1, 0, 0, 0, 429, 430, 5, 17, 0, 0, 430, 43, 1, 0, 0, 0, 431, 432, 5, 37, 0, 0, 432, 434, 3, 194, 97, 0, 433, 435, 3, 62, 31, 0, 434, 433, 1, 0, 0, 0, 434, 435, 1, 0, 0, 0, 435, 440, 1, 0, 0, 0, 436, 439, 5, 121, 0, 0, 437, 439, 3, 198, 99, 0, 438, 436, 1, 0, 0, 0, 438, 437, 1, 0, 0, 0, 439, 442, 1, 0, 0, 0, 440, 438, 1, 0, 0, 0, 440, 441, 1, 0, 0, 0, 441, 445, 1, 0, 0, 0, 442, 440, 1, 0, 0, 0, 443, 446, 5, 2, 0, 0, 444, 446, 3, 94, 47, 0, 445, 443, 1, 0, 0, 0, 445, 444, 1, 0, 0, 0, 446, 45, 1, 0, 0, 0, 447, 453, 3, 194, 97, 0, 448, 450, 5, 23, 0, 0, 449, 451, 3, 144, 72, 0, 450, 449, 1, 0, 0, 0, 450, 451, 1, 0, 0, 0, 451, 452, 1, 0, 0, 0, 452, 454, 5, 24, 0, 0, 453, 448, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 47, 1, 0, 0, 0, 455, 456, 3, 50, 25, 0, 456, 457, 3, 62, 31, 0, 457, 459, 3, 54, 27, 0, 458, 460, 3, 52, 26, 0, 459, 458, 1, 0, 0, 0, 459, 460, 1, 0, 0, 0, 460, 463, 1, 0, 0, 0, 461, 464, 5, 2, 0, 0, 462, 464, 3, 94, 47, 0, 463, 461, 1, 0, 0, 0, 463, 462, 1, 0, 0, 0, 464, 49, 1, 0, 0, 0, 465, 467, 5, 38, 0, 0, 466, 468, 3, 194, 97, 0, 467, 466, 1, 0, 0, 0, 467, 468, 1, 0, 0, 0, 468, 473, 1, 0, 0, 0, 469, 473, 5, 126, 0, 0, 470, 473, 5, 127, 0, 0, 471, 473, 5, 128, 0, 0, 472, 465, 1, 0, 0, 0, 472, 469, 1, 0, 0, 0, 472, 470, 1, 0, 0, 0, 472, 471, 1, 0, 0, 0, 473, 51, 1, 0, 0, 0, 474, 475, 5, 39, 0, 0, 475, 476, 3, 62, 31, 0, 476, 53, 1, 0, 0, 0, 477, 486, 5, 115, 0, 0, 478, 486, 5, 120, 0, 0, 479, 486, 5, 117, 0, 0, 480, 486, 5, 119, 0, 0, 481, 486, 5, 121, 0, 0, 482, 486, 3, 92, 46, 0, 483, 486, 3, 46, 23, 0, 484, 486, 3, 198, 99, 0, 485, 477, 1, 0, 0, 0, 485, 478, 1, 0, 0, 0, 485, 479, 1, 0, 0, 0, 485, 480, 1, 0, 0, 0, 485, 481, 1, 0, 0, 0, 485, 482, 1, 0, 0, 0, 485, 483, 1, 0, 0, 0, 485, 484, 1, 0, 0, 0, 486, 489, 1, 0, 0, 0, 487, 485, 1, 0, 0, 0, 487, 488, 1, 0, 0, 0, 488, 55, 1, 0, 0, 0, 489, 487, 1, 0, 0, 0, 490, 491, 5, 40, 0, 0, 491, 492, 3, 194, 97, 0, 492, 494, 3, 66, 33, 0, 493, 495, 5, 108, 0, 0, 494, 493, 1, 0, 0, 0, 494, 495, 1, 0, 0, 0, 495, 496, 1, 0, 0, 0, 496, 497, 5, 2, 0, 0, 497, 57, 1, 0, 0, 0, 498, 499, 3, 194, 97, 0, 499, 59, 1, 0, 0, 0, 500, 501, 5, 41, 0, 0, 501, 502, 3, 194, 97, 0, 502, 504, 5, 15, 0, 0, 503, 505, 3, 58, 29, 0, 504, 503, 1, 0, 0, 0, 504, 505, 1, 0, 0, 0, 505, 510, 1, 0, 0, 0, 506, 507, 5, 16, 0, 0, 507, 509, 3, 58, 29, 0, 508, 506, 1, 0, 0, 0, 509, 512, 1, 0, 0, 0, 510, 508, 1, 0, 0, 0, 510, 511, 1, 0, 0, 0, 511, 513, 1, 0, 0, 0, 512, 510, 1, 0, 0, 0, 513, 514, 5, 17, 0, 0, 514, 61, 1, 0, 0, 0, 515, 524, 5, 23, 0, 0, 516, 521, 3, 64, 32, 0, 517, 518, 5, 16, 0, 0, 518, 520, 3, 64, 32, 0, 519, 517, 1, 0, 0, 0, 520, 523, 1, 0, 0, 0, 521, 519, 1, 0, 0, 0, 521, 522, 1, 0, 0, 0, 522, 525, 1, 0, 0, 0, 523, 521, 1, 0, 0, 0, 524, 516, 1, 0, 0, 0, 524, 525, 1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526, 527, 5, 24, 0, 0, 527, 63, 1, 0, 0, 0, 528, 530, 3, 76, 38, 0, 529, 531, 3, 90, 45, 0, 530, 529, 1, 0, 0, 0, 530, 531, 1, 0, 0, 0, 531, 533, 1, 0, 0, 0, 532, 534, 3, 194, 97, 0, 533, 532, 1, 0, 0, 0, 533, 534, 1, 0, 0, 0, 534, 65, 1, 0, 0, 0, 535, 544, 5, 23, 0, 0, 536, 541, 3, 68, 34, 0, 537, 538, 5, 16, 0, 0, 538, 540, 3, 68, 34, 0, 539, 537, 1, 0, 0, 0, 540, 543, 1, 0, 0, 0, 541, 539, 1, 0, 0, 0, 541, 542, 1, 0, 0, 0, 542, 545, 1, 0, 0, 0, 543, 541, 1, 0, 0, 0, 544, 536, 1, 0, 0, 0, 544, 545, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 547, 5, 24, 0, 0, 547, 67, 1, 0, 0, 0, 548, 550, 3, 76, 38, 0, 549, 551, 5, 116, 0, 0, 550, 549, 1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 553, 1, 0, 0, 0, 552, 554, 3, 194, 97, 0, 553, 552, 1, 0, 0, 0, 553, 554, 1, 0, 0, 0, 554, 69, 1, 0, 0, 0, 555, 564, 5, 23, 0, 0, 556, 561, 3, 72, 36, 0, 557, 558, 5, 16, 0, 0, 558, 560, 3, 72, 36, 0, 559, 557, 1, 0, 0, 0, 560, 563, 1, 0, 0, 0, 561, 559, 1, 0, 0, 0, 561, 562, 1, 0, 0, 0, 562, 565, 1, 0, 0, 0, 563, 561, 1, 0, 0, 0, 564, 556, 1, 0, 0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 567, 5, 24, 0, 0, 567, 71, 1, 0, 0, 0, 568, 570, 3, 76, 38, 0, 569, 571, 3, 90, 45, 0, 570, 569, 1, 0, 0, 0, 570, 571, 1, 0, 0, 0, 571, 73, 1, 0, 0, 0, 572, 574, 3, 76, 38, 0, 573, 575, 3, 90, 45, 0, 574, 573, 1, 0, 0, 0, 574, 575, 1, 0, 0, 0, 575, 576, 1, 0, 0, 0, 576, 577, 3, 194, 97, 0, 577, 75, 1, 0, 0, 0, 578, 579, 6, 38, -1, 0, 579, 586, 3, 138, 69, 0, 580, 586, 3, 78, 39, 0, 581, 586, 3, 82, 41, 0, 582, 586, 3, 88, 44, 0, 583, 584, 5, 44, 0, 0, 584, 586, 5, 118, 0, 0, 585, 578, 1, 0, 0, 0, 585, 580, 1, 0, 0, 0, 585, 581, 1, 0, 0, 0, 585, 582, 1, 0, 0, 0, 585, 583, 1, 0, 0, 0, 586, 595, 1, 0, 0, 0, 587, 588, 10, 3, 0, 0, 588, 590, 5, 42, 0, 0, 589, 591, 3, 140, 70, 0, 590, 589, 1, 0, 0, 0, 590, 591, 1, 0, 0, 0, 591, 592, 1, 0, 0, 0, 592, 594, 5, 43, 0, 0, 593, 587, 1, 0, 0, 0, 594, 597, 1, 0, 0, 0, 595, 593, 1, 0, 0, 0, 595, 596, 1, 0, 0, 0, 596, 77, 1, 0, 0, 0, 597, 595, 1, 0, 0, 0, 598, 603, 3, 194, 97, 0, 599, 600, 5, 45, 0, 0, 600, 602, 3, 194, 97, 0, 601, 599, 1, 0, 0, 0, 602, 605, 1, 0, 0, 0, 603, 601, 1, 0, 0, 0, 603, 604, 1, 0, 0, 0, 604, 79, 1, 0, 0, 0, 605, 603, 1, 0, 0, 0, 606, 609, 3, 138, 69, 0, 607, 609, 3, 78, 39, 0, 608, 606, 1, 0, 0, 0, 608, 607, 1, 0, 0, 0, 609, 81, 1, 0, 0, 0, 610, 611, 5, 46, 0, 0, 611, 612, 5, 23, 0, 0, 612, 614, 3, 80, 40, 0, 613, 615, 3, 84, 42, 0, 614, 613, 1, 0, 0, 0, 614, 615, 1, 0, 0, 0, 615, 616, 1, 0, 0, 0, 616, 617, 5, 47, 0, 0, 617, 619, 3, 76, 38, 0, 618, 620, 3, 86, 43, 0, 619, 618, 1, 0, 0, 0, 619, 620, 1, 0, 0, 0, 620, 621, 1, 0, 0, 0, 621, 622, 5, 24, 0, 0, 622, 83, 1, 0, 0, 0, 623, 624, 3, 194, 97, 0, 624, 85, 1, 0, 0, 0, 625, 626, 3, 194, 97, 0, 626, 87, 1, 0, 0, 0, 627, 628, 5, 38, 0, 0, 628, 634, 3, 70, 35, 0, 629, 633, 5, 117, 0, 0, 630, 633, 5, 115, 0, 0, 631, 633, 3, 92, 46, 0, 632, 629, 1, 0, 0, 0, 632, 630, 1, 0, 0, 0, 632, 631, 1, 0, 0, 0, 633, 636, 1, 0, 0, 0, 634, 632, 1, 0, 0, 0, 634, 635, 1, 0, 0, 0, 635, 639, 1, 0, 0, 0, 636, 634, 1, 0, 0, 0, 637, 638, 5, 39, 0, 0, 638, 640, 3, 70, 35, 0, 639, 637, 1, 0, 0, 0, 639, 640, 1, 0, 0, 0, 640, 89, 1, 0, 0, 0, 641, 642, 7, 3, 0, 0, 642, 91, 1, 0, 0, 0, 643, 644, 7, 4, 0, 0, 644, 93, 1, 0, 0, 0, 645, 649, 5, 15, 0, 0, 646, 648, 3, 96, 48, 0, 647, 646, 1, 0, 0, 0, 648, 651, 1, 0, 0, 0, 649, 647, 1, 0, 0, 0, 649, 650, 1, 0, 0, 0, 650, 652, 1, 0, 0, 0, 651, 649, 1, 0, 0, 0, 652, 653, 5, 17, 0, 0, 653, 95, 1, 0, 0, 0, 654, 670, 3, 100, 50, 0, 655, 670, 3, 102, 51, 0, 656, 670, 3, 106, 53, 0, 657, 670, 3, 112, 56, 0, 658, 670, 3, 94, 47, 0, 659, 670, 3, 114, 57, 0, 660, 670, 3, 118, 59, 0, 661, 670, 3, 120, 60, 0, 662, 670, 3, 122, 61, 0, 663, 670, 3, 124, 62, 0, 664, 670, 3, 126, 63, 0, 665, 670, 3, 128, 64, 0, 666, 670, 3, 108, 54, 0, 667, 670, 3, 110, 55, 0, 668, 670, 3, 130, 65, 0, 669, 654, 1, 0, 0, 0, 669, 655, 1, 0, 0, 0, 669, 656, 1, 0, 0, 0, 669, 657, 1, 0, 0, 0, 669, 658, 1, 0, 0, 0, 669, 659, 1, 0, 0, 0, 669, 660, 1, 0, 0, 0, 669, 661, 1, 0, 0, 0, 669, 662, 1, 0, 0, 0, 669, 663, 1, 0, 0, 0, 669, 664, 1, 0, 0, 0, 669, 665, 1, 0, 0, 0, 669, 666, 1, 0, 0, 0, 669, 667, 1, 0, 0, 0, 669, 668, 1, 0, 0, 0, 670, 97, 1, 0, 0, 0, 671, 672, 3, 140, 70, 0, 672, 673, 5, 2, 0, 0, 673, 99, 1, 0, 0, 0, 674, 675, 5, 51, 0, 0, 675, 676, 5, 23, 0, 0, 676, 677, 3, 140, 70, 0, 677, 678, 5, 24, 0, 0, 678, 681, 3, 96, 48, 0, 679, 680, 5, 52, 0, 0, 680, 682, 3, 96, 48, 0, 681, 679, 1, 0, 0, 0, 681, 682, 1, 0, 0, 0, 682, 101, 1, 0, 0, 0, 683, 684, 5, 53, 0, 0, 684, 686, 3, 140, 70, 0, 685, 687, 3, 52, 26, 0, 686, 685, 1, 0, 0, 0, 686, 687, 1, 0, 0, 0, 687, 688, 1, 0, 0, 0, 688, 690, 3, 94, 47, 0, 689, 691, 3, 104, 52, 0, 690, 689, 1, 0, 0, 0, 691, 692, 1, 0, 0, 0, 692, 690, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 693, 103, 1, 0, 0, 0, 694, 699, 5, 54, 0, 0, 695, 697, 3, 194, 97, 0, 696, 695, 1, 0, 0, 0, 696, 697, 1, 0, 0, 0, 697, 698, 1, 0, 0, 0, 698, 700, 3, 62, 31, 0, 699, 696, 1, 0, 0, 0, 699, 700, 1, 0, 0, 0, 700, 701, 1, 0, 0, 0, 701, 702, 3, 94, 47, 0, 702, 105, 1, 0, 0, 0, 703, 704, 5, 55, 0, 0, 704, 705, 5, 23, 0, 0, 705, 706, 3, 140, 70, 0, 706, 707, 5, 24, 0, 0, 707, 708, 3, 96, 48, 0, 708, 107, 1, 0, 0, 0, 709, 712, 3, 132, 66, 0, 710, 712, 3, 98, 49, 0, 711, 709, 1, 0, 0, 0, 711, 710, 1, 0, 0, 0, 712, 109, 1, 0, 0, 0, 713, 714, 5, 56, 0, 0, 714, 715, 3, 94, 47, 0, 715, 111, 1, 0, 0, 0, 716, 717, 5, 27, 0, 0, 717, 720, 5, 23, 0, 0, 718, 721, 3, 108, 54, 0, 719, 721, 5, 2, 0, 0, 720, 718, 1, 0, 0, 0, 720, 719, 1, 0, 0, 0, 721, 724, 1, 0, 0, 0, 722, 725, 3, 98, 49, 0, 723, 725, 5, 2, 0, 0, 724, 722, 1, 0, 0, 0, 724, 723, 1, 0, 0, 0, 725, 727, 1, 0, 0, 0, 726, 728, 3, 140, 70, 0, 727, 726, 1, 0, 0, 0, 727, 728, 1, 0, 0, 0, 728, 729, 1, 0, 0, 0, 729, 730, 5, 24, 0, 0, 730, 731, 3, 96, 48, 0, 731, 113, 1, 0, 0, 0, 732, 734, 5, 57, 0, 0, 733, 735, 5, 130, 0, 0, 734, 733, 1, 0, 0, 0, 734, 735, 1, 0, 0, 0, 735, 740, 1, 0, 0, 0, 736, 737, 5, 23, 0, 0, 737, 738, 3, 116, 58, 0, 738, 739, 5, 24, 0, 0, 739, 741, 1, 0, 0, 0, 740, 736, 1, 0, 0, 0, 740, 741, 1, 0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 743, 3, 154, 77, 0, 743, 115, 1, 0, 0, 0, 744, 745, 3, 200, 100, 0, 745, 117, 1, 0, 0, 0, 746, 747, 5, 58, 0, 0, 747, 748, 3, 96, 48, 0, 748, 749, 5, 55, 0, 0, 749, 750, 5, 23, 0, 0, 750, 751, 3, 140, 70, 0, 751, 752, 5, 24, 0, 0, 752, 753, 5, 2, 0, 0, 753, 119, 1, 0, 0, 0, 754, 755, 5, 113, 0, 0, 755, 756, 5, 2, 0, 0, 756, 121, 1, 0, 0, 0, 757, 758, 5, 109, 0, 0, 758, 759, 5, 2, 0, 0, 759, 123, 1, 0, 0, 0, 760, 762, 5, 59, 0, 0, 761, 763, 3, 140, 70, 0, 762, 761, 1, 0, 0, 0, 762, 763, 1, 0, 0, 0, 763, 764, 1, 0, 0, 0, 764, 765, 5, 2, 0, 0, 765, 125, 1, 0, 0, 0, 766, 767, 5, 60, 0, 0, 767, 768, 5, 2, 0, 0, 768, 127, 1, 0, 0, 0, 769, 770, 5, 61, 0, 0, 770, 771, 3, 152, 76, 0, 771, 772, 5, 2, 0, 0, 772, 129, 1, 0, 0, 0, 773, 774, 5, 62, 0, 0, 774, 775, 3, 152, 76, 0, 775, 776, 5, 2, 0, 0, 776, 131, 1, 0, 0, 0, 777, 778, 5, 63, 0, 0, 778, 785, 3, 136, 68, 0, 779, 785, 3, 74, 37, 0, 780, 781, 5, 23, 0, 0, 781, 782, 3, 134, 67, 0, 782, 783, 5, 24, 0, 0, 783, 785, 1, 0, 0, 0, 784, 777, 1, 0, 0, 0, 784, 779, 1, 0, 0, 0, 784, 780, 1, 0, 0, 0, 785, 788, 1, 0, 0, 0, 786, 787, 5, 11, 0, 0, 787, 789, 3, 140, 70, 0, 788, 786, 1, 0, 0, 0, 788, 789, 1, 0, 0, 0, 789, 790, 1, 0, 0, 0, 790, 791, 5, 2, 0, 0, 791, 133, 1, 0, 0, 0, 792, 794, 3, 74, 37, 0, 793, 792, 1, 0, 0, 0, 793, 794, 1, 0, 0, 0, 794, 801, 1, 0, 0, 0, 795, 797, 5, 16, 0, 0, 796, 798, 3, 74, 37, 0, 797, 796, 1, 0, 0, 0, 797, 798, 1, 0, 0, 0, 798, 800, 1, 0, 0, 0, 799, 795, 1, 0, 0, 0, 800, 803, 1, 0, 0, 0, 801, 799, 1, 0, 0, 0, 801, 802, 1, 0, 0, 0, 802, 135, 1, 0, 0, 0, 803, 801, 1, 0, 0, 0, 804, 811, 5, 23, 0, 0, 805, 807, 3, 194, 97, 0, 806, 805, 1, 0, 0, 0, 806, 807, 1, 0, 0, 0, 807, 808, 1, 0, 0, 0, 808, 810, 5, 16, 0, 0, 809, 806, 1, 0, 0, 0, 810, 813, 1, 0, 0, 0, 811, 809, 1, 0, 0, 0, 811, 812, 1, 0, 0, 0, 812, 815, 1, 0, 0, 0, 813, 811, 1, 0, 0, 0, 814, 816, 3, 194, 97, 0, 815, 814, 1, 0, 0, 0, 815, 816, 1, 0, 0, 0, 816, 817, 1, 0, 0, 0, 817, 818, 5, 24, 0, 0, 818, 137, 1, 0, 0, 0, 819, 820, 7, 5, 0, 0, 820, 139, 1, 0, 0, 0, 821, 822, 6, 70, -1, 0, 822, 823, 5, 69, 0, 0, 823, 840, 3, 76, 38, 0, 824, 825, 5, 23, 0, 0, 825, 826, 3, 140, 70, 0, 826, 827, 5, 24, 0, 0, 827, 840, 1, 0, 0, 0, 828, 829, 7, 6, 0, 0, 829, 840, 3, 140, 70, 19, 830, 831, 7, 7, 0, 0, 831, 840, 3, 140, 70, 18, 832, 833, 5, 71, 0, 0, 833, 840, 3, 140, 70, 17, 834, 835, 5, 72, 0, 0, 835, 840, 3, 140, 70, 16, 836, 837, 5, 6, 0, 0, 837, 840, 3, 140, 70, 15, 838, 840, 3, 142, 71, 0, 839, 821, 1, 0, 0, 0, 839, 824, 1, 0, 0, 0, 839, 828, 1, 0, 0, 0, 839, 830, 1, 0, 0, 0, 839, 832, 1, 0, 0, 0, 839, 834, 1, 0, 0, 0, 839, 836, 1, 0, 0, 0, 839, 838, 1, 0, 0, 0, 840, 915, 1, 0, 0, 0, 841, 842, 10, 14, 0, 0, 842, 843, 5, 73, 0, 0, 843, 914, 3, 140, 70, 14, 844, 845, 10, 13, 0, 0, 845, 846, 7, 8, 0, 0, 846, 914, 3, 140, 70, 14, 847, 848, 10, 12, 0, 0, 848, 849, 7, 7, 0, 0, 849, 914, 3, 140, 70, 13, 850, 851, 10, 11, 0, 0, 851, 852, 7, 9, 0, 0, 852, 914, 3, 140, 70, 12, 853, 854, 10, 10, 0, 0, 854, 855, 5, 29, 0, 0, 855, 914, 3, 140, 70, 11, 856, 857, 10, 9, 0, 0, 857, 858, 5, 5, 0, 0, 858, 914, 3, 140, 70, 10, 859, 860, 10, 8, 0, 0, 860, 861, 5, 28, 0, 0, 861, 914, 3, 140, 70, 9, 862, 863, 10, 7, 0, 0, 863, 864, 7, 10, 0, 0, 864, 914, 3, 140, 70, 8, 865, 866, 10, 6, 0, 0, 866, 867, 7, 11, 0, 0, 867, 914, 3, 140, 70, 7, 868, 869, 10, 5, 0, 0, 869, 870, 5, 76, 0, 0, 870, 914, 3, 140, 70, 6, 871, 872, 10, 4, 0, 0, 872, 873, 5, 4, 0, 0, 873, 914, 3, 140, 70, 5, 874, 875, 10, 3, 0, 0, 875, 876, 5, 77, 0, 0, 876, 877, 3, 140, 70, 0, 877, 878, 5, 70, 0, 0, 878, 879, 3, 140, 70, 3, 879, 914, 1, 0, 0, 0, 880, 881, 10, 2, 0, 0, 881, 882, 7, 12, 0, 0, 882, 914, 3, 140, 70, 3, 883, 884, 10, 27, 0, 0, 884, 914, 7, 6, 0, 0, 885, 886, 10, 25, 0, 0, 886, 887, 5, 42, 0, 0, 887, 888, 3, 140, 70, 0, 888, 889, 5, 43, 0, 0, 889, 914, 1, 0, 0, 0, 890, 891, 10, 24, 0, 0, 891, 893, 5, 42, 0, 0, 892, 894, 3, 140, 70, 0, 893, 892, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 895, 1, 0, 0, 0, 895, 897, 5, 70, 0, 0, 896, 898, 3, 140, 70, 0, 897, 896, 1, 0, 0, 0, 897, 898, 1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 914, 5, 43, 0, 0, 900, 901, 10, 23, 0, 0, 901, 902, 5, 45, 0, 0, 902, 914, 3, 194, 97, 0, 903, 904, 10, 22, 0, 0, 904, 905, 5, 15, 0, 0, 905, 906, 3, 146, 73, 0, 906, 907, 5, 17, 0, 0, 907, 914, 1, 0, 0, 0, 908, 909, 10, 21, 0, 0, 909, 910, 5, 23, 0, 0, 910, 911, 3, 150, 75, 0, 911, 912, 5, 24, 0, 0, 912, 914, 1, 0, 0, 0, 913, 841, 1, 0, 0, 0, 913, 844, 1, 0, 0, 0, 913, 847, 1, 0, 0, 0, 913, 850, 1, 0, 0, 0, 913, 853, 1, 0, 0, 0, 913, 856, 1, 0, 0, 0, 913, 859, 1, 0, 0, 0, 913, 862, 1, 0, 0, 0, 913, 865, 1, 0, 0, 0, 913, 868, 1, 0, 0, 0, 913, 871, 1, 0, 0, 0, 913, 874, 1, 0, 0, 0, 913, 880, 1, 0, 0, 0, 913, 883, 1, 0, 0, 0, 913, 885, 1, 0, 0, 0, 913, 890, 1, 0, 0, 0, 913, 900, 1, 0, 0, 0, 913, 903, 1, 0, 0, 0, 913, 908, 1, 0, 0, 0, 914, 917, 1, 0, 0, 0, 915, 913, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 141, 1, 0, 0, 0, 917, 915, 1, 0, 0, 0, 918, 928, 5, 102, 0, 0, 919, 928, 3, 192, 96, 0, 920, 928, 3, 196, 98, 0, 921, 928, 3, 200, 100, 0, 922, 928, 3, 194, 97, 0, 923, 928, 5, 123, 0, 0, 924, 928, 5, 118, 0, 0, 925, 928, 3, 190, 95, 0, 926, 928, 3, 76, 38, 0, 927, 918, 1, 0, 0, 0, 927, 919, 1, 0, 0, 0, 927, 920, 1, 0, 0, 0, 927, 921, 1, 0, 0, 0, 927, 922, 1, 0, 0, 0, 927, 923, 1, 0, 0, 0, 927, 924, 1, 0, 0, 0, 927, 925, 1, 0, 0, 0, 927, 926, 1, 0, 0, 0, 928, 143, 1, 0, 0, 0, 929, 934, 3, 140, 70, 0, 930, 931, 5, 16, 0, 0, 931, 933, 3, 140, 70, 0, 932, 930, 1, 0, 0, 0, 933, 936, 1, 0, 0, 0, 934, 932, 1, 0, 0, 0, 934, 935, 1, 0, 0, 0, 935, 145, 1, 0, 0, 0, 936, 934, 1, 0, 0, 0, 937, 942, 3, 148, 74, 0, 938, 939, 5, 16, 0, 0, 939, 941, 3, 148, 74, 0, 940, 938, 1, 0, 0, 0, 941, 944, 1, 0, 0, 0, 942, 940, 1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 946, 1, 0, 0, 0, 944, 942, 1, 0, 0, 0, 945, 947, 5, 16, 0, 0, 946, 945, 1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 147, 1, 0, 0, 0, 948, 949, 3, 194, 97, 0, 949, 950, 5, 70, 0, 0, 950, 951, 3, 140, 70, 0, 951, 149, 1, 0, 0, 0, 952, 954, 5, 15, 0, 0, 953, 955, 3, 146, 73, 0, 954, 953, 1, 0, 0, 0, 954, 955, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 961, 5, 17, 0, 0, 957, 959, 3, 144, 72, 0, 958, 957, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 961, 1, 0, 0, 0, 960, 952, 1, 0, 0, 0, 960, 958, 1, 0, 0, 0, 961, 151, 1, 0, 0, 0, 962, 963, 3, 140, 70, 0, 963, 964, 5, 23, 0, 0, 964, 965, 3, 150, 75, 0, 965, 966, 5, 24, 0, 0, 966, 153, 1, 0, 0, 0, 967, 971, 5, 15, 0, 0, 968, 970, 3, 156, 78, 0, 969, 968, 1, 0, 0, 0, 970, 973, 1, 0, 0, 0, 971, 969, 1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 974, 1, 0, 0, 0, 973, 971, 1, 0, 0, 0, 974, 975, 5, 17, 0, 0, 975, 155, 1, 0, 0, 0, 976, 994, 3, 194, 97, 0, 977, 994, 3, 154, 77, 0, 978, 994, 3, 158, 79, 0, 979, 994, 3, 164, 82, 0, 980, 994, 3, 166, 83, 0, 981, 994, 3, 172, 86, 0, 982, 994, 3, 174, 87, 0, 983, 994, 3, 176, 88, 0, 984, 994, 3, 180, 90, 0, 985, 994, 3, 184, 92, 0, 986, 994, 3, 186, 93, 0, 987, 994, 5, 109, 0, 0, 988, 994, 5, 113, 0, 0, 989, 994, 5, 114, 0, 0, 990, 994, 3, 192, 96, 0, 991, 994, 3, 200, 100, 0, 992, 994, 3, 196, 98, 0, 993, 976, 1, 0, 0, 0, 993, 977, 1, 0, 0, 0, 993, 978, 1, 0, 0, 0, 993, 979, 1, 0, 0, 0, 993, 980, 1, 0, 0, 0, 993, 981, 1, 0, 0, 0, 993, 982, 1, 0, 0, 0, 993, 983, 1, 0, 0, 0, 993, 984, 1, 0, 0, 0, 993, 985, 1, 0, 0, 0, 993, 986, 1, 0, 0, 0, 993, 987, 1, 0, 0, 0, 993, 988, 1, 0, 0, 0, 993, 989, 1, 0, 0, 0, 993, 990, 1, 0, 0, 0, 993, 991, 1, 0, 0, 0, 993, 992, 1, 0, 0, 0, 994, 157, 1, 0, 0, 0, 995, 999, 3, 162, 81, 0, 996, 999, 3, 188, 94, 0, 997, 999, 3, 160, 80, 0, 998, 995, 1, 0, 0, 0, 998, 996, 1, 0, 0, 0, 998, 997, 1, 0, 0, 0, 999, 159, 1, 0, 0, 0, 1e3, 1001, 3, 194, 97, 0, 1001, 1002, 5, 45, 0, 0, 1002, 1003, 3, 194, 97, 0, 1003, 161, 1, 0, 0, 0, 1004, 1009, 5, 59, 0, 0, 1005, 1009, 5, 44, 0, 0, 1006, 1009, 5, 66, 0, 0, 1007, 1009, 3, 194, 97, 0, 1008, 1004, 1, 0, 0, 0, 1008, 1005, 1, 0, 0, 0, 1008, 1006, 1, 0, 0, 0, 1008, 1007, 1, 0, 0, 0, 1009, 1022, 1, 0, 0, 0, 1010, 1012, 5, 23, 0, 0, 1011, 1013, 3, 158, 79, 0, 1012, 1011, 1, 0, 0, 0, 1012, 1013, 1, 0, 0, 0, 1013, 1018, 1, 0, 0, 0, 1014, 1015, 5, 16, 0, 0, 1015, 1017, 3, 158, 79, 0, 1016, 1014, 1, 0, 0, 0, 1017, 1020, 1, 0, 0, 0, 1018, 1016, 1, 0, 0, 0, 1018, 1019, 1, 0, 0, 0, 1019, 1021, 1, 0, 0, 0, 1020, 1018, 1, 0, 0, 0, 1021, 1023, 5, 24, 0, 0, 1022, 1010, 1, 0, 0, 0, 1022, 1023, 1, 0, 0, 0, 1023, 163, 1, 0, 0, 0, 1024, 1025, 5, 88, 0, 0, 1025, 1028, 3, 168, 84, 0, 1026, 1027, 5, 89, 0, 0, 1027, 1029, 3, 158, 79, 0, 1028, 1026, 1, 0, 0, 0, 1028, 1029, 1, 0, 0, 0, 1029, 165, 1, 0, 0, 0, 1030, 1031, 3, 168, 84, 0, 1031, 1032, 5, 89, 0, 0, 1032, 1033, 3, 158, 79, 0, 1033, 167, 1, 0, 0, 0, 1034, 1042, 3, 194, 97, 0, 1035, 1042, 3, 160, 80, 0, 1036, 1042, 3, 170, 85, 0, 1037, 1038, 5, 23, 0, 0, 1038, 1039, 3, 170, 85, 0, 1039, 1040, 5, 24, 0, 0, 1040, 1042, 1, 0, 0, 0, 1041, 1034, 1, 0, 0, 0, 1041, 1035, 1, 0, 0, 0, 1041, 1036, 1, 0, 0, 0, 1041, 1037, 1, 0, 0, 0, 1042, 169, 1, 0, 0, 0, 1043, 1048, 3, 194, 97, 0, 1044, 1045, 5, 16, 0, 0, 1045, 1047, 3, 194, 97, 0, 1046, 1044, 1, 0, 0, 0, 1047, 1050, 1, 0, 0, 0, 1048, 1046, 1, 0, 0, 0, 1048, 1049, 1, 0, 0, 0, 1049, 171, 1, 0, 0, 0, 1050, 1048, 1, 0, 0, 0, 1051, 1052, 3, 158, 79, 0, 1052, 1053, 5, 90, 0, 0, 1053, 1054, 3, 194, 97, 0, 1054, 173, 1, 0, 0, 0, 1055, 1056, 3, 194, 97, 0, 1056, 1057, 5, 70, 0, 0, 1057, 175, 1, 0, 0, 0, 1058, 1059, 5, 91, 0, 0, 1059, 1063, 3, 158, 79, 0, 1060, 1062, 3, 178, 89, 0, 1061, 1060, 1, 0, 0, 0, 1062, 1065, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 1063, 1064, 1, 0, 0, 0, 1064, 177, 1, 0, 0, 0, 1065, 1063, 1, 0, 0, 0, 1066, 1067, 5, 92, 0, 0, 1067, 1068, 3, 188, 94, 0, 1068, 1069, 3, 154, 77, 0, 1069, 1073, 1, 0, 0, 0, 1070, 1071, 5, 93, 0, 0, 1071, 1073, 3, 154, 77, 0, 1072, 1066, 1, 0, 0, 0, 1072, 1070, 1, 0, 0, 0, 1073, 179, 1, 0, 0, 0, 1074, 1075, 5, 38, 0, 0, 1075, 1076, 3, 194, 97, 0, 1076, 1078, 5, 23, 0, 0, 1077, 1079, 3, 170, 85, 0, 1078, 1077, 1, 0, 0, 0, 1078, 1079, 1, 0, 0, 0, 1079, 1080, 1, 0, 0, 0, 1080, 1082, 5, 24, 0, 0, 1081, 1083, 3, 182, 91, 0, 1082, 1081, 1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 1084, 1, 0, 0, 0, 1084, 1085, 3, 154, 77, 0, 1085, 181, 1, 0, 0, 0, 1086, 1087, 5, 94, 0, 0, 1087, 1088, 3, 170, 85, 0, 1088, 183, 1, 0, 0, 0, 1089, 1092, 5, 27, 0, 0, 1090, 1093, 3, 154, 77, 0, 1091, 1093, 3, 158, 79, 0, 1092, 1090, 1, 0, 0, 0, 1092, 1091, 1, 0, 0, 0, 1093, 1094, 1, 0, 0, 0, 1094, 1097, 3, 158, 79, 0, 1095, 1098, 3, 154, 77, 0, 1096, 1098, 3, 158, 79, 0, 1097, 1095, 1, 0, 0, 0, 1097, 1096, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1100, 3, 154, 77, 0, 1100, 185, 1, 0, 0, 0, 1101, 1102, 5, 51, 0, 0, 1102, 1103, 3, 158, 79, 0, 1103, 1104, 3, 154, 77, 0, 1104, 187, 1, 0, 0, 0, 1105, 1111, 3, 200, 100, 0, 1106, 1111, 5, 103, 0, 0, 1107, 1111, 5, 104, 0, 0, 1108, 1111, 3, 196, 98, 0, 1109, 1111, 5, 102, 0, 0, 1110, 1105, 1, 0, 0, 0, 1110, 1106, 1, 0, 0, 0, 1110, 1107, 1, 0, 0, 0, 1110, 1108, 1, 0, 0, 0, 1110, 1109, 1, 0, 0, 0, 1111, 189, 1, 0, 0, 0, 1112, 1114, 5, 23, 0, 0, 1113, 1115, 3, 140, 70, 0, 1114, 1113, 1, 0, 0, 0, 1114, 1115, 1, 0, 0, 0, 1115, 1122, 1, 0, 0, 0, 1116, 1118, 5, 16, 0, 0, 1117, 1119, 3, 140, 70, 0, 1118, 1117, 1, 0, 0, 0, 1118, 1119, 1, 0, 0, 0, 1119, 1121, 1, 0, 0, 0, 1120, 1116, 1, 0, 0, 0, 1121, 1124, 1, 0, 0, 0, 1122, 1120, 1, 0, 0, 0, 1122, 1123, 1, 0, 0, 0, 1123, 1125, 1, 0, 0, 0, 1124, 1122, 1, 0, 0, 0, 1125, 1139, 5, 24, 0, 0, 1126, 1135, 5, 42, 0, 0, 1127, 1132, 3, 140, 70, 0, 1128, 1129, 5, 16, 0, 0, 1129, 1131, 3, 140, 70, 0, 1130, 1128, 1, 0, 0, 0, 1131, 1134, 1, 0, 0, 0, 1132, 1130, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 1136, 1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1135, 1127, 1, 0, 0, 0, 1135, 1136, 1, 0, 0, 0, 1136, 1137, 1, 0, 0, 0, 1137, 1139, 5, 43, 0, 0, 1138, 1112, 1, 0, 0, 0, 1138, 1126, 1, 0, 0, 0, 1139, 191, 1, 0, 0, 0, 1140, 1142, 7, 13, 0, 0, 1141, 1143, 5, 105, 0, 0, 1142, 1141, 1, 0, 0, 0, 1142, 1143, 1, 0, 0, 0, 1143, 193, 1, 0, 0, 0, 1144, 1145, 7, 14, 0, 0, 1145, 195, 1, 0, 0, 0, 1146, 1148, 5, 106, 0, 0, 1147, 1146, 1, 0, 0, 0, 1148, 1149, 1, 0, 0, 0, 1149, 1147, 1, 0, 0, 0, 1149, 1150, 1, 0, 0, 0, 1150, 197, 1, 0, 0, 0, 1151, 1163, 5, 96, 0, 0, 1152, 1153, 5, 23, 0, 0, 1153, 1158, 3, 78, 39, 0, 1154, 1155, 5, 16, 0, 0, 1155, 1157, 3, 78, 39, 0, 1156, 1154, 1, 0, 0, 0, 1157, 1160, 1, 0, 0, 0, 1158, 1156, 1, 0, 0, 0, 1158, 1159, 1, 0, 0, 0, 1159, 1161, 1, 0, 0, 0, 1160, 1158, 1, 0, 0, 0, 1161, 1162, 5, 24, 0, 0, 1162, 1164, 1, 0, 0, 0, 1163, 1152, 1, 0, 0, 0, 1163, 1164, 1, 0, 0, 0, 1164, 199, 1, 0, 0, 0, 1165, 1167, 5, 130, 0, 0, 1166, 1165, 1, 0, 0, 0, 1167, 1168, 1, 0, 0, 0, 1168, 1166, 1, 0, 0, 0, 1168, 1169, 1, 0, 0, 0, 1169, 201, 1, 0, 0, 0, 130, 213, 215, 230, 234, 239, 245, 249, 252, 257, 263, 270, 274, 287, 295, 300, 310, 313, 319, 327, 330, 341, 351, 353, 359, 386, 389, 400, 405, 410, 424, 427, 434, 438, 440, 445, 450, 453, 459, 463, 467, 472, 485, 487, 494, 504, 510, 521, 524, 530, 533, 541, 544, 550, 553, 561, 564, 570, 574, 585, 590, 595, 603, 608, 614, 619, 632, 634, 639, 649, 669, 681, 686, 692, 696, 699, 711, 720, 724, 727, 734, 740, 762, 784, 788, 793, 797, 801, 806, 811, 815, 839, 893, 897, 913, 915, 927, 934, 942, 946, 954, 958, 960, 971, 993, 998, 1008, 1012, 1018, 1022, 1028, 1041, 1048, 1063, 1072, 1078, 1082, 1092, 1097, 1110, 1114, 1118, 1122, 1132, 1135, 1138, 1142, 1149, 1158, 1163, 1168], A2.DecisionsToDFA = A2._ATN.decisionToState.map((t5, e4) => new d(t5, e4));
            var w2 = A2, N2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              EOF() {
                return this.getToken(w2.EOF, 0);
              }
              pragmaDirective_list() {
                return this.getTypedRuleContexts(I2);
              }
              pragmaDirective(t5) {
                return this.getTypedRuleContext(I2, t5);
              }
              importDirective_list() {
                return this.getTypedRuleContexts(H2);
              }
              importDirective(t5) {
                return this.getTypedRuleContext(H2, t5);
              }
              contractDefinition_list() {
                return this.getTypedRuleContexts(K2);
              }
              contractDefinition(t5) {
                return this.getTypedRuleContext(K2, t5);
              }
              enumDefinition_list() {
                return this.getTypedRuleContexts(at2);
              }
              enumDefinition(t5) {
                return this.getTypedRuleContext(at2, t5);
              }
              eventDefinition_list() {
                return this.getTypedRuleContexts(rt2);
              }
              eventDefinition(t5) {
                return this.getTypedRuleContext(rt2, t5);
              }
              structDefinition_list() {
                return this.getTypedRuleContexts(J2);
              }
              structDefinition(t5) {
                return this.getTypedRuleContext(J2, t5);
              }
              functionDefinition_list() {
                return this.getTypedRuleContexts(tt2);
              }
              functionDefinition(t5) {
                return this.getTypedRuleContext(tt2, t5);
              }
              fileLevelConstant_list() {
                return this.getTypedRuleContexts(j);
              }
              fileLevelConstant(t5) {
                return this.getTypedRuleContext(j, t5);
              }
              customErrorDefinition_list() {
                return this.getTypedRuleContexts(G2);
              }
              customErrorDefinition(t5) {
                return this.getTypedRuleContext(G2, t5);
              }
              typeDefinition_list() {
                return this.getTypedRuleContexts(z2);
              }
              typeDefinition(t5) {
                return this.getTypedRuleContext(z2, t5);
              }
              usingForDeclaration_list() {
                return this.getTypedRuleContexts(q2);
              }
              usingForDeclaration(t5) {
                return this.getTypedRuleContext(q2, t5);
              }
              get ruleIndex() {
                return w2.RULE_sourceUnit;
              }
              enterRule(t5) {
                t5.enterSourceUnit && t5.enterSourceUnit(this);
              }
              exitRule(t5) {
                t5.exitSourceUnit && t5.exitSourceUnit(this);
              }
              accept(t5) {
                return t5.visitSourceUnit ? t5.visitSourceUnit(this) : t5.visitChildren(this);
              }
            }, I2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              pragmaName() {
                return this.getTypedRuleContext(k2, 0);
              }
              pragmaValue() {
                return this.getTypedRuleContext(D, 0);
              }
              get ruleIndex() {
                return w2.RULE_pragmaDirective;
              }
              enterRule(t5) {
                t5.enterPragmaDirective && t5.enterPragmaDirective(this);
              }
              exitRule(t5) {
                t5.exitPragmaDirective && t5.exitPragmaDirective(this);
              }
              accept(t5) {
                return t5.visitPragmaDirective ? t5.visitPragmaDirective(this) : t5.visitChildren(this);
              }
            }, k2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_pragmaName;
              }
              enterRule(t5) {
                t5.enterPragmaName && t5.enterPragmaName(this);
              }
              exitRule(t5) {
                t5.exitPragmaName && t5.exitPragmaName(this);
              }
              accept(t5) {
                return t5.visitPragmaName ? t5.visitPragmaName(this) : t5.visitChildren(this);
              }
            }, D = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              version() {
                return this.getTypedRuleContext(O2, 0);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_pragmaValue;
              }
              enterRule(t5) {
                t5.enterPragmaValue && t5.enterPragmaValue(this);
              }
              exitRule(t5) {
                t5.exitPragmaValue && t5.exitPragmaValue(this);
              }
              accept(t5) {
                return t5.visitPragmaValue ? t5.visitPragmaValue(this) : t5.visitChildren(this);
              }
            }, O2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              versionConstraint_list() {
                return this.getTypedRuleContexts(F);
              }
              versionConstraint(t5) {
                return this.getTypedRuleContext(F, t5);
              }
              get ruleIndex() {
                return w2.RULE_version;
              }
              enterRule(t5) {
                t5.enterVersion && t5.enterVersion(this);
              }
              exitRule(t5) {
                t5.exitVersion && t5.exitVersion(this);
              }
              accept(t5) {
                return t5.visitVersion ? t5.visitVersion(this) : t5.visitChildren(this);
              }
            }, P2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              get ruleIndex() {
                return w2.RULE_versionOperator;
              }
              enterRule(t5) {
                t5.enterVersionOperator && t5.enterVersionOperator(this);
              }
              exitRule(t5) {
                t5.exitVersionOperator && t5.exitVersionOperator(this);
              }
              accept(t5) {
                return t5.visitVersionOperator ? t5.visitVersionOperator(this) : t5.visitChildren(this);
              }
            }, F = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              VersionLiteral() {
                return this.getToken(w2.VersionLiteral, 0);
              }
              versionOperator() {
                return this.getTypedRuleContext(P2, 0);
              }
              DecimalNumber() {
                return this.getToken(w2.DecimalNumber, 0);
              }
              get ruleIndex() {
                return w2.RULE_versionConstraint;
              }
              enterRule(t5) {
                t5.enterVersionConstraint && t5.enterVersionConstraint(this);
              }
              exitRule(t5) {
                t5.exitVersionConstraint && t5.exitVersionConstraint(this);
              }
              accept(t5) {
                return t5.visitVersionConstraint ? t5.visitVersionConstraint(this) : t5.visitChildren(this);
              }
            }, U2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier_list() {
                return this.getTypedRuleContexts(ge2);
              }
              identifier(t5) {
                return this.getTypedRuleContext(ge2, t5);
              }
              get ruleIndex() {
                return w2.RULE_importDeclaration;
              }
              enterRule(t5) {
                t5.enterImportDeclaration && t5.enterImportDeclaration(this);
              }
              exitRule(t5) {
                t5.exitImportDeclaration && t5.exitImportDeclaration(this);
              }
              accept(t5) {
                return t5.visitImportDeclaration ? t5.visitImportDeclaration(this) : t5.visitChildren(this);
              }
            }, H2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              importPath() {
                return this.getTypedRuleContext(M2, 0);
              }
              identifier_list() {
                return this.getTypedRuleContexts(ge2);
              }
              identifier(t5) {
                return this.getTypedRuleContext(ge2, t5);
              }
              importDeclaration_list() {
                return this.getTypedRuleContexts(U2);
              }
              importDeclaration(t5) {
                return this.getTypedRuleContext(U2, t5);
              }
              get ruleIndex() {
                return w2.RULE_importDirective;
              }
              enterRule(t5) {
                t5.enterImportDirective && t5.enterImportDirective(this);
              }
              exitRule(t5) {
                t5.exitImportDirective && t5.exitImportDirective(this);
              }
              accept(t5) {
                return t5.visitImportDirective ? t5.visitImportDirective(this) : t5.visitChildren(this);
              }
            }, M2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              StringLiteralFragment() {
                return this.getToken(w2.StringLiteralFragment, 0);
              }
              get ruleIndex() {
                return w2.RULE_importPath;
              }
              enterRule(t5) {
                t5.enterImportPath && t5.enterImportPath(this);
              }
              exitRule(t5) {
                t5.exitImportPath && t5.exitImportPath(this);
              }
              accept(t5) {
                return t5.visitImportPath ? t5.visitImportPath(this) : t5.visitChildren(this);
              }
            }, K2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              inheritanceSpecifier_list() {
                return this.getTypedRuleContexts(V2);
              }
              inheritanceSpecifier(t5) {
                return this.getTypedRuleContext(V2, t5);
              }
              contractPart_list() {
                return this.getTypedRuleContexts(B2);
              }
              contractPart(t5) {
                return this.getTypedRuleContext(B2, t5);
              }
              get ruleIndex() {
                return w2.RULE_contractDefinition;
              }
              enterRule(t5) {
                t5.enterContractDefinition && t5.enterContractDefinition(this);
              }
              exitRule(t5) {
                t5.exitContractDefinition && t5.exitContractDefinition(this);
              }
              accept(t5) {
                return t5.visitContractDefinition ? t5.visitContractDefinition(this) : t5.visitChildren(this);
              }
            }, V2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              userDefinedTypeName() {
                return this.getTypedRuleContext(_t2, 0);
              }
              expressionList() {
                return this.getTypedRuleContext(Wt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_inheritanceSpecifier;
              }
              enterRule(t5) {
                t5.enterInheritanceSpecifier && t5.enterInheritanceSpecifier(this);
              }
              exitRule(t5) {
                t5.exitInheritanceSpecifier && t5.exitInheritanceSpecifier(this);
              }
              accept(t5) {
                return t5.visitInheritanceSpecifier ? t5.visitInheritanceSpecifier(this) : t5.visitChildren(this);
              }
            }, B2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              stateVariableDeclaration() {
                return this.getTypedRuleContext($2, 0);
              }
              usingForDeclaration() {
                return this.getTypedRuleContext(q2, 0);
              }
              structDefinition() {
                return this.getTypedRuleContext(J2, 0);
              }
              modifierDefinition() {
                return this.getTypedRuleContext(Q2, 0);
              }
              functionDefinition() {
                return this.getTypedRuleContext(tt2, 0);
              }
              eventDefinition() {
                return this.getTypedRuleContext(rt2, 0);
              }
              enumDefinition() {
                return this.getTypedRuleContext(at2, 0);
              }
              customErrorDefinition() {
                return this.getTypedRuleContext(G2, 0);
              }
              typeDefinition() {
                return this.getTypedRuleContext(z2, 0);
              }
              get ruleIndex() {
                return w2.RULE_contractPart;
              }
              enterRule(t5) {
                t5.enterContractPart && t5.enterContractPart(this);
              }
              exitRule(t5) {
                t5.exitContractPart && t5.exitContractPart(this);
              }
              accept(t5) {
                return t5.visitContractPart ? t5.visitContractPart(this) : t5.visitChildren(this);
              }
            }, $2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              PublicKeyword_list() {
                return this.getTokens(w2.PublicKeyword);
              }
              PublicKeyword(t5) {
                return this.getToken(w2.PublicKeyword, t5);
              }
              InternalKeyword_list() {
                return this.getTokens(w2.InternalKeyword);
              }
              InternalKeyword(t5) {
                return this.getToken(w2.InternalKeyword, t5);
              }
              PrivateKeyword_list() {
                return this.getTokens(w2.PrivateKeyword);
              }
              PrivateKeyword(t5) {
                return this.getToken(w2.PrivateKeyword, t5);
              }
              ConstantKeyword_list() {
                return this.getTokens(w2.ConstantKeyword);
              }
              ConstantKeyword(t5) {
                return this.getToken(w2.ConstantKeyword, t5);
              }
              TransientKeyword_list() {
                return this.getTokens(w2.TransientKeyword);
              }
              TransientKeyword(t5) {
                return this.getToken(w2.TransientKeyword, t5);
              }
              ImmutableKeyword_list() {
                return this.getTokens(w2.ImmutableKeyword);
              }
              ImmutableKeyword(t5) {
                return this.getToken(w2.ImmutableKeyword, t5);
              }
              overrideSpecifier_list() {
                return this.getTypedRuleContexts(Ee2);
              }
              overrideSpecifier(t5) {
                return this.getTypedRuleContext(Ee2, t5);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_stateVariableDeclaration;
              }
              enterRule(t5) {
                t5.enterStateVariableDeclaration && t5.enterStateVariableDeclaration(this);
              }
              exitRule(t5) {
                t5.exitStateVariableDeclaration && t5.exitStateVariableDeclaration(this);
              }
              accept(t5) {
                return t5.visitStateVariableDeclaration ? t5.visitStateVariableDeclaration(this) : t5.visitChildren(this);
              }
            }, j = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              ConstantKeyword() {
                return this.getToken(w2.ConstantKeyword, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_fileLevelConstant;
              }
              enterRule(t5) {
                t5.enterFileLevelConstant && t5.enterFileLevelConstant(this);
              }
              exitRule(t5) {
                t5.exitFileLevelConstant && t5.exitFileLevelConstant(this);
              }
              accept(t5) {
                return t5.visitFileLevelConstant ? t5.visitFileLevelConstant(this) : t5.visitChildren(this);
              }
            }, G2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              parameterList() {
                return this.getTypedRuleContext(ot2, 0);
              }
              get ruleIndex() {
                return w2.RULE_customErrorDefinition;
              }
              enterRule(t5) {
                t5.enterCustomErrorDefinition && t5.enterCustomErrorDefinition(this);
              }
              exitRule(t5) {
                t5.exitCustomErrorDefinition && t5.exitCustomErrorDefinition(this);
              }
              accept(t5) {
                return t5.visitCustomErrorDefinition ? t5.visitCustomErrorDefinition(this) : t5.visitChildren(this);
              }
            }, z2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              TypeKeyword() {
                return this.getToken(w2.TypeKeyword, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              elementaryTypeName() {
                return this.getTypedRuleContext(Gt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_typeDefinition;
              }
              enterRule(t5) {
                t5.enterTypeDefinition && t5.enterTypeDefinition(this);
              }
              exitRule(t5) {
                t5.exitTypeDefinition && t5.exitTypeDefinition(this);
              }
              accept(t5) {
                return t5.visitTypeDefinition ? t5.visitTypeDefinition(this) : t5.visitChildren(this);
              }
            }, q2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              usingForObject() {
                return this.getTypedRuleContext(W2, 0);
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              GlobalKeyword() {
                return this.getToken(w2.GlobalKeyword, 0);
              }
              get ruleIndex() {
                return w2.RULE_usingForDeclaration;
              }
              enterRule(t5) {
                t5.enterUsingForDeclaration && t5.enterUsingForDeclaration(this);
              }
              exitRule(t5) {
                t5.exitUsingForDeclaration && t5.exitUsingForDeclaration(this);
              }
              accept(t5) {
                return t5.visitUsingForDeclaration ? t5.visitUsingForDeclaration(this) : t5.visitChildren(this);
              }
            }, W2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              userDefinedTypeName() {
                return this.getTypedRuleContext(_t2, 0);
              }
              usingForObjectDirective_list() {
                return this.getTypedRuleContexts(Y2);
              }
              usingForObjectDirective(t5) {
                return this.getTypedRuleContext(Y2, t5);
              }
              get ruleIndex() {
                return w2.RULE_usingForObject;
              }
              enterRule(t5) {
                t5.enterUsingForObject && t5.enterUsingForObject(this);
              }
              exitRule(t5) {
                t5.exitUsingForObject && t5.exitUsingForObject(this);
              }
              accept(t5) {
                return t5.visitUsingForObject ? t5.visitUsingForObject(this) : t5.visitChildren(this);
              }
            }, Y2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              userDefinedTypeName() {
                return this.getTypedRuleContext(_t2, 0);
              }
              userDefinableOperators() {
                return this.getTypedRuleContext(X, 0);
              }
              get ruleIndex() {
                return w2.RULE_usingForObjectDirective;
              }
              enterRule(t5) {
                t5.enterUsingForObjectDirective && t5.enterUsingForObjectDirective(this);
              }
              exitRule(t5) {
                t5.exitUsingForObjectDirective && t5.exitUsingForObjectDirective(this);
              }
              accept(t5) {
                return t5.visitUsingForObjectDirective ? t5.visitUsingForObjectDirective(this) : t5.visitChildren(this);
              }
            }, X = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              get ruleIndex() {
                return w2.RULE_userDefinableOperators;
              }
              enterRule(t5) {
                t5.enterUserDefinableOperators && t5.enterUserDefinableOperators(this);
              }
              exitRule(t5) {
                t5.exitUserDefinableOperators && t5.exitUserDefinableOperators(this);
              }
              accept(t5) {
                return t5.visitUserDefinableOperators ? t5.visitUserDefinableOperators(this) : t5.visitChildren(this);
              }
            }, J2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              variableDeclaration_list() {
                return this.getTypedRuleContexts(dt2);
              }
              variableDeclaration(t5) {
                return this.getTypedRuleContext(dt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_structDefinition;
              }
              enterRule(t5) {
                t5.enterStructDefinition && t5.enterStructDefinition(this);
              }
              exitRule(t5) {
                t5.exitStructDefinition && t5.exitStructDefinition(this);
              }
              accept(t5) {
                return t5.visitStructDefinition ? t5.visitStructDefinition(this) : t5.visitChildren(this);
              }
            }, Q2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              block() {
                return this.getTypedRuleContext(vt2, 0);
              }
              parameterList() {
                return this.getTypedRuleContext(ot2, 0);
              }
              VirtualKeyword_list() {
                return this.getTokens(w2.VirtualKeyword);
              }
              VirtualKeyword(t5) {
                return this.getToken(w2.VirtualKeyword, t5);
              }
              overrideSpecifier_list() {
                return this.getTypedRuleContexts(Ee2);
              }
              overrideSpecifier(t5) {
                return this.getTypedRuleContext(Ee2, t5);
              }
              get ruleIndex() {
                return w2.RULE_modifierDefinition;
              }
              enterRule(t5) {
                t5.enterModifierDefinition && t5.enterModifierDefinition(this);
              }
              exitRule(t5) {
                t5.exitModifierDefinition && t5.exitModifierDefinition(this);
              }
              accept(t5) {
                return t5.visitModifierDefinition ? t5.visitModifierDefinition(this) : t5.visitChildren(this);
              }
            }, Z2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              expressionList() {
                return this.getTypedRuleContext(Wt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_modifierInvocation;
              }
              enterRule(t5) {
                t5.enterModifierInvocation && t5.enterModifierInvocation(this);
              }
              exitRule(t5) {
                t5.exitModifierInvocation && t5.exitModifierInvocation(this);
              }
              accept(t5) {
                return t5.visitModifierInvocation ? t5.visitModifierInvocation(this) : t5.visitChildren(this);
              }
            }, tt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              functionDescriptor() {
                return this.getTypedRuleContext(et2, 0);
              }
              parameterList() {
                return this.getTypedRuleContext(ot2, 0);
              }
              modifierList() {
                return this.getTypedRuleContext(st2, 0);
              }
              block() {
                return this.getTypedRuleContext(vt2, 0);
              }
              returnParameters() {
                return this.getTypedRuleContext(it2, 0);
              }
              get ruleIndex() {
                return w2.RULE_functionDefinition;
              }
              enterRule(t5) {
                t5.enterFunctionDefinition && t5.enterFunctionDefinition(this);
              }
              exitRule(t5) {
                t5.exitFunctionDefinition && t5.exitFunctionDefinition(this);
              }
              accept(t5) {
                return t5.visitFunctionDefinition ? t5.visitFunctionDefinition(this) : t5.visitChildren(this);
              }
            }, et2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              ConstructorKeyword() {
                return this.getToken(w2.ConstructorKeyword, 0);
              }
              FallbackKeyword() {
                return this.getToken(w2.FallbackKeyword, 0);
              }
              ReceiveKeyword() {
                return this.getToken(w2.ReceiveKeyword, 0);
              }
              get ruleIndex() {
                return w2.RULE_functionDescriptor;
              }
              enterRule(t5) {
                t5.enterFunctionDescriptor && t5.enterFunctionDescriptor(this);
              }
              exitRule(t5) {
                t5.exitFunctionDescriptor && t5.exitFunctionDescriptor(this);
              }
              accept(t5) {
                return t5.visitFunctionDescriptor ? t5.visitFunctionDescriptor(this) : t5.visitChildren(this);
              }
            }, it2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              parameterList() {
                return this.getTypedRuleContext(ot2, 0);
              }
              get ruleIndex() {
                return w2.RULE_returnParameters;
              }
              enterRule(t5) {
                t5.enterReturnParameters && t5.enterReturnParameters(this);
              }
              exitRule(t5) {
                t5.exitReturnParameters && t5.exitReturnParameters(this);
              }
              accept(t5) {
                return t5.visitReturnParameters ? t5.visitReturnParameters(this) : t5.visitChildren(this);
              }
            }, st2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              ExternalKeyword_list() {
                return this.getTokens(w2.ExternalKeyword);
              }
              ExternalKeyword(t5) {
                return this.getToken(w2.ExternalKeyword, t5);
              }
              PublicKeyword_list() {
                return this.getTokens(w2.PublicKeyword);
              }
              PublicKeyword(t5) {
                return this.getToken(w2.PublicKeyword, t5);
              }
              InternalKeyword_list() {
                return this.getTokens(w2.InternalKeyword);
              }
              InternalKeyword(t5) {
                return this.getToken(w2.InternalKeyword, t5);
              }
              PrivateKeyword_list() {
                return this.getTokens(w2.PrivateKeyword);
              }
              PrivateKeyword(t5) {
                return this.getToken(w2.PrivateKeyword, t5);
              }
              VirtualKeyword_list() {
                return this.getTokens(w2.VirtualKeyword);
              }
              VirtualKeyword(t5) {
                return this.getToken(w2.VirtualKeyword, t5);
              }
              stateMutability_list() {
                return this.getTypedRuleContexts(Rt2);
              }
              stateMutability(t5) {
                return this.getTypedRuleContext(Rt2, t5);
              }
              modifierInvocation_list() {
                return this.getTypedRuleContexts(Z2);
              }
              modifierInvocation(t5) {
                return this.getTypedRuleContext(Z2, t5);
              }
              overrideSpecifier_list() {
                return this.getTypedRuleContexts(Ee2);
              }
              overrideSpecifier(t5) {
                return this.getTypedRuleContext(Ee2, t5);
              }
              get ruleIndex() {
                return w2.RULE_modifierList;
              }
              enterRule(t5) {
                t5.enterModifierList && t5.enterModifierList(this);
              }
              exitRule(t5) {
                t5.exitModifierList && t5.exitModifierList(this);
              }
              accept(t5) {
                return t5.visitModifierList ? t5.visitModifierList(this) : t5.visitChildren(this);
              }
            }, rt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              eventParameterList() {
                return this.getTypedRuleContext(ht2, 0);
              }
              AnonymousKeyword() {
                return this.getToken(w2.AnonymousKeyword, 0);
              }
              get ruleIndex() {
                return w2.RULE_eventDefinition;
              }
              enterRule(t5) {
                t5.enterEventDefinition && t5.enterEventDefinition(this);
              }
              exitRule(t5) {
                t5.exitEventDefinition && t5.exitEventDefinition(this);
              }
              accept(t5) {
                return t5.visitEventDefinition ? t5.visitEventDefinition(this) : t5.visitChildren(this);
              }
            }, nt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_enumValue;
              }
              enterRule(t5) {
                t5.enterEnumValue && t5.enterEnumValue(this);
              }
              exitRule(t5) {
                t5.exitEnumValue && t5.exitEnumValue(this);
              }
              accept(t5) {
                return t5.visitEnumValue ? t5.visitEnumValue(this) : t5.visitChildren(this);
              }
            }, at2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              enumValue_list() {
                return this.getTypedRuleContexts(nt2);
              }
              enumValue(t5) {
                return this.getTypedRuleContext(nt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_enumDefinition;
              }
              enterRule(t5) {
                t5.enterEnumDefinition && t5.enterEnumDefinition(this);
              }
              exitRule(t5) {
                t5.exitEnumDefinition && t5.exitEnumDefinition(this);
              }
              accept(t5) {
                return t5.visitEnumDefinition ? t5.visitEnumDefinition(this) : t5.visitChildren(this);
              }
            }, ot2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              parameter_list() {
                return this.getTypedRuleContexts(lt2);
              }
              parameter(t5) {
                return this.getTypedRuleContext(lt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_parameterList;
              }
              enterRule(t5) {
                t5.enterParameterList && t5.enterParameterList(this);
              }
              exitRule(t5) {
                t5.exitParameterList && t5.exitParameterList(this);
              }
              accept(t5) {
                return t5.visitParameterList ? t5.visitParameterList(this) : t5.visitChildren(this);
              }
            }, lt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              storageLocation() {
                return this.getTypedRuleContext(Et2, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_parameter;
              }
              enterRule(t5) {
                t5.enterParameter && t5.enterParameter(this);
              }
              exitRule(t5) {
                t5.exitParameter && t5.exitParameter(this);
              }
              accept(t5) {
                return t5.visitParameter ? t5.visitParameter(this) : t5.visitChildren(this);
              }
            }, ht2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              eventParameter_list() {
                return this.getTypedRuleContexts(ct2);
              }
              eventParameter(t5) {
                return this.getTypedRuleContext(ct2, t5);
              }
              get ruleIndex() {
                return w2.RULE_eventParameterList;
              }
              enterRule(t5) {
                t5.enterEventParameterList && t5.enterEventParameterList(this);
              }
              exitRule(t5) {
                t5.exitEventParameterList && t5.exitEventParameterList(this);
              }
              accept(t5) {
                return t5.visitEventParameterList ? t5.visitEventParameterList(this) : t5.visitChildren(this);
              }
            }, ct2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              IndexedKeyword() {
                return this.getToken(w2.IndexedKeyword, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_eventParameter;
              }
              enterRule(t5) {
                t5.enterEventParameter && t5.enterEventParameter(this);
              }
              exitRule(t5) {
                t5.exitEventParameter && t5.exitEventParameter(this);
              }
              accept(t5) {
                return t5.visitEventParameter ? t5.visitEventParameter(this) : t5.visitChildren(this);
              }
            }, ut2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              functionTypeParameter_list() {
                return this.getTypedRuleContexts(pt2);
              }
              functionTypeParameter(t5) {
                return this.getTypedRuleContext(pt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_functionTypeParameterList;
              }
              enterRule(t5) {
                t5.enterFunctionTypeParameterList && t5.enterFunctionTypeParameterList(this);
              }
              exitRule(t5) {
                t5.exitFunctionTypeParameterList && t5.exitFunctionTypeParameterList(this);
              }
              accept(t5) {
                return t5.visitFunctionTypeParameterList ? t5.visitFunctionTypeParameterList(this) : t5.visitChildren(this);
              }
            }, pt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              storageLocation() {
                return this.getTypedRuleContext(Et2, 0);
              }
              get ruleIndex() {
                return w2.RULE_functionTypeParameter;
              }
              enterRule(t5) {
                t5.enterFunctionTypeParameter && t5.enterFunctionTypeParameter(this);
              }
              exitRule(t5) {
                t5.exitFunctionTypeParameter && t5.exitFunctionTypeParameter(this);
              }
              accept(t5) {
                return t5.visitFunctionTypeParameter ? t5.visitFunctionTypeParameter(this) : t5.visitChildren(this);
              }
            }, dt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              storageLocation() {
                return this.getTypedRuleContext(Et2, 0);
              }
              get ruleIndex() {
                return w2.RULE_variableDeclaration;
              }
              enterRule(t5) {
                t5.enterVariableDeclaration && t5.enterVariableDeclaration(this);
              }
              exitRule(t5) {
                t5.exitVariableDeclaration && t5.exitVariableDeclaration(this);
              }
              accept(t5) {
                return t5.visitVariableDeclaration ? t5.visitVariableDeclaration(this) : t5.visitChildren(this);
              }
            }, mt2 = class t5 extends R2 {
              constructor(t6, e4, i4) {
                super(e4, i4), this.parser = t6;
              }
              elementaryTypeName() {
                return this.getTypedRuleContext(Gt2, 0);
              }
              userDefinedTypeName() {
                return this.getTypedRuleContext(_t2, 0);
              }
              mapping() {
                return this.getTypedRuleContext(ft2, 0);
              }
              functionTypeName() {
                return this.getTypedRuleContext(Tt2, 0);
              }
              PayableKeyword() {
                return this.getToken(w2.PayableKeyword, 0);
              }
              typeName() {
                return this.getTypedRuleContext(t5, 0);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_typeName;
              }
              enterRule(t6) {
                t6.enterTypeName && t6.enterTypeName(this);
              }
              exitRule(t6) {
                t6.exitTypeName && t6.exitTypeName(this);
              }
              accept(t6) {
                return t6.visitTypeName ? t6.visitTypeName(this) : t6.visitChildren(this);
              }
            }, _t2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier_list() {
                return this.getTypedRuleContexts(ge2);
              }
              identifier(t5) {
                return this.getTypedRuleContext(ge2, t5);
              }
              get ruleIndex() {
                return w2.RULE_userDefinedTypeName;
              }
              enterRule(t5) {
                t5.enterUserDefinedTypeName && t5.enterUserDefinedTypeName(this);
              }
              exitRule(t5) {
                t5.exitUserDefinedTypeName && t5.exitUserDefinedTypeName(this);
              }
              accept(t5) {
                return t5.visitUserDefinedTypeName ? t5.visitUserDefinedTypeName(this) : t5.visitChildren(this);
              }
            }, xt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              elementaryTypeName() {
                return this.getTypedRuleContext(Gt2, 0);
              }
              userDefinedTypeName() {
                return this.getTypedRuleContext(_t2, 0);
              }
              get ruleIndex() {
                return w2.RULE_mappingKey;
              }
              enterRule(t5) {
                t5.enterMappingKey && t5.enterMappingKey(this);
              }
              exitRule(t5) {
                t5.exitMappingKey && t5.exitMappingKey(this);
              }
              accept(t5) {
                return t5.visitMappingKey ? t5.visitMappingKey(this) : t5.visitChildren(this);
              }
            }, ft2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              mappingKey() {
                return this.getTypedRuleContext(xt2, 0);
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              mappingKeyName() {
                return this.getTypedRuleContext(yt, 0);
              }
              mappingValueName() {
                return this.getTypedRuleContext(gt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_mapping;
              }
              enterRule(t5) {
                t5.enterMapping && t5.enterMapping(this);
              }
              exitRule(t5) {
                t5.exitMapping && t5.exitMapping(this);
              }
              accept(t5) {
                return t5.visitMapping ? t5.visitMapping(this) : t5.visitChildren(this);
              }
            }, yt = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_mappingKeyName;
              }
              enterRule(t5) {
                t5.enterMappingKeyName && t5.enterMappingKeyName(this);
              }
              exitRule(t5) {
                t5.exitMappingKeyName && t5.exitMappingKeyName(this);
              }
              accept(t5) {
                return t5.visitMappingKeyName ? t5.visitMappingKeyName(this) : t5.visitChildren(this);
              }
            }, gt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_mappingValueName;
              }
              enterRule(t5) {
                t5.enterMappingValueName && t5.enterMappingValueName(this);
              }
              exitRule(t5) {
                t5.exitMappingValueName && t5.exitMappingValueName(this);
              }
              accept(t5) {
                return t5.visitMappingValueName ? t5.visitMappingValueName(this) : t5.visitChildren(this);
              }
            }, Tt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              functionTypeParameterList_list() {
                return this.getTypedRuleContexts(ut2);
              }
              functionTypeParameterList(t5) {
                return this.getTypedRuleContext(ut2, t5);
              }
              InternalKeyword_list() {
                return this.getTokens(w2.InternalKeyword);
              }
              InternalKeyword(t5) {
                return this.getToken(w2.InternalKeyword, t5);
              }
              ExternalKeyword_list() {
                return this.getTokens(w2.ExternalKeyword);
              }
              ExternalKeyword(t5) {
                return this.getToken(w2.ExternalKeyword, t5);
              }
              stateMutability_list() {
                return this.getTypedRuleContexts(Rt2);
              }
              stateMutability(t5) {
                return this.getTypedRuleContext(Rt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_functionTypeName;
              }
              enterRule(t5) {
                t5.enterFunctionTypeName && t5.enterFunctionTypeName(this);
              }
              exitRule(t5) {
                t5.exitFunctionTypeName && t5.exitFunctionTypeName(this);
              }
              accept(t5) {
                return t5.visitFunctionTypeName ? t5.visitFunctionTypeName(this) : t5.visitChildren(this);
              }
            }, Et2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              get ruleIndex() {
                return w2.RULE_storageLocation;
              }
              enterRule(t5) {
                t5.enterStorageLocation && t5.enterStorageLocation(this);
              }
              exitRule(t5) {
                t5.exitStorageLocation && t5.exitStorageLocation(this);
              }
              accept(t5) {
                return t5.visitStorageLocation ? t5.visitStorageLocation(this) : t5.visitChildren(this);
              }
            }, Rt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              PureKeyword() {
                return this.getToken(w2.PureKeyword, 0);
              }
              ConstantKeyword() {
                return this.getToken(w2.ConstantKeyword, 0);
              }
              ViewKeyword() {
                return this.getToken(w2.ViewKeyword, 0);
              }
              PayableKeyword() {
                return this.getToken(w2.PayableKeyword, 0);
              }
              get ruleIndex() {
                return w2.RULE_stateMutability;
              }
              enterRule(t5) {
                t5.enterStateMutability && t5.enterStateMutability(this);
              }
              exitRule(t5) {
                t5.exitStateMutability && t5.exitStateMutability(this);
              }
              accept(t5) {
                return t5.visitStateMutability ? t5.visitStateMutability(this) : t5.visitChildren(this);
              }
            }, vt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              statement_list() {
                return this.getTypedRuleContexts(bt2);
              }
              statement(t5) {
                return this.getTypedRuleContext(bt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_block;
              }
              enterRule(t5) {
                t5.enterBlock && t5.enterBlock(this);
              }
              exitRule(t5) {
                t5.exitBlock && t5.exitBlock(this);
              }
              accept(t5) {
                return t5.visitBlock ? t5.visitBlock(this) : t5.visitChildren(this);
              }
            }, bt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              ifStatement() {
                return this.getTypedRuleContext(St2, 0);
              }
              tryStatement() {
                return this.getTypedRuleContext(Ct2, 0);
              }
              whileStatement() {
                return this.getTypedRuleContext(wt2, 0);
              }
              forStatement() {
                return this.getTypedRuleContext(kt2, 0);
              }
              block() {
                return this.getTypedRuleContext(vt2, 0);
              }
              inlineAssemblyStatement() {
                return this.getTypedRuleContext(Dt2, 0);
              }
              doWhileStatement() {
                return this.getTypedRuleContext(Pt2, 0);
              }
              continueStatement() {
                return this.getTypedRuleContext(Ft2, 0);
              }
              breakStatement() {
                return this.getTypedRuleContext(Ut2, 0);
              }
              returnStatement() {
                return this.getTypedRuleContext(Ht2, 0);
              }
              throwStatement() {
                return this.getTypedRuleContext(Mt2, 0);
              }
              emitStatement() {
                return this.getTypedRuleContext(Kt2, 0);
              }
              simpleStatement() {
                return this.getTypedRuleContext(Nt2, 0);
              }
              uncheckedStatement() {
                return this.getTypedRuleContext(It2, 0);
              }
              revertStatement() {
                return this.getTypedRuleContext(Vt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_statement;
              }
              enterRule(t5) {
                t5.enterStatement && t5.enterStatement(this);
              }
              exitRule(t5) {
                t5.exitStatement && t5.exitStatement(this);
              }
              accept(t5) {
                return t5.visitStatement ? t5.visitStatement(this) : t5.visitChildren(this);
              }
            }, Lt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_expressionStatement;
              }
              enterRule(t5) {
                t5.enterExpressionStatement && t5.enterExpressionStatement(this);
              }
              exitRule(t5) {
                t5.exitExpressionStatement && t5.exitExpressionStatement(this);
              }
              accept(t5) {
                return t5.visitExpressionStatement ? t5.visitExpressionStatement(this) : t5.visitChildren(this);
              }
            }, St2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              statement_list() {
                return this.getTypedRuleContexts(bt2);
              }
              statement(t5) {
                return this.getTypedRuleContext(bt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_ifStatement;
              }
              enterRule(t5) {
                t5.enterIfStatement && t5.enterIfStatement(this);
              }
              exitRule(t5) {
                t5.exitIfStatement && t5.exitIfStatement(this);
              }
              accept(t5) {
                return t5.visitIfStatement ? t5.visitIfStatement(this) : t5.visitChildren(this);
              }
            }, Ct2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              block() {
                return this.getTypedRuleContext(vt2, 0);
              }
              returnParameters() {
                return this.getTypedRuleContext(it2, 0);
              }
              catchClause_list() {
                return this.getTypedRuleContexts(At2);
              }
              catchClause(t5) {
                return this.getTypedRuleContext(At2, t5);
              }
              get ruleIndex() {
                return w2.RULE_tryStatement;
              }
              enterRule(t5) {
                t5.enterTryStatement && t5.enterTryStatement(this);
              }
              exitRule(t5) {
                t5.exitTryStatement && t5.exitTryStatement(this);
              }
              accept(t5) {
                return t5.visitTryStatement ? t5.visitTryStatement(this) : t5.visitChildren(this);
              }
            }, At2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              block() {
                return this.getTypedRuleContext(vt2, 0);
              }
              parameterList() {
                return this.getTypedRuleContext(ot2, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_catchClause;
              }
              enterRule(t5) {
                t5.enterCatchClause && t5.enterCatchClause(this);
              }
              exitRule(t5) {
                t5.exitCatchClause && t5.exitCatchClause(this);
              }
              accept(t5) {
                return t5.visitCatchClause ? t5.visitCatchClause(this) : t5.visitChildren(this);
              }
            }, wt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              statement() {
                return this.getTypedRuleContext(bt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_whileStatement;
              }
              enterRule(t5) {
                t5.enterWhileStatement && t5.enterWhileStatement(this);
              }
              exitRule(t5) {
                t5.exitWhileStatement && t5.exitWhileStatement(this);
              }
              accept(t5) {
                return t5.visitWhileStatement ? t5.visitWhileStatement(this) : t5.visitChildren(this);
              }
            }, Nt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              variableDeclarationStatement() {
                return this.getTypedRuleContext(Bt2, 0);
              }
              expressionStatement() {
                return this.getTypedRuleContext(Lt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_simpleStatement;
              }
              enterRule(t5) {
                t5.enterSimpleStatement && t5.enterSimpleStatement(this);
              }
              exitRule(t5) {
                t5.exitSimpleStatement && t5.exitSimpleStatement(this);
              }
              accept(t5) {
                return t5.visitSimpleStatement ? t5.visitSimpleStatement(this) : t5.visitChildren(this);
              }
            }, It2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              block() {
                return this.getTypedRuleContext(vt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_uncheckedStatement;
              }
              enterRule(t5) {
                t5.enterUncheckedStatement && t5.enterUncheckedStatement(this);
              }
              exitRule(t5) {
                t5.exitUncheckedStatement && t5.exitUncheckedStatement(this);
              }
              accept(t5) {
                return t5.visitUncheckedStatement ? t5.visitUncheckedStatement(this) : t5.visitChildren(this);
              }
            }, kt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              statement() {
                return this.getTypedRuleContext(bt2, 0);
              }
              simpleStatement() {
                return this.getTypedRuleContext(Nt2, 0);
              }
              expressionStatement() {
                return this.getTypedRuleContext(Lt2, 0);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_forStatement;
              }
              enterRule(t5) {
                t5.enterForStatement && t5.enterForStatement(this);
              }
              exitRule(t5) {
                t5.exitForStatement && t5.exitForStatement(this);
              }
              accept(t5) {
                return t5.visitForStatement ? t5.visitForStatement(this) : t5.visitChildren(this);
              }
            }, Dt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyBlock() {
                return this.getTypedRuleContext(Zt2, 0);
              }
              StringLiteralFragment() {
                return this.getToken(w2.StringLiteralFragment, 0);
              }
              inlineAssemblyStatementFlag() {
                return this.getTypedRuleContext(Ot2, 0);
              }
              get ruleIndex() {
                return w2.RULE_inlineAssemblyStatement;
              }
              enterRule(t5) {
                t5.enterInlineAssemblyStatement && t5.enterInlineAssemblyStatement(this);
              }
              exitRule(t5) {
                t5.exitInlineAssemblyStatement && t5.exitInlineAssemblyStatement(this);
              }
              accept(t5) {
                return t5.visitInlineAssemblyStatement ? t5.visitInlineAssemblyStatement(this) : t5.visitChildren(this);
              }
            }, Ot2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              stringLiteral() {
                return this.getTypedRuleContext(Re2, 0);
              }
              get ruleIndex() {
                return w2.RULE_inlineAssemblyStatementFlag;
              }
              enterRule(t5) {
                t5.enterInlineAssemblyStatementFlag && t5.enterInlineAssemblyStatementFlag(this);
              }
              exitRule(t5) {
                t5.exitInlineAssemblyStatementFlag && t5.exitInlineAssemblyStatementFlag(this);
              }
              accept(t5) {
                return t5.visitInlineAssemblyStatementFlag ? t5.visitInlineAssemblyStatementFlag(this) : t5.visitChildren(this);
              }
            }, Pt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              statement() {
                return this.getTypedRuleContext(bt2, 0);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_doWhileStatement;
              }
              enterRule(t5) {
                t5.enterDoWhileStatement && t5.enterDoWhileStatement(this);
              }
              exitRule(t5) {
                t5.exitDoWhileStatement && t5.exitDoWhileStatement(this);
              }
              accept(t5) {
                return t5.visitDoWhileStatement ? t5.visitDoWhileStatement(this) : t5.visitChildren(this);
              }
            }, Ft2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              ContinueKeyword() {
                return this.getToken(w2.ContinueKeyword, 0);
              }
              get ruleIndex() {
                return w2.RULE_continueStatement;
              }
              enterRule(t5) {
                t5.enterContinueStatement && t5.enterContinueStatement(this);
              }
              exitRule(t5) {
                t5.exitContinueStatement && t5.exitContinueStatement(this);
              }
              accept(t5) {
                return t5.visitContinueStatement ? t5.visitContinueStatement(this) : t5.visitChildren(this);
              }
            }, Ut2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              BreakKeyword() {
                return this.getToken(w2.BreakKeyword, 0);
              }
              get ruleIndex() {
                return w2.RULE_breakStatement;
              }
              enterRule(t5) {
                t5.enterBreakStatement && t5.enterBreakStatement(this);
              }
              exitRule(t5) {
                t5.exitBreakStatement && t5.exitBreakStatement(this);
              }
              accept(t5) {
                return t5.visitBreakStatement ? t5.visitBreakStatement(this) : t5.visitChildren(this);
              }
            }, Ht2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_returnStatement;
              }
              enterRule(t5) {
                t5.enterReturnStatement && t5.enterReturnStatement(this);
              }
              exitRule(t5) {
                t5.exitReturnStatement && t5.exitReturnStatement(this);
              }
              accept(t5) {
                return t5.visitReturnStatement ? t5.visitReturnStatement(this) : t5.visitChildren(this);
              }
            }, Mt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              get ruleIndex() {
                return w2.RULE_throwStatement;
              }
              enterRule(t5) {
                t5.enterThrowStatement && t5.enterThrowStatement(this);
              }
              exitRule(t5) {
                t5.exitThrowStatement && t5.exitThrowStatement(this);
              }
              accept(t5) {
                return t5.visitThrowStatement ? t5.visitThrowStatement(this) : t5.visitChildren(this);
              }
            }, Kt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              functionCall() {
                return this.getTypedRuleContext(Qt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_emitStatement;
              }
              enterRule(t5) {
                t5.enterEmitStatement && t5.enterEmitStatement(this);
              }
              exitRule(t5) {
                t5.exitEmitStatement && t5.exitEmitStatement(this);
              }
              accept(t5) {
                return t5.visitEmitStatement ? t5.visitEmitStatement(this) : t5.visitChildren(this);
              }
            }, Vt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              functionCall() {
                return this.getTypedRuleContext(Qt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_revertStatement;
              }
              enterRule(t5) {
                t5.enterRevertStatement && t5.enterRevertStatement(this);
              }
              exitRule(t5) {
                t5.exitRevertStatement && t5.exitRevertStatement(this);
              }
              accept(t5) {
                return t5.visitRevertStatement ? t5.visitRevertStatement(this) : t5.visitChildren(this);
              }
            }, Bt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifierList() {
                return this.getTypedRuleContext(jt2, 0);
              }
              variableDeclaration() {
                return this.getTypedRuleContext(dt2, 0);
              }
              variableDeclarationList() {
                return this.getTypedRuleContext($t2, 0);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_variableDeclarationStatement;
              }
              enterRule(t5) {
                t5.enterVariableDeclarationStatement && t5.enterVariableDeclarationStatement(this);
              }
              exitRule(t5) {
                t5.exitVariableDeclarationStatement && t5.exitVariableDeclarationStatement(this);
              }
              accept(t5) {
                return t5.visitVariableDeclarationStatement ? t5.visitVariableDeclarationStatement(this) : t5.visitChildren(this);
              }
            }, $t2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              variableDeclaration_list() {
                return this.getTypedRuleContexts(dt2);
              }
              variableDeclaration(t5) {
                return this.getTypedRuleContext(dt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_variableDeclarationList;
              }
              enterRule(t5) {
                t5.enterVariableDeclarationList && t5.enterVariableDeclarationList(this);
              }
              exitRule(t5) {
                t5.exitVariableDeclarationList && t5.exitVariableDeclarationList(this);
              }
              accept(t5) {
                return t5.visitVariableDeclarationList ? t5.visitVariableDeclarationList(this) : t5.visitChildren(this);
              }
            }, jt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier_list() {
                return this.getTypedRuleContexts(ge2);
              }
              identifier(t5) {
                return this.getTypedRuleContext(ge2, t5);
              }
              get ruleIndex() {
                return w2.RULE_identifierList;
              }
              enterRule(t5) {
                t5.enterIdentifierList && t5.enterIdentifierList(this);
              }
              exitRule(t5) {
                t5.exitIdentifierList && t5.exitIdentifierList(this);
              }
              accept(t5) {
                return t5.visitIdentifierList ? t5.visitIdentifierList(this) : t5.visitChildren(this);
              }
            }, Gt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              Int() {
                return this.getToken(w2.Int, 0);
              }
              Uint() {
                return this.getToken(w2.Uint, 0);
              }
              Byte() {
                return this.getToken(w2.Byte, 0);
              }
              Fixed() {
                return this.getToken(w2.Fixed, 0);
              }
              Ufixed() {
                return this.getToken(w2.Ufixed, 0);
              }
              get ruleIndex() {
                return w2.RULE_elementaryTypeName;
              }
              enterRule(t5) {
                t5.enterElementaryTypeName && t5.enterElementaryTypeName(this);
              }
              exitRule(t5) {
                t5.exitElementaryTypeName && t5.exitElementaryTypeName(this);
              }
              accept(t5) {
                return t5.visitElementaryTypeName ? t5.visitElementaryTypeName(this) : t5.visitChildren(this);
              }
            }, zt2 = class t5 extends R2 {
              constructor(t6, e4, i4) {
                super(e4, i4), this.parser = t6;
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              expression_list() {
                return this.getTypedRuleContexts(t5);
              }
              expression(e4) {
                return this.getTypedRuleContext(t5, e4);
              }
              primaryExpression() {
                return this.getTypedRuleContext(qt2, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              nameValueList() {
                return this.getTypedRuleContext(Yt2, 0);
              }
              functionCallArguments() {
                return this.getTypedRuleContext(Jt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_expression;
              }
              enterRule(t6) {
                t6.enterExpression && t6.enterExpression(this);
              }
              exitRule(t6) {
                t6.exitExpression && t6.exitExpression(this);
              }
              accept(t6) {
                return t6.visitExpression ? t6.visitExpression(this) : t6.visitChildren(this);
              }
            }, qt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              BooleanLiteral() {
                return this.getToken(w2.BooleanLiteral, 0);
              }
              numberLiteral() {
                return this.getTypedRuleContext(ye2, 0);
              }
              hexLiteral() {
                return this.getTypedRuleContext(Te2, 0);
              }
              stringLiteral() {
                return this.getTypedRuleContext(Re2, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              TypeKeyword() {
                return this.getToken(w2.TypeKeyword, 0);
              }
              PayableKeyword() {
                return this.getToken(w2.PayableKeyword, 0);
              }
              tupleExpression() {
                return this.getTypedRuleContext(fe2, 0);
              }
              typeName() {
                return this.getTypedRuleContext(mt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_primaryExpression;
              }
              enterRule(t5) {
                t5.enterPrimaryExpression && t5.enterPrimaryExpression(this);
              }
              exitRule(t5) {
                t5.exitPrimaryExpression && t5.exitPrimaryExpression(this);
              }
              accept(t5) {
                return t5.visitPrimaryExpression ? t5.visitPrimaryExpression(this) : t5.visitChildren(this);
              }
            }, Wt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression_list() {
                return this.getTypedRuleContexts(zt2);
              }
              expression(t5) {
                return this.getTypedRuleContext(zt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_expressionList;
              }
              enterRule(t5) {
                t5.enterExpressionList && t5.enterExpressionList(this);
              }
              exitRule(t5) {
                t5.exitExpressionList && t5.exitExpressionList(this);
              }
              accept(t5) {
                return t5.visitExpressionList ? t5.visitExpressionList(this) : t5.visitChildren(this);
              }
            }, Yt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              nameValue_list() {
                return this.getTypedRuleContexts(Xt2);
              }
              nameValue(t5) {
                return this.getTypedRuleContext(Xt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_nameValueList;
              }
              enterRule(t5) {
                t5.enterNameValueList && t5.enterNameValueList(this);
              }
              exitRule(t5) {
                t5.exitNameValueList && t5.exitNameValueList(this);
              }
              accept(t5) {
                return t5.visitNameValueList ? t5.visitNameValueList(this) : t5.visitChildren(this);
              }
            }, Xt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_nameValue;
              }
              enterRule(t5) {
                t5.enterNameValue && t5.enterNameValue(this);
              }
              exitRule(t5) {
                t5.exitNameValue && t5.exitNameValue(this);
              }
              accept(t5) {
                return t5.visitNameValue ? t5.visitNameValue(this) : t5.visitChildren(this);
              }
            }, Jt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              nameValueList() {
                return this.getTypedRuleContext(Yt2, 0);
              }
              expressionList() {
                return this.getTypedRuleContext(Wt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_functionCallArguments;
              }
              enterRule(t5) {
                t5.enterFunctionCallArguments && t5.enterFunctionCallArguments(this);
              }
              exitRule(t5) {
                t5.exitFunctionCallArguments && t5.exitFunctionCallArguments(this);
              }
              accept(t5) {
                return t5.visitFunctionCallArguments ? t5.visitFunctionCallArguments(this) : t5.visitChildren(this);
              }
            }, Qt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression() {
                return this.getTypedRuleContext(zt2, 0);
              }
              functionCallArguments() {
                return this.getTypedRuleContext(Jt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_functionCall;
              }
              enterRule(t5) {
                t5.enterFunctionCall && t5.enterFunctionCall(this);
              }
              exitRule(t5) {
                t5.exitFunctionCall && t5.exitFunctionCall(this);
              }
              accept(t5) {
                return t5.visitFunctionCall ? t5.visitFunctionCall(this) : t5.visitChildren(this);
              }
            }, Zt2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyItem_list() {
                return this.getTypedRuleContexts(te2);
              }
              assemblyItem(t5) {
                return this.getTypedRuleContext(te2, t5);
              }
              get ruleIndex() {
                return w2.RULE_assemblyBlock;
              }
              enterRule(t5) {
                t5.enterAssemblyBlock && t5.enterAssemblyBlock(this);
              }
              exitRule(t5) {
                t5.exitAssemblyBlock && t5.exitAssemblyBlock(this);
              }
              accept(t5) {
                return t5.visitAssemblyBlock ? t5.visitAssemblyBlock(this) : t5.visitChildren(this);
              }
            }, te2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              assemblyBlock() {
                return this.getTypedRuleContext(Zt2, 0);
              }
              assemblyExpression() {
                return this.getTypedRuleContext(ee2, 0);
              }
              assemblyLocalDefinition() {
                return this.getTypedRuleContext(re2, 0);
              }
              assemblyAssignment() {
                return this.getTypedRuleContext(ne2, 0);
              }
              assemblyStackAssignment() {
                return this.getTypedRuleContext(le2, 0);
              }
              labelDefinition() {
                return this.getTypedRuleContext(he2, 0);
              }
              assemblySwitch() {
                return this.getTypedRuleContext(ce2, 0);
              }
              assemblyFunctionDefinition() {
                return this.getTypedRuleContext(pe2, 0);
              }
              assemblyFor() {
                return this.getTypedRuleContext(me2, 0);
              }
              assemblyIf() {
                return this.getTypedRuleContext(_e2, 0);
              }
              BreakKeyword() {
                return this.getToken(w2.BreakKeyword, 0);
              }
              ContinueKeyword() {
                return this.getToken(w2.ContinueKeyword, 0);
              }
              LeaveKeyword() {
                return this.getToken(w2.LeaveKeyword, 0);
              }
              numberLiteral() {
                return this.getTypedRuleContext(ye2, 0);
              }
              stringLiteral() {
                return this.getTypedRuleContext(Re2, 0);
              }
              hexLiteral() {
                return this.getTypedRuleContext(Te2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyItem;
              }
              enterRule(t5) {
                t5.enterAssemblyItem && t5.enterAssemblyItem(this);
              }
              exitRule(t5) {
                t5.exitAssemblyItem && t5.exitAssemblyItem(this);
              }
              accept(t5) {
                return t5.visitAssemblyItem ? t5.visitAssemblyItem(this) : t5.visitChildren(this);
              }
            }, ee2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyCall() {
                return this.getTypedRuleContext(se2, 0);
              }
              assemblyLiteral() {
                return this.getTypedRuleContext(xe2, 0);
              }
              assemblyMember() {
                return this.getTypedRuleContext(ie2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyExpression;
              }
              enterRule(t5) {
                t5.enterAssemblyExpression && t5.enterAssemblyExpression(this);
              }
              exitRule(t5) {
                t5.exitAssemblyExpression && t5.exitAssemblyExpression(this);
              }
              accept(t5) {
                return t5.visitAssemblyExpression ? t5.visitAssemblyExpression(this) : t5.visitChildren(this);
              }
            }, ie2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier_list() {
                return this.getTypedRuleContexts(ge2);
              }
              identifier(t5) {
                return this.getTypedRuleContext(ge2, t5);
              }
              get ruleIndex() {
                return w2.RULE_assemblyMember;
              }
              enterRule(t5) {
                t5.enterAssemblyMember && t5.enterAssemblyMember(this);
              }
              exitRule(t5) {
                t5.exitAssemblyMember && t5.exitAssemblyMember(this);
              }
              accept(t5) {
                return t5.visitAssemblyMember ? t5.visitAssemblyMember(this) : t5.visitChildren(this);
              }
            }, se2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              assemblyExpression_list() {
                return this.getTypedRuleContexts(ee2);
              }
              assemblyExpression(t5) {
                return this.getTypedRuleContext(ee2, t5);
              }
              get ruleIndex() {
                return w2.RULE_assemblyCall;
              }
              enterRule(t5) {
                t5.enterAssemblyCall && t5.enterAssemblyCall(this);
              }
              exitRule(t5) {
                t5.exitAssemblyCall && t5.exitAssemblyCall(this);
              }
              accept(t5) {
                return t5.visitAssemblyCall ? t5.visitAssemblyCall(this) : t5.visitChildren(this);
              }
            }, re2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyIdentifierOrList() {
                return this.getTypedRuleContext(ae, 0);
              }
              assemblyExpression() {
                return this.getTypedRuleContext(ee2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyLocalDefinition;
              }
              enterRule(t5) {
                t5.enterAssemblyLocalDefinition && t5.enterAssemblyLocalDefinition(this);
              }
              exitRule(t5) {
                t5.exitAssemblyLocalDefinition && t5.exitAssemblyLocalDefinition(this);
              }
              accept(t5) {
                return t5.visitAssemblyLocalDefinition ? t5.visitAssemblyLocalDefinition(this) : t5.visitChildren(this);
              }
            }, ne2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyIdentifierOrList() {
                return this.getTypedRuleContext(ae, 0);
              }
              assemblyExpression() {
                return this.getTypedRuleContext(ee2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyAssignment;
              }
              enterRule(t5) {
                t5.enterAssemblyAssignment && t5.enterAssemblyAssignment(this);
              }
              exitRule(t5) {
                t5.exitAssemblyAssignment && t5.exitAssemblyAssignment(this);
              }
              accept(t5) {
                return t5.visitAssemblyAssignment ? t5.visitAssemblyAssignment(this) : t5.visitChildren(this);
              }
            }, ae = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              assemblyMember() {
                return this.getTypedRuleContext(ie2, 0);
              }
              assemblyIdentifierList() {
                return this.getTypedRuleContext(oe2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyIdentifierOrList;
              }
              enterRule(t5) {
                t5.enterAssemblyIdentifierOrList && t5.enterAssemblyIdentifierOrList(this);
              }
              exitRule(t5) {
                t5.exitAssemblyIdentifierOrList && t5.exitAssemblyIdentifierOrList(this);
              }
              accept(t5) {
                return t5.visitAssemblyIdentifierOrList ? t5.visitAssemblyIdentifierOrList(this) : t5.visitChildren(this);
              }
            }, oe2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier_list() {
                return this.getTypedRuleContexts(ge2);
              }
              identifier(t5) {
                return this.getTypedRuleContext(ge2, t5);
              }
              get ruleIndex() {
                return w2.RULE_assemblyIdentifierList;
              }
              enterRule(t5) {
                t5.enterAssemblyIdentifierList && t5.enterAssemblyIdentifierList(this);
              }
              exitRule(t5) {
                t5.exitAssemblyIdentifierList && t5.exitAssemblyIdentifierList(this);
              }
              accept(t5) {
                return t5.visitAssemblyIdentifierList ? t5.visitAssemblyIdentifierList(this) : t5.visitChildren(this);
              }
            }, le2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyExpression() {
                return this.getTypedRuleContext(ee2, 0);
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyStackAssignment;
              }
              enterRule(t5) {
                t5.enterAssemblyStackAssignment && t5.enterAssemblyStackAssignment(this);
              }
              exitRule(t5) {
                t5.exitAssemblyStackAssignment && t5.exitAssemblyStackAssignment(this);
              }
              accept(t5) {
                return t5.visitAssemblyStackAssignment ? t5.visitAssemblyStackAssignment(this) : t5.visitChildren(this);
              }
            }, he2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              get ruleIndex() {
                return w2.RULE_labelDefinition;
              }
              enterRule(t5) {
                t5.enterLabelDefinition && t5.enterLabelDefinition(this);
              }
              exitRule(t5) {
                t5.exitLabelDefinition && t5.exitLabelDefinition(this);
              }
              accept(t5) {
                return t5.visitLabelDefinition ? t5.visitLabelDefinition(this) : t5.visitChildren(this);
              }
            }, ce2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyExpression() {
                return this.getTypedRuleContext(ee2, 0);
              }
              assemblyCase_list() {
                return this.getTypedRuleContexts(ue2);
              }
              assemblyCase(t5) {
                return this.getTypedRuleContext(ue2, t5);
              }
              get ruleIndex() {
                return w2.RULE_assemblySwitch;
              }
              enterRule(t5) {
                t5.enterAssemblySwitch && t5.enterAssemblySwitch(this);
              }
              exitRule(t5) {
                t5.exitAssemblySwitch && t5.exitAssemblySwitch(this);
              }
              accept(t5) {
                return t5.visitAssemblySwitch ? t5.visitAssemblySwitch(this) : t5.visitChildren(this);
              }
            }, ue2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyLiteral() {
                return this.getTypedRuleContext(xe2, 0);
              }
              assemblyBlock() {
                return this.getTypedRuleContext(Zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyCase;
              }
              enterRule(t5) {
                t5.enterAssemblyCase && t5.enterAssemblyCase(this);
              }
              exitRule(t5) {
                t5.exitAssemblyCase && t5.exitAssemblyCase(this);
              }
              accept(t5) {
                return t5.visitAssemblyCase ? t5.visitAssemblyCase(this) : t5.visitChildren(this);
              }
            }, pe2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              identifier() {
                return this.getTypedRuleContext(ge2, 0);
              }
              assemblyBlock() {
                return this.getTypedRuleContext(Zt2, 0);
              }
              assemblyIdentifierList() {
                return this.getTypedRuleContext(oe2, 0);
              }
              assemblyFunctionReturns() {
                return this.getTypedRuleContext(de2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyFunctionDefinition;
              }
              enterRule(t5) {
                t5.enterAssemblyFunctionDefinition && t5.enterAssemblyFunctionDefinition(this);
              }
              exitRule(t5) {
                t5.exitAssemblyFunctionDefinition && t5.exitAssemblyFunctionDefinition(this);
              }
              accept(t5) {
                return t5.visitAssemblyFunctionDefinition ? t5.visitAssemblyFunctionDefinition(this) : t5.visitChildren(this);
              }
            }, de2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyIdentifierList() {
                return this.getTypedRuleContext(oe2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyFunctionReturns;
              }
              enterRule(t5) {
                t5.enterAssemblyFunctionReturns && t5.enterAssemblyFunctionReturns(this);
              }
              exitRule(t5) {
                t5.exitAssemblyFunctionReturns && t5.exitAssemblyFunctionReturns(this);
              }
              accept(t5) {
                return t5.visitAssemblyFunctionReturns ? t5.visitAssemblyFunctionReturns(this) : t5.visitChildren(this);
              }
            }, me2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyExpression_list() {
                return this.getTypedRuleContexts(ee2);
              }
              assemblyExpression(t5) {
                return this.getTypedRuleContext(ee2, t5);
              }
              assemblyBlock_list() {
                return this.getTypedRuleContexts(Zt2);
              }
              assemblyBlock(t5) {
                return this.getTypedRuleContext(Zt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_assemblyFor;
              }
              enterRule(t5) {
                t5.enterAssemblyFor && t5.enterAssemblyFor(this);
              }
              exitRule(t5) {
                t5.exitAssemblyFor && t5.exitAssemblyFor(this);
              }
              accept(t5) {
                return t5.visitAssemblyFor ? t5.visitAssemblyFor(this) : t5.visitChildren(this);
              }
            }, _e2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              assemblyExpression() {
                return this.getTypedRuleContext(ee2, 0);
              }
              assemblyBlock() {
                return this.getTypedRuleContext(Zt2, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyIf;
              }
              enterRule(t5) {
                t5.enterAssemblyIf && t5.enterAssemblyIf(this);
              }
              exitRule(t5) {
                t5.exitAssemblyIf && t5.exitAssemblyIf(this);
              }
              accept(t5) {
                return t5.visitAssemblyIf ? t5.visitAssemblyIf(this) : t5.visitChildren(this);
              }
            }, xe2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              stringLiteral() {
                return this.getTypedRuleContext(Re2, 0);
              }
              DecimalNumber() {
                return this.getToken(w2.DecimalNumber, 0);
              }
              HexNumber() {
                return this.getToken(w2.HexNumber, 0);
              }
              hexLiteral() {
                return this.getTypedRuleContext(Te2, 0);
              }
              BooleanLiteral() {
                return this.getToken(w2.BooleanLiteral, 0);
              }
              get ruleIndex() {
                return w2.RULE_assemblyLiteral;
              }
              enterRule(t5) {
                t5.enterAssemblyLiteral && t5.enterAssemblyLiteral(this);
              }
              exitRule(t5) {
                t5.exitAssemblyLiteral && t5.exitAssemblyLiteral(this);
              }
              accept(t5) {
                return t5.visitAssemblyLiteral ? t5.visitAssemblyLiteral(this) : t5.visitChildren(this);
              }
            }, fe2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              expression_list() {
                return this.getTypedRuleContexts(zt2);
              }
              expression(t5) {
                return this.getTypedRuleContext(zt2, t5);
              }
              get ruleIndex() {
                return w2.RULE_tupleExpression;
              }
              enterRule(t5) {
                t5.enterTupleExpression && t5.enterTupleExpression(this);
              }
              exitRule(t5) {
                t5.exitTupleExpression && t5.exitTupleExpression(this);
              }
              accept(t5) {
                return t5.visitTupleExpression ? t5.visitTupleExpression(this) : t5.visitChildren(this);
              }
            }, ye2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              DecimalNumber() {
                return this.getToken(w2.DecimalNumber, 0);
              }
              HexNumber() {
                return this.getToken(w2.HexNumber, 0);
              }
              NumberUnit() {
                return this.getToken(w2.NumberUnit, 0);
              }
              get ruleIndex() {
                return w2.RULE_numberLiteral;
              }
              enterRule(t5) {
                t5.enterNumberLiteral && t5.enterNumberLiteral(this);
              }
              exitRule(t5) {
                t5.exitNumberLiteral && t5.exitNumberLiteral(this);
              }
              accept(t5) {
                return t5.visitNumberLiteral ? t5.visitNumberLiteral(this) : t5.visitChildren(this);
              }
            }, ge2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              ReceiveKeyword() {
                return this.getToken(w2.ReceiveKeyword, 0);
              }
              GlobalKeyword() {
                return this.getToken(w2.GlobalKeyword, 0);
              }
              ConstructorKeyword() {
                return this.getToken(w2.ConstructorKeyword, 0);
              }
              PayableKeyword() {
                return this.getToken(w2.PayableKeyword, 0);
              }
              LeaveKeyword() {
                return this.getToken(w2.LeaveKeyword, 0);
              }
              Identifier() {
                return this.getToken(w2.Identifier, 0);
              }
              get ruleIndex() {
                return w2.RULE_identifier;
              }
              enterRule(t5) {
                t5.enterIdentifier && t5.enterIdentifier(this);
              }
              exitRule(t5) {
                t5.exitIdentifier && t5.exitIdentifier(this);
              }
              accept(t5) {
                return t5.visitIdentifier ? t5.visitIdentifier(this) : t5.visitChildren(this);
              }
            }, Te2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              HexLiteralFragment_list() {
                return this.getTokens(w2.HexLiteralFragment);
              }
              HexLiteralFragment(t5) {
                return this.getToken(w2.HexLiteralFragment, t5);
              }
              get ruleIndex() {
                return w2.RULE_hexLiteral;
              }
              enterRule(t5) {
                t5.enterHexLiteral && t5.enterHexLiteral(this);
              }
              exitRule(t5) {
                t5.exitHexLiteral && t5.exitHexLiteral(this);
              }
              accept(t5) {
                return t5.visitHexLiteral ? t5.visitHexLiteral(this) : t5.visitChildren(this);
              }
            }, Ee2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              userDefinedTypeName_list() {
                return this.getTypedRuleContexts(_t2);
              }
              userDefinedTypeName(t5) {
                return this.getTypedRuleContext(_t2, t5);
              }
              get ruleIndex() {
                return w2.RULE_overrideSpecifier;
              }
              enterRule(t5) {
                t5.enterOverrideSpecifier && t5.enterOverrideSpecifier(this);
              }
              exitRule(t5) {
                t5.exitOverrideSpecifier && t5.exitOverrideSpecifier(this);
              }
              accept(t5) {
                return t5.visitOverrideSpecifier ? t5.visitOverrideSpecifier(this) : t5.visitChildren(this);
              }
            }, Re2 = class extends R2 {
              constructor(t5, e4, i4) {
                super(e4, i4), this.parser = t5;
              }
              StringLiteralFragment_list() {
                return this.getTokens(w2.StringLiteralFragment);
              }
              StringLiteralFragment(t5) {
                return this.getToken(w2.StringLiteralFragment, t5);
              }
              get ruleIndex() {
                return w2.RULE_stringLiteral;
              }
              enterRule(t5) {
                t5.enterStringLiteral && t5.enterStringLiteral(this);
              }
              exitRule(t5) {
                t5.exitStringLiteral && t5.exitStringLiteral(this);
              }
              accept(t5) {
                return t5.visitStringLiteral ? t5.visitStringLiteral(this) : t5.visitChildren(this);
              }
            }, ve2 = ["SourceUnit", "PragmaDirective", "ImportDirective", "ContractDefinition", "InheritanceSpecifier", "StateVariableDeclaration", "UsingForDeclaration", "StructDefinition", "ModifierDefinition", "ModifierInvocation", "FunctionDefinition", "EventDefinition", "CustomErrorDefinition", "RevertStatement", "EnumValue", "EnumDefinition", "VariableDeclaration", "UserDefinedTypeName", "Mapping", "ArrayTypeName", "FunctionTypeName", "Block", "ExpressionStatement", "IfStatement", "WhileStatement", "ForStatement", "InlineAssemblyStatement", "DoWhileStatement", "ContinueStatement", "Break", "Continue", "BreakStatement", "ReturnStatement", "EmitStatement", "ThrowStatement", "VariableDeclarationStatement", "ElementaryTypeName", "FunctionCall", "AssemblyBlock", "AssemblyCall", "AssemblyLocalDefinition", "AssemblyAssignment", "AssemblyStackAssignment", "LabelDefinition", "AssemblySwitch", "AssemblyCase", "AssemblyFunctionDefinition", "AssemblyFor", "AssemblyIf", "TupleExpression", "NameValueExpression", "BooleanLiteral", "NumberLiteral", "Identifier", "BinaryOperation", "UnaryOperation", "NewExpression", "Conditional", "StringLiteral", "HexLiteral", "HexNumber", "DecimalNumber", "MemberAccess", "IndexAccess", "IndexRangeAccess", "NameValueList", "UncheckedStatement", "TryStatement", "CatchClause", "FileLevelConstant", "AssemblyMemberAccess", "TypeDefinition"], be2 = ["+", "-", "*", "/", "**", "%", "<<", ">>", "&&", "||", "&", "^", "<", ">", "<=", ">=", "==", "!=", "=", "^=", "&=", "<<=", ">>=", "+=", "-=", "*=", "/=", "%=", "|", "|="], Le2 = ["-", "+", "++", "--", "~", "after", "delete", "!"], Se2 = class extends g {
              constructor(t5) {
                super(), this.options = t5, this.result = null;
              }
              defaultResult() {
                throw new Error("Unknown node");
              }
              aggregateResult() {
                return { type: "" };
              }
              visitSourceUnit(t5) {
                const e4 = { type: "SourceUnit", children: (t5.children ?? []).slice(0, -1).map((t6) => this.visit(t6)) }, i4 = this._addMeta(e4, t5);
                return this.result = i4, i4;
              }
              visitContractPart(t5) {
                return this.visit(t5.getChild(0));
              }
              visitContractDefinition(t5) {
                const e4 = this._toText(t5.identifier()), i4 = this._toText(t5.getChild(0));
                this._currentContract = e4;
                const s4 = { type: "ContractDefinition", name: e4, baseContracts: t5.inheritanceSpecifier_list().map((t6) => this.visitInheritanceSpecifier(t6)), subNodes: t5.contractPart_list().map((t6) => this.visit(t6)), kind: i4 };
                return this._addMeta(s4, t5);
              }
              visitStateVariableDeclaration(t5) {
                const e4 = this.visitTypeName(t5.typeName()), i4 = t5.identifier(), s4 = this._toText(i4);
                let r3 = null;
                const n2 = t5.expression();
                n2 && (r3 = this.visitExpression(n2));
                let a2 = "default";
                t5.InternalKeyword_list().length > 0 ? a2 = "internal" : t5.PublicKeyword_list().length > 0 ? a2 = "public" : t5.PrivateKeyword_list().length > 0 && (a2 = "private");
                let o2, l2 = false;
                t5.ConstantKeyword_list().length > 0 && (l2 = true);
                const h2 = t5.overrideSpecifier_list();
                o2 = 0 === h2.length ? null : h2[0].userDefinedTypeName_list().map((t6) => this.visitUserDefinedTypeName(t6));
                let c2 = false;
                t5.ImmutableKeyword_list().length > 0 && (c2 = true);
                let u2 = false;
                t5.TransientKeyword_list().length > 0 && (u2 = true);
                const p2 = { type: "VariableDeclaration", typeName: e4, name: s4, identifier: this.visitIdentifier(i4), expression: r3, visibility: a2, isStateVar: true, isDeclaredConst: l2, isIndexed: false, isImmutable: c2, isTransient: u2, override: o2, storageLocation: null }, d2 = { type: "StateVariableDeclaration", variables: [this._addMeta(p2, t5)], initialValue: r3 };
                return this._addMeta(d2, t5);
              }
              visitVariableDeclaration(t5) {
                let e4 = null;
                const i4 = t5.storageLocation();
                i4 && (e4 = this._toText(i4));
                const s4 = t5.identifier(), r3 = { type: "VariableDeclaration", typeName: this.visitTypeName(t5.typeName()), name: this._toText(s4), identifier: this.visitIdentifier(s4), storageLocation: e4, isStateVar: false, isIndexed: false, expression: null };
                return this._addMeta(r3, t5);
              }
              visitVariableDeclarationStatement(t5) {
                let e4 = [];
                const i4 = t5.variableDeclaration(), s4 = t5.identifierList(), r3 = t5.variableDeclarationList();
                i4 ? e4 = [this.visitVariableDeclaration(i4)] : s4 ? e4 = this.buildIdentifierList(s4) : r3 && (e4 = this.buildVariableDeclarationList(r3));
                let n2 = null;
                const a2 = t5.expression();
                a2 && (n2 = this.visitExpression(a2));
                const o2 = { type: "VariableDeclarationStatement", variables: e4, initialValue: n2 };
                return this._addMeta(o2, t5);
              }
              visitStatement(t5) {
                return this.visit(t5.getChild(0));
              }
              visitSimpleStatement(t5) {
                return this.visit(t5.getChild(0));
              }
              visitEventDefinition(t5) {
                const e4 = t5.eventParameterList().eventParameter_list().map((t6) => {
                  const e5 = this.visitTypeName(t6.typeName());
                  let i5 = null;
                  const s4 = t6.identifier();
                  s4 && (i5 = this._toText(s4));
                  const r3 = { type: "VariableDeclaration", typeName: e5, name: i5, identifier: s4 ? this.visitIdentifier(s4) : null, isStateVar: false, isIndexed: Boolean(t6.IndexedKeyword()), storageLocation: null, expression: null };
                  return this._addMeta(r3, t6);
                }), i4 = { type: "EventDefinition", name: this._toText(t5.identifier()), parameters: e4, isAnonymous: Boolean(t5.AnonymousKeyword()) };
                return this._addMeta(i4, t5);
              }
              visitBlock(t5) {
                const e4 = { type: "Block", statements: t5.statement_list().map((t6) => this.visitStatement(t6)) };
                return this._addMeta(e4, t5);
              }
              visitParameter(t5) {
                let e4 = null;
                const i4 = t5.storageLocation();
                i4 && (e4 = this._toText(i4));
                let s4 = null;
                const r3 = t5.identifier();
                r3 && (s4 = this._toText(r3));
                const n2 = { type: "VariableDeclaration", typeName: this.visitTypeName(t5.typeName()), name: s4, identifier: r3 ? this.visitIdentifier(r3) : null, storageLocation: e4, isStateVar: false, isIndexed: false, expression: null };
                return this._addMeta(n2, t5);
              }
              visitFunctionDefinition(t5) {
                let e4 = false, i4 = false, s4 = false, r3 = false, n2 = null, a2 = [], o2 = null, l2 = "default", h2 = null;
                const c2 = t5.block();
                c2 && (h2 = this.visitBlock(c2));
                const u2 = t5.modifierList().modifierInvocation_list().map((t6) => this.visitModifierInvocation(t6));
                let p2 = null;
                t5.modifierList().stateMutability_list().length > 0 && (p2 = this._stateMutabilityToText(t5.modifierList().stateMutability(0)));
                const d2 = t5.returnParameters();
                switch (this._toText(t5.functionDescriptor().getChild(0))) {
                  case "constructor":
                    a2 = t5.parameterList().parameter_list().map((t6) => this.visit(t6)), l2 = t5.modifierList().InternalKeyword_list().length > 0 ? "internal" : t5.modifierList().PublicKeyword_list().length > 0 ? "public" : "default", e4 = true;
                    break;
                  case "fallback":
                    a2 = t5.parameterList().parameter_list().map((t6) => this.visit(t6)), o2 = d2 ? this.visitReturnParameters(d2) : null, l2 = "external", i4 = true;
                    break;
                  case "receive":
                    l2 = "external", s4 = true;
                    break;
                  case "function": {
                    const s5 = t5.functionDescriptor().identifier();
                    n2 = s5 ? this._toText(s5) : "", a2 = t5.parameterList().parameter_list().map((t6) => this.visit(t6)), o2 = d2 ? this.visitReturnParameters(d2) : null, t5.modifierList().ExternalKeyword_list().length > 0 ? l2 = "external" : t5.modifierList().InternalKeyword_list().length > 0 ? l2 = "internal" : t5.modifierList().PublicKeyword_list().length > 0 ? l2 = "public" : t5.modifierList().PrivateKeyword_list().length > 0 && (l2 = "private"), e4 = n2 === this._currentContract, i4 = "" === n2;
                    break;
                  }
                }
                let m2;
                t5.modifierList().VirtualKeyword_list().length > 0 && (r3 = true);
                const _3 = t5.modifierList().overrideSpecifier_list();
                m2 = 0 === _3.length ? null : _3[0].userDefinedTypeName_list().map((t6) => this.visitUserDefinedTypeName(t6));
                const x3 = { type: "FunctionDefinition", name: n2, parameters: a2, returnParameters: o2, body: h2, visibility: l2, modifiers: u2, override: m2, isConstructor: e4, isReceiveEther: s4, isFallback: i4, isVirtual: r3, stateMutability: p2 };
                return this._addMeta(x3, t5);
              }
              visitEnumDefinition(t5) {
                const e4 = { type: "EnumDefinition", name: this._toText(t5.identifier()), members: t5.enumValue_list().map((t6) => this.visitEnumValue(t6)) };
                return this._addMeta(e4, t5);
              }
              visitEnumValue(t5) {
                const e4 = { type: "EnumValue", name: this._toText(t5.identifier()) };
                return this._addMeta(e4, t5);
              }
              visitElementaryTypeName(t5) {
                const e4 = { type: "ElementaryTypeName", name: this._toText(t5), stateMutability: null };
                return this._addMeta(e4, t5);
              }
              visitIdentifier(t5) {
                const e4 = { type: "Identifier", name: this._toText(t5) };
                return this._addMeta(e4, t5);
              }
              visitTypeName(t5) {
                if (t5.children && t5.children.length > 2) {
                  let e4 = null;
                  if (4 === t5.children.length) {
                    const i5 = t5.expression();
                    if (null == i5) throw new Error("Assertion error: a typeName with 4 children should have an expression");
                    e4 = this.visitExpression(i5);
                  }
                  const i4 = { type: "ArrayTypeName", baseTypeName: this.visitTypeName(t5.typeName()), length: e4 };
                  return this._addMeta(i4, t5);
                }
                if (2 === t5.children?.length) {
                  const e4 = { type: "ElementaryTypeName", name: this._toText(t5.getChild(0)), stateMutability: this._toText(t5.getChild(1)) };
                  return this._addMeta(e4, t5);
                }
                if (t5.elementaryTypeName()) return this.visitElementaryTypeName(t5.elementaryTypeName());
                if (t5.userDefinedTypeName()) return this.visitUserDefinedTypeName(t5.userDefinedTypeName());
                if (t5.mapping()) return this.visitMapping(t5.mapping());
                if (t5.functionTypeName()) return this.visitFunctionTypeName(t5.functionTypeName());
                throw new Error("Assertion error: unhandled type name case");
              }
              visitUserDefinedTypeName(t5) {
                const e4 = { type: "UserDefinedTypeName", namePath: this._toText(t5) };
                return this._addMeta(e4, t5);
              }
              visitUsingForDeclaration(t5) {
                let e4 = null;
                const i4 = t5.typeName();
                i4 && (e4 = this.visitTypeName(i4));
                const s4 = Boolean(t5.GlobalKeyword()), r3 = t5.usingForObject(), n2 = r3.userDefinedTypeName();
                let a2;
                if (n2) a2 = { type: "UsingForDeclaration", isGlobal: s4, typeName: e4, libraryName: this._toText(n2), functions: [], operators: [] };
                else {
                  const t6 = r3.usingForObjectDirective_list(), i5 = [], n3 = [];
                  for (const e5 of t6) {
                    i5.push(this._toText(e5.userDefinedTypeName()));
                    const t7 = e5.userDefinableOperators();
                    t7 ? n3.push(this._toText(t7)) : n3.push(null);
                  }
                  a2 = { type: "UsingForDeclaration", isGlobal: s4, typeName: e4, libraryName: null, functions: i5, operators: n3 };
                }
                return this._addMeta(a2, t5);
              }
              visitPragmaDirective(t5) {
                const e4 = t5.pragmaValue().version();
                let i4 = this._toText(t5.pragmaValue());
                e4?.children && (i4 = e4.children.map((t6) => this._toText(t6)).join(" "));
                const s4 = { type: "PragmaDirective", name: this._toText(t5.pragmaName()), value: i4 };
                return this._addMeta(s4, t5);
              }
              visitInheritanceSpecifier(t5) {
                const e4 = t5.expressionList(), i4 = e4 ? e4.expression_list().map((t6) => this.visitExpression(t6)) : [], s4 = { type: "InheritanceSpecifier", baseName: this.visitUserDefinedTypeName(t5.userDefinedTypeName()), arguments: i4 };
                return this._addMeta(s4, t5);
              }
              visitModifierInvocation(t5) {
                const e4 = t5.expressionList();
                let i4;
                i4 = null != e4 ? e4.expression_list().map((t6) => this.visit(t6)) : t5.children && t5.children.length > 1 ? [] : null;
                const s4 = { type: "ModifierInvocation", name: this._toText(t5.identifier()), arguments: i4 };
                return this._addMeta(s4, t5);
              }
              visitFunctionTypeName(t5) {
                const e4 = t5.functionTypeParameterList(0).functionTypeParameter_list().map((t6) => this.visitFunctionTypeParameter(t6));
                let i4 = [];
                t5.functionTypeParameterList_list().length > 1 && (i4 = t5.functionTypeParameterList(1).functionTypeParameter_list().map((t6) => this.visitFunctionTypeParameter(t6)));
                let s4 = "default";
                t5.InternalKeyword_list().length > 0 ? s4 = "internal" : t5.ExternalKeyword_list().length > 0 && (s4 = "external");
                let r3 = null;
                t5.stateMutability_list().length > 0 && (r3 = this._toText(t5.stateMutability(0)));
                const n2 = { type: "FunctionTypeName", parameterTypes: e4, returnTypes: i4, visibility: s4, stateMutability: r3 };
                return this._addMeta(n2, t5);
              }
              visitFunctionTypeParameter(t5) {
                let e4 = null;
                t5.storageLocation() && (e4 = this._toText(t5.storageLocation()));
                const i4 = { type: "VariableDeclaration", typeName: this.visitTypeName(t5.typeName()), name: null, identifier: null, storageLocation: e4, isStateVar: false, isIndexed: false, expression: null };
                return this._addMeta(i4, t5);
              }
              visitThrowStatement(t5) {
                return this._addMeta({ type: "ThrowStatement" }, t5);
              }
              visitReturnStatement(t5) {
                let e4 = null;
                const i4 = t5.expression();
                i4 && (e4 = this.visitExpression(i4));
                const s4 = { type: "ReturnStatement", expression: e4 };
                return this._addMeta(s4, t5);
              }
              visitEmitStatement(t5) {
                const e4 = { type: "EmitStatement", eventCall: this.visitFunctionCall(t5.functionCall()) };
                return this._addMeta(e4, t5);
              }
              visitCustomErrorDefinition(t5) {
                const e4 = { type: "CustomErrorDefinition", name: this._toText(t5.identifier()), parameters: this.visitParameterList(t5.parameterList()) };
                return this._addMeta(e4, t5);
              }
              visitTypeDefinition(t5) {
                const e4 = { type: "TypeDefinition", name: this._toText(t5.identifier()), definition: this.visitElementaryTypeName(t5.elementaryTypeName()) };
                return this._addMeta(e4, t5);
              }
              visitRevertStatement(t5) {
                const e4 = { type: "RevertStatement", revertCall: this.visitFunctionCall(t5.functionCall()) };
                return this._addMeta(e4, t5);
              }
              visitFunctionCall(t5) {
                let e4 = [];
                const i4 = [], s4 = [], r3 = t5.functionCallArguments(), n2 = r3.expressionList(), a2 = r3.nameValueList();
                if (n2) e4 = n2.expression_list().map((t6) => this.visitExpression(t6));
                else if (a2) for (const t6 of a2.nameValue_list()) e4.push(this.visitExpression(t6.expression())), i4.push(this._toText(t6.identifier())), s4.push(this.visitIdentifier(t6.identifier()));
                const o2 = { type: "FunctionCall", expression: this.visitExpression(t5.expression()), arguments: e4, names: i4, identifiers: s4 };
                return this._addMeta(o2, t5);
              }
              visitStructDefinition(t5) {
                const e4 = { type: "StructDefinition", name: this._toText(t5.identifier()), members: t5.variableDeclaration_list().map((t6) => this.visitVariableDeclaration(t6)) };
                return this._addMeta(e4, t5);
              }
              visitWhileStatement(t5) {
                const e4 = { type: "WhileStatement", condition: this.visitExpression(t5.expression()), body: this.visitStatement(t5.statement()) };
                return this._addMeta(e4, t5);
              }
              visitDoWhileStatement(t5) {
                const e4 = { type: "DoWhileStatement", condition: this.visitExpression(t5.expression()), body: this.visitStatement(t5.statement()) };
                return this._addMeta(e4, t5);
              }
              visitIfStatement(t5) {
                const e4 = this.visitStatement(t5.statement(0));
                let i4 = null;
                t5.statement_list().length > 1 && (i4 = this.visitStatement(t5.statement(1)));
                const s4 = { type: "IfStatement", condition: this.visitExpression(t5.expression()), trueBody: e4, falseBody: i4 };
                return this._addMeta(s4, t5);
              }
              visitTryStatement(t5) {
                let e4 = null;
                const i4 = t5.returnParameters();
                i4 && (e4 = this.visitReturnParameters(i4));
                const s4 = t5.catchClause_list().map((t6) => this.visitCatchClause(t6)), r3 = { type: "TryStatement", expression: this.visitExpression(t5.expression()), returnParameters: e4, body: this.visitBlock(t5.block()), catchClauses: s4 };
                return this._addMeta(r3, t5);
              }
              visitCatchClause(t5) {
                let e4 = null;
                if (t5.parameterList() && (e4 = this.visitParameterList(t5.parameterList())), t5.identifier() && "Error" !== this._toText(t5.identifier()) && "Panic" !== this._toText(t5.identifier())) throw new Error('Expected "Error" or "Panic" identifier in catch clause');
                let i4 = null;
                const s4 = t5.identifier();
                s4 && (i4 = this._toText(s4));
                const r3 = { type: "CatchClause", isReasonStringType: "Error" === i4, kind: i4, parameters: e4, body: this.visitBlock(t5.block()) };
                return this._addMeta(r3, t5);
              }
              visitExpressionStatement(t5) {
                if (!t5) return null;
                const e4 = { type: "ExpressionStatement", expression: this.visitExpression(t5.expression()) };
                return this._addMeta(e4, t5);
              }
              visitNumberLiteral(t5) {
                const e4 = this._toText(t5.getChild(0));
                let i4 = null;
                2 === t5.children?.length && (i4 = this._toText(t5.getChild(1)));
                const s4 = { type: "NumberLiteral", number: e4, subdenomination: i4 };
                return this._addMeta(s4, t5);
              }
              visitMappingKey(t5) {
                if (t5.elementaryTypeName()) return this.visitElementaryTypeName(t5.elementaryTypeName());
                if (t5.userDefinedTypeName()) return this.visitUserDefinedTypeName(t5.userDefinedTypeName());
                throw new Error("Expected MappingKey to have either elementaryTypeName or userDefinedTypeName");
              }
              visitMapping(t5) {
                const e4 = t5.mappingKeyName(), i4 = t5.mappingValueName(), s4 = { type: "Mapping", keyType: this.visitMappingKey(t5.mappingKey()), keyName: e4 ? this.visitIdentifier(e4.identifier()) : null, valueType: this.visitTypeName(t5.typeName()), valueName: i4 ? this.visitIdentifier(i4.identifier()) : null };
                return this._addMeta(s4, t5);
              }
              visitModifierDefinition(t5) {
                let e4 = null;
                t5.parameterList() && (e4 = this.visitParameterList(t5.parameterList()));
                let i4, s4 = false;
                t5.VirtualKeyword_list().length > 0 && (s4 = true);
                const r3 = t5.overrideSpecifier_list();
                i4 = 0 === r3.length ? null : r3[0].userDefinedTypeName_list().map((t6) => this.visitUserDefinedTypeName(t6));
                let n2 = null;
                const a2 = t5.block();
                a2 && (n2 = this.visitBlock(a2));
                const o2 = { type: "ModifierDefinition", name: this._toText(t5.identifier()), parameters: e4, body: n2, isVirtual: s4, override: i4 };
                return this._addMeta(o2, t5);
              }
              visitUncheckedStatement(t5) {
                const e4 = { type: "UncheckedStatement", block: this.visitBlock(t5.block()) };
                return this._addMeta(e4, t5);
              }
              visitExpression(t5) {
                let e4;
                switch (t5.children.length) {
                  case 1: {
                    const e5 = t5.primaryExpression();
                    if (null == e5) throw new Error("Assertion error: primary expression should exist when children length is 1");
                    return this.visitPrimaryExpression(e5);
                  }
                  case 2:
                    if (e4 = this._toText(t5.getChild(0)), "new" === e4) {
                      const e5 = { type: "NewExpression", typeName: this.visitTypeName(t5.typeName()) };
                      return this._addMeta(e5, t5);
                    }
                    if (Le2.includes(e4)) {
                      const i4 = { type: "UnaryOperation", operator: e4, subExpression: this.visitExpression(t5.expression(0)), isPrefix: true };
                      return this._addMeta(i4, t5);
                    }
                    if (e4 = this._toText(t5.getChild(1)), ["++", "--"].includes(e4)) {
                      const i4 = { type: "UnaryOperation", operator: e4, subExpression: this.visitExpression(t5.expression(0)), isPrefix: false };
                      return this._addMeta(i4, t5);
                    }
                    break;
                  case 3:
                    if ("(" === this._toText(t5.getChild(0)) && ")" === this._toText(t5.getChild(2))) {
                      const e5 = { type: "TupleExpression", components: [this.visitExpression(t5.expression(0))], isArray: false };
                      return this._addMeta(e5, t5);
                    }
                    if (e4 = this._toText(t5.getChild(1)), "." === e4) {
                      const e5 = { type: "MemberAccess", expression: this.visitExpression(t5.expression(0)), memberName: this._toText(t5.identifier()) };
                      return this._addMeta(e5, t5);
                    }
                    if (function(t6) {
                      return be2.includes(t6);
                    }(e4)) {
                      const i4 = { type: "BinaryOperation", operator: e4, left: this.visitExpression(t5.expression(0)), right: this.visitExpression(t5.expression(1)) };
                      return this._addMeta(i4, t5);
                    }
                    break;
                  case 4:
                    if ("(" === this._toText(t5.getChild(1)) && ")" === this._toText(t5.getChild(3))) {
                      let e5 = [];
                      const i4 = [], s4 = [], r3 = t5.functionCallArguments();
                      if (r3.expressionList()) e5 = r3.expressionList().expression_list().map((t6) => this.visitExpression(t6));
                      else if (r3.nameValueList()) for (const t6 of r3.nameValueList().nameValue_list()) e5.push(this.visitExpression(t6.expression())), i4.push(this._toText(t6.identifier())), s4.push(this.visitIdentifier(t6.identifier()));
                      const n2 = { type: "FunctionCall", expression: this.visitExpression(t5.expression(0)), arguments: e5, names: i4, identifiers: s4 };
                      return this._addMeta(n2, t5);
                    }
                    if ("[" === this._toText(t5.getChild(1)) && "]" === this._toText(t5.getChild(3))) {
                      if (":" === t5.getChild(2).getText()) {
                        const e6 = { type: "IndexRangeAccess", base: this.visitExpression(t5.expression(0)) };
                        return this._addMeta(e6, t5);
                      }
                      const e5 = { type: "IndexAccess", base: this.visitExpression(t5.expression(0)), index: this.visitExpression(t5.expression(1)) };
                      return this._addMeta(e5, t5);
                    }
                    if ("{" === this._toText(t5.getChild(1)) && "}" === this._toText(t5.getChild(3))) {
                      const e5 = { type: "NameValueExpression", expression: this.visitExpression(t5.expression(0)), arguments: this.visitNameValueList(t5.nameValueList()) };
                      return this._addMeta(e5, t5);
                    }
                    break;
                  case 5:
                    if ("?" === this._toText(t5.getChild(1)) && ":" === this._toText(t5.getChild(3))) {
                      const e5 = { type: "Conditional", condition: this.visitExpression(t5.expression(0)), trueExpression: this.visitExpression(t5.expression(1)), falseExpression: this.visitExpression(t5.expression(2)) };
                      return this._addMeta(e5, t5);
                    }
                    if ("[" === this._toText(t5.getChild(1)) && ":" === this._toText(t5.getChild(2)) && "]" === this._toText(t5.getChild(4))) {
                      const e5 = { type: "IndexRangeAccess", base: this.visitExpression(t5.expression(0)), indexEnd: this.visitExpression(t5.expression(1)) };
                      return this._addMeta(e5, t5);
                    }
                    if ("[" === this._toText(t5.getChild(1)) && ":" === this._toText(t5.getChild(3)) && "]" === this._toText(t5.getChild(4))) {
                      const e5 = { type: "IndexRangeAccess", base: this.visitExpression(t5.expression(0)), indexStart: this.visitExpression(t5.expression(1)) };
                      return this._addMeta(e5, t5);
                    }
                    break;
                  case 6:
                    if ("[" === this._toText(t5.getChild(1)) && ":" === this._toText(t5.getChild(3)) && "]" === this._toText(t5.getChild(5))) {
                      const e5 = { type: "IndexRangeAccess", base: this.visitExpression(t5.expression(0)), indexStart: this.visitExpression(t5.expression(1)), indexEnd: this.visitExpression(t5.expression(2)) };
                      return this._addMeta(e5, t5);
                    }
                }
                throw new Error("Unrecognized expression");
              }
              visitNameValueList(t5) {
                const e4 = [], i4 = [], s4 = [];
                for (const r4 of t5.nameValue_list()) e4.push(this._toText(r4.identifier())), i4.push(this.visitIdentifier(r4.identifier())), s4.push(this.visitExpression(r4.expression()));
                const r3 = { type: "NameValueList", names: e4, identifiers: i4, arguments: s4 };
                return this._addMeta(r3, t5);
              }
              visitFileLevelConstant(t5) {
                const e4 = { type: "FileLevelConstant", typeName: this.visitTypeName(t5.typeName()), name: this._toText(t5.identifier()), initialValue: this.visitExpression(t5.expression()), isDeclaredConst: true, isImmutable: false };
                return this._addMeta(e4, t5);
              }
              visitForStatement(t5) {
                let e4 = this.visitExpressionStatement(t5.expressionStatement());
                e4 && (e4 = e4.expression);
                const i4 = { type: "ForStatement", initExpression: t5.simpleStatement() ? this.visitSimpleStatement(t5.simpleStatement()) : null, conditionExpression: e4, loopExpression: { type: "ExpressionStatement", expression: t5.expression() ? this.visitExpression(t5.expression()) : null }, body: this.visitStatement(t5.statement()) };
                return this._addMeta(i4, t5);
              }
              visitHexLiteral(t5) {
                const e4 = t5.HexLiteralFragment_list().map((t6) => this._toText(t6)).map((t6) => t6.substring(4, t6.length - 1)), i4 = { type: "HexLiteral", value: e4.join(""), parts: e4 };
                return this._addMeta(i4, t5);
              }
              visitPrimaryExpression(t5) {
                if (t5.BooleanLiteral()) {
                  const e4 = { type: "BooleanLiteral", value: "true" === this._toText(t5.BooleanLiteral()) };
                  return this._addMeta(e4, t5);
                }
                if (t5.hexLiteral()) return this.visitHexLiteral(t5.hexLiteral());
                if (t5.stringLiteral()) {
                  const e4 = t5.stringLiteral().StringLiteralFragment_list().map((t6) => {
                    let e5 = this._toText(t6);
                    const i5 = "unicode" === e5.slice(0, 7);
                    i5 && (e5 = e5.slice(7));
                    const s5 = "'" === e5[0], r3 = e5.substring(1, e5.length - 1);
                    return { value: s5 ? r3.replace(new RegExp("\\\\'", "g"), "'") : r3.replace(new RegExp('\\\\"', "g"), '"'), isUnicode: i5 };
                  }), i4 = e4.map((t6) => t6.value), s4 = { type: "StringLiteral", value: i4.join(""), parts: i4, isUnicode: e4.map((t6) => t6.isUnicode) };
                  return this._addMeta(s4, t5);
                }
                if (t5.numberLiteral()) return this.visitNumberLiteral(t5.numberLiteral());
                if (t5.TypeKeyword()) {
                  const e4 = { type: "Identifier", name: "type" };
                  return this._addMeta(e4, t5);
                }
                return t5.typeName() ? this.visitTypeName(t5.typeName()) : this.visit(t5.getChild(0));
              }
              visitTupleExpression(t5) {
                const e4 = t5.children.slice(1, -1), i4 = { type: "TupleExpression", components: this._mapCommasToNulls(e4).map((t6) => null === t6 ? null : this.visit(t6)), isArray: "[" === this._toText(t5.getChild(0)) };
                return this._addMeta(i4, t5);
              }
              buildIdentifierList(t5) {
                const e4 = t5.children.slice(1, -1), i4 = t5.identifier_list();
                let s4 = 0;
                return this._mapCommasToNulls(e4).map((t6) => {
                  if (null === t6) return null;
                  const e5 = i4[s4];
                  s4++;
                  const r3 = { type: "VariableDeclaration", name: this._toText(e5), identifier: this.visitIdentifier(e5), isStateVar: false, isIndexed: false, typeName: null, storageLocation: null, expression: null };
                  return this._addMeta(r3, e5);
                });
              }
              buildVariableDeclarationList(t5) {
                const e4 = t5.variableDeclaration_list();
                let i4 = 0;
                return this._mapCommasToNulls(t5.children ?? []).map((t6) => {
                  if (!t6) return null;
                  const s4 = e4[i4];
                  i4++;
                  let r3 = null;
                  s4.storageLocation() && (r3 = this._toText(s4.storageLocation()));
                  const n2 = s4.identifier(), a2 = { type: "VariableDeclaration", name: this._toText(n2), identifier: this.visitIdentifier(n2), typeName: this.visitTypeName(s4.typeName()), storageLocation: r3, isStateVar: false, isIndexed: false, expression: null };
                  return this._addMeta(a2, s4);
                });
              }
              visitImportDirective(t5) {
                const e4 = this._toText(t5.importPath());
                let i4 = null, s4 = null, r3 = null, n2 = null;
                if (t5.importDeclaration_list().length > 0) r3 = t5.importDeclaration_list().map((t6) => {
                  const e5 = this._toText(t6.identifier(0));
                  let i5 = null;
                  return t6.identifier_list().length > 1 && (i5 = this._toText(t6.identifier(1))), [e5, i5];
                }), n2 = t5.importDeclaration_list().map((t6) => {
                  const e5 = this.visitIdentifier(t6.identifier(0));
                  let i5 = null;
                  return t6.identifier_list().length > 1 && (i5 = this.visitIdentifier(t6.identifier(1))), [e5, i5];
                });
                else {
                  const e5 = t5.identifier_list();
                  if (0 === e5.length) ;
                  else if (1 === e5.length) {
                    const e6 = t5.identifier(0);
                    i4 = this._toText(e6), s4 = this.visitIdentifier(e6);
                  } else {
                    if (2 !== e5.length) throw new Error("Assertion error: an import should have one or two identifiers");
                    {
                      const e6 = t5.identifier(1);
                      i4 = this._toText(e6), s4 = this.visitIdentifier(e6);
                    }
                  }
                }
                const a2 = e4.substring(1, e4.length - 1), o2 = { type: "StringLiteral", value: a2, parts: [a2], isUnicode: [false] }, l2 = { type: "ImportDirective", path: a2, pathLiteral: this._addMeta(o2, t5.importPath()), unitAlias: i4, unitAliasIdentifier: s4, symbolAliases: r3, symbolAliasesIdentifiers: n2 };
                return this._addMeta(l2, t5);
              }
              buildEventParameterList(t5) {
                return t5.eventParameter_list().map((t6) => {
                  const e4 = this.visit(t6.typeName()), i4 = t6.identifier();
                  return { type: "VariableDeclaration", typeName: e4, name: i4 ? this._toText(i4) : null, isStateVar: false, isIndexed: !!t6.IndexedKeyword() };
                });
              }
              visitReturnParameters(t5) {
                return this.visitParameterList(t5.parameterList());
              }
              visitParameterList(t5) {
                return t5.parameter_list().map((t6) => this.visitParameter(t6));
              }
              visitInlineAssemblyStatement(t5) {
                let e4 = null;
                t5.StringLiteralFragment() && (e4 = this._toText(t5.StringLiteralFragment()), e4 = e4.substring(1, e4.length - 1));
                const i4 = [], s4 = t5.inlineAssemblyStatementFlag();
                if (s4) {
                  const t6 = this._toText(s4.stringLiteral());
                  i4.push(t6.slice(1, t6.length - 1));
                }
                const r3 = { type: "InlineAssemblyStatement", language: e4, flags: i4, body: this.visitAssemblyBlock(t5.assemblyBlock()) };
                return this._addMeta(r3, t5);
              }
              visitAssemblyBlock(t5) {
                const e4 = { type: "AssemblyBlock", operations: t5.assemblyItem_list().map((t6) => this.visitAssemblyItem(t6)) };
                return this._addMeta(e4, t5);
              }
              visitAssemblyItem(t5) {
                let e4;
                if (t5.hexLiteral()) return this.visitHexLiteral(t5.hexLiteral());
                if (t5.stringLiteral()) {
                  e4 = this._toText(t5.stringLiteral());
                  const i4 = e4.substring(1, e4.length - 1), s4 = { type: "StringLiteral", value: i4, parts: [i4], isUnicode: [false] };
                  return this._addMeta(s4, t5);
                }
                if (t5.BreakKeyword()) {
                  const e5 = { type: "Break" };
                  return this._addMeta(e5, t5);
                }
                if (t5.ContinueKeyword()) {
                  const e5 = { type: "Continue" };
                  return this._addMeta(e5, t5);
                }
                return this.visit(t5.getChild(0));
              }
              visitAssemblyExpression(t5) {
                return this.visit(t5.getChild(0));
              }
              visitAssemblyCall(t5) {
                const e4 = { type: "AssemblyCall", functionName: this._toText(t5.getChild(0)), arguments: t5.assemblyExpression_list().map((t6) => this.visitAssemblyExpression(t6)) };
                return this._addMeta(e4, t5);
              }
              visitAssemblyLiteral(t5) {
                let e4;
                if (t5.stringLiteral()) {
                  e4 = this._toText(t5);
                  const i4 = e4.substring(1, e4.length - 1), s4 = { type: "StringLiteral", value: i4, parts: [i4], isUnicode: [false] };
                  return this._addMeta(s4, t5);
                }
                if (t5.BooleanLiteral()) {
                  const e5 = { type: "BooleanLiteral", value: "true" === this._toText(t5.BooleanLiteral()) };
                  return this._addMeta(e5, t5);
                }
                if (t5.DecimalNumber()) {
                  const e5 = { type: "DecimalNumber", value: this._toText(t5) };
                  return this._addMeta(e5, t5);
                }
                if (t5.HexNumber()) {
                  const e5 = { type: "HexNumber", value: this._toText(t5) };
                  return this._addMeta(e5, t5);
                }
                if (t5.hexLiteral()) return this.visitHexLiteral(t5.hexLiteral());
                throw new Error("Should never reach here");
              }
              visitAssemblySwitch(t5) {
                const e4 = { type: "AssemblySwitch", expression: this.visitAssemblyExpression(t5.assemblyExpression()), cases: t5.assemblyCase_list().map((t6) => this.visitAssemblyCase(t6)) };
                return this._addMeta(e4, t5);
              }
              visitAssemblyCase(t5) {
                let e4 = null;
                "case" === this._toText(t5.getChild(0)) && (e4 = this.visitAssemblyLiteral(t5.assemblyLiteral()));
                const i4 = { type: "AssemblyCase", block: this.visitAssemblyBlock(t5.assemblyBlock()), value: e4, default: null === e4 };
                return this._addMeta(i4, t5);
              }
              visitAssemblyLocalDefinition(t5) {
                const e4 = t5.assemblyIdentifierOrList();
                let i4;
                i4 = e4.identifier() ? [this.visitIdentifier(e4.identifier())] : e4.assemblyMember() ? [this.visitAssemblyMember(e4.assemblyMember())] : e4.assemblyIdentifierList().identifier_list().map((t6) => this.visitIdentifier(t6));
                let s4 = null;
                t5.assemblyExpression() && (s4 = this.visitAssemblyExpression(t5.assemblyExpression()));
                const r3 = { type: "AssemblyLocalDefinition", names: i4, expression: s4 };
                return this._addMeta(r3, t5);
              }
              visitAssemblyFunctionDefinition(t5) {
                const e4 = t5.assemblyIdentifierList(), i4 = e4 ? e4.identifier_list().map((t6) => this.visitIdentifier(t6)) : [], s4 = t5.assemblyFunctionReturns(), r3 = s4 ? s4.assemblyIdentifierList().identifier_list().map((t6) => this.visitIdentifier(t6)) : [], n2 = { type: "AssemblyFunctionDefinition", name: this._toText(t5.identifier()), arguments: i4, returnArguments: r3, body: this.visitAssemblyBlock(t5.assemblyBlock()) };
                return this._addMeta(n2, t5);
              }
              visitAssemblyAssignment(t5) {
                const e4 = t5.assemblyIdentifierOrList();
                let i4;
                i4 = e4.identifier() ? [this.visitIdentifier(e4.identifier())] : e4.assemblyMember() ? [this.visitAssemblyMember(e4.assemblyMember())] : e4.assemblyIdentifierList().identifier_list().map((t6) => this.visitIdentifier(t6));
                const s4 = { type: "AssemblyAssignment", names: i4, expression: this.visitAssemblyExpression(t5.assemblyExpression()) };
                return this._addMeta(s4, t5);
              }
              visitAssemblyMember(t5) {
                const [e4, i4] = t5.identifier_list(), s4 = { type: "AssemblyMemberAccess", expression: this.visitIdentifier(e4), memberName: this.visitIdentifier(i4) };
                return this._addMeta(s4, t5);
              }
              visitLabelDefinition(t5) {
                const e4 = { type: "LabelDefinition", name: this._toText(t5.identifier()) };
                return this._addMeta(e4, t5);
              }
              visitAssemblyStackAssignment(t5) {
                const e4 = { type: "AssemblyStackAssignment", name: this._toText(t5.identifier()), expression: this.visitAssemblyExpression(t5.assemblyExpression()) };
                return this._addMeta(e4, t5);
              }
              visitAssemblyFor(t5) {
                const e4 = { type: "AssemblyFor", pre: this.visit(t5.getChild(1)), condition: this.visit(t5.getChild(2)), post: this.visit(t5.getChild(3)), body: this.visit(t5.getChild(4)) };
                return this._addMeta(e4, t5);
              }
              visitAssemblyIf(t5) {
                const e4 = { type: "AssemblyIf", condition: this.visitAssemblyExpression(t5.assemblyExpression()), body: this.visitAssemblyBlock(t5.assemblyBlock()) };
                return this._addMeta(e4, t5);
              }
              visitContinueStatement(t5) {
                return this._addMeta({ type: "ContinueStatement" }, t5);
              }
              visitBreakStatement(t5) {
                return this._addMeta({ type: "BreakStatement" }, t5);
              }
              _toText(t5) {
                const e4 = t5.getText();
                if (null == e4) throw new Error("Assertion error: text should never be undefined");
                return e4;
              }
              _stateMutabilityToText(t5) {
                if (t5.PureKeyword()) return "pure";
                if (t5.ConstantKeyword()) return "constant";
                if (t5.PayableKeyword()) return "payable";
                if (t5.ViewKeyword()) return "view";
                throw new Error("Assertion error: non-exhaustive stateMutability check");
              }
              _loc(t5) {
                return { start: { line: t5.start.line, column: t5.start.column }, end: { line: t5.stop ? t5.stop.line : t5.start.line, column: t5.stop ? t5.stop.column : t5.start.column } };
              }
              _range(t5) {
                return [t5.start.start, t5.stop?.stop ?? t5.start.start];
              }
              _addMeta(t5, e4) {
                const i4 = { type: t5.type };
                return true === this.options.loc && (t5.loc = this._loc(e4)), true === this.options.range && (t5.range = this._range(e4)), { ...i4, ...t5 };
              }
              _mapCommasToNulls(t5) {
                if (0 === t5.length) return [];
                const e4 = [];
                let i4 = true;
                for (const s4 of t5) if (i4) "," === this._toText(s4) ? e4.push(null) : (e4.push(s4), i4 = false);
                else {
                  if ("," !== this._toText(s4)) throw new Error("expected comma");
                  i4 = true;
                }
                return i4 && e4.push(null), e4;
              }
            }, Ce2 = class extends m {
              constructor() {
                super(), this._errors = [];
              }
              syntaxError(t5, e4, i4, s4, r3) {
                this._errors.push({ message: r3, line: i4, column: s4 });
              }
              getErrors() {
                return this._errors;
              }
              hasErrors() {
                return this._errors.length > 0;
              }
            }, Ae2 = { 1: "pragma", 2: ";", 3: "*", 4: "||", 5: "^", 6: "~", 7: ">=", 8: ">", 9: "<", 10: "<=", 11: "=", 12: "as", 13: "import", 14: "from", 15: "{", 16: ",", 17: "}", 18: "abstract", 19: "contract", 20: "interface", 21: "library", 22: "is", 23: "(", 24: ")", 25: "error", 26: "using", 27: "for", 28: "|", 29: "&", 30: "+", 31: "-", 32: "/", 33: "%", 34: "==", 35: "!=", 36: "struct", 37: "modifier", 38: "function", 39: "returns", 40: "event", 41: "enum", 42: "[", 43: "]", 44: "address", 45: ".", 46: "mapping", 47: "=>", 48: "memory", 49: "storage", 50: "calldata", 51: "if", 52: "else", 53: "try", 54: "catch", 55: "while", 56: "unchecked", 57: "assembly", 58: "do", 59: "return", 60: "throw", 61: "emit", 62: "revert", 63: "var", 64: "bool", 65: "string", 66: "byte", 67: "++", 68: "--", 69: "new", 70: ":", 71: "delete", 72: "!", 73: "**", 74: "<<", 75: ">>", 76: "&&", 77: "?", 78: "|=", 79: "^=", 80: "&=", 81: "<<=", 82: ">>=", 83: "+=", 84: "-=", 85: "*=", 86: "/=", 87: "%=", 88: "let", 89: ":=", 90: "=:", 91: "switch", 92: "case", 93: "default", 94: "->", 95: "callback", 96: "override", 97: "Int", 98: "Uint", 99: "Byte", 100: "Fixed", 101: "Ufixed", 102: "BooleanLiteral", 103: "DecimalNumber", 104: "HexNumber", 105: "NumberUnit", 106: "HexLiteralFragment", 107: "ReservedKeyword", 108: "anonymous", 109: "break", 110: "constant", 111: "transient", 112: "immutable", 113: "continue", 114: "leave", 115: "external", 116: "indexed", 117: "internal", 118: "payable", 119: "private", 120: "public", 121: "virtual", 122: "pure", 123: "type", 124: "view", 125: "global", 126: "constructor", 127: "fallback", 128: "receive", 129: "Identifier", 130: "StringLiteralFragment", 131: "VersionLiteral", 132: "WS", 133: "COMMENT", 134: "LINE_COMMENT" }, we2 = ["var", "bool", "address", "string", "Int", "Uint", "Byte", "Fixed", "UFixed"];
            function Ne2(t5) {
              return [t5.start, t5.stop + 1];
            }
            function Ie2(t5) {
              const e4 = (t5.text ?? "").split(/\r?\n/), i4 = e4.length - 1;
              return { start: { line: t5.line, column: t5.column }, end: { line: t5.line + i4, column: e4[i4].length + (0 === i4 ? t5.column : 0) } };
            }
            function ke2(t5, e4) {
              return t5.map((t6) => {
                var i4;
                const s4 = { type: "Identifier" === (i4 = Ae2[t6.type.toString()]) || "from" === i4 ? "Identifier" : "TrueLiteral" === i4 || "FalseLiteral" === i4 ? "Boolean" : "VersionLiteral" === i4 ? "Version" : "StringLiteral" === i4 ? "String" : we2.includes(i4) ? "Type" : "NumberUnit" === i4 ? "Subdenomination" : "DecimalNumber" === i4 ? "Numeric" : "HexLiteral" === i4 ? "Hex" : "ReservedKeyword" === i4 ? "Reserved" : /^\W+$/.test(i4) ? "Punctuator" : "Keyword", value: t6.text };
                return true === e4.range && (s4.range = Ne2(t6)), true === e4.loc && (s4.loc = Ie2(t6)), s4;
              });
            }
            var De2 = class extends Error {
              constructor(t5) {
                super();
                const { message: e4, line: i4, column: s4 } = t5.errors[0];
                this.message = `${e4} (${i4}:${s4})`, this.errors = t5.errors, void 0 !== Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack;
              }
            };
            function Oe2(t5, e4 = {}) {
              const i4 = new u(t5);
              return ke2(new C(i4).getAllTokens(), e4);
            }
            function Pe2(t5, e4 = {}) {
              const i4 = new u(t5), s4 = new C(i4), r3 = new p(s4), n2 = new w2(r3), a2 = new Ce2();
              s4.removeErrorListeners(), s4.addErrorListener(a2), n2.removeErrorListeners(), n2.addErrorListener(a2), n2.buildParseTrees = true;
              const o2 = n2.sourceUnit(), l2 = new Se2(e4);
              l2.visit(o2);
              const h2 = l2.result;
              if (null === h2) throw new Error("ast should never be null");
              if (true === e4.tokens && (h2.tokens = ke2(r3.tokens, e4)), true === e4.comments && (h2.comments = function(t6, e5, i5) {
                return t6.filter((t7) => t7.channel === e5).map((t7) => {
                  const e6 = t7.text.startsWith("//") ? { type: "LineComment", value: t7.text.slice(2) } : { type: "BlockComment", value: t7.text.slice(2, -2) };
                  return true === i5.range && (e6.range = Ne2(t7)), true === i5.loc && (e6.loc = Ie2(t7)), e6;
                });
              }(r3.tokens, s4.channelNames.indexOf("HIDDEN"), e4)), a2.hasErrors()) {
                if (true !== e4.tolerant) throw new De2({ errors: a2.getErrors() });
                h2.errors = a2.getErrors();
              }
              return h2;
            }
            function Fe2(t5, e4, i4) {
              if (Array.isArray(t5) && t5.forEach((t6) => Fe2(t6, e4, i4)), !function(t6) {
                if ("object" != typeof t6 || null === t6) return false;
                const e5 = t6;
                return !(!Object.prototype.hasOwnProperty.call(e5, "type") || "string" != typeof e5.type) && ve2.includes(e5.type);
              }(t5)) return;
              let s4 = true;
              if (void 0 !== e4[t5.type] && (s4 = e4[t5.type](t5, i4)), false === s4) return;
              for (const i5 in t5) Object.prototype.hasOwnProperty.call(t5, i5) && Fe2(t5[i5], e4, t5);
              const r3 = t5.type + ":exit";
              void 0 !== e4[r3] && e4[r3](t5, i4);
            }
            var Ue2, He2 = { ParserError: De2, parse: Pe2, tokenize: Oe2, visit: Fe2 };
            return Ue2 = r2, ((r3, n2, a2, o2) => {
              if (n2 && "object" == typeof n2 || "function" == typeof n2) for (let a3 of i3(n2)) s3.call(r3, a3) || void 0 === a3 || t4(r3, a3, { get: () => n2[a3], enumerable: !(o2 = e3(n2, a3)) || o2.enumerable });
              return r3;
            })(t4({}, "__esModule", { value: true }), Ue2);
          })();
          return t3;
        }, t2.exports = s2();
      }, 904: (t2, e2, i2) => {
        const s2 = Symbol("SemVer ANY");
        class r2 {
          static get ANY() {
            return s2;
          }
          constructor(t3, e3) {
            if (e3 = n(e3), t3 instanceof r2) {
              if (t3.loose === !!e3.loose) return t3;
              t3 = t3.value;
            }
            t3 = t3.trim().split(/\s+/).join(" "), h("comparator", t3, e3), this.options = e3, this.loose = !!e3.loose, this.parse(t3), this.semver === s2 ? this.value = "" : this.value = this.operator + this.semver.version, h("comp", this);
          }
          parse(t3) {
            const e3 = this.options.loose ? a[o.COMPARATORLOOSE] : a[o.COMPARATOR], i3 = t3.match(e3);
            if (!i3) throw new TypeError(`Invalid comparator: ${t3}`);
            this.operator = void 0 !== i3[1] ? i3[1] : "", "=" === this.operator && (this.operator = ""), i3[2] ? this.semver = new c(i3[2], this.options.loose) : this.semver = s2;
          }
          toString() {
            return this.value;
          }
          test(t3) {
            if (h("Comparator.test", t3, this.options.loose), this.semver === s2 || t3 === s2) return true;
            if ("string" == typeof t3) try {
              t3 = new c(t3, this.options);
            } catch (t4) {
              return false;
            }
            return l(t3, this.operator, this.semver, this.options);
          }
          intersects(t3, e3) {
            if (!(t3 instanceof r2)) throw new TypeError("a Comparator is required");
            return "" === this.operator ? "" === this.value || new u(t3.value, e3).test(this.value) : "" === t3.operator ? "" === t3.value || new u(this.value, e3).test(t3.semver) : !((e3 = n(e3)).includePrerelease && ("<0.0.0-0" === this.value || "<0.0.0-0" === t3.value) || !e3.includePrerelease && (this.value.startsWith("<0.0.0") || t3.value.startsWith("<0.0.0")) || (!this.operator.startsWith(">") || !t3.operator.startsWith(">")) && (!this.operator.startsWith("<") || !t3.operator.startsWith("<")) && (this.semver.version !== t3.semver.version || !this.operator.includes("=") || !t3.operator.includes("=")) && !(l(this.semver, "<", t3.semver, e3) && this.operator.startsWith(">") && t3.operator.startsWith("<")) && !(l(this.semver, ">", t3.semver, e3) && this.operator.startsWith("<") && t3.operator.startsWith(">")));
          }
        }
        t2.exports = r2;
        const n = i2(587), { safeRe: a, t: o } = i2(718), l = i2(111), h = i2(272), c = i2(908), u = i2(311);
      }, 311: (t2, e2, i2) => {
        const s2 = /\s+/g;
        class r2 {
          constructor(t3, e3) {
            if (e3 = a(e3), t3 instanceof r2) return t3.loose === !!e3.loose && t3.includePrerelease === !!e3.includePrerelease ? t3 : new r2(t3.raw, e3);
            if (t3 instanceof o) return this.raw = t3.value, this.set = [[t3]], this.formatted = void 0, this;
            if (this.options = e3, this.loose = !!e3.loose, this.includePrerelease = !!e3.includePrerelease, this.raw = t3.trim().replace(s2, " "), this.set = this.raw.split("||").map((t4) => this.parseRange(t4.trim())).filter((t4) => t4.length), !this.set.length) throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
            if (this.set.length > 1) {
              const t4 = this.set[0];
              if (this.set = this.set.filter((t5) => !f(t5[0])), 0 === this.set.length) this.set = [t4];
              else if (this.set.length > 1) {
                for (const t5 of this.set) if (1 === t5.length && y2(t5[0])) {
                  this.set = [t5];
                  break;
                }
              }
            }
            this.formatted = void 0;
          }
          get range() {
            if (void 0 === this.formatted) {
              this.formatted = "";
              for (let t3 = 0; t3 < this.set.length; t3++) {
                t3 > 0 && (this.formatted += "||");
                const e3 = this.set[t3];
                for (let t4 = 0; t4 < e3.length; t4++) t4 > 0 && (this.formatted += " "), this.formatted += e3[t4].toString().trim();
              }
            }
            return this.formatted;
          }
          format() {
            return this.range;
          }
          toString() {
            return this.range;
          }
          parseRange(t3) {
            const e3 = ((this.options.includePrerelease && _2) | (this.options.loose && x2)) + ":" + t3, i3 = n.get(e3);
            if (i3) return i3;
            const s3 = this.options.loose, r3 = s3 ? c[u.HYPHENRANGELOOSE] : c[u.HYPHENRANGE];
            t3 = t3.replace(r3, N2(this.options.includePrerelease)), l("hyphen replace", t3), t3 = t3.replace(c[u.COMPARATORTRIM], p), l("comparator trim", t3), t3 = t3.replace(c[u.TILDETRIM], d), l("tilde trim", t3), t3 = t3.replace(c[u.CARETTRIM], m), l("caret trim", t3);
            let a2 = t3.split(" ").map((t4) => T2(t4, this.options)).join(" ").split(/\s+/).map((t4) => w2(t4, this.options));
            s3 && (a2 = a2.filter((t4) => (l("loose invalid filter", t4, this.options), !!t4.match(c[u.COMPARATORLOOSE])))), l("range list", a2);
            const h2 = /* @__PURE__ */ new Map(), y3 = a2.map((t4) => new o(t4, this.options));
            for (const t4 of y3) {
              if (f(t4)) return [t4];
              h2.set(t4.value, t4);
            }
            h2.size > 1 && h2.has("") && h2.delete("");
            const g2 = [...h2.values()];
            return n.set(e3, g2), g2;
          }
          intersects(t3, e3) {
            if (!(t3 instanceof r2)) throw new TypeError("a Range is required");
            return this.set.some((i3) => g(i3, e3) && t3.set.some((t4) => g(t4, e3) && i3.every((i4) => t4.every((t5) => i4.intersects(t5, e3)))));
          }
          test(t3) {
            if (!t3) return false;
            if ("string" == typeof t3) try {
              t3 = new h(t3, this.options);
            } catch (t4) {
              return false;
            }
            for (let e3 = 0; e3 < this.set.length; e3++) if (I2(this.set[e3], t3, this.options)) return true;
            return false;
          }
        }
        t2.exports = r2;
        const n = new (i2(794))(), a = i2(587), o = i2(904), l = i2(272), h = i2(908), { safeRe: c, t: u, comparatorTrimReplace: p, tildeTrimReplace: d, caretTrimReplace: m } = i2(718), { FLAG_INCLUDE_PRERELEASE: _2, FLAG_LOOSE: x2 } = i2(874), f = (t3) => "<0.0.0-0" === t3.value, y2 = (t3) => "" === t3.value, g = (t3, e3) => {
          let i3 = true;
          const s3 = t3.slice();
          let r3 = s3.pop();
          for (; i3 && s3.length; ) i3 = s3.every((t4) => r3.intersects(t4, e3)), r3 = s3.pop();
          return i3;
        }, T2 = (t3, e3) => (l("comp", t3, e3), t3 = b(t3, e3), l("caret", t3), t3 = R2(t3, e3), l("tildes", t3), t3 = S2(t3, e3), l("xrange", t3), t3 = A2(t3, e3), l("stars", t3), t3), E = (t3) => !t3 || "x" === t3.toLowerCase() || "*" === t3, R2 = (t3, e3) => t3.trim().split(/\s+/).map((t4) => v(t4, e3)).join(" "), v = (t3, e3) => {
          const i3 = e3.loose ? c[u.TILDELOOSE] : c[u.TILDE];
          return t3.replace(i3, (e4, i4, s3, r3, n2) => {
            let a2;
            return l("tilde", t3, e4, i4, s3, r3, n2), E(i4) ? a2 = "" : E(s3) ? a2 = `>=${i4}.0.0 <${+i4 + 1}.0.0-0` : E(r3) ? a2 = `>=${i4}.${s3}.0 <${i4}.${+s3 + 1}.0-0` : n2 ? (l("replaceTilde pr", n2), a2 = `>=${i4}.${s3}.${r3}-${n2} <${i4}.${+s3 + 1}.0-0`) : a2 = `>=${i4}.${s3}.${r3} <${i4}.${+s3 + 1}.0-0`, l("tilde return", a2), a2;
          });
        }, b = (t3, e3) => t3.trim().split(/\s+/).map((t4) => L2(t4, e3)).join(" "), L2 = (t3, e3) => {
          l("caret", t3, e3);
          const i3 = e3.loose ? c[u.CARETLOOSE] : c[u.CARET], s3 = e3.includePrerelease ? "-0" : "";
          return t3.replace(i3, (e4, i4, r3, n2, a2) => {
            let o2;
            return l("caret", t3, e4, i4, r3, n2, a2), E(i4) ? o2 = "" : E(r3) ? o2 = `>=${i4}.0.0${s3} <${+i4 + 1}.0.0-0` : E(n2) ? o2 = "0" === i4 ? `>=${i4}.${r3}.0${s3} <${i4}.${+r3 + 1}.0-0` : `>=${i4}.${r3}.0${s3} <${+i4 + 1}.0.0-0` : a2 ? (l("replaceCaret pr", a2), o2 = "0" === i4 ? "0" === r3 ? `>=${i4}.${r3}.${n2}-${a2} <${i4}.${r3}.${+n2 + 1}-0` : `>=${i4}.${r3}.${n2}-${a2} <${i4}.${+r3 + 1}.0-0` : `>=${i4}.${r3}.${n2}-${a2} <${+i4 + 1}.0.0-0`) : (l("no pr"), o2 = "0" === i4 ? "0" === r3 ? `>=${i4}.${r3}.${n2}${s3} <${i4}.${r3}.${+n2 + 1}-0` : `>=${i4}.${r3}.${n2}${s3} <${i4}.${+r3 + 1}.0-0` : `>=${i4}.${r3}.${n2} <${+i4 + 1}.0.0-0`), l("caret return", o2), o2;
          });
        }, S2 = (t3, e3) => (l("replaceXRanges", t3, e3), t3.split(/\s+/).map((t4) => C(t4, e3)).join(" ")), C = (t3, e3) => {
          t3 = t3.trim();
          const i3 = e3.loose ? c[u.XRANGELOOSE] : c[u.XRANGE];
          return t3.replace(i3, (i4, s3, r3, n2, a2, o2) => {
            l("xRange", t3, i4, s3, r3, n2, a2, o2);
            const h2 = E(r3), c2 = h2 || E(n2), u2 = c2 || E(a2), p2 = u2;
            return "=" === s3 && p2 && (s3 = ""), o2 = e3.includePrerelease ? "-0" : "", h2 ? i4 = ">" === s3 || "<" === s3 ? "<0.0.0-0" : "*" : s3 && p2 ? (c2 && (n2 = 0), a2 = 0, ">" === s3 ? (s3 = ">=", c2 ? (r3 = +r3 + 1, n2 = 0, a2 = 0) : (n2 = +n2 + 1, a2 = 0)) : "<=" === s3 && (s3 = "<", c2 ? r3 = +r3 + 1 : n2 = +n2 + 1), "<" === s3 && (o2 = "-0"), i4 = `${s3 + r3}.${n2}.${a2}${o2}`) : c2 ? i4 = `>=${r3}.0.0${o2} <${+r3 + 1}.0.0-0` : u2 && (i4 = `>=${r3}.${n2}.0${o2} <${r3}.${+n2 + 1}.0-0`), l("xRange return", i4), i4;
          });
        }, A2 = (t3, e3) => (l("replaceStars", t3, e3), t3.trim().replace(c[u.STAR], "")), w2 = (t3, e3) => (l("replaceGTE0", t3, e3), t3.trim().replace(c[e3.includePrerelease ? u.GTE0PRE : u.GTE0], "")), N2 = (t3) => (e3, i3, s3, r3, n2, a2, o2, l2, h2, c2, u2, p2) => `${i3 = E(s3) ? "" : E(r3) ? `>=${s3}.0.0${t3 ? "-0" : ""}` : E(n2) ? `>=${s3}.${r3}.0${t3 ? "-0" : ""}` : a2 ? `>=${i3}` : `>=${i3}${t3 ? "-0" : ""}`} ${l2 = E(h2) ? "" : E(c2) ? `<${+h2 + 1}.0.0-0` : E(u2) ? `<${h2}.${+c2 + 1}.0-0` : p2 ? `<=${h2}.${c2}.${u2}-${p2}` : t3 ? `<${h2}.${c2}.${+u2 + 1}-0` : `<=${l2}`}`.trim(), I2 = (t3, e3, i3) => {
          for (let i4 = 0; i4 < t3.length; i4++) if (!t3[i4].test(e3)) return false;
          if (e3.prerelease.length && !i3.includePrerelease) {
            for (let i4 = 0; i4 < t3.length; i4++) if (l(t3[i4].semver), t3[i4].semver !== o.ANY && t3[i4].semver.prerelease.length > 0) {
              const s3 = t3[i4].semver;
              if (s3.major === e3.major && s3.minor === e3.minor && s3.patch === e3.patch) return true;
            }
            return false;
          }
          return true;
        };
      }, 908: (t2, e2, i2) => {
        const s2 = i2(272), { MAX_LENGTH: r2, MAX_SAFE_INTEGER: n } = i2(874), { safeRe: a, t: o } = i2(718), l = i2(587), { compareIdentifiers: h } = i2(123);
        class c {
          constructor(t3, e3) {
            if (e3 = l(e3), t3 instanceof c) {
              if (t3.loose === !!e3.loose && t3.includePrerelease === !!e3.includePrerelease) return t3;
              t3 = t3.version;
            } else if ("string" != typeof t3) throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t3}".`);
            if (t3.length > r2) throw new TypeError(`version is longer than ${r2} characters`);
            s2("SemVer", t3, e3), this.options = e3, this.loose = !!e3.loose, this.includePrerelease = !!e3.includePrerelease;
            const i3 = t3.trim().match(e3.loose ? a[o.LOOSE] : a[o.FULL]);
            if (!i3) throw new TypeError(`Invalid Version: ${t3}`);
            if (this.raw = t3, this.major = +i3[1], this.minor = +i3[2], this.patch = +i3[3], this.major > n || this.major < 0) throw new TypeError("Invalid major version");
            if (this.minor > n || this.minor < 0) throw new TypeError("Invalid minor version");
            if (this.patch > n || this.patch < 0) throw new TypeError("Invalid patch version");
            i3[4] ? this.prerelease = i3[4].split(".").map((t4) => {
              if (/^[0-9]+$/.test(t4)) {
                const e4 = +t4;
                if (e4 >= 0 && e4 < n) return e4;
              }
              return t4;
            }) : this.prerelease = [], this.build = i3[5] ? i3[5].split(".") : [], this.format();
          }
          format() {
            return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
          }
          toString() {
            return this.version;
          }
          compare(t3) {
            if (s2("SemVer.compare", this.version, this.options, t3), !(t3 instanceof c)) {
              if ("string" == typeof t3 && t3 === this.version) return 0;
              t3 = new c(t3, this.options);
            }
            return t3.version === this.version ? 0 : this.compareMain(t3) || this.comparePre(t3);
          }
          compareMain(t3) {
            return t3 instanceof c || (t3 = new c(t3, this.options)), h(this.major, t3.major) || h(this.minor, t3.minor) || h(this.patch, t3.patch);
          }
          comparePre(t3) {
            if (t3 instanceof c || (t3 = new c(t3, this.options)), this.prerelease.length && !t3.prerelease.length) return -1;
            if (!this.prerelease.length && t3.prerelease.length) return 1;
            if (!this.prerelease.length && !t3.prerelease.length) return 0;
            let e3 = 0;
            do {
              const i3 = this.prerelease[e3], r3 = t3.prerelease[e3];
              if (s2("prerelease compare", e3, i3, r3), void 0 === i3 && void 0 === r3) return 0;
              if (void 0 === r3) return 1;
              if (void 0 === i3) return -1;
              if (i3 !== r3) return h(i3, r3);
            } while (++e3);
          }
          compareBuild(t3) {
            t3 instanceof c || (t3 = new c(t3, this.options));
            let e3 = 0;
            do {
              const i3 = this.build[e3], r3 = t3.build[e3];
              if (s2("build compare", e3, i3, r3), void 0 === i3 && void 0 === r3) return 0;
              if (void 0 === r3) return 1;
              if (void 0 === i3) return -1;
              if (i3 !== r3) return h(i3, r3);
            } while (++e3);
          }
          inc(t3, e3, i3) {
            switch (t3) {
              case "premajor":
                this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", e3, i3);
                break;
              case "preminor":
                this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", e3, i3);
                break;
              case "prepatch":
                this.prerelease.length = 0, this.inc("patch", e3, i3), this.inc("pre", e3, i3);
                break;
              case "prerelease":
                0 === this.prerelease.length && this.inc("patch", e3, i3), this.inc("pre", e3, i3);
                break;
              case "major":
                0 === this.minor && 0 === this.patch && 0 !== this.prerelease.length || this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
                break;
              case "minor":
                0 === this.patch && 0 !== this.prerelease.length || this.minor++, this.patch = 0, this.prerelease = [];
                break;
              case "patch":
                0 === this.prerelease.length && this.patch++, this.prerelease = [];
                break;
              case "pre": {
                const t4 = Number(i3) ? 1 : 0;
                if (!e3 && false === i3) throw new Error("invalid increment argument: identifier is empty");
                if (0 === this.prerelease.length) this.prerelease = [t4];
                else {
                  let s3 = this.prerelease.length;
                  for (; --s3 >= 0; ) "number" == typeof this.prerelease[s3] && (this.prerelease[s3]++, s3 = -2);
                  if (-1 === s3) {
                    if (e3 === this.prerelease.join(".") && false === i3) throw new Error("invalid increment argument: identifier already exists");
                    this.prerelease.push(t4);
                  }
                }
                if (e3) {
                  let s3 = [e3, t4];
                  false === i3 && (s3 = [e3]), 0 === h(this.prerelease[0], e3) ? isNaN(this.prerelease[1]) && (this.prerelease = s3) : this.prerelease = s3;
                }
                break;
              }
              default:
                throw new Error(`invalid increment argument: ${t3}`);
            }
            return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
          }
        }
        t2.exports = c;
      }, 111: (t2, e2, i2) => {
        const s2 = i2(641), r2 = i2(999), n = i2(580), a = i2(89), o = i2(59), l = i2(200);
        t2.exports = (t3, e3, i3, h) => {
          switch (e3) {
            case "===":
              return "object" == typeof t3 && (t3 = t3.version), "object" == typeof i3 && (i3 = i3.version), t3 === i3;
            case "!==":
              return "object" == typeof t3 && (t3 = t3.version), "object" == typeof i3 && (i3 = i3.version), t3 !== i3;
            case "":
            case "=":
            case "==":
              return s2(t3, i3, h);
            case "!=":
              return r2(t3, i3, h);
            case ">":
              return n(t3, i3, h);
            case ">=":
              return a(t3, i3, h);
            case "<":
              return o(t3, i3, h);
            case "<=":
              return l(t3, i3, h);
            default:
              throw new TypeError(`Invalid operator: ${e3}`);
          }
        };
      }, 170: (t2, e2, i2) => {
        const s2 = i2(908), r2 = i2(144), { safeRe: n, t: a } = i2(718);
        t2.exports = (t3, e3) => {
          if (t3 instanceof s2) return t3;
          if ("number" == typeof t3 && (t3 = String(t3)), "string" != typeof t3) return null;
          let i3 = null;
          if ((e3 = e3 || {}).rtl) {
            const s3 = e3.includePrerelease ? n[a.COERCERTLFULL] : n[a.COERCERTL];
            let r3;
            for (; (r3 = s3.exec(t3)) && (!i3 || i3.index + i3[0].length !== t3.length); ) i3 && r3.index + r3[0].length === i3.index + i3[0].length || (i3 = r3), s3.lastIndex = r3.index + r3[1].length + r3[2].length;
            s3.lastIndex = -1;
          } else i3 = t3.match(e3.includePrerelease ? n[a.COERCEFULL] : n[a.COERCE]);
          if (null === i3) return null;
          const o = i3[2], l = i3[3] || "0", h = i3[4] || "0", c = e3.includePrerelease && i3[5] ? `-${i3[5]}` : "", u = e3.includePrerelease && i3[6] ? `+${i3[6]}` : "";
          return r2(`${o}.${l}.${h}${c}${u}`, e3);
        };
      }, 560: (t2, e2, i2) => {
        const s2 = i2(908);
        t2.exports = (t3, e3, i3) => new s2(t3, i3).compare(new s2(e3, i3));
      }, 641: (t2, e2, i2) => {
        const s2 = i2(560);
        t2.exports = (t3, e3, i3) => 0 === s2(t3, e3, i3);
      }, 580: (t2, e2, i2) => {
        const s2 = i2(560);
        t2.exports = (t3, e3, i3) => s2(t3, e3, i3) > 0;
      }, 89: (t2, e2, i2) => {
        const s2 = i2(560);
        t2.exports = (t3, e3, i3) => s2(t3, e3, i3) >= 0;
      }, 59: (t2, e2, i2) => {
        const s2 = i2(560);
        t2.exports = (t3, e3, i3) => s2(t3, e3, i3) < 0;
      }, 200: (t2, e2, i2) => {
        const s2 = i2(560);
        t2.exports = (t3, e3, i3) => s2(t3, e3, i3) <= 0;
      }, 999: (t2, e2, i2) => {
        const s2 = i2(560);
        t2.exports = (t3, e3, i3) => 0 !== s2(t3, e3, i3);
      }, 144: (t2, e2, i2) => {
        const s2 = i2(908);
        t2.exports = (t3, e3, i3 = false) => {
          if (t3 instanceof s2) return t3;
          try {
            return new s2(t3, e3);
          } catch (t4) {
            if (!i3) return null;
            throw t4;
          }
        };
      }, 638: (t2, e2, i2) => {
        const s2 = i2(311);
        t2.exports = (t3, e3, i3) => {
          try {
            e3 = new s2(e3, i3);
          } catch (t4) {
            return false;
          }
          return e3.test(t3);
        };
      }, 874: (t2) => {
        const e2 = Number.MAX_SAFE_INTEGER || 9007199254740991;
        t2.exports = { MAX_LENGTH: 256, MAX_SAFE_COMPONENT_LENGTH: 16, MAX_SAFE_BUILD_LENGTH: 250, MAX_SAFE_INTEGER: e2, RELEASE_TYPES: ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"], SEMVER_SPEC_VERSION: "2.0.0", FLAG_INCLUDE_PRERELEASE: 1, FLAG_LOOSE: 2 };
      }, 272: (t2) => {
        const e2 = "object" == typeof process && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...t3) => console.error("SEMVER", ...t3) : () => {
        };
        t2.exports = e2;
      }, 123: (t2) => {
        const e2 = /^[0-9]+$/, i2 = (t3, i3) => {
          const s2 = e2.test(t3), r2 = e2.test(i3);
          return s2 && r2 && (t3 = +t3, i3 = +i3), t3 === i3 ? 0 : s2 && !r2 ? -1 : r2 && !s2 ? 1 : t3 < i3 ? -1 : 1;
        };
        t2.exports = { compareIdentifiers: i2, rcompareIdentifiers: (t3, e3) => i2(e3, t3) };
      }, 794: (t2) => {
        t2.exports = class {
          constructor() {
            this.max = 1e3, this.map = /* @__PURE__ */ new Map();
          }
          get(t3) {
            const e2 = this.map.get(t3);
            return void 0 === e2 ? void 0 : (this.map.delete(t3), this.map.set(t3, e2), e2);
          }
          delete(t3) {
            return this.map.delete(t3);
          }
          set(t3, e2) {
            if (!this.delete(t3) && void 0 !== e2) {
              if (this.map.size >= this.max) {
                const t4 = this.map.keys().next().value;
                this.delete(t4);
              }
              this.map.set(t3, e2);
            }
            return this;
          }
        };
      }, 587: (t2) => {
        const e2 = Object.freeze({ loose: true }), i2 = Object.freeze({});
        t2.exports = (t3) => t3 ? "object" != typeof t3 ? e2 : t3 : i2;
      }, 718: (t2, e2, i2) => {
        const { MAX_SAFE_COMPONENT_LENGTH: s2, MAX_SAFE_BUILD_LENGTH: r2, MAX_LENGTH: n } = i2(874), a = i2(272), o = (e2 = t2.exports = {}).re = [], l = e2.safeRe = [], h = e2.src = [], c = e2.t = {};
        let u = 0;
        const p = "[a-zA-Z0-9-]", d = [["\\s", 1], ["\\d", n], [p, r2]], m = (t3, e3, i3) => {
          const s3 = ((t4) => {
            for (const [e4, i4] of d) t4 = t4.split(`${e4}*`).join(`${e4}{0,${i4}}`).split(`${e4}+`).join(`${e4}{1,${i4}}`);
            return t4;
          })(e3), r3 = u++;
          a(t3, r3, e3), c[t3] = r3, h[r3] = e3, o[r3] = new RegExp(e3, i3 ? "g" : void 0), l[r3] = new RegExp(s3, i3 ? "g" : void 0);
        };
        m("NUMERICIDENTIFIER", "0|[1-9]\\d*"), m("NUMERICIDENTIFIERLOOSE", "\\d+"), m("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${p}*`), m("MAINVERSION", `(${h[c.NUMERICIDENTIFIER]})\\.(${h[c.NUMERICIDENTIFIER]})\\.(${h[c.NUMERICIDENTIFIER]})`), m("MAINVERSIONLOOSE", `(${h[c.NUMERICIDENTIFIERLOOSE]})\\.(${h[c.NUMERICIDENTIFIERLOOSE]})\\.(${h[c.NUMERICIDENTIFIERLOOSE]})`), m("PRERELEASEIDENTIFIER", `(?:${h[c.NUMERICIDENTIFIER]}|${h[c.NONNUMERICIDENTIFIER]})`), m("PRERELEASEIDENTIFIERLOOSE", `(?:${h[c.NUMERICIDENTIFIERLOOSE]}|${h[c.NONNUMERICIDENTIFIER]})`), m("PRERELEASE", `(?:-(${h[c.PRERELEASEIDENTIFIER]}(?:\\.${h[c.PRERELEASEIDENTIFIER]})*))`), m("PRERELEASELOOSE", `(?:-?(${h[c.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${h[c.PRERELEASEIDENTIFIERLOOSE]})*))`), m("BUILDIDENTIFIER", `${p}+`), m("BUILD", `(?:\\+(${h[c.BUILDIDENTIFIER]}(?:\\.${h[c.BUILDIDENTIFIER]})*))`), m("FULLPLAIN", `v?${h[c.MAINVERSION]}${h[c.PRERELEASE]}?${h[c.BUILD]}?`), m("FULL", `^${h[c.FULLPLAIN]}$`), m("LOOSEPLAIN", `[v=\\s]*${h[c.MAINVERSIONLOOSE]}${h[c.PRERELEASELOOSE]}?${h[c.BUILD]}?`), m("LOOSE", `^${h[c.LOOSEPLAIN]}$`), m("GTLT", "((?:<|>)?=?)"), m("XRANGEIDENTIFIERLOOSE", `${h[c.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), m("XRANGEIDENTIFIER", `${h[c.NUMERICIDENTIFIER]}|x|X|\\*`), m("XRANGEPLAIN", `[v=\\s]*(${h[c.XRANGEIDENTIFIER]})(?:\\.(${h[c.XRANGEIDENTIFIER]})(?:\\.(${h[c.XRANGEIDENTIFIER]})(?:${h[c.PRERELEASE]})?${h[c.BUILD]}?)?)?`), m("XRANGEPLAINLOOSE", `[v=\\s]*(${h[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${h[c.XRANGEIDENTIFIERLOOSE]})(?:\\.(${h[c.XRANGEIDENTIFIERLOOSE]})(?:${h[c.PRERELEASELOOSE]})?${h[c.BUILD]}?)?)?`), m("XRANGE", `^${h[c.GTLT]}\\s*${h[c.XRANGEPLAIN]}$`), m("XRANGELOOSE", `^${h[c.GTLT]}\\s*${h[c.XRANGEPLAINLOOSE]}$`), m("COERCEPLAIN", `(^|[^\\d])(\\d{1,${s2}})(?:\\.(\\d{1,${s2}}))?(?:\\.(\\d{1,${s2}}))?`), m("COERCE", `${h[c.COERCEPLAIN]}(?:$|[^\\d])`), m("COERCEFULL", h[c.COERCEPLAIN] + `(?:${h[c.PRERELEASE]})?(?:${h[c.BUILD]})?(?:$|[^\\d])`), m("COERCERTL", h[c.COERCE], true), m("COERCERTLFULL", h[c.COERCEFULL], true), m("LONETILDE", "(?:~>?)"), m("TILDETRIM", `(\\s*)${h[c.LONETILDE]}\\s+`, true), e2.tildeTrimReplace = "$1~", m("TILDE", `^${h[c.LONETILDE]}${h[c.XRANGEPLAIN]}$`), m("TILDELOOSE", `^${h[c.LONETILDE]}${h[c.XRANGEPLAINLOOSE]}$`), m("LONECARET", "(?:\\^)"), m("CARETTRIM", `(\\s*)${h[c.LONECARET]}\\s+`, true), e2.caretTrimReplace = "$1^", m("CARET", `^${h[c.LONECARET]}${h[c.XRANGEPLAIN]}$`), m("CARETLOOSE", `^${h[c.LONECARET]}${h[c.XRANGEPLAINLOOSE]}$`), m("COMPARATORLOOSE", `^${h[c.GTLT]}\\s*(${h[c.LOOSEPLAIN]})$|^$`), m("COMPARATOR", `^${h[c.GTLT]}\\s*(${h[c.FULLPLAIN]})$|^$`), m("COMPARATORTRIM", `(\\s*)${h[c.GTLT]}\\s*(${h[c.LOOSEPLAIN]}|${h[c.XRANGEPLAIN]})`, true), e2.comparatorTrimReplace = "$1$2$3", m("HYPHENRANGE", `^\\s*(${h[c.XRANGEPLAIN]})\\s+-\\s+(${h[c.XRANGEPLAIN]})\\s*$`), m("HYPHENRANGELOOSE", `^\\s*(${h[c.XRANGEPLAINLOOSE]})\\s+-\\s+(${h[c.XRANGEPLAINLOOSE]})\\s*$`), m("STAR", "(<|>)?=?\\s*\\*"), m("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), m("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
      }, 576: (e2) => {
        e2.exports = t;
      } }, i = {};
      function s(t2) {
        var r2 = i[t2];
        if (void 0 !== r2) return r2.exports;
        var n = i[t2] = { exports: {} };
        return e[t2].call(n.exports, n, n.exports, s), n.exports;
      }
      s.d = (t2, e2) => {
        for (var i2 in e2) s.o(e2, i2) && !s.o(t2, i2) && Object.defineProperty(t2, i2, { enumerable: true, get: e2[i2] });
      }, s.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (t2) {
          if ("object" == typeof window) return window;
        }
      }(), s.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), s.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var r = {};
      return (() => {
        s.d(r, { default: () => fr2 });
        var t2 = {};
        s.r(t2), s.d(t2, { arithmetic: () => At2, assignment: () => kt2, bit: () => Dt2, comparison: () => bt2, exponentiation: () => Ut2, logical: () => Vt2, shift: () => Bt2 });
        var e2 = {};
        s.r(e2), s.d(e2, { ArrayTypeName: () => G2, AssemblyAssignment: () => q2, AssemblyBlock: () => nt2, AssemblyCall: () => at2, AssemblyCase: () => ot2, AssemblyFor: () => ht2, AssemblyFunctionDefinition: () => ut2, AssemblyIf: () => pt2, AssemblyLocalDefinition: () => mt2, AssemblyMemberAccess: () => _t2, AssemblyStackAssignment: () => ft2, AssemblySwitch: () => Tt2, BinaryOperation: () => $t2, Block: () => zt2, BooleanLiteral: () => qt2, Break: () => Wt2, BreakStatement: () => Yt2, CatchClause: () => Jt2, Conditional: () => re2, Continue: () => ne2, ContinueStatement: () => ae, ContractDefinition: () => pe2, CustomErrorDefinition: () => me2, DecimalNumber: () => _e2, DoWhileStatement: () => Te2, ElementaryTypeName: () => Re2, EmitStatement: () => ve2, EnumDefinition: () => Se2, EnumValue: () => Ce2, EventDefinition: () => we2, ExpressionStatement: () => Ie2, FileLevelConstant: () => ke2, ForStatement: () => Ke2, FunctionCall: () => ze2, FunctionDefinition: () => li2, FunctionTypeName: () => _i, HexLiteral: () => yi2, HexNumber: () => gi2, Identifier: () => Ti2, IfStatement: () => Si2, ImportDirective: () => Ni2, IndexAccess: () => Fi2, IndexRangeAccess: () => Ui2, InheritanceSpecifier: () => Mi2, InlineAssemblyStatement: () => Ki2, LabelDefinition: () => $i2, Mapping: () => Gi2, MemberAccess: () => Xi2, ModifierDefinition: () => ns, ModifierInvocation: () => os, NameValueExpression: () => ls, NameValueList: () => us, NewExpression: () => ps, NumberLiteral: () => ds, PragmaDirective: () => ms, ReturnStatement: () => gs, RevertStatement: () => Ts, SourceUnit: () => Rs, StateVariableDeclaration: () => Cs, StringLiteral: () => Ns, StructDefinition: () => ks, ThrowStatement: () => Ds, TryStatement: () => Fs, TupleExpression: () => Ms, TypeDefinition: () => Ks, UnaryOperation: () => Vs, UncheckedStatement: () => $s, UserDefinedTypeName: () => js, UsingForDeclaration: () => qs, VariableDeclaration: () => nr2, VariableDeclarationStatement: () => lr2, WhileStatement: () => dr2 });
        var i2 = s(576), n = s(638);
        const a = (t3) => n(i2.version, t3);
        function o(t3, e3) {
          const s2 = { quote: '"', regex: /"/g }, r2 = { quote: "'", regex: /'/g }, n2 = e3.singleQuote ? r2 : s2, a2 = n2 === r2 ? s2 : r2;
          let o2 = false;
          (t3.includes(n2.quote) || t3.includes(a2.quote)) && (o2 = (t3.match(n2.regex) || []).length > (t3.match(a2.regex) || []).length);
          const l2 = o2 ? a2.quote : n2.quote;
          return i2.util.makeString(t3, l2);
        }
        const l = a("^2.3.0");
        function h(t3, e3, s2) {
          return l ? t3.charAt(i2.util.getNextNonSpaceNonCommentCharacterIndex(t3, e3, s2)) : i2.util.getNextNonSpaceNonCommentCharacter(t3, s2(e3));
        }
        const { addLeadingComment: c, addTrailingComment: u, addDanglingComment: p, hasNewline: d, hasNewlineInRange: m } = i2.util;
        function _2(t3, e3) {
          if (!t3.body) return void p(t3, e3);
          const i3 = t3.body.filter((t4) => "EmptyStatement" !== t4.type);
          0 === i3.length ? p(t3, e3) : c(i3[0], e3);
        }
        function x2(t3, e3) {
          "BlockStatement" === t3.type ? _2(t3, e3) : c(t3, e3);
        }
        function f(t3, e3, i3, s2, r2, n2) {
          return !(!i3 || "IfStatement" !== i3.type || !s2) && (")" === h(t3, r2, n2.locEnd) ? (u(e3, r2), true) : e3 === i3.trueBody && s2 === i3.falseBody ? ("ExpressionStatement" === e3.type ? u(e3, r2) : p(i3, r2), true) : "ExpressionStatement" === s2.type ? (_2(s2, r2), true) : "IfStatement" === s2.type ? (x2(s2.trueBody, r2), true) : i3.trueBody === s2 && (c(s2, r2), true));
        }
        function y2(t3, e3, i3, s2, r2, n2) {
          return !(!i3 || "WhileStatement" !== i3.type || !s2) && (")" === h(t3, r2, n2.locEnd) ? (u(e3, r2), true) : "BlockStatement" === s2.type && (_2(s2, r2), true));
        }
        function g(t3, e3, i3, s2) {
          return !(!t3 || "TryStatement" !== t3.type && "CatchClause" !== t3.type || !i3 || ("CatchClause" === t3.type && e3 ? (u(e3, s2), 0) : "BlockStatement" === i3.type ? (_2(i3, s2), 0) : "TryStatement" === i3.type ? (x2(i3.finalizer, s2), 0) : "CatchClause" !== i3.type || (x2(i3.body, s2), 0)));
        }
        function T2(t3, e3, i3, s2) {
          return !(!(t3 && ("ClassDeclaration" === t3.type || "ClassExpression" === t3.type) && t3.decorators && t3.decorators.length > 0) || i3 && "Decorator" === i3.type || (t3.decorators && 0 !== t3.decorators.length ? u(t3.decorators[t3.decorators.length - 1], s2) : c(t3, s2), 0));
        }
        function E(t3, e3, i3, s2, r2) {
          return (e3 && i3 && ("Property" === e3.type || "MethodDefinition" === e3.type) && "Identifier" === i3.type && e3.key === i3 && ":" !== h(t3, i3, r2.locEnd) || !(!i3 || !e3 || "Decorator" !== i3.type || "ClassMethod" !== e3.type && "ClassProperty" !== e3.type && "TSAbstractClassProperty" !== e3.type && "TSAbstractMethodDefinition" !== e3.type && "MethodDefinition" !== e3.type)) && (u(i3, s2), true);
        }
        function R2(t3, e3, i3, s2, r2, n2) {
          return (e3 && "FunctionTypeParam" === e3.type && i3 && "FunctionTypeAnnotation" === i3.type && s2 && "FunctionTypeParam" !== s2.type || !(!e3 || "Identifier" !== e3.type && "AssignmentPattern" !== e3.type || !i3 || "ArrowFunctionExpression" !== i3.type && "FunctionExpression" !== i3.type && "FunctionDeclaration" !== i3.type && "ObjectMethod" !== i3.type && "ClassMethod" !== i3.type || ")" !== h(t3, r2, n2.locEnd))) && (u(e3, r2), true);
        }
        function v(t3, e3) {
          return !(!t3 || "ImportSpecifier" !== t3.type || (c(t3, e3), 0));
        }
        function b(t3, e3, i3, s2) {
          return e3 && e3.body && 0 === e3.body.length ? (s2 ? p(e3, i3) : c(e3, i3), true) : !(!t3 || "Program" !== t3.type || 0 !== t3.body.length || !t3.directives || 0 !== t3.directives.length || (s2 ? p(t3, i3) : c(t3, i3), 0));
        }
        const { addLeadingComment: L2, addTrailingComment: S2, addDanglingComment: C } = i2.util, { addLeadingComment: A2, addTrailingComment: w2, addDanglingComment: N2 } = i2.util, I2 = [function({ text: t3, precedingNode: e3, enclosingNode: i3, followingNode: s2, comment: r2, options: n2 }) {
          if (!i3 || "ContractDefinition" !== i3.type) return false;
          const a2 = h(t3, r2, n2.locEnd);
          return "InheritanceSpecifier" === s2?.type || "{" === a2 ? "InheritanceSpecifier" === e3?.type ? (S2(e3, r2), true) : (L2(i3, r2), true) : 0 === i3.subNodes.length && (C(i3, r2), true);
        }, function({ text: t3, precedingNode: e3, enclosingNode: i3, comment: s2, options: r2 }) {
          if (!i3 || "ModifierInvocation" !== i3.type) return false;
          const n2 = h(t3, s2, r2.locEnd);
          return "(" === n2 ? (A2(i3, s2), true) : ")" === n2 && (e3 ? (w2(e3, s2), true) : "LineComment" === s2.type ? (A2(i3, s2), true) : (N2(i3, s2), true));
        }], { hardline: k2, join: D } = i2.doc.builders, O2 = /* @__PURE__ */ new Set(["loc", "range", "comments"]);
        function P2() {
        }
        P2.ignoredProperties = O2;
        const F = P2;
        function U2(t3, e3) {
          return e3.range ? e3.range[t3] : e3.expression?.range ? e3.expression.range[t3] : null;
        }
        const H2 = { locEnd: (t3) => U2(1, t3), locStart: (t3) => U2(0, t3) }, M2 = "Global", K2 = "Common", V2 = { printWidth: { since: "0.0.0", category: M2, type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, tabWidth: { type: "int", category: M2, default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: Number.POSITIVE_INFINITY, step: 1 } }, useTabs: { since: "1.0.0", category: M2, type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, bracketSpacing: { since: "0.0.0", category: K2, type: "boolean", default: true, description: "Print spaces between brackets.", oppositeDescription: "Do not print spaces between brackets." }, singleQuote: { since: "0.0.0", category: K2, type: "boolean", default: false, description: "Use single quotes instead of double quotes." }, experimentalTernaries: { category: "JavaScript", type: "boolean", default: false, description: "Use curious ternaries, with the question mark after the condition.", oppositeDescription: "Default behavior of ternaries; keep question marks on the same line as the consequent." }, compiler: { category: "Solidity", type: "string", description: "The Solidity compiler version to help us avoid critical errors in format for the wrong version." } };
        var B2 = s(121), $2 = s(170);
        const j = (t3, e3) => "BinaryOperation" === t3.type && e3.includes(t3.operator) ? { type: "TupleExpression", components: [t3], isArray: false } : t3, G2 = { print: ({ node: t3, path: e3, print: i3 }) => [e3.call(i3, "baseTypeName"), "[", t3.length ? e3.call(i3, "length") : "", "]"] }, { join: z2 } = i2.doc.builders, q2 = { print: ({ path: t3, print: e3 }) => [z2(", ", t3.map(e3, "names")), " := ", t3.call(e3, "expression")] }, { group: W2, indent: Y2, join: X, line: J2, softline: Q2, hardline: Z2 } = i2.doc.builders, tt2 = (t3, e3, i3, s2 = () => true) => {
          if (!t3.comments) return "";
          const r2 = X(J2, e3.map((t4) => {
            const e4 = t4.getValue();
            return e4.trailing || e4.leading || e4.printed ? null : s2(e4) ? (e4.printed = true, i3.printer.printComment(t4, i3)) : null;
          }, "comments").filter(Boolean));
          return l ? r2.parts : r2;
        };
        function et2(t3, e3, s2, r2) {
          const n2 = [];
          return t3.each((t4, a2) => {
            const o2 = t4.getValue(), h2 = o2.type;
            var c2, u2;
            0 !== n2.length && "LabelDefinition" !== h2 && n2.push(Z2), n2.push(r2(t4)), !function(t5, e4, i3) {
              return l ? i3 === t5.getParentNode()[e4].length - 1 : t5.isLast;
            }(t4, e3, a2) && (c2 = s2.originalText, u2 = s2.locEnd(o2) + 1, l ? i2.util.isNextLineEmptyAfterIndex(c2, u2) : i2.util.isNextLineEmpty(c2, u2)) && n2.push(Z2);
          }, e3), n2;
        }
        const it2 = (t3, { firstSeparator: e3 = Q2, lastSeparator: i3 = e3, grouped: s2 = true } = {}) => {
          const r2 = [Y2([e3, t3]), i3];
          return s2 ? W2(r2) : r2;
        }, st2 = (t3, { firstSeparator: e3, separator: i3 = [",", J2], lastSeparator: s2, grouped: r2 } = {}) => it2(X(i3, t3), { firstSeparator: e3, lastSeparator: s2, grouped: r2 }), { hardline: rt2 } = i2.doc.builders, nt2 = { print: ({ node: t3, options: e3, path: i3, print: s2 }) => 0 !== t3.operations.length || t3.comments ? ["{", it2([et2(i3, "operations", e3, s2), tt2(t3, i3, e3)], { firstSeparator: rt2, grouped: false }), "}"] : "{}" }, at2 = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => 0 === t3.arguments.length && ")" !== s2.originalText.charAt(s2.locEnd(t3)) ? t3.functionName : [t3.functionName, "(", st2(e3.map(i3, "arguments")), ")"] }, ot2 = { print: ({ node: t3, path: e3, print: i3 }) => [t3.default ? "default" : ["case ", e3.call(i3, "value")], " ", e3.call(i3, "block")] }, { join: lt2 } = i2.doc.builders, ht2 = { print: ({ path: t3, print: e3 }) => lt2(" ", ["for", t3.call(e3, "pre"), t3.call(e3, "condition"), t3.call(e3, "post"), t3.call(e3, "body")]) }, { line: ct2 } = i2.doc.builders, ut2 = { print: ({ node: t3, path: e3, print: i3 }) => ["function ", t3.name, "(", st2(e3.map(i3, "arguments")), ")", 0 === t3.returnArguments.length ? " " : it2(["->", st2(e3.map(i3, "returnArguments"), { firstSeparator: ct2, lastSeparator: "" })], { firstSeparator: ct2 }), e3.call(i3, "body")] }, pt2 = { print: ({ path: t3, print: e3 }) => ["if ", t3.call(e3, "condition"), " ", t3.call(e3, "body")] }, { line: dt2 } = i2.doc.builders, mt2 = { print: ({ node: t3, path: e3, print: i3 }) => {
          const s2 = ["let", st2(e3.map(i3, "names"), { firstSeparator: dt2 })];
          return null !== t3.expression && (s2.push(":= "), s2.push(e3.call(i3, "expression"))), s2;
        } }, _t2 = { print: ({ path: t3, print: e3 }) => [t3.call(e3, "expression"), ".", t3.call(e3, "memberName")] }, { hardline: xt2 } = i2.doc.builders, ft2 = { print: ({ node: t3, path: e3, print: i3 }) => [e3.call(i3, "expression"), xt2, "=: ", t3.name] }, { hardline: yt, join: gt2 } = i2.doc.builders, Tt2 = { print: ({ path: t3, print: e3 }) => ["switch ", t3.call(e3, "expression"), yt, gt2(yt, t3.map(e3, "cases"))] }, { group: Et2, indent: Rt2, line: vt2 } = i2.doc.builders, bt2 = { match: (t3) => ["<", ">", "<=", ">=", "==", "!="].includes(t3), print: (t3, e3, i3) => {
          const s2 = /* @__PURE__ */ ((t4) => (e4) => {
            let i4 = t4.getNode();
            for (let s3 = 0; ; s3 += 1) {
              const r3 = t4.getParentNode(s3);
              if ("ReturnStatement" === r3.type) return e4;
              if ("IfStatement" === r3.type) return e4;
              if ("ForStatement" === r3.type) return e4;
              if ("WhileStatement" === r3.type) return e4;
              if ("BinaryOperation" !== r3.type) return Rt2(e4);
              if (i4 === r3.right) return e4;
              i4 = r3;
            }
          })(e3), r2 = [t3.operator, vt2, e3.call(i3, "right")], n2 = "BinaryOperation" !== t3.left.type && "BinaryOperation" !== e3.getParentNode().type;
          return Et2([e3.call(i3, "left"), " ", s2(n2 ? Et2(r2) : r2)]);
        } }, { group: Lt2, line: St2, indent: Ct2 } = i2.doc.builders, At2 = { match: (t3) => ["+", "-", "*", "/", "%"].includes(t3), print: (t3, e3, i3) => {
          const s2 = /* @__PURE__ */ ((t4) => (e4) => {
            const i4 = t4.getParentNode();
            return "BinaryOperation" !== i4.type || bt2.match(i4.operator) ? Lt2(e4) : e4;
          })(e3), r2 = /* @__PURE__ */ ((t4) => (e4) => {
            let i4 = t4.getNode();
            for (let s3 = 0; ; s3 += 1) {
              const r3 = t4.getParentNode(s3);
              if ("ReturnStatement" === r3.type) return e4;
              if ("BinaryOperation" !== r3.type || bt2.match(r3.operator)) return Ct2(e4);
              if (i4 === r3.right) return e4;
              i4 = r3;
            }
          })(e3), n2 = [t3.operator, St2, e3.call(i3, "right")], a2 = "BinaryOperation" !== t3.left.type && "BinaryOperation" !== e3.getParentNode().type;
          return s2([e3.call(i3, "left"), " ", r2(a2 ? Lt2(n2) : n2)]);
        } }, { group: wt2, line: Nt2, indent: It2 } = i2.doc.builders, kt2 = { match: (t3) => ["=", "|=", "^=", "&=", "<<=", ">>=", "+=", "-=", "*=", "/=", "%="].includes(t3), print: (t3, e3, i3) => [e3.call(i3, "left"), " ", t3.operator, "BinaryOperation" === t3.right.type ? wt2(It2([Nt2, e3.call(i3, "right")])) : [" ", e3.call(i3, "right")]] }, Dt2 = { match: (t3) => ["&", "|", "^"].includes(t3), print: At2.print }, { group: Ot2, indent: Pt2, line: Ft2 } = i2.doc.builders, Ut2 = { match: (t3) => "**" === t3, print: (t3, e3, i3) => {
          const s2 = [" ", t3.operator, Ft2, e3.call(i3, "right")], r2 = "BinaryOperation" !== t3.left.type && "BinaryOperation" !== e3.getParentNode().type;
          return Ot2([e3.call(i3, "left"), Pt2(r2 ? Ot2(s2) : s2)]);
        } }, { group: Ht2, line: Mt2, indent: Kt2 } = i2.doc.builders, Vt2 = { match: (t3) => ["&&", "||"].includes(t3), print: (t3, e3, i3, s2) => {
          const r2 = /* @__PURE__ */ ((t4) => (e4) => "BinaryOperation" === t4.getParentNode().type ? e4 : Ht2(e4))(e3), n2 = /* @__PURE__ */ ((t4, e4) => (i4) => {
            let s3 = t4.getNode();
            for (let r3 = 0; ; r3 += 1) {
              const n3 = t4.getParentNode(r3);
              if ("ReturnStatement" === n3.type) return i4;
              if ("IfStatement" === n3.type) return i4;
              if ("WhileStatement" === n3.type) return i4;
              if (e4.experimentalTernaries && "Conditional" === n3.type && n3.condition === s3) return i4;
              if ("BinaryOperation" !== n3.type) return Kt2(i4);
              if (s3 === n3.right) return i4;
              s3 = n3;
            }
          })(e3, s2), a2 = [t3.operator, Mt2, e3.call(i3, "right")], o2 = "BinaryOperation" !== t3.left.type && "BinaryOperation" !== e3.getParentNode().type;
          return r2([e3.call(i3, "left"), " ", n2(o2 ? Ht2(a2) : a2)]);
        } }, Bt2 = { match: (t3) => ["<<", ">>"].includes(t3), print: At2.print }, $t2 = { print: ({ node: e3, path: i3, print: s2, options: r2 }) => {
          const n2 = Object.values(t2).find((t3) => t3.match(e3.operator));
          if (void 0 === n2) throw new Error(`Assertion error: no printer found for operator ${JSON.stringify(e3.operator)}`);
          return n2.print(e3, i3, s2, r2);
        } }, { hardline: jt2, indent: Gt2 } = i2.doc.builders, zt2 = { print: ({ node: t3, options: e3, path: i3, print: s2 }) => 0 !== t3.statements.length || t3.comments ? ["{", Gt2([jt2, et2(i3, "statements", e3, s2), tt2(t3, i3, e3)]), jt2, "}"] : "{}" }, qt2 = { print: ({ node: t3 }) => t3.value ? "true" : "false" }, Wt2 = { print: () => "break" }, Yt2 = { print: () => "break;" }, Xt2 = (t3, e3, i3) => t3.parameters ? [t3.kind || "", "(", st2(e3.map(i3, "parameters")), ") "] : "", Jt2 = { print: ({ node: t3, path: e3, print: i3 }) => ["catch ", Xt2(t3, e3, i3), e3.call(i3, "body")] }, { group: Qt2, hardline: Zt2, ifBreak: te2, indent: ee2, line: ie2, softline: se2 } = i2.doc.builders, re2 = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => s2.experimentalTernaries ? ((t4, e4, i4, s3) => {
          const r2 = e4.getParentNode(), n2 = "Conditional" === r2.type, a2 = n2 && r2.trueExpression === t4, o2 = "Conditional" === t4.falseExpression.type, l2 = e4.call(i4, "condition"), h2 = Qt2(["TupleExpression" === t4.condition.type ? l2 : te2(["(", it2(l2), ")"], l2), " ?"]), c2 = ee2([a2 ? Zt2 : ie2, e4.call(i4, "trueExpression")]), u2 = Qt2([h2, c2], { id: Symbol("Conditional.trueExpression") });
          let p2 = " ";
          !o2 && (s3.tabWidth > 2 || s3.useTabs) && (p2 = s3.useTabs ? "	" : " ".repeat(s3.tabWidth - 1));
          const d2 = e4.call(i4, "falseExpression"), m2 = [n2 ? Zt2 : ie2, ":", o2 ? [" ", d2] : te2([p2, ee2(d2)], [" ", d2], { groupId: u2.id })], _3 = Qt2([u2, m2]);
          return "VariableDeclarationStatement" === r2.type ? ee2([se2, _3]) : _3;
        })(t3, e3, i3, s2) : ((t4, e4) => Qt2([t4.call(e4, "condition"), ee2(["Conditional" === t4.getParentNode().type ? Zt2 : ie2, "? ", t4.call(e4, "trueExpression"), ie2, ": ", t4.call(e4, "falseExpression")])]))(e3, i3) }, ne2 = { print: () => "continue" }, ae = { print: () => "continue;" }, { group: oe2, line: le2, hardline: he2 } = i2.doc.builders, ce2 = (t3, e3, i3) => t3.baseContracts.length > 0 ? [" is", st2(e3.map(i3, "baseContracts"), { firstSeparator: le2 })] : le2, ue2 = (t3, e3, i3, s2) => {
          const r2 = tt2(t3, e3, i3);
          return t3.subNodes.length > 0 || r2?.length ? it2([et2(e3, "subNodes", i3, s2), r2], { firstSeparator: he2, grouped: false }) : "";
        }, pe2 = { print: ({ node: t3, options: e3, path: i3, print: s2 }) => [oe2(["abstract" === t3.kind ? "abstract contract" : t3.kind, " ", t3.name, ce2(t3, i3, s2), "{"]), ue2(t3, i3, e3, s2), "}"] }, de2 = (t3, e3, i3) => t3.parameters?.length > 0 ? st2(e3.map(i3, "parameters")) : "", me2 = { print: ({ node: t3, path: e3, print: i3 }) => ["error ", t3.name, "(", de2(t3, e3, i3), ");"] }, _e2 = { print: ({ node: t3 }) => t3.value }, { group: xe2, indent: fe2, line: ye2 } = i2.doc.builders, ge2 = (t3, e3, i3) => "Block" === t3.body.type ? [" ", e3.call(i3, "body"), " "] : xe2([fe2([ye2, e3.call(i3, "body")]), ye2]), Te2 = { print: ({ node: t3, path: e3, print: i3 }) => ["do", ge2(t3, e3, i3), "while (", it2(e3.call(i3, "condition")), ");"] }, Ee2 = (t3) => t3.stateMutability?.length > 0 ? [" ", t3.stateMutability] : "", Re2 = { print: ({ node: t3 }) => [t3.name, Ee2(t3)] }, ve2 = { print: ({ path: t3, print: e3 }) => ["emit ", t3.call(e3, "eventCall"), ";"] }, { group: be2, hardline: Le2 } = i2.doc.builders, Se2 = { print: ({ node: t3, path: e3, print: i3 }) => be2(["enum ", t3.name, " {", st2(e3.map(i3, "members"), { firstSeparator: Le2 }), "}"]) }, Ce2 = { print: ({ node: t3 }) => t3.name }, Ae2 = (t3, e3, i3) => t3.parameters?.length > 0 ? st2(e3.map(i3, "parameters")) : "", we2 = { print: ({ node: t3, path: e3, print: i3 }) => ["event ", t3.name, "(", Ae2(t3, e3, i3), ")", t3.isAnonymous ? " anonymous" : "", ";"] }, { hardline: Ne2 } = i2.doc.builders, Ie2 = { print: ({ node: t3, options: e3, path: i3, print: s2 }) => {
          const r2 = [];
          if ("IfStatement" === i3.getParentNode().type && t3.comments?.length) {
            const s3 = tt2(t3, i3, e3);
            s3?.length && (r2.push(s3), r2.push(Ne2));
          }
          return r2.push(i3.call(s2, "expression")), r2.push(t3.omitSemicolon ? "" : ";"), r2;
        } }, ke2 = { print: ({ node: t3, path: e3, print: i3 }) => [e3.call(i3, "typeName"), " constant ", t3.name, " = ", e3.call(i3, "initialValue"), ";"] }, { group: De2, indent: Oe2, line: Pe2 } = i2.doc.builders, Fe2 = (t3, e3, i3) => t3.initExpression ? e3.call(i3, "initExpression") : "", Ue2 = (t3, e3, i3) => t3.conditionExpression ? e3.call(i3, "conditionExpression") : "", He2 = (t3, e3, i3) => t3.loopExpression.expression ? e3.call(i3, "loopExpression") : "", Me2 = (t3, e3, i3) => "Block" === t3.body.type ? [" ", e3.call(i3, "body")] : De2(Oe2([Pe2, e3.call(i3, "body")])), Ke2 = { print: ({ node: t3, path: e3, print: i3 }) => ["for (", st2([Fe2(t3, e3, i3), Ue2(t3, e3, i3), He2(t3, e3, i3)], { separator: t3.initExpression || t3.conditionExpression || t3.loopExpression.expression ? [";", Pe2] : ";" }), ")", Me2(t3, e3, i3)] }, { group: Ve2, indentIfBreak: Be2, label: $e, line: je2, softline: Ge2 } = i2.doc.builders, ze2 = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => {
          let r2 = e3.call(i3, "expression"), n2 = ")";
          return t3.arguments?.length > 0 && (n2 = t3.identifiers?.length > 0 ? ((t4, e4, i4) => {
            const s3 = t4.map(e4, "identifiers");
            return ["{", st2(t4.map(e4, "arguments").map((t5, e5) => [s3[e5], ": ", t5]), { firstSeparator: i4.bracketSpacing ? je2 : Ge2, lastSeparator: [i4.bracketSpacing ? je2 : Ge2, "})"] })];
          })(e3, i3, s2) : ((t4, e4) => st2(t4.map(e4, "arguments"), { lastSeparator: [Ge2, ")"] }))(e3, i3)), "MemberAccessChain" === r2.label ? (r2 = Ve2(r2.contents, { id: Symbol("FunctionCall.expression") }), n2 = Be2(n2, { groupId: r2.id }), $e("MemberAccessChain", [r2, "(", n2])) : [r2, "(", n2];
        } }, { dedent: qe2, group: We2, indent: Ye2, join: Xe2, line: Je2 } = i2.doc.builders, Qe2 = (t3, e3) => t3.isConstructor && !t3.name ? "constructor" : t3.name ? `function ${t3.name}` : t3.isReceiveEther ? "receive" : { fallback: "fallback", function: "function" }[e3.originalText.slice(e3.locStart(t3), e3.locStart(t3) + 8)], Ze2 = (t3, e3, i3, s2, r2) => {
          if (e3[t3]?.length > 0) return st2(i3.map(s2, t3), { grouped: false });
          if (e3.comments?.length > 0) {
            const t4 = tt2(e3, i3, r2, (t5) => ")" === h(r2.originalText, t5, r2.locEnd));
            return t4.length > 0 ? it2(t4) : "";
          }
          return "";
        }, ti2 = (t3) => t3.visibility && "default" !== t3.visibility ? [Je2, t3.visibility] : "", ei2 = (t3) => t3.isVirtual ? [Je2, "virtual"] : "", ii2 = (t3, e3, i3) => t3.override ? 0 === t3.override.length ? [Je2, "override"] : [Je2, "override(", st2(e3.map(i3, "override")), ")"] : "", si2 = (t3) => t3.stateMutability ? [Je2, t3.stateMutability] : "", ri2 = (t3, e3, i3) => t3.modifiers.length > 0 ? [Je2, Xe2(Je2, e3.map(i3, "modifiers"))] : "", ni2 = (t3, e3, i3, s2) => t3.returnParameters ? [Je2, "returns (", We2(Ze2("returnParameters", t3, e3, i3, s2)), ")"] : "", ai2 = (t3) => t3.body ? qe2(Je2) : ";", oi2 = (t3, e3, i3) => t3.body ? e3.call(i3, "body") : "", li2 = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => [We2([Qe2(t3, s2), "(", Ze2("parameters", t3, e3, i3, s2), ")", Ye2(We2([tt2(t3, e3, s2), ti2(t3), si2(t3), ei2(t3), ii2(t3, e3, i3), ri2(t3, e3, i3), ni2(t3, e3, i3, s2), ai2(t3)]))]), oi2(t3, e3, i3)] }, { group: hi2, indent: ci2, line: ui2 } = i2.doc.builders, pi2 = (t3, e3, i3) => t3.returnTypes.length > 0 ? [ui2, "returns (", st2(e3.map(i3, "returnTypes")), ")"] : "", di2 = (t3) => t3.visibility && "default" !== t3.visibility ? [ui2, t3.visibility] : "", mi2 = (t3) => t3.stateMutability && "default" !== t3.stateMutability ? [ui2, t3.stateMutability] : "", _i = { print: ({ node: t3, path: e3, print: i3 }) => hi2(["function(", st2(e3.map(i3, "parameterTypes"), { grouped: false }), ")", ci2(hi2([di2(t3), mi2(t3), pi2(t3, e3, i3)]))]) }, { join: xi, hardline: fi2 } = i2.doc.builders, yi2 = { print: ({ node: t3, options: e3 }) => {
          const i3 = t3.parts.map((t4) => `hex${o(t4, e3)}`);
          return xi(fi2, i3);
        } }, gi2 = { print: ({ node: t3 }) => t3.value }, Ti2 = { print: ({ node: t3 }) => t3.name }, { group: Ei2, hardline: Ri2, indent: vi2, line: bi2 } = i2.doc.builders, Li2 = (t3, e3, i3) => "Block" === t3.falseBody.type || "IfStatement" === t3.falseBody.type ? [" ", e3.call(i3, "falseBody")] : Ei2(vi2([bi2, e3.call(i3, "falseBody")])), Si2 = { print: ({ node: t3, options: e3, path: i3, print: s2 }) => {
          const r2 = (t3.comments || []).filter((t4) => !t4.leading && !t4.trailing), n2 = [];
          return n2.push("if (", it2(i3.call(s2, "condition")), ")"), n2.push(((t4, e4, i4) => {
            if ("Block" === t4.trueBody.type) return [" ", e4.call(i4, "trueBody")];
            const s3 = "IfStatement" === t4.trueBody.type;
            return Ei2(vi2([s3 ? Ri2 : bi2, e4.call(i4, "trueBody")]));
          })(t3, i3, s2)), r2.length && t3.falseBody && (n2.push(Ri2), n2.push(tt2(t3, i3, e3))), n2.push(((t4, e4, i4, s3) => t4.falseBody ? ["Block" === t4.trueBody.type && 0 === s3.length ? " " : Ri2, "else", Li2(t4, e4, i4)] : "")(t3, i3, s2, r2)), n2;
        } }, { group: Ci, line: Ai2, softline: wi } = i2.doc.builders, Ni2 = { print: ({ node: t3, options: e3 }) => {
          const i3 = o(t3.path, e3);
          let s2;
          if (t3.unitAlias) s2 = e3.originalText.slice(e3.locStart(t3), e3.locStart(t3.pathLiteral)).includes("*") ? ["* as ", t3.unitAlias, " from ", i3] : [i3, " as ", t3.unitAlias];
          else if (t3.symbolAliases) {
            const r2 = $2(e3.compiler), a2 = t3.symbolAliases.map(([t4, e4]) => e4 ? `${t4} as ${e4}` : t4);
            let o2, l2;
            r2 && n(r2, ">=0.7.4") ? (o2 = e3.bracketSpacing ? Ai2 : wi, l2 = [",", Ai2]) : (o2 = e3.bracketSpacing ? " " : "", l2 = ", "), s2 = ["{", st2(a2, { firstSeparator: o2, separator: l2 }), "} from ", i3];
          } else s2 = i3;
          return Ci(["import ", s2, ";"]);
        } }, { group: Ii2, indent: ki2, indentIfBreak: Di2, label: Oi2, softline: Pi2 } = i2.doc.builders, Fi2 = { print: ({ path: t3, print: e3 }) => {
          let i3 = t3.call(e3, "base"), s2 = Ii2([ki2([Pi2, t3.call(e3, "index")]), Pi2, "]"]);
          return "MemberAccessChain" === i3.label ? (i3 = Ii2(i3.contents, { id: Symbol("IndexAccess.base") }), s2 = Di2(s2, { groupId: i3.id }), Oi2("MemberAccessChain", [i3, "[", s2])) : [i3, "[", s2];
        } }, Ui2 = { print: ({ node: t3, path: e3, print: i3 }) => [e3.call(i3, "base"), "[", t3.indexStart ? e3.call(i3, "indexStart") : "", ":", t3.indexEnd ? e3.call(i3, "indexEnd") : "", "]"] }, Hi2 = (t3, e3, i3) => t3.arguments?.length ? ["(", st2(e3.map(i3, "arguments")), ")"] : "", Mi2 = { print: ({ node: t3, path: e3, print: i3 }) => [e3.call(i3, "baseName"), Hi2(t3, e3, i3)] }, Ki2 = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => ["assembly ", t3.language ? `${o(t3.language, s2)} ` : "", t3.flags?.length > 0 ? ["(", st2(t3.flags.map((t4) => o(t4, s2))), ") "] : "", e3.call(i3, "body")] }, { dedent: Vi2, line: Bi2 } = i2.doc.builders, $i2 = { print: ({ node: t3 }) => [Vi2(Bi2), t3.name, ":"] }, ji2 = (t3, e3, i3, s2) => e3[`${t3}Name`] ? [i3.call(s2, `${t3}Type`), " ", i3.call(s2, `${t3}Name`)] : i3.call(s2, `${t3}Type`), Gi2 = { print: ({ node: t3, path: e3, print: i3 }) => ["mapping(", ji2("key", t3, e3, i3), " => ", ji2("value", t3, e3, i3), ")"] }, { group: zi2, indent: qi2, label: Wi, softline: Yi2 } = i2.doc.builders, Xi2 = { print: ({ node: t3, path: e3, print: i3 }) => {
          let s2 = e3.call(i3, "expression");
          Array.isArray(s2) && (s2 = s2.flat());
          const r2 = [s2, Wi("separator", [Yi2, "."]), t3.memberName].flat();
          return ((t4, e4) => {
            let i4 = 0, s3 = t4, r3 = e4.getParentNode(i4);
            for (; r3 && ["FunctionCall", "IndexAccess", "NameValueExpression", "MemberAccess"].includes(r3.type); ) {
              switch (r3.type) {
                case "MemberAccess":
                  return false;
                case "IndexAccess":
                  if (s3 !== r3.base) return true;
                  break;
                case "FunctionCall":
                  if (s3 !== r3.expression) return true;
              }
              i4 += 1, s3 = r3, r3 = e4.getParentNode(i4);
            }
            return true;
          })(t3, e3) ? ((t4) => {
            const e4 = t4.findIndex((t5) => "separator" === t5.label), i4 = t4.slice(0, e4), s3 = zi2(qi2(t4.slice(e4)));
            return Wi("MemberAccessChain", zi2([i4, s3]));
          })(r2) : r2;
        } }, { dedent: Ji2, group: Qi2, indent: Zi2, line: ts } = i2.doc.builders, es = (t3, e3, i3) => t3.parameters?.length > 0 ? ["(", st2(e3.map(i3, "parameters"), { separator: [",", ts] }), ")"] : "()", is = (t3) => t3.isVirtual ? [ts, "virtual"] : "", ss = (t3, e3, i3) => t3.override ? 0 === t3.override.length ? [ts, "override"] : [ts, "override(", st2(e3.map(i3, "override")), ")"] : "", rs = (t3, e3, i3) => t3.body ? t3.isVirtual ? Qi2(e3.call(i3, "body")) : [e3.call(i3, "body")] : ";", ns = { print: ({ node: t3, path: e3, print: i3 }) => ["modifier ", t3.name, es(t3, e3, i3), Qi2(Zi2([is(t3), ss(t3, e3, i3), t3.body ? Ji2(ts) : ""])), rs(t3, e3, i3)] }, as = (t3, e3, i3, s2) => t3.arguments ? t3.arguments.length > 0 ? ["(", st2(e3.map(i3, "arguments")), ")"] : "()" : t3.comments?.some((t4) => !t4.leading && !t4.trailing && !t4.printed) ? ["(", tt2(t3, e3, s2), ")"] : "", os = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => [t3.name, as(t3, e3, i3, s2)] }, ls = { print: ({ path: t3, print: e3 }) => [t3.call(e3, "expression"), "{", t3.call(e3, "arguments"), "}"] }, { line: hs, softline: cs } = i2.doc.builders, us = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => st2(e3.map(i3, "arguments").map((e4, i4) => [t3.names[i4], ": ", e4]), { firstSeparator: s2.bracketSpacing ? hs : cs }) }, ps = { print: ({ path: t3, print: e3 }) => ["new ", t3.call(e3, "typeName")] }, ds = { print: ({ node: t3 }) => t3.subdenomination ? [t3.number, " ", t3.subdenomination] : t3.number }, ms = { print: ({ node: t3 }) => ["pragma ", t3.name, " ", t3.value, ";"] }, { group: _s, indent: xs, line: fs } = i2.doc.builders, ys = (t3, e3, i3, s2) => t3.expression ? "TupleExpression" === t3.expression.type || s2.experimentalTernaries && "Conditional" === t3.expression.type ? [" ", e3.call(i3, "expression")] : _s(xs([fs, e3.call(i3, "expression")])) : "", gs = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => ["return", ys(t3, e3, i3, s2), ";"] }, Ts = { print: ({ path: t3, print: e3 }) => ["revert ", t3.call(e3, "revertCall"), ";"] }, { line: Es } = i2.doc.builders, Rs = { print: ({ options: t3, path: e3, print: i3 }) => [et2(e3, "children", t3, i3), t3.parentParser ? "" : Es] }, { group: vs, indent: bs, line: Ls } = i2.doc.builders, Ss = (t3, e3, i3) => t3.initialValue ? "TupleExpression" === t3.initialValue.type ? [" = ", e3.call(i3, "initialValue")] : vs([" =", bs([Ls, e3.call(i3, "initialValue")])]) : "", Cs = { print: ({ node: t3, path: e3, print: i3 }) => [...e3.map(i3, "variables"), Ss(t3, e3, i3), ";"] }, { join: As, hardline: ws } = i2.doc.builders, Ns = { print: ({ node: t3, options: e3 }) => {
          const i3 = t3.parts.map((i4, s2) => (t3.isUnicode[s2] ? "unicode" : "") + o(i4, e3));
          return As(ws, i3);
        } }, { hardline: Is } = i2.doc.builders, ks = { print: ({ node: t3, path: e3, print: i3 }) => ["struct ", t3.name, " {", t3.members.length > 0 ? st2(e3.map(i3, "members"), { firstSeparator: Is, separator: [";", Is], lastSeparator: [";", Is] }) : "", "}"] }, Ds = { print: () => "throw;" }, { join: Os, line: Ps } = i2.doc.builders, Fs = { print: ({ node: t3, path: e3, print: i3 }) => {
          let s2 = ["try", it2(e3.call(i3, "expression"), { firstSeparator: Ps })];
          const r2 = ((t4, e4, i4) => t4.returnParameters ? ["returns (", st2(e4.map(i4, "returnParameters")), ")"] : "")(t3, e3, i3);
          return r2 && (s2 = s2.concat([r2, " "])), s2 = s2.concat([e3.call(i3, "body"), " ", Os(" ", e3.map(i3, "catchClauses"))]), s2;
        } }, { group: Us } = i2.doc.builders, Hs = (t3, e3, i3) => 1 === t3.components?.length && "BinaryOperation" === t3.components[0].type ? e3.map(i3, "components") : st2(e3.map(i3, "components")), Ms = { print: ({ node: t3, path: e3, print: i3 }) => Us([t3.isArray ? "[" : "(", Hs(t3, e3, i3), t3.isArray ? "]" : ")"]) }, Ks = { print: ({ node: t3 }) => ["type ", t3.name, " is ", t3.definition.name, ";"] }, Vs = { print: ({ node: t3, path: e3, print: i3 }) => t3.isPrefix ? [t3.operator, "delete" === t3.operator ? " " : "", e3.call(i3, "subExpression")] : [e3.call(i3, "subExpression"), t3.operator] }, { group: Bs } = i2.doc.builders, $s = { print: ({ path: t3, print: e3 }) => Bs(["unchecked ", t3.call(e3, "block")]) }, js = { print: ({ node: t3 }) => t3.namePath }, { line: Gs, softline: zs } = i2.doc.builders, qs = { print: ({ node: t3, path: e3, print: i3, options: s2 }) => ["using ", t3.functions?.length ? ["{", st2(t3.functions.map((e4, i4) => t3.operators[i4] ? [e4, " as ", t3.operators[i4]] : e4), { firstSeparator: s2.bracketSpacing ? Gs : zs }), "}"] : t3.libraryName, " for ", t3.typeName ? e3.call(i3, "typeName") : "*", t3.isGlobal ? " global;" : ";"] }, { group: Ws, indent: Ys, line: Xs } = i2.doc.builders, Js = (t3) => t3.isIndexed ? " indexed" : "", Qs = (t3) => t3.visibility && "default" !== t3.visibility ? [Xs, t3.visibility] : "", Zs = (t3) => t3.isDeclaredConst ? " constant" : "", tr2 = (t3) => t3.storageLocation && "default" !== t3.visibility ? [Xs, t3.storageLocation] : "", er2 = (t3) => t3.isImmutable ? " immutable" : "", ir2 = (t3) => t3.isTransient ? " transient" : "", sr2 = (t3, e3, i3) => t3.override ? 0 === t3.override.length ? [Xs, "override"] : [Xs, "override(", st2(e3.map(i3, "override")), ")"] : "", rr2 = (t3) => t3.name ? [" ", t3.name] : "", nr2 = { print: ({ node: t3, path: e3, print: i3 }) => t3.typeName ? Ws([e3.call(i3, "typeName"), Ys([Js(t3), Qs(t3), Zs(t3), tr2(t3), er2(t3), ir2(t3), sr2(t3, e3, i3), rr2(t3)])]) : t3.name }, { group: ar2, indentIfBreak: or2 } = i2.doc.builders, lr2 = { print: ({ node: t3, path: e3, print: i3 }) => {
          const s2 = 0 === t3.variables.filter((t4) => t4?.typeName).length, r2 = ar2([s2 ? "var " : "", (n2 = e3.map(i3, "variables"), a2 = t3.variables.length > 1 || s2, a2 ? ["(", st2(n2), ")"] : n2)], { id: Symbol("VariableDeclarationStatement.variables") });
          var n2, a2;
          const o2 = ((t4, e4, i4) => t4.initialValue ? [" = ", e4.call(i4, "initialValue")] : "")(t3, e3, i3);
          return ar2([r2, or2(o2, { groupId: r2.id }), t3.omitSemicolon ? "" : ";"]);
        } }, { group: hr2, indent: cr2, line: ur } = i2.doc.builders, pr2 = (t3, e3, i3) => "Block" === t3.body.type ? [" ", e3.call(i3, "body")] : hr2(cr2([ur, e3.call(i3, "body")])), dr2 = { print: ({ node: t3, path: e3, print: i3 }) => ["while (", it2(e3.call(i3, "condition")), ")", pr2(t3, e3, i3)] }, mr2 = function t3(e3) {
          const i3 = e3.getValue();
          null !== i3 && "object" == typeof i3 && Object.keys(i3).forEach((s2) => {
            switch (s2) {
              case "loc":
              case "range":
                break;
              case "comments":
                e3.each((t4) => {
                  t4.getValue().printed = true;
                }, "comments");
                break;
              default:
                if ("object" == typeof i3[s2]) {
                  if (Array.isArray(i3[s2])) return void e3.each(t3, s2);
                  e3.call(t3, s2);
                }
            }
          });
        };
        let _r2 = false;
        const xr2 = { "solidity-ast": { canAttachComment: (t3) => t3.type && "BlockComment" !== t3.type && "LineComment" !== t3.type, handleComments: { ownLine: function(t3, e3, i3, s2, r2) {
          const { precedingNode: n2, enclosingNode: a2, followingNode: o2 } = t3, l2 = { text: e3, precedingNode: n2, enclosingNode: a2, followingNode: o2, comment: t3, options: i3 };
          return !(!I2.some((t4) => t4(l2)) && !function(t4, e4, i4, s3, r3) {
            const { precedingNode: n3, enclosingNode: a3, followingNode: o3 } = t4;
            return !!(R2(e4, n3, a3, o3, t4, i4) || function(t5, e5, i5) {
              return !(!t5 || "MemberExpression" !== t5.type || !e5 || "Identifier" !== e5.type || (c(t5, i5), 0));
            }(a3, o3, t4) || f(e4, n3, a3, o3, t4, i4) || y2(e4, n3, a3, o3, t4, i4) || g(a3, n3, o3, t4) || T2(a3, 0, o3, t4) || v(a3, t4) || function(t5, e5, i5) {
              return !(!t5 || "ForInStatement" !== t5.type && "ForOfStatement" !== t5.type || (c(t5, i5), 0));
            }(a3, 0, t4) || function(t5, e5, i5, s4) {
              return !(!e5 || "UnionTypeAnnotation" !== e5.type && "TSUnionType" !== e5.type || (u(t5, s4), 0));
            }(n3, a3, 0, t4) || b(a3, s3, t4, r3) || function(t5, e5, i5, s4, r4) {
              return !!(i5 && "ImportSpecifier" === i5.type && e5 && "ImportDeclaration" === e5.type && d(t5, r4.locEnd(s4))) && (u(i5, s4), true);
            }(e4, a3, n3, t4, i4) || function(t5, e5) {
              return !(!t5 || "AssignmentPattern" !== t5.type || (c(t5, e5), 0));
            }(a3, t4) || E(e4, a3, n3, t4, i4));
          }(t3, e3, i3, s2, r2));
        }, endOfLine: function(t3, e3, i3, s2, r2) {
          const { precedingNode: n2, enclosingNode: a2, followingNode: o2 } = t3, l2 = { text: e3, precedingNode: n2, enclosingNode: a2, followingNode: o2, comment: t3, options: i3 };
          return !(!I2.some((t4) => t4(l2)) && !function(t4, e4, i4, s3, r3) {
            const { precedingNode: n3, enclosingNode: a3, followingNode: o3 } = t4;
            return !!(R2(e4, n3, a3, o3, t4, i4) || function(t5, e5, i5, s4, r4, n4) {
              const a4 = e5 && !m(r4, n4.locEnd(e5), n4.locStart(s4));
              return !(e5 && a4 || !t5 || "ConditionalExpression" !== t5.type || !i5 || (c(i5, s4), 0));
            }(a3, n3, o3, t4, e4, i4) || v(a3, t4) || f(e4, n3, a3, o3, t4, i4) || y2(e4, n3, a3, o3, t4, i4) || g(a3, n3, o3, t4) || T2(a3, 0, o3, t4) || function(t5, e5) {
              return !(!t5 || "LabeledStatement" !== t5.type || (c(t5, e5), 0));
            }(a3, t4) || function(t5, e5, i5) {
              return !!(e5 && "CallExpression" === e5.type && t5 && e5.callee === t5 && e5.arguments.length > 0) && (c(e5.arguments[0], i5), true);
            }(n3, a3, t4) || function(t5, e5) {
              return !(!t5 || "Property" !== t5.type && "ObjectProperty" !== t5.type || (c(t5, e5), 0));
            }(a3, t4) || b(a3, s3, t4, r3) || function(t5, e5, i5) {
              return !(!t5 || "TypeAlias" !== t5.type || (c(t5, i5), 0));
            }(a3, 0, t4) || function(t5, e5, i5) {
              return !(!t5 || "VariableDeclarator" !== t5.type && "AssignmentExpression" !== t5.type || !e5 || "ObjectExpression" !== e5.type && "ArrayExpression" !== e5.type && "TemplateLiteral" !== e5.type && "TaggedTemplateExpression" !== e5.type || (c(e5, i5), 0));
            }(a3, o3, t4));
          }(t3, e3, i3, s2, r2));
        }, remaining: function(t3, e3, i3, s2, r2) {
          const { precedingNode: n2, enclosingNode: a2, followingNode: o2 } = t3, l2 = { text: e3, precedingNode: n2, enclosingNode: a2, followingNode: o2, comment: t3, options: i3 };
          return !(!I2.some((t4) => t4(l2)) && !function(t4, e4, i4, s3, r3) {
            const { precedingNode: n3, enclosingNode: a3, followingNode: o3 } = t4;
            return !!(f(e4, n3, a3, o3, t4, i4) || y2(e4, n3, a3, o3, t4, i4) || function(t5, e5, i5) {
              return !(!t5 || "ObjectProperty" !== t5.type && "Property" !== t5.type || !t5.shorthand || t5.key !== e5 || "AssignmentPattern" !== t5.value.type || (u(t5.value.left, i5), 0));
            }(a3, n3, t4) || function(t5, e5, i5, s4) {
              return !(")" !== h(t5, i5, s4.locEnd) || (!e5 || ("FunctionDeclaration" !== e5.type && "FunctionExpression" !== e5.type && ("ArrowFunctionExpression" !== e5.type || "CallExpression" === e5.body.type && 0 !== e5.body.arguments.length) && "ClassMethod" !== e5.type && "ObjectMethod" !== e5.type || 0 !== e5.params.length) && ("CallExpression" !== e5.type && "NewExpression" !== e5.type || 0 !== e5.arguments.length) ? !e5 || "MethodDefinition" !== e5.type || 0 !== e5.value.params.length || (p(e5.value, i5), 0) : (p(e5, i5), 0)));
            }(e4, a3, t4, i4) || E(e4, a3, n3, t4, i4) || b(a3, s3, t4, r3) || function(t5, e5, i5, s4) {
              if (!e5 || "ArrowFunctionExpression" !== e5.type) return false;
              const r4 = getNextNonSpaceNonCommentCharacterIndex(t5, i5, s4);
              return "=>" === t5.substr(r4, 2) && (p(e5, i5), true);
            }(e4, a3, t4, i4) || function(t5, e5, i5, s4, r4) {
              return !("(" !== h(t5, s4, r4.locEnd) || !i5 || !e5 || "FunctionDeclaration" !== e5.type && "FunctionExpression" !== e5.type && "ClassMethod" !== e5.type && "MethodDefinition" !== e5.type && "ObjectMethod" !== e5.type || (u(i5, s4), 0));
            }(e4, a3, n3, t4, i4) || function(t5, e5, i5, s4, r4) {
              return !(!e5 || "TSMappedType" !== e5.type || (s4 && "TSTypeParameter" === s4.type && s4.name ? (c(s4.name, r4), 0) : !i5 || "TSTypeParameter" !== i5.type || !i5.constraint || (u(i5.constraint, r4), 0)));
            }(0, a3, n3, o3, t4) || function(t5, e5) {
              return !(!t5 || "ContinueStatement" !== t5.type && "BreakStatement" !== t5.type || t5.label || (u(t5, e5), 0));
            }(a3, t4));
          }(t3, e3, i3, s2, r2));
        } }, isBlockComment: function(t3) {
          return "BlockComment" === t3.type;
        }, massageAstNode: F, print: function(t3, i3, s2) {
          !function() {
            if (!_r2) {
              if (!a(">=2.3.0")) throw new Error('The version of prettier in your node-modules does not satisfy the required ">=2.3.0" constraint. Please update the version of Prettier.');
              _r2 = true;
            }
          }();
          const r2 = t3.getValue();
          if (null === r2) return "";
          if (!(r2.type in e2)) throw new Error(`Unknown type: ${JSON.stringify(r2.type)}`);
          return function(t4) {
            return t4?.comments?.length > 0 && t4.comments.some((t5) => "prettier-ignore" === t5.value.trim());
          }(r2) ? (mr2(t3), i3.originalText.slice(i3.locStart(r2), i3.locEnd(r2) + 1)) : e2[r2.type].print({ node: r2, options: i3, path: t3, print: s2 });
        }, printComment: function(t3, e3) {
          const s2 = t3.getValue();
          switch (s2.type) {
            case "BlockComment":
              if (function(t4) {
                const e4 = `*${t4.value}*`.split("\n");
                return e4.length > 1 && e4.every((t5) => "*" === t5.trim()[0]);
              }(s2)) {
                const t4 = function(t5) {
                  const e4 = t5.value.split("\n");
                  return ["/*", D(k2, e4.map((t6, i3) => 0 === i3 ? t6.trimEnd() : ` ${i3 < e4.length - 1 ? t6.trim() : t6.trimStart()}`)), "*/"];
                }(s2);
                return s2.trailing && !i2.util.hasNewline(e3.originalText, e3.locStart(s2), { backwards: true }) ? [k2, t4] : t4;
              }
              return `/*${s2.value}*/`;
            case "LineComment":
              return `//${s2.value.trimEnd()}`;
            default:
              throw new Error(`Not a comment: ${JSON.stringify(s2)}`);
          }
        } } }, fr2 = { languages: [{ linguistLanguageId: 237469032, name: "Solidity", type: "programming", color: "#AA6746", aceMode: "text", tmScope: "source.solidity", extensions: [".sol"], parsers: ["solidity-parse"], vscodeLanguageIds: ["solidity"] }], parsers: { "solidity-parse": { astFormat: "solidity-ast", parse: function(t3, e3, i3 = e3) {
          const s2 = $2(i3.compiler), r2 = B2.parse(t3, { loc: true, range: true, comments: true });
          return B2.visit(r2, { PragmaDirective(t4) {
            "solidity" === t4.name && s2 && (n(s2, t4.value) || console.warn(`[prettier-solidity] The compiler option is set to '${i3.compiler}', which does not satisfy 'pragma solidity ${t4.value}'.`));
          }, ModifierDefinition(t4) {
            t4.parameters || (t4.parameters = []);
          }, FunctionDefinition(t4) {
            t4.isConstructor || t4.modifiers.forEach((t5) => {
              0 === t5.arguments?.length && (t5.arguments = null);
            });
          }, ForStatement(t4) {
            t4.initExpression && (t4.initExpression.omitSemicolon = true), t4.loopExpression.omitSemicolon = true;
          }, HexLiteral(t4) {
            const e4 = t4.value.slice(4, -1);
            t4.value = i3.singleQuote ? `hex'${e4}'` : `hex"${e4}"`;
          }, Conditional(t4) {
            if (i3.experimentalTernaries) for (; "TupleExpression" === t4.condition.type && !t4.condition.isArray && 1 === t4.condition.components.length && "Conditional" !== t4.condition.components[0].type; ) [t4.condition] = t4.condition.components;
          }, BinaryOperation(t4) {
            switch (t4.operator) {
              case "+":
              case "-":
                t4.left = j(t4.left, ["%"]), t4.right = j(t4.right, ["%"]);
                break;
              case "*":
                t4.left = j(t4.left, ["/", "%"]);
                break;
              case "/":
                t4.left = j(t4.left, ["*", "%"]);
                break;
              case "%":
                t4.left = j(t4.left, ["*", "/", "%"]);
                break;
              case "**":
                if (!s2) break;
                if (n(s2, ">=0.8.0")) {
                  t4.right = j(t4.right, ["**"]);
                  break;
                }
                if ("BinaryOperation" === t4.right.type && "**" === t4.right.operator) {
                  const e4 = { type: "BinaryOperation", operator: "**", left: t4.left, right: t4.right.left };
                  t4.left = { type: "TupleExpression", components: [e4], isArray: false }, t4.right = t4.right.right;
                }
                break;
              case "<<":
              case ">>":
                t4.left = j(t4.left, ["+", "-", "*", "/", "**", "<<", ">>"]), t4.right = j(t4.right, ["+", "-", "*", "/", "**"]);
                break;
              case "&":
                t4.left = j(t4.left, ["+", "-", "*", "/", "**", "<<", ">>"]), t4.right = j(t4.right, ["+", "-", "*", "/", "**", "<<", ">>"]);
                break;
              case "|":
                t4.left = j(t4.left, ["+", "-", "*", "/", "**", "<<", ">>", "&", "^"]), t4.right = j(t4.right, ["+", "-", "*", "/", "**", "<<", ">>", "&", "^"]);
                break;
              case "^":
                t4.left = j(t4.left, ["+", "-", "*", "/", "**", "<<", ">>", "&"]), t4.right = j(t4.right, ["+", "-", "*", "/", "**", "<<", ">>", "&"]);
                break;
              case "||":
                t4.left = j(t4.left, ["&&"]), t4.right = j(t4.right, ["&&"]);
            }
          } }), r2;
        }, ...H2 } }, printers: xr2, options: V2, defaultOptions: { bracketSpacing: false, tabWidth: 4 } };
      })(), r.default;
    })());
  }
});

// src/action.ts
var import_core = __toESM(require_core());

// node_modules/viem/_esm/utils/encoding/toRlp.js
init_base();
init_cursor2();
init_toBytes();
init_toHex();
function toRlp(bytes, to2 = "hex") {
  const encodable = getEncodable(bytes);
  const cursor = createCursor(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (to2 === "hex")
    return bytesToHex(cursor.bytes);
  return cursor.bytes;
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x2) => getEncodable(x2)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x2) => acc + x2.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode } of list) {
        encode(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? hexToBytes(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length) {
  if (length < 2 ** 8)
    return 1;
  if (length < 2 ** 16)
    return 2;
  if (length < 2 ** 24)
    return 3;
  if (length < 2 ** 32)
    return 4;
  throw new BaseError("Length is too large.");
}

// node_modules/viem/_esm/utils/formatters/block.js
init_formatter();

// node_modules/viem/_esm/utils/formatters/transaction.js
init_fromHex();
init_formatter();
var transactionType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function formatTransaction(transaction) {
  const transaction_ = {
    ...transaction,
    blockHash: transaction.blockHash ? transaction.blockHash : null,
    blockNumber: transaction.blockNumber ? BigInt(transaction.blockNumber) : null,
    chainId: transaction.chainId ? hexToNumber(transaction.chainId) : void 0,
    gas: transaction.gas ? BigInt(transaction.gas) : void 0,
    gasPrice: transaction.gasPrice ? BigInt(transaction.gasPrice) : void 0,
    maxFeePerBlobGas: transaction.maxFeePerBlobGas ? BigInt(transaction.maxFeePerBlobGas) : void 0,
    maxFeePerGas: transaction.maxFeePerGas ? BigInt(transaction.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ? BigInt(transaction.maxPriorityFeePerGas) : void 0,
    nonce: transaction.nonce ? hexToNumber(transaction.nonce) : void 0,
    to: transaction.to ? transaction.to : null,
    transactionIndex: transaction.transactionIndex ? Number(transaction.transactionIndex) : null,
    type: transaction.type ? transactionType[transaction.type] : void 0,
    typeHex: transaction.type ? transaction.type : void 0,
    value: transaction.value ? BigInt(transaction.value) : void 0,
    v: transaction.v ? BigInt(transaction.v) : void 0
  };
  if (transaction.authorizationList)
    transaction_.authorizationList = formatAuthorizationList2(transaction.authorizationList);
  transaction_.yParity = (() => {
    if (transaction.yParity)
      return Number(transaction.yParity);
    if (typeof transaction_.v === "bigint") {
      if (transaction_.v === 0n || transaction_.v === 27n)
        return 0;
      if (transaction_.v === 1n || transaction_.v === 28n)
        return 1;
      if (transaction_.v >= 35n)
        return transaction_.v % 2n === 0n ? 1 : 0;
    }
    return void 0;
  })();
  if (transaction_.type === "legacy") {
    delete transaction_.accessList;
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
    delete transaction_.yParity;
  }
  if (transaction_.type === "eip2930") {
    delete transaction_.maxFeePerBlobGas;
    delete transaction_.maxFeePerGas;
    delete transaction_.maxPriorityFeePerGas;
  }
  if (transaction_.type === "eip1559") {
    delete transaction_.maxFeePerBlobGas;
  }
  return transaction_;
}
var defineTransaction = /* @__PURE__ */ defineFormatter("transaction", formatTransaction);
function formatAuthorizationList2(authorizationList) {
  return authorizationList.map((authorization) => ({
    contractAddress: authorization.address,
    chainId: Number(authorization.chainId),
    nonce: Number(authorization.nonce),
    r: authorization.r,
    s: authorization.s,
    yParity: Number(authorization.yParity)
  }));
}

// node_modules/viem/_esm/utils/formatters/block.js
function formatBlock(block) {
  const transactions = (block.transactions ?? []).map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return formatTransaction(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : null,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: block.gasLimit ? BigInt(block.gasLimit) : void 0,
    gasUsed: block.gasUsed ? BigInt(block.gasUsed) : void 0,
    hash: block.hash ? block.hash : null,
    logsBloom: block.logsBloom ? block.logsBloom : null,
    nonce: block.nonce ? block.nonce : null,
    number: block.number ? BigInt(block.number) : null,
    size: block.size ? BigInt(block.size) : void 0,
    timestamp: block.timestamp ? BigInt(block.timestamp) : void 0,
    transactions,
    totalDifficulty: block.totalDifficulty ? BigInt(block.totalDifficulty) : null
  };
}
var defineBlock = /* @__PURE__ */ defineFormatter("block", formatBlock);

// node_modules/viem/_esm/utils/blob/blobsToCommitments.js
init_toBytes();
init_toHex();
function blobsToCommitments(parameters) {
  const { kzg } = parameters;
  const to2 = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x2) => hexToBytes(x2)) : parameters.blobs;
  const commitments = [];
  for (const blob of blobs)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return to2 === "bytes" ? commitments : commitments.map((x2) => bytesToHex(x2));
}

// node_modules/viem/_esm/utils/blob/blobsToProofs.js
init_toBytes();
init_toHex();
function blobsToProofs(parameters) {
  const { kzg } = parameters;
  const to2 = parameters.to ?? (typeof parameters.blobs[0] === "string" ? "hex" : "bytes");
  const blobs = typeof parameters.blobs[0] === "string" ? parameters.blobs.map((x2) => hexToBytes(x2)) : parameters.blobs;
  const commitments = typeof parameters.commitments[0] === "string" ? parameters.commitments.map((x2) => hexToBytes(x2)) : parameters.commitments;
  const proofs = [];
  for (let i = 0; i < blobs.length; i++) {
    const blob = blobs[i];
    const commitment = commitments[i];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return to2 === "bytes" ? proofs : proofs.map((x2) => bytesToHex(x2));
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
init_toHex();

// node_modules/viem/_esm/utils/hash/sha256.js
init_sha256();
init_isHex();
init_toBytes();
init_toHex();
function sha2562(value, to_) {
  const to2 = to_ || "hex";
  const bytes = sha256(isHex(value, { strict: false }) ? toBytes(value) : value);
  if (to2 === "bytes")
    return bytes;
  return toHex(bytes);
}

// node_modules/viem/_esm/utils/blob/commitmentToVersionedHash.js
function commitmentToVersionedHash(parameters) {
  const { commitment, version: version2 = 1 } = parameters;
  const to2 = parameters.to ?? (typeof commitment === "string" ? "hex" : "bytes");
  const versionedHash = sha2562(commitment, "bytes");
  versionedHash.set([version2], 0);
  return to2 === "bytes" ? versionedHash : bytesToHex(versionedHash);
}

// node_modules/viem/_esm/utils/blob/commitmentsToVersionedHashes.js
function commitmentsToVersionedHashes(parameters) {
  const { commitments, version: version2 } = parameters;
  const to2 = parameters.to ?? (typeof commitments[0] === "string" ? "hex" : "bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash({
      commitment,
      to: to2,
      version: version2
    }));
  }
  return hashes;
}

// node_modules/viem/_esm/constants/blob.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;

// node_modules/viem/_esm/constants/kzg.js
var versionedHashVersionKzg = 1;

// node_modules/viem/_esm/errors/blob.js
init_base();
var BlobSizeTooLargeError = class extends BaseError {
  constructor({ maxSize, size: size2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError = class extends BaseError {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};
var InvalidVersionedHashSizeError = class extends BaseError {
  constructor({ hash, size: size2 }) {
    super(`Versioned hash "${hash}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size2}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError = class extends BaseError {
  constructor({ hash, version: version2 }) {
    super(`Versioned hash "${hash}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersionKzg}`,
        `Received: ${version2}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
};

// node_modules/viem/_esm/utils/blob/toBlobs.js
init_cursor2();
init_size();
init_toBytes();
init_toHex();
function toBlobs(parameters) {
  const to2 = parameters.to ?? (typeof parameters.data === "string" ? "hex" : "bytes");
  const data = typeof parameters.data === "string" ? hexToBytes(parameters.data) : parameters.data;
  const size_ = size(data);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = createCursor(new Uint8Array(bytesPerBlob));
    let size2 = 0;
    while (size2 < fieldElementsPerBlob) {
      const bytes = data.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size2++;
      position += 31;
    }
    blobs.push(blob);
  }
  return to2 === "bytes" ? blobs.map((x2) => x2.bytes) : blobs.map((x2) => bytesToHex(x2.bytes));
}

// node_modules/viem/_esm/utils/blob/toBlobSidecars.js
function toBlobSidecars(parameters) {
  const { data, kzg, to: to2 } = parameters;
  const blobs = parameters.blobs ?? toBlobs({ data, to: to2 });
  const commitments = parameters.commitments ?? blobsToCommitments({ blobs, kzg, to: to2 });
  const proofs = parameters.proofs ?? blobsToProofs({ blobs, commitments, kzg, to: to2 });
  const sidecars = [];
  for (let i = 0; i < blobs.length; i++)
    sidecars.push({
      blob: blobs[i],
      commitment: commitments[i],
      proof: proofs[i]
    });
  return sidecars;
}

// node_modules/viem/_esm/utils/transaction/getTransactionType.js
init_transaction();
function getTransactionType(transaction) {
  if (transaction.type)
    return transaction.type;
  if (typeof transaction.authorizationList !== "undefined")
    return "eip7702";
  if (typeof transaction.blobs !== "undefined" || typeof transaction.blobVersionedHashes !== "undefined" || typeof transaction.maxFeePerBlobGas !== "undefined" || typeof transaction.sidecars !== "undefined")
    return "eip4844";
  if (typeof transaction.maxFeePerGas !== "undefined" || typeof transaction.maxPriorityFeePerGas !== "undefined") {
    return "eip1559";
  }
  if (typeof transaction.gasPrice !== "undefined") {
    if (typeof transaction.accessList !== "undefined")
      return "eip2930";
    return "legacy";
  }
  throw new InvalidSerializableTransactionError({ transaction });
}

// node_modules/viem/_esm/utils/formatters/log.js
function formatLog(log, { args, eventName } = {}) {
  return {
    ...log,
    blockHash: log.blockHash ? log.blockHash : null,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionHash: log.transactionHash ? log.transactionHash : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null,
    ...eventName ? { args, eventName } : {}
  };
}

// node_modules/viem/_esm/errors/account.js
init_base();
var AccountNotFoundError = class extends BaseError {
  constructor({ docsPath } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join("\n"), {
      docsPath,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
};

// node_modules/viem/_esm/actions/public/getCode.js
init_toHex();
async function getCode(client, { address, blockNumber, blockTag = "latest" }) {
  const blockNumberHex = blockNumber !== void 0 ? numberToHex(blockNumber) : void 0;
  const hex = await client.request({
    method: "eth_getCode",
    params: [address, blockNumberHex || blockTag]
  }, { dedupe: Boolean(blockNumberHex) });
  if (hex === "0x")
    return void 0;
  return hex;
}

// node_modules/viem/_esm/utils/chain/defineChain.js
function defineChain(chain) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...chain
  };
}

// node_modules/viem/_esm/utils/formatters/transactionReceipt.js
init_fromHex();
init_formatter();
var receiptStatuses = {
  "0x0": "reverted",
  "0x1": "success"
};
function formatTransactionReceipt(transactionReceipt) {
  const receipt = {
    ...transactionReceipt,
    blockNumber: transactionReceipt.blockNumber ? BigInt(transactionReceipt.blockNumber) : null,
    contractAddress: transactionReceipt.contractAddress ? transactionReceipt.contractAddress : null,
    cumulativeGasUsed: transactionReceipt.cumulativeGasUsed ? BigInt(transactionReceipt.cumulativeGasUsed) : null,
    effectiveGasPrice: transactionReceipt.effectiveGasPrice ? BigInt(transactionReceipt.effectiveGasPrice) : null,
    gasUsed: transactionReceipt.gasUsed ? BigInt(transactionReceipt.gasUsed) : null,
    logs: transactionReceipt.logs ? transactionReceipt.logs.map((log) => formatLog(log)) : null,
    to: transactionReceipt.to ? transactionReceipt.to : null,
    transactionIndex: transactionReceipt.transactionIndex ? hexToNumber(transactionReceipt.transactionIndex) : null,
    status: transactionReceipt.status ? receiptStatuses[transactionReceipt.status] : null,
    type: transactionReceipt.type ? transactionType[transactionReceipt.type] || transactionReceipt.type : null
  };
  if (transactionReceipt.blobGasPrice)
    receipt.blobGasPrice = BigInt(transactionReceipt.blobGasPrice);
  if (transactionReceipt.blobGasUsed)
    receipt.blobGasUsed = BigInt(transactionReceipt.blobGasUsed);
  return receipt;
}
var defineTransactionReceipt = /* @__PURE__ */ defineFormatter("transactionReceipt", formatTransactionReceipt);

// node_modules/viem/_esm/utils/transaction/assertTransaction.js
init_number();
init_address();
init_base();
init_chain();
init_node();
init_isAddress();
init_size();
init_slice();
init_fromHex();
function assertTransactionEIP7702(transaction) {
  const { authorizationList } = transaction;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { contractAddress, chainId } = authorization;
      if (!isAddress(contractAddress))
        throw new InvalidAddressError({ address: contractAddress });
      if (chainId < 0)
        throw new InvalidChainIdError({ chainId });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP4844(transaction) {
  const { blobVersionedHashes } = transaction;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobError();
    for (const hash of blobVersionedHashes) {
      const size_ = size(hash);
      const version2 = hexToNumber(slice(hash, 0, 1));
      if (size_ !== 32)
        throw new InvalidVersionedHashSizeError({ hash, size: size_ });
      if (version2 !== versionedHashVersionKzg)
        throw new InvalidVersionedHashVersionError({
          hash,
          version: version2
        });
    }
  }
  assertTransactionEIP1559(transaction);
}
function assertTransactionEIP1559(transaction) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to2 } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to2 && !isAddress(to2))
    throw new InvalidAddressError({ address: to2 });
  if (maxFeePerGas && maxFeePerGas > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
}
function assertTransactionEIP2930(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to2 } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to2 && !isAddress(to2))
    throw new InvalidAddressError({ address: to2 });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}
function assertTransactionLegacy(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to2 } = transaction;
  if (to2 && !isAddress(to2))
    throw new InvalidAddressError({ address: to2 });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (maxPriorityFeePerGas || maxFeePerGas)
    throw new BaseError("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (gasPrice && gasPrice > maxUint256)
    throw new FeeCapTooHighError({ maxFeePerGas: gasPrice });
}

// node_modules/viem/_esm/utils/transaction/serializeTransaction.js
init_transaction();
init_concat();
init_trim();
init_toHex();

// node_modules/viem/_esm/experimental/eip7702/utils/serializeAuthorizationList.js
init_toHex();
function serializeAuthorizationList(authorizationList) {
  if (!authorizationList || authorizationList.length === 0)
    return [];
  const serializedAuthorizationList = [];
  for (const authorization of authorizationList) {
    const { contractAddress, chainId, nonce, ...signature } = authorization;
    serializedAuthorizationList.push([
      chainId ? toHex(chainId) : "0x",
      contractAddress,
      nonce ? toHex(nonce) : "0x",
      ...toYParitySignatureArray({}, signature)
    ]);
  }
  return serializedAuthorizationList;
}

// node_modules/viem/_esm/utils/transaction/serializeAccessList.js
init_address();
init_transaction();
init_isAddress();
function serializeAccessList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const serializedAccessList = [];
  for (let i = 0; i < accessList.length; i++) {
    const { address, storageKeys } = accessList[i];
    for (let j = 0; j < storageKeys.length; j++) {
      if (storageKeys[j].length - 2 !== 64) {
        throw new InvalidStorageKeySizeError({ storageKey: storageKeys[j] });
      }
    }
    if (!isAddress(address, { strict: false })) {
      throw new InvalidAddressError({ address });
    }
    serializedAccessList.push([address, storageKeys]);
  }
  return serializedAccessList;
}

// node_modules/viem/_esm/utils/transaction/serializeTransaction.js
function serializeTransaction(transaction, signature) {
  const type = getTransactionType(transaction);
  if (type === "eip1559")
    return serializeTransactionEIP1559(transaction, signature);
  if (type === "eip2930")
    return serializeTransactionEIP2930(transaction, signature);
  if (type === "eip4844")
    return serializeTransactionEIP4844(transaction, signature);
  if (type === "eip7702")
    return serializeTransactionEIP7702(transaction, signature);
  return serializeTransactionLegacy(transaction, signature);
}
function serializeTransactionEIP7702(transaction, signature) {
  const { authorizationList, chainId, gas, nonce, to: to2, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP7702(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedAuthorizationList = serializeAuthorizationList(authorizationList);
  return concatHex([
    "0x04",
    toRlp([
      toHex(chainId),
      nonce ? toHex(nonce) : "0x",
      maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
      maxFeePerGas ? toHex(maxFeePerGas) : "0x",
      gas ? toHex(gas) : "0x",
      to2 ?? "0x",
      value ? toHex(value) : "0x",
      data ?? "0x",
      serializedAccessList,
      serializedAuthorizationList,
      ...toYParitySignatureArray(transaction, signature)
    ])
  ]);
}
function serializeTransactionEIP4844(transaction, signature) {
  const { chainId, gas, nonce, to: to2, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP4844(transaction);
  let blobVersionedHashes = transaction.blobVersionedHashes;
  let sidecars = transaction.sidecars;
  if (transaction.blobs && (typeof blobVersionedHashes === "undefined" || typeof sidecars === "undefined")) {
    const blobs2 = typeof transaction.blobs[0] === "string" ? transaction.blobs : transaction.blobs.map((x2) => bytesToHex(x2));
    const kzg = transaction.kzg;
    const commitments2 = blobsToCommitments({
      blobs: blobs2,
      kzg
    });
    if (typeof blobVersionedHashes === "undefined")
      blobVersionedHashes = commitmentsToVersionedHashes({
        commitments: commitments2
      });
    if (typeof sidecars === "undefined") {
      const proofs2 = blobsToProofs({ blobs: blobs2, commitments: commitments2, kzg });
      sidecars = toBlobSidecars({ blobs: blobs2, commitments: commitments2, proofs: proofs2 });
    }
  }
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to2 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    maxFeePerBlobGas ? toHex(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...toYParitySignatureArray(transaction, signature)
  ];
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i = 0; i < sidecars.length; i++) {
      const { blob, commitment, proof } = sidecars[i];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concatHex([
    "0x03",
    sidecars ? (
      // If sidecars are enabled, envelope turns into a "wrapper":
      toRlp([serializedTransaction, blobs, commitments, proofs])
    ) : (
      // If sidecars are disabled, standard envelope is used:
      toRlp(serializedTransaction)
    )
  ]);
}
function serializeTransactionEIP1559(transaction, signature) {
  const { chainId, gas, nonce, to: to2, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = transaction;
  assertTransactionEIP1559(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to2 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x02",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionEIP2930(transaction, signature) {
  const { chainId, gas, data, nonce, to: to2, value, accessList, gasPrice } = transaction;
  assertTransactionEIP2930(transaction);
  const serializedAccessList = serializeAccessList(accessList);
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to2 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializedAccessList,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x01",
    toRlp(serializedTransaction)
  ]);
}
function serializeTransactionLegacy(transaction, signature) {
  const { chainId = 0, gas, data, nonce, to: to2, value, gasPrice } = transaction;
  assertTransactionLegacy(transaction);
  let serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    gasPrice ? toHex(gasPrice) : "0x",
    gas ? toHex(gas) : "0x",
    to2 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x"
  ];
  if (signature) {
    const v = (() => {
      if (signature.v >= 35n) {
        const inferredChainId = (signature.v - 35n) / 2n;
        if (inferredChainId > 0)
          return signature.v;
        return 27n + (signature.v === 35n ? 0n : 1n);
      }
      if (chainId > 0)
        return BigInt(chainId * 2) + BigInt(35n + signature.v - 27n);
      const v2 = 27n + (signature.v === 27n ? 0n : 1n);
      if (signature.v !== v2)
        throw new InvalidLegacyVError({ v: signature.v });
      return v2;
    })();
    const r = trim(signature.r);
    const s = trim(signature.s);
    serializedTransaction = [
      ...serializedTransaction,
      toHex(v),
      r === "0x00" ? "0x" : r,
      s === "0x00" ? "0x" : s
    ];
  } else if (chainId > 0) {
    serializedTransaction = [
      ...serializedTransaction,
      toHex(chainId),
      "0x",
      "0x"
    ];
  }
  return toRlp(serializedTransaction);
}
function toYParitySignatureArray(transaction, signature_) {
  const signature = signature_ ?? transaction;
  const { v, yParity } = signature;
  if (typeof signature.r === "undefined")
    return [];
  if (typeof signature.s === "undefined")
    return [];
  if (typeof v === "undefined" && typeof yParity === "undefined")
    return [];
  const r = trim(signature.r);
  const s = trim(signature.s);
  const yParity_ = (() => {
    if (typeof yParity === "number")
      return yParity ? toHex(1) : "0x";
    if (v === 0n)
      return "0x";
    if (v === 1n)
      return toHex(1);
    return v === 27n ? "0x" : toHex(1);
  })();
  return [yParity_, r === "0x00" ? "0x" : r, s === "0x00" ? "0x" : s];
}

// node_modules/diff/lib/index.mjs
function Diff() {
}
Diff.prototype = {
  diff: function diff(oldString, newString) {
    var _options$timeout;
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var callback = options.callback;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    var self2 = this;
    function done(value) {
      value = self2.postProcess(value, options);
      if (callback) {
        setTimeout(function() {
          callback(value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }
    oldString = this.castInput(oldString, options);
    newString = this.castInput(newString, options);
    oldString = this.removeEmpty(this.tokenize(oldString, options));
    newString = this.removeEmpty(this.tokenize(newString, options));
    var newLen = newString.length, oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    if (options.maxEditLength != null) {
      maxEditLength = Math.min(maxEditLength, options.maxEditLength);
    }
    var maxExecutionTime = (_options$timeout = options.timeout) !== null && _options$timeout !== void 0 ? _options$timeout : Infinity;
    var abortAfterTimestamp = Date.now() + maxExecutionTime;
    var bestPath = [{
      oldPos: -1,
      lastComponent: void 0
    }];
    var newPos = this.extractCommon(bestPath[0], newString, oldString, 0, options);
    if (bestPath[0].oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
      return done(buildValues(self2, bestPath[0].lastComponent, newString, oldString, self2.useLongestToken));
    }
    var minDiagonalToConsider = -Infinity, maxDiagonalToConsider = Infinity;
    function execEditLength() {
      for (var diagonalPath = Math.max(minDiagonalToConsider, -editLength); diagonalPath <= Math.min(maxDiagonalToConsider, editLength); diagonalPath += 2) {
        var basePath = void 0;
        var removePath = bestPath[diagonalPath - 1], addPath = bestPath[diagonalPath + 1];
        if (removePath) {
          bestPath[diagonalPath - 1] = void 0;
        }
        var canAdd = false;
        if (addPath) {
          var addPathNewPos = addPath.oldPos - diagonalPath;
          canAdd = addPath && 0 <= addPathNewPos && addPathNewPos < newLen;
        }
        var canRemove = removePath && removePath.oldPos + 1 < oldLen;
        if (!canAdd && !canRemove) {
          bestPath[diagonalPath] = void 0;
          continue;
        }
        if (!canRemove || canAdd && removePath.oldPos < addPath.oldPos) {
          basePath = self2.addToPath(addPath, true, false, 0, options);
        } else {
          basePath = self2.addToPath(removePath, false, true, 1, options);
        }
        newPos = self2.extractCommon(basePath, newString, oldString, diagonalPath, options);
        if (basePath.oldPos + 1 >= oldLen && newPos + 1 >= newLen) {
          return done(buildValues(self2, basePath.lastComponent, newString, oldString, self2.useLongestToken));
        } else {
          bestPath[diagonalPath] = basePath;
          if (basePath.oldPos + 1 >= oldLen) {
            maxDiagonalToConsider = Math.min(maxDiagonalToConsider, diagonalPath - 1);
          }
          if (newPos + 1 >= newLen) {
            minDiagonalToConsider = Math.max(minDiagonalToConsider, diagonalPath + 1);
          }
        }
      }
      editLength++;
    }
    if (callback) {
      (function exec() {
        setTimeout(function() {
          if (editLength > maxEditLength || Date.now() > abortAfterTimestamp) {
            return callback();
          }
          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength && Date.now() <= abortAfterTimestamp) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  addToPath: function addToPath(path, added, removed, oldPosInc, options) {
    var last = path.lastComponent;
    if (last && !options.oneChangePerToken && last.added === added && last.removed === removed) {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: last.count + 1,
          added,
          removed,
          previousComponent: last.previousComponent
        }
      };
    } else {
      return {
        oldPos: path.oldPos + oldPosInc,
        lastComponent: {
          count: 1,
          added,
          removed,
          previousComponent: last
        }
      };
    }
  },
  extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath, options) {
    var newLen = newString.length, oldLen = oldString.length, oldPos = basePath.oldPos, newPos = oldPos - diagonalPath, commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(oldString[oldPos + 1], newString[newPos + 1], options)) {
      newPos++;
      oldPos++;
      commonCount++;
      if (options.oneChangePerToken) {
        basePath.lastComponent = {
          count: 1,
          previousComponent: basePath.lastComponent,
          added: false,
          removed: false
        };
      }
    }
    if (commonCount && !options.oneChangePerToken) {
      basePath.lastComponent = {
        count: commonCount,
        previousComponent: basePath.lastComponent,
        added: false,
        removed: false
      };
    }
    basePath.oldPos = oldPos;
    return newPos;
  },
  equals: function equals(left, right, options) {
    if (options.comparator) {
      return options.comparator(left, right);
    } else {
      return left === right || options.ignoreCase && left.toLowerCase() === right.toLowerCase();
    }
  },
  removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  castInput: function castInput(value) {
    return value;
  },
  tokenize: function tokenize(value) {
    return Array.from(value);
  },
  join: function join(chars) {
    return chars.join("");
  },
  postProcess: function postProcess(changeObjects) {
    return changeObjects;
  }
};
function buildValues(diff2, lastComponent, newString, oldString, useLongestToken) {
  var components = [];
  var nextComponent;
  while (lastComponent) {
    components.push(lastComponent);
    nextComponent = lastComponent.previousComponent;
    delete lastComponent.previousComponent;
    lastComponent = nextComponent;
  }
  components.reverse();
  var componentPos = 0, componentLen = components.length, newPos = 0, oldPos = 0;
  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function(value2, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value2.length ? oldValue : value2;
        });
        component.value = diff2.join(value);
      } else {
        component.value = diff2.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff2.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;
    }
  }
  return components;
}
function longestCommonPrefix(str1, str2) {
  var i;
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[i] != str2[i]) {
      return str1.slice(0, i);
    }
  }
  return str1.slice(0, i);
}
function longestCommonSuffix(str1, str2) {
  var i;
  if (!str1 || !str2 || str1[str1.length - 1] != str2[str2.length - 1]) {
    return "";
  }
  for (i = 0; i < str1.length && i < str2.length; i++) {
    if (str1[str1.length - (i + 1)] != str2[str2.length - (i + 1)]) {
      return str1.slice(-i);
    }
  }
  return str1.slice(-i);
}
function replacePrefix(string, oldPrefix, newPrefix) {
  if (string.slice(0, oldPrefix.length) != oldPrefix) {
    throw Error("string ".concat(JSON.stringify(string), " doesn't start with prefix ").concat(JSON.stringify(oldPrefix), "; this is a bug"));
  }
  return newPrefix + string.slice(oldPrefix.length);
}
function replaceSuffix(string, oldSuffix, newSuffix) {
  if (!oldSuffix) {
    return string + newSuffix;
  }
  if (string.slice(-oldSuffix.length) != oldSuffix) {
    throw Error("string ".concat(JSON.stringify(string), " doesn't end with suffix ").concat(JSON.stringify(oldSuffix), "; this is a bug"));
  }
  return string.slice(0, -oldSuffix.length) + newSuffix;
}
function removePrefix(string, oldPrefix) {
  return replacePrefix(string, oldPrefix, "");
}
function removeSuffix(string, oldSuffix) {
  return replaceSuffix(string, oldSuffix, "");
}
function maximumOverlap(string1, string2) {
  return string2.slice(0, overlapCount(string1, string2));
}
function overlapCount(a, b) {
  var startA = 0;
  if (a.length > b.length) {
    startA = a.length - b.length;
  }
  var endB = b.length;
  if (a.length < b.length) {
    endB = a.length;
  }
  var map = Array(endB);
  var k2 = 0;
  map[0] = 0;
  for (var j = 1; j < endB; j++) {
    if (b[j] == b[k2]) {
      map[j] = map[k2];
    } else {
      map[j] = k2;
    }
    while (k2 > 0 && b[j] != b[k2]) {
      k2 = map[k2];
    }
    if (b[j] == b[k2]) {
      k2++;
    }
  }
  k2 = 0;
  for (var i = startA; i < a.length; i++) {
    while (k2 > 0 && a[i] != b[k2]) {
      k2 = map[k2];
    }
    if (a[i] == b[k2]) {
      k2++;
    }
  }
  return k2;
}
var extendedWordChars = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var tokenizeIncludingWhitespace = new RegExp("[".concat(extendedWordChars, "]+|\\s+|[^").concat(extendedWordChars, "]"), "ug");
var wordDiff = new Diff();
wordDiff.equals = function(left, right, options) {
  if (options.ignoreCase) {
    left = left.toLowerCase();
    right = right.toLowerCase();
  }
  return left.trim() === right.trim();
};
wordDiff.tokenize = function(value) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var parts;
  if (options.intlSegmenter) {
    if (options.intlSegmenter.resolvedOptions().granularity != "word") {
      throw new Error('The segmenter passed must have a granularity of "word"');
    }
    parts = Array.from(options.intlSegmenter.segment(value), function(segment) {
      return segment.segment;
    });
  } else {
    parts = value.match(tokenizeIncludingWhitespace) || [];
  }
  var tokens = [];
  var prevPart = null;
  parts.forEach(function(part) {
    if (/\s/.test(part)) {
      if (prevPart == null) {
        tokens.push(part);
      } else {
        tokens.push(tokens.pop() + part);
      }
    } else if (/\s/.test(prevPart)) {
      if (tokens[tokens.length - 1] == prevPart) {
        tokens.push(tokens.pop() + part);
      } else {
        tokens.push(prevPart + part);
      }
    } else {
      tokens.push(part);
    }
    prevPart = part;
  });
  return tokens;
};
wordDiff.join = function(tokens) {
  return tokens.map(function(token, i) {
    if (i == 0) {
      return token;
    } else {
      return token.replace(/^\s+/, "");
    }
  }).join("");
};
wordDiff.postProcess = function(changes, options) {
  if (!changes || options.oneChangePerToken) {
    return changes;
  }
  var lastKeep = null;
  var insertion = null;
  var deletion = null;
  changes.forEach(function(change) {
    if (change.added) {
      insertion = change;
    } else if (change.removed) {
      deletion = change;
    } else {
      if (insertion || deletion) {
        dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, change);
      }
      lastKeep = change;
      insertion = null;
      deletion = null;
    }
  });
  if (insertion || deletion) {
    dedupeWhitespaceInChangeObjects(lastKeep, deletion, insertion, null);
  }
  return changes;
};
function dedupeWhitespaceInChangeObjects(startKeep, deletion, insertion, endKeep) {
  if (deletion && insertion) {
    var oldWsPrefix = deletion.value.match(/^\s*/)[0];
    var oldWsSuffix = deletion.value.match(/\s*$/)[0];
    var newWsPrefix = insertion.value.match(/^\s*/)[0];
    var newWsSuffix = insertion.value.match(/\s*$/)[0];
    if (startKeep) {
      var commonWsPrefix = longestCommonPrefix(oldWsPrefix, newWsPrefix);
      startKeep.value = replaceSuffix(startKeep.value, newWsPrefix, commonWsPrefix);
      deletion.value = removePrefix(deletion.value, commonWsPrefix);
      insertion.value = removePrefix(insertion.value, commonWsPrefix);
    }
    if (endKeep) {
      var commonWsSuffix = longestCommonSuffix(oldWsSuffix, newWsSuffix);
      endKeep.value = replacePrefix(endKeep.value, newWsSuffix, commonWsSuffix);
      deletion.value = removeSuffix(deletion.value, commonWsSuffix);
      insertion.value = removeSuffix(insertion.value, commonWsSuffix);
    }
  } else if (insertion) {
    if (startKeep) {
      insertion.value = insertion.value.replace(/^\s*/, "");
    }
    if (endKeep) {
      endKeep.value = endKeep.value.replace(/^\s*/, "");
    }
  } else if (startKeep && endKeep) {
    var newWsFull = endKeep.value.match(/^\s*/)[0], delWsStart = deletion.value.match(/^\s*/)[0], delWsEnd = deletion.value.match(/\s*$/)[0];
    var newWsStart = longestCommonPrefix(newWsFull, delWsStart);
    deletion.value = removePrefix(deletion.value, newWsStart);
    var newWsEnd = longestCommonSuffix(removePrefix(newWsFull, newWsStart), delWsEnd);
    deletion.value = removeSuffix(deletion.value, newWsEnd);
    endKeep.value = replacePrefix(endKeep.value, newWsFull, newWsEnd);
    startKeep.value = replaceSuffix(startKeep.value, newWsFull, newWsFull.slice(0, newWsFull.length - newWsEnd.length));
  } else if (endKeep) {
    var endKeepWsPrefix = endKeep.value.match(/^\s*/)[0];
    var deletionWsSuffix = deletion.value.match(/\s*$/)[0];
    var overlap = maximumOverlap(deletionWsSuffix, endKeepWsPrefix);
    deletion.value = removeSuffix(deletion.value, overlap);
  } else if (startKeep) {
    var startKeepWsSuffix = startKeep.value.match(/\s*$/)[0];
    var deletionWsPrefix = deletion.value.match(/^\s*/)[0];
    var _overlap = maximumOverlap(startKeepWsSuffix, deletionWsPrefix);
    deletion.value = removePrefix(deletion.value, _overlap);
  }
}
var wordWithSpaceDiff = new Diff();
wordWithSpaceDiff.tokenize = function(value) {
  var regex = new RegExp("(\\r?\\n)|[".concat(extendedWordChars, "]+|[^\\S\\n\\r]+|[^").concat(extendedWordChars, "]"), "ug");
  return value.match(regex) || [];
};
var lineDiff = new Diff();
lineDiff.tokenize = function(value, options) {
  if (options.stripTrailingCr) {
    value = value.replace(/\r\n/g, "\n");
  }
  var retLines = [], linesAndNewlines = value.split(/(\n|\r\n)/);
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];
    if (i % 2 && !options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      retLines.push(line);
    }
  }
  return retLines;
};
lineDiff.equals = function(left, right, options) {
  if (options.ignoreWhitespace) {
    if (!options.newlineIsToken || !left.includes("\n")) {
      left = left.trim();
    }
    if (!options.newlineIsToken || !right.includes("\n")) {
      right = right.trim();
    }
  } else if (options.ignoreNewlineAtEof && !options.newlineIsToken) {
    if (left.endsWith("\n")) {
      left = left.slice(0, -1);
    }
    if (right.endsWith("\n")) {
      right = right.slice(0, -1);
    }
  }
  return Diff.prototype.equals.call(this, left, right, options);
};
var sentenceDiff = new Diff();
sentenceDiff.tokenize = function(value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var cssDiff = new Diff();
cssDiff.tokenize = function(value) {
  return value.split(/([{}:;,]|\s+)/);
};
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
var jsonDiff = new Diff();
jsonDiff.useLongestToken = true;
jsonDiff.tokenize = lineDiff.tokenize;
jsonDiff.castInput = function(value, options) {
  var undefinedReplacement = options.undefinedReplacement, _options$stringifyRep = options.stringifyReplacer, stringifyReplacer = _options$stringifyRep === void 0 ? function(k2, v) {
    return typeof v === "undefined" ? undefinedReplacement : v;
  } : _options$stringifyRep;
  return typeof value === "string" ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, "  ");
};
jsonDiff.equals = function(left, right, options) {
  return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, "$1"), right.replace(/,([\r\n])/g, "$1"), options);
};
function canonicalize(obj, stack, replacementStack, replacer, key) {
  stack = stack || [];
  replacementStack = replacementStack || [];
  if (replacer) {
    obj = replacer(key, obj);
  }
  var i;
  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }
  var canonicalizedObj;
  if ("[object Array]" === Object.prototype.toString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }
  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }
  if (_typeof(obj) === "object" && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [], _key;
    for (_key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, _key)) {
        sortedKeys.push(_key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      _key = sortedKeys[i];
      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}
var arrayDiff = new Diff();
arrayDiff.tokenize = function(value) {
  return value.slice();
};
arrayDiff.join = arrayDiff.removeEmpty = function(value) {
  return value;
};

// node_modules/viem/_esm/zksync/formatters.js
init_fromHex();
init_toBytes();
init_toHex();
init_transactionRequest();

// node_modules/viem/_esm/zksync/constants/number.js
init_number();
var gasPerPubdataDefault = 50000n;
var maxBytecodeSize = maxUint16 * 32n;

// node_modules/viem/_esm/zksync/formatters.js
var formatters = {
  block: /* @__PURE__ */ defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatters.transaction?.format(transaction);
        if (formatted.typeHex === "0x71")
          formatted.type = "eip712";
        else if (formatted.typeHex === "0xff")
          formatted.type = "priority";
        return formatted;
      });
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTimestamp: args.l1BatchTimestamp ? hexToBigInt(args.l1BatchTimestamp) : null,
        transactions
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x71")
        transaction.type = "eip712";
      else if (args.type === "0xff")
        transaction.type = "priority";
      return {
        ...transaction,
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(args) {
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null,
        logs: args.logs.map((log) => {
          return {
            ...formatLog(log),
            l1BatchNumber: log.l1BatchNumber ? hexToBigInt(log.l1BatchNumber) : null,
            transactionLogIndex: hexToNumber(log.transactionLogIndex),
            logType: log.logType
          };
        }),
        l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
          return {
            blockNumber: hexToBigInt(l2ToL1Log.blockHash),
            blockHash: l2ToL1Log.blockHash,
            l1BatchNumber: l2ToL1Log.l1BatchNumber ? hexToBigInt(l2ToL1Log.l1BatchNumber) : null,
            transactionIndex: hexToBigInt(l2ToL1Log.transactionIndex),
            shardId: hexToBigInt(l2ToL1Log.shardId),
            isService: l2ToL1Log.isService,
            sender: l2ToL1Log.sender,
            key: l2ToL1Log.key,
            value: l2ToL1Log.value,
            transactionHash: l2ToL1Log.transactionHash,
            logIndex: hexToBigInt(l2ToL1Log.logIndex)
          };
        })
      };
    }
  }),
  transactionRequest: /* @__PURE__ */ defineTransactionRequest({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(args) {
      if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
        return {
          eip712Meta: {
            ...args.gasPerPubdata ? { gasPerPubdata: toHex(args.gasPerPubdata) } : { gasPerPubdata: toHex(gasPerPubdataDefault) },
            ...args.paymaster && args.paymasterInput ? {
              paymasterParams: {
                paymaster: args.paymaster,
                paymasterInput: Array.from(hexToBytes(args.paymasterInput))
              }
            } : {},
            ...args.factoryDeps ? {
              factoryDeps: args.factoryDeps.map((dep) => Array.from(hexToBytes(dep)))
            } : {},
            ...args.customSignature ? {
              customSignature: Array.from(hexToBytes(args.customSignature))
            } : {}
          },
          type: "0x71"
        };
      return {};
    }
  })
};

// node_modules/viem/_esm/zksync/serializers.js
init_concat();
init_toHex();

// node_modules/viem/_esm/zksync/utils/assertEip712Transaction.js
init_address();
init_base();
init_chain();
init_isAddress();

// node_modules/viem/_esm/zksync/errors/transaction.js
init_base();
var InvalidEip712TransactionError = class extends BaseError {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join("\n"), { name: "InvalidEip712TransactionError" });
  }
};

// node_modules/viem/_esm/zksync/utils/isEip712Transaction.js
function isEIP712Transaction(transaction) {
  if (transaction.type === "eip712")
    return true;
  if ("customSignature" in transaction && transaction.customSignature || "paymaster" in transaction && transaction.paymaster || "paymasterInput" in transaction && transaction.paymasterInput || "gasPerPubdata" in transaction && typeof transaction.gasPerPubdata === "bigint" || "factoryDeps" in transaction && transaction.factoryDeps)
    return true;
  return false;
}

// node_modules/viem/_esm/zksync/utils/assertEip712Transaction.js
function assertEip712Transaction(transaction) {
  const { chainId, to: to2, from, paymaster, paymasterInput } = transaction;
  if (!isEIP712Transaction(transaction))
    throw new InvalidEip712TransactionError();
  if (!chainId || chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to2 && !isAddress(to2))
    throw new InvalidAddressError({ address: to2 });
  if (from && !isAddress(from))
    throw new InvalidAddressError({ address: from });
  if (paymaster && !isAddress(paymaster))
    throw new InvalidAddressError({ address: paymaster });
  if (paymaster && !paymasterInput) {
    throw new BaseError("`paymasterInput` must be provided when `paymaster` is defined");
  }
  if (!paymaster && paymasterInput) {
    throw new BaseError("`paymaster` must be provided when `paymasterInput` is defined");
  }
}

// node_modules/viem/_esm/zksync/serializers.js
function serializeTransaction2(transaction, signature) {
  if (isEIP712Transaction(transaction))
    return serializeTransactionEIP712(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction2
};
function serializeTransactionEIP712(transaction) {
  const { chainId, gas, nonce, to: to2, from, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  assertEip712Transaction(transaction);
  const serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to2 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    toHex(chainId),
    toHex(""),
    toHex(""),
    toHex(chainId),
    from ?? "0x",
    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),
    factoryDeps ?? [],
    customSignature ?? "0x",
    // EIP712 signature
    paymaster && paymasterInput ? [paymaster, paymasterInput] : []
  ];
  return concatHex([
    "0x71",
    toRlp(serializedTransaction)
  ]);
}

// node_modules/viem/_esm/zksync/utils/getEip712Domain.js
init_toHex();

// node_modules/viem/_esm/zksync/utils/hashBytecode.js
init_pad();
init_toBytes();

// node_modules/viem/_esm/zksync/errors/bytecode.js
init_base();
var BytecodeLengthExceedsMaxSizeError = class extends BaseError {
  constructor({ givenLength, maxBytecodeSize: maxBytecodeSize2 }) {
    super(`Bytecode cannot be longer than ${maxBytecodeSize2} bytes. Given length: ${givenLength}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
};
var BytecodeLengthInWordsMustBeOddError = class extends BaseError {
  constructor({ givenLengthInWords }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
};
var BytecodeLengthMustBeDivisibleBy32Error = class extends BaseError {
  constructor({ givenLength }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
};

// node_modules/viem/_esm/zksync/utils/hashBytecode.js
function hashBytecode(bytecode) {
  const bytecodeBytes = toBytes(bytecode);
  if (bytecodeBytes.length % 32 !== 0)
    throw new BytecodeLengthMustBeDivisibleBy32Error({
      givenLength: bytecodeBytes.length
    });
  if (bytecodeBytes.length > maxBytecodeSize)
    throw new BytecodeLengthExceedsMaxSizeError({
      givenLength: bytecodeBytes.length,
      maxBytecodeSize
    });
  const hashStr = sha2562(bytecodeBytes);
  const hash = toBytes(hashStr);
  const bytecodeLengthInWords = bytecodeBytes.length / 32;
  if (bytecodeLengthInWords % 2 === 0) {
    throw new BytecodeLengthInWordsMustBeOddError({
      givenLengthInWords: bytecodeLengthInWords
    });
  }
  const bytecodeLength = toBytes(bytecodeLengthInWords);
  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 });
  const codeHashVersion = new Uint8Array([1, 0]);
  hash.set(codeHashVersion, 0);
  hash.set(bytecodeLengthPadded, 2);
  return hash;
}

// node_modules/viem/_esm/zksync/utils/getEip712Domain.js
var getEip712Domain = (transaction) => {
  assertEip712Transaction(transaction);
  const message = transactionToMessage(transaction);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: transaction.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message
  };
};
function transactionToMessage(transaction) {
  const { gas, nonce, to: to2, from, value, maxFeePerGas, maxPriorityFeePerGas, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  return {
    txType: 113n,
    from: BigInt(from),
    to: to2 ? BigInt(to2) : 0n,
    gasLimit: gas ?? 0n,
    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,
    maxFeePerGas: maxFeePerGas ?? 0n,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
    paymaster: paymaster ? BigInt(paymaster) : 0n,
    nonce: nonce ? BigInt(nonce) : 0n,
    value: value ?? 0n,
    data: data ? data : "0x0",
    factoryDeps: factoryDeps?.map((dep) => toHex(hashBytecode(dep))) ?? [],
    paymasterInput: paymasterInput ? paymasterInput : "0x"
  };
}

// node_modules/viem/_esm/zksync/chainConfig.js
var chainConfig = {
  formatters,
  serializers,
  custom: {
    getEip712Domain
  }
};

// node_modules/viem/_esm/op-stack/contracts.js
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};

// node_modules/viem/_esm/op-stack/formatters.js
init_fromHex();
var formatters2 = {
  block: /* @__PURE__ */ defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: /* @__PURE__ */ defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// node_modules/viem/_esm/op-stack/serializers.js
init_address();
init_isAddress();
init_concat();
init_toHex();
function serializeTransaction3(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers2 = {
  transaction: serializeTransaction3
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from, gas, isSystemTx, mint, to: to2, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from,
    to2 ?? "0x",
    mint ? toHex(mint) : "0x",
    value ? toHex(value) : "0x",
    gas ? toHex(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from, to: to2 } = transaction;
  if (from && !isAddress(from))
    throw new InvalidAddressError({ address: from });
  if (to2 && !isAddress(to2))
    throw new InvalidAddressError({ address: to2 });
}

// node_modules/viem/_esm/op-stack/chainConfig.js
var chainConfig2 = {
  contracts,
  formatters: formatters2,
  serializers: serializers2
};

// node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = /* @__PURE__ */ defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = /* @__PURE__ */ defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = /* @__PURE__ */ defineChain({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});

// node_modules/viem/_esm/chains/definitions/avalancheFuji.js
var avalancheFuji = /* @__PURE__ */ defineChain({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/base.js
var sourceId = 1;
var base = /* @__PURE__ */ defineChain({
  ...chainConfig2,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId
});

// node_modules/viem/_esm/chains/definitions/baseSepolia.js
var sourceId2 = 11155111;
var baseSepolia = /* @__PURE__ */ defineChain({
  ...chainConfig2,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId2]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId2
});

// node_modules/viem/_esm/chains/definitions/bsc.js
var bsc = /* @__PURE__ */ defineChain({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/bsc"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
});

// node_modules/viem/_esm/celo/fees.js
var fees = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (params) => {
    if (!params.request?.feeCurrency)
      return null;
    const [gasPrice, maxPriorityFeePerGas, cel2] = await Promise.all([
      estimateFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),
      estimateMaxPriorityFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),
      isCel2(params.client)
    ]);
    const maxFeePerGas = cel2 ? (
      // eth_gasPrice for cel2 returns baseFeePerGas + maxPriorityFeePerGas
      params.multiply(gasPrice - maxPriorityFeePerGas) + maxPriorityFeePerGas
    ) : (
      // eth_gasPrice for Celo L1 returns (baseFeePerGas * multiplier), where the multiplier is 2 by default.
      gasPrice + maxPriorityFeePerGas
    );
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
};
async function estimateFeePerGasInFeeCurrency(client, feeCurrency) {
  const fee = await client.request({
    method: "eth_gasPrice",
    params: [feeCurrency]
  });
  return BigInt(fee);
}
async function estimateMaxPriorityFeePerGasInFeeCurrency(client, feeCurrency) {
  const feesPerGas = await client.request({
    method: "eth_maxPriorityFeePerGas",
    params: [feeCurrency]
  });
  return BigInt(feesPerGas);
}
async function isCel2(client) {
  const proxyAdminAddress = "0x4200000000000000000000000000000000000018";
  const code = await getCode(client, { address: proxyAdminAddress });
  return Boolean(code);
}

// node_modules/viem/_esm/celo/formatters.js
init_fromHex();
init_transactionRequest();

// node_modules/viem/_esm/celo/utils.js
init_trim();
function isEmpty(value) {
  return value === 0 || value === 0n || value === void 0 || value === null || value === "0" || value === "" || typeof value === "string" && (trim(value).toLowerCase() === "0x" || trim(value).toLowerCase() === "0x00");
}
function isPresent(value) {
  return !isEmpty(value);
}
function isEIP1559(transaction) {
  return typeof transaction.maxFeePerGas !== "undefined" && typeof transaction.maxPriorityFeePerGas !== "undefined";
}
function isCIP64(transaction) {
  if (transaction.type === "cip64") {
    return true;
  }
  return isEIP1559(transaction) && isPresent(transaction.feeCurrency);
}

// node_modules/viem/_esm/celo/formatters.js
var formatters3 = {
  block: /* @__PURE__ */ defineBlock({
    format(args) {
      const transactions = args.transactions?.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        return {
          ...formatted,
          ...transaction.gatewayFee ? {
            gatewayFee: hexToBigInt(transaction.gatewayFee),
            gatewayFeeRecipient: transaction.gatewayFeeRecipient
          } : {},
          feeCurrency: transaction.feeCurrency
        };
      });
      return {
        transactions,
        ...args.randomness ? { randomness: args.randomness } : {}
      };
    }
  }),
  transaction: /* @__PURE__ */ defineTransaction({
    format(args) {
      if (args.type === "0x7e")
        return {
          isSystemTx: args.isSystemTx,
          mint: args.mint ? hexToBigInt(args.mint) : void 0,
          sourceHash: args.sourceHash,
          type: "deposit"
        };
      const transaction = { feeCurrency: args.feeCurrency };
      if (args.type === "0x7b")
        transaction.type = "cip64";
      else {
        if (args.type === "0x7c")
          transaction.type = "cip42";
        transaction.gatewayFee = args.gatewayFee ? hexToBigInt(args.gatewayFee) : null;
        transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
      }
      return transaction;
    }
  }),
  transactionRequest: /* @__PURE__ */ defineTransactionRequest({
    format(args) {
      const request = {};
      if (args.feeCurrency)
        request.feeCurrency = args.feeCurrency;
      if (isCIP64(args))
        request.type = "0x7b";
      return request;
    }
  })
};

// node_modules/viem/_esm/celo/serializers.js
init_number();
init_address();
init_base();
init_chain();
init_node();
init_isAddress();
init_concat();
init_toHex();
function serializeTransaction4(transaction, signature) {
  if (isCIP64(transaction))
    return serializeTransactionCIP64(transaction, signature);
  return serializeTransaction3(transaction, signature);
}
var serializers3 = {
  transaction: serializeTransaction4
};
function serializeTransactionCIP64(transaction, signature) {
  assertTransactionCIP64(transaction);
  const { chainId, gas, nonce, to: to2, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to2 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializeAccessList(accessList),
    feeCurrency,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x7b",
    toRlp(serializedTransaction)
  ]);
}
var MAX_MAX_FEE_PER_GAS = maxUint256;
function assertTransactionCIP64(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to2, feeCurrency } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to2 && !isAddress(to2))
    throw new InvalidAddressError({ address: to2 });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  }
  if (isEmpty(feeCurrency)) {
    throw new BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
  }
}

// node_modules/viem/_esm/celo/chainConfig.js
var chainConfig3 = {
  contracts,
  formatters: formatters3,
  serializers: serializers3,
  fees
};

// node_modules/viem/_esm/chains/definitions/celo.js
var celo = /* @__PURE__ */ defineChain({
  ...chainConfig3,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/fantom.js
var fantom = /* @__PURE__ */ defineChain({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/fantom"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantomTestnet.js
var fantomTestnet = /* @__PURE__ */ defineChain({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/gnosis.js
var gnosis = /* @__PURE__ */ defineChain({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
});

// node_modules/viem/_esm/chains/definitions/harmonyOne.js
var harmonyOne = /* @__PURE__ */ defineChain({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.ankr.com/harmony"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
});

// node_modules/viem/_esm/linea/actions/estimateGas.js
init_parseAccount();
init_toHex();
init_getCallError();
init_extract();
init_transactionRequest();
init_assertRequest();
async function estimateGas(client, args) {
  const { account: account_ = client.account } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to2, value, ...rest } = args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = client.chain?.formatters?.transactionRequest?.format;
    const format = chainFormat || formatTransactionRequest;
    const request = format({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account?.address,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: to2,
      value
    });
    const { baseFeePerGas, gasLimit, priorityFeePerGas } = await client.request({
      method: "linea_estimateGas",
      params: block ? [request, block] : [request]
    });
    return {
      baseFeePerGas: BigInt(baseFeePerGas),
      gasLimit: BigInt(gasLimit),
      priorityFeePerGas: BigInt(priorityFeePerGas)
    };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/linea/chainConfig.js
var chainConfig4 = {
  fees: {
    estimateFeesPerGas,
    async maxPriorityFeePerGas({ block, client, request }) {
      const response = await estimateFeesPerGas({
        block,
        client,
        multiply: (x2) => x2,
        request,
        type: "eip1559"
      });
      if (!response?.maxPriorityFeePerGas)
        return null;
      return response.maxPriorityFeePerGas;
    }
  }
};
async function estimateFeesPerGas({ client, multiply, request, type }) {
  try {
    const response = await estimateGas(client, {
      ...request,
      account: request?.account
    });
    const { priorityFeePerGas: maxPriorityFeePerGas } = response;
    const baseFeePerGas = multiply(BigInt(response.baseFeePerGas));
    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas;
    if (type === "legacy")
      return { gasPrice: maxFeePerGas };
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/chains/definitions/linea.js
var linea = /* @__PURE__ */ defineChain({
  ...chainConfig4,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = /* @__PURE__ */ defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantle.js
var mantle = /* @__PURE__ */ defineChain({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metis.js
var metis = /* @__PURE__ */ defineChain({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "wss://metis-rpc.publicnode.com",
        "https://andromeda.metis.io/?owner=1088",
        "wss://metis.drpc.org",
        "https://metis-mainnet.public.blastapi.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/optimism.js
var sourceId3 = 1;
var optimism = /* @__PURE__ */ defineChain({
  ...chainConfig2,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId3]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId3]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId3]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId3]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId3
});

// node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var sourceId4 = 11155111;
var optimismSepolia = /* @__PURE__ */ defineChain({
  ...chainConfig2,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId4]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId4]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId4]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId4]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId4
});

// node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = /* @__PURE__ */ defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonAmoy.js
var polygonAmoy = /* @__PURE__ */ defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvm.js
var polygonZkEvm = /* @__PURE__ */ defineChain({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
});

// node_modules/viem/_esm/chains/definitions/scroll.js
var scroll = /* @__PURE__ */ defineChain({
  id: 534352,
  name: "Scroll",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/scrollSepolia.js
var scrollSepolia = /* @__PURE__ */ defineChain({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = /* @__PURE__ */ defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sonic.js
var sonic = /* @__PURE__ */ defineChain({
  id: 146,
  name: "Sonic",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zksync.js
var zksync = /* @__PURE__ */ defineChain({
  ...chainConfig,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
});

// node_modules/prettier/standalone.mjs
var Au = Object.create;
var At = Object.defineProperty;
var vu = Object.getOwnPropertyDescriptor;
var Bu = Object.getOwnPropertyNames;
var wu = Object.getPrototypeOf;
var _u = Object.prototype.hasOwnProperty;
var dr = (e) => {
  throw TypeError(e);
};
var pr = (e, t) => () => (t || e((t = { exports: {} }).exports, t), t.exports);
var vt = (e, t) => {
  for (var r in t) At(e, r, { get: t[r], enumerable: true });
};
var xu = (e, t, r, n) => {
  if (t && typeof t == "object" || typeof t == "function") for (let u of Bu(t)) !_u.call(e, u) && u !== r && At(e, u, { get: () => t[u], enumerable: !(n = vu(t, u)) || n.enumerable });
  return e;
};
var Me = (e, t, r) => (r = e != null ? Au(wu(e)) : {}, xu(At(r, "default", { value: e, enumerable: true }) , e));
var bu = (e, t, r) => t.has(e) || dr("Cannot " + r);
var Fr = (e, t, r) => t.has(e) ? dr("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, r);
var pe = (e, t, r) => (bu(e, t, "access private method"), r);
var ot = pr((Da, mn) => {
  var Fn = new Proxy(String, { get: () => Fn });
  mn.exports = Fn;
});
var $n = pr((ur) => {
  Object.defineProperty(ur, "__esModule", { value: true });
  function wi() {
    return new Proxy({}, { get: () => (e) => e });
  }
  var Wn = /\r\n|[\n\r\u2028\u2029]/;
  function _i(e, t, r) {
    let n = Object.assign({ column: 0, line: -1 }, e.start), u = Object.assign({}, n, e.end), { linesAbove: i = 2, linesBelow: o = 3 } = r || {}, s = n.line, a = n.column, D = u.line, l = u.column, p = Math.max(s - (i + 1), 0), f = Math.min(t.length, D + o);
    s === -1 && (p = 0), D === -1 && (f = t.length);
    let d = D - s, c = {};
    if (d) for (let F = 0; F <= d; F++) {
      let m = F + s;
      if (!a) c[m] = true;
      else if (F === 0) {
        let h = t[m - 1].length;
        c[m] = [a, h - a + 1];
      } else if (F === d) c[m] = [0, l];
      else {
        let h = t[m - F].length;
        c[m] = [0, h];
      }
    }
    else a === l ? a ? c[s] = [a, 0] : c[s] = true : c[s] = [a, l - a];
    return { start: p, end: f, markerLines: c };
  }
  function xi(e, t, r = {}) {
    let u = wi(), i = e.split(Wn), { start: o, end: s, markerLines: a } = _i(t, i, r), D = t.start && typeof t.start.column == "number", l = String(s).length, f = e.split(Wn, s).slice(o, s).map((d, c) => {
      let F = o + 1 + c, h = ` ${` ${F}`.slice(-l)} |`, C = a[F], v = !a[F + 1];
      if (C) {
        let E = "";
        if (Array.isArray(C)) {
          let g = d.slice(0, Math.max(C[0] - 1, 0)).replace(/[^\t]/g, " "), j = C[1] || 1;
          E = [`
 `, u.gutter(h.replace(/\d/g, " ")), " ", g, u.marker("^").repeat(j)].join(""), v && r.message && (E += " " + u.message(r.message));
        }
        return [u.marker(">"), u.gutter(h), d.length > 0 ? ` ${d}` : "", E].join("");
      } else return ` ${u.gutter(h)}${d.length > 0 ? ` ${d}` : ""}`;
    }).join(`
`);
    return r.message && !D && (f = `${" ".repeat(l + 1)}${r.message}
${f}`), f;
  }
  ur.codeFrameColumns = xi;
});
var fr = {};
vt(fr, { __debug: () => lo, check: () => ao, doc: () => Dr, format: () => yu, formatWithCursor: () => gu, getSupportInfo: () => Do, util: () => cr, version: () => cu });
var Nu = (e, t, r, n) => {
  if (!(e && t == null)) return t.replaceAll ? t.replaceAll(r, n) : r.global ? t.replace(r, n) : t.split(r).join(n);
};
var ne = Nu;
function U() {
}
U.prototype = { diff: function(t, r) {
  var n, u = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = u.callback;
  typeof u == "function" && (i = u, u = {});
  var o = this;
  function s(E) {
    return E = o.postProcess(E, u), i ? (setTimeout(function() {
      i(E);
    }, 0), true) : E;
  }
  t = this.castInput(t, u), r = this.castInput(r, u), t = this.removeEmpty(this.tokenize(t, u)), r = this.removeEmpty(this.tokenize(r, u));
  var a = r.length, D = t.length, l = 1, p = a + D;
  u.maxEditLength != null && (p = Math.min(p, u.maxEditLength));
  var f = (n = u.timeout) !== null && n !== void 0 ? n : 1 / 0, d = Date.now() + f, c = [{ oldPos: -1, lastComponent: void 0 }], F = this.extractCommon(c[0], r, t, 0, u);
  if (c[0].oldPos + 1 >= D && F + 1 >= a) return s(mr(o, c[0].lastComponent, r, t, o.useLongestToken));
  var m = -1 / 0, h = 1 / 0;
  function C() {
    for (var E = Math.max(m, -l); E <= Math.min(h, l); E += 2) {
      var g = void 0, j = c[E - 1], b = c[E + 1];
      j && (c[E - 1] = void 0);
      var X = false;
      if (b) {
        var ae = b.oldPos - E;
        X = b && 0 <= ae && ae < a;
      }
      var $e = j && j.oldPos + 1 < D;
      if (!X && !$e) {
        c[E] = void 0;
        continue;
      }
      if (!$e || X && j.oldPos < b.oldPos ? g = o.addToPath(b, true, false, 0, u) : g = o.addToPath(j, false, true, 1, u), F = o.extractCommon(g, r, t, E, u), g.oldPos + 1 >= D && F + 1 >= a) return s(mr(o, g.lastComponent, r, t, o.useLongestToken));
      c[E] = g, g.oldPos + 1 >= D && (h = Math.min(h, E - 1)), F + 1 >= a && (m = Math.max(m, E + 1));
    }
    l++;
  }
  if (i) (function E() {
    setTimeout(function() {
      if (l > p || Date.now() > d) return i();
      C() || E();
    }, 0);
  })();
  else for (; l <= p && Date.now() <= d; ) {
    var v = C();
    if (v) return v;
  }
}, addToPath: function(t, r, n, u, i) {
  var o = t.lastComponent;
  return o && !i.oneChangePerToken && o.added === r && o.removed === n ? { oldPos: t.oldPos + u, lastComponent: { count: o.count + 1, added: r, removed: n, previousComponent: o.previousComponent } } : { oldPos: t.oldPos + u, lastComponent: { count: 1, added: r, removed: n, previousComponent: o } };
}, extractCommon: function(t, r, n, u, i) {
  for (var o = r.length, s = n.length, a = t.oldPos, D = a - u, l = 0; D + 1 < o && a + 1 < s && this.equals(n[a + 1], r[D + 1], i); ) D++, a++, l++, i.oneChangePerToken && (t.lastComponent = { count: 1, previousComponent: t.lastComponent, added: false, removed: false });
  return l && !i.oneChangePerToken && (t.lastComponent = { count: l, previousComponent: t.lastComponent, added: false, removed: false }), t.oldPos = a, D;
}, equals: function(t, r, n) {
  return n.comparator ? n.comparator(t, r) : t === r || n.ignoreCase && t.toLowerCase() === r.toLowerCase();
}, removeEmpty: function(t) {
  for (var r = [], n = 0; n < t.length; n++) t[n] && r.push(t[n]);
  return r;
}, castInput: function(t) {
  return t;
}, tokenize: function(t) {
  return Array.from(t);
}, join: function(t) {
  return t.join("");
}, postProcess: function(t) {
  return t;
} };
function mr(e, t, r, n, u) {
  for (var i = [], o; t; ) i.push(t), o = t.previousComponent, delete t.previousComponent, t = o;
  i.reverse();
  for (var s = 0, a = i.length, D = 0, l = 0; s < a; s++) {
    var p = i[s];
    if (p.removed) p.value = e.join(n.slice(l, l + p.count)), l += p.count;
    else {
      if (!p.added && u) {
        var f = r.slice(D, D + p.count);
        f = f.map(function(d, c) {
          var F = n[l + c];
          return F.length > d.length ? F : d;
        }), p.value = e.join(f);
      } else p.value = e.join(r.slice(D, D + p.count));
      D += p.count, p.added || (l += p.count);
    }
  }
  return i;
}
function hr(e, t) {
  var r;
  for (r = 0; r < e.length && r < t.length; r++) if (e[r] != t[r]) return e.slice(0, r);
  return e.slice(0, r);
}
function Er(e, t) {
  var r;
  if (!e || !t || e[e.length - 1] != t[t.length - 1]) return "";
  for (r = 0; r < e.length && r < t.length; r++) if (e[e.length - (r + 1)] != t[t.length - (r + 1)]) return e.slice(-r);
  return e.slice(-r);
}
function Bt(e, t, r) {
  if (e.slice(0, t.length) != t) throw Error("string ".concat(JSON.stringify(e), " doesn't start with prefix ").concat(JSON.stringify(t), "; this is a bug"));
  return r + e.slice(t.length);
}
function wt(e, t, r) {
  if (!t) return e + r;
  if (e.slice(-t.length) != t) throw Error("string ".concat(JSON.stringify(e), " doesn't end with suffix ").concat(JSON.stringify(t), "; this is a bug"));
  return e.slice(0, -t.length) + r;
}
function _e(e, t) {
  return Bt(e, t, "");
}
function Ve(e, t) {
  return wt(e, t, "");
}
function Cr(e, t) {
  return t.slice(0, Ou(e, t));
}
function Ou(e, t) {
  var r = 0;
  e.length > t.length && (r = e.length - t.length);
  var n = t.length;
  e.length < t.length && (n = e.length);
  var u = Array(n), i = 0;
  u[0] = 0;
  for (var o = 1; o < n; o++) {
    for (t[o] == t[i] ? u[o] = u[i] : u[o] = i; i > 0 && t[o] != t[i]; ) i = u[i];
    t[o] == t[i] && i++;
  }
  i = 0;
  for (var s = r; s < e.length; s++) {
    for (; i > 0 && e[s] != t[i]; ) i = u[i];
    e[s] == t[i] && i++;
  }
  return i;
}
var Ue = "a-zA-Z0-9_\\u{C0}-\\u{FF}\\u{D8}-\\u{F6}\\u{F8}-\\u{2C6}\\u{2C8}-\\u{2D7}\\u{2DE}-\\u{2FF}\\u{1E00}-\\u{1EFF}";
var Su = new RegExp("[".concat(Ue, "]+|\\s+|[^").concat(Ue, "]"), "ug");
var Ge = new U();
Ge.equals = function(e, t, r) {
  return r.ignoreCase && (e = e.toLowerCase(), t = t.toLowerCase()), e.trim() === t.trim();
};
Ge.tokenize = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r;
  if (t.intlSegmenter) {
    if (t.intlSegmenter.resolvedOptions().granularity != "word") throw new Error('The segmenter passed must have a granularity of "word"');
    r = Array.from(t.intlSegmenter.segment(e), function(i) {
      return i.segment;
    });
  } else r = e.match(Su) || [];
  var n = [], u = null;
  return r.forEach(function(i) {
    /\s/.test(i) ? u == null ? n.push(i) : n.push(n.pop() + i) : /\s/.test(u) ? n[n.length - 1] == u ? n.push(n.pop() + i) : n.push(u + i) : n.push(i), u = i;
  }), n;
};
Ge.join = function(e) {
  return e.map(function(t, r) {
    return r == 0 ? t : t.replace(/^\s+/, "");
  }).join("");
};
Ge.postProcess = function(e, t) {
  if (!e || t.oneChangePerToken) return e;
  var r = null, n = null, u = null;
  return e.forEach(function(i) {
    i.added ? n = i : i.removed ? u = i : ((n || u) && gr(r, u, n, i), r = i, n = null, u = null);
  }), (n || u) && gr(r, u, n, null), e;
};
function gr(e, t, r, n) {
  if (t && r) {
    var u = t.value.match(/^\s*/)[0], i = t.value.match(/\s*$/)[0], o = r.value.match(/^\s*/)[0], s = r.value.match(/\s*$/)[0];
    if (e) {
      var a = hr(u, o);
      e.value = wt(e.value, o, a), t.value = _e(t.value, a), r.value = _e(r.value, a);
    }
    if (n) {
      var D = Er(i, s);
      n.value = Bt(n.value, s, D), t.value = Ve(t.value, D), r.value = Ve(r.value, D);
    }
  } else if (r) e && (r.value = r.value.replace(/^\s*/, "")), n && (n.value = n.value.replace(/^\s*/, ""));
  else if (e && n) {
    var l = n.value.match(/^\s*/)[0], p = t.value.match(/^\s*/)[0], f = t.value.match(/\s*$/)[0], d = hr(l, p);
    t.value = _e(t.value, d);
    var c = Er(_e(l, d), f);
    t.value = Ve(t.value, c), n.value = Bt(n.value, l, c), e.value = wt(e.value, l, l.slice(0, l.length - c.length));
  } else if (n) {
    var F = n.value.match(/^\s*/)[0], m = t.value.match(/\s*$/)[0], h = Cr(m, F);
    t.value = Ve(t.value, h);
  } else if (e) {
    var C = e.value.match(/\s*$/)[0], v = t.value.match(/^\s*/)[0], E = Cr(C, v);
    t.value = _e(t.value, E);
  }
}
var Tu = new U();
Tu.tokenize = function(e) {
  var t = new RegExp("(\\r?\\n)|[".concat(Ue, "]+|[^\\S\\n\\r]+|[^").concat(Ue, "]"), "ug");
  return e.match(t) || [];
};
var bt = new U();
bt.tokenize = function(e, t) {
  t.stripTrailingCr && (e = e.replace(/\r\n/g, `
`));
  var r = [], n = e.split(/(\n|\r\n)/);
  n[n.length - 1] || n.pop();
  for (var u = 0; u < n.length; u++) {
    var i = n[u];
    u % 2 && !t.newlineIsToken ? r[r.length - 1] += i : r.push(i);
  }
  return r;
};
bt.equals = function(e, t, r) {
  return r.ignoreWhitespace ? ((!r.newlineIsToken || !e.includes(`
`)) && (e = e.trim()), (!r.newlineIsToken || !t.includes(`
`)) && (t = t.trim())) : r.ignoreNewlineAtEof && !r.newlineIsToken && (e.endsWith(`
`) && (e = e.slice(0, -1)), t.endsWith(`
`) && (t = t.slice(0, -1))), U.prototype.equals.call(this, e, t, r);
};
var ku = new U();
ku.tokenize = function(e) {
  return e.split(/(\S.+?[.!?])(?=\s+|$)/);
};
var Lu = new U();
Lu.tokenize = function(e) {
  return e.split(/([{}:;,]|\s+)/);
};
function _t(e) {
  "@babel/helpers - typeof";
  return _t = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _t(e);
}
var xe = new U();
xe.useLongestToken = true;
xe.tokenize = bt.tokenize;
xe.castInput = function(e, t) {
  var r = t.undefinedReplacement, n = t.stringifyReplacer, u = n === void 0 ? function(i, o) {
    return typeof o > "u" ? r : o;
  } : n;
  return typeof e == "string" ? e : JSON.stringify(xt(e, null, null, u), u, "  ");
};
xe.equals = function(e, t, r) {
  return U.prototype.equals.call(xe, e.replace(/,([\r\n])/g, "$1"), t.replace(/,([\r\n])/g, "$1"), r);
};
function xt(e, t, r, n, u) {
  t = t || [], r = r || [], n && (e = n(u, e));
  var i;
  for (i = 0; i < t.length; i += 1) if (t[i] === e) return r[i];
  var o;
  if (Object.prototype.toString.call(e) === "[object Array]") {
    for (t.push(e), o = new Array(e.length), r.push(o), i = 0; i < e.length; i += 1) o[i] = xt(e[i], t, r, n, u);
    return t.pop(), r.pop(), o;
  }
  if (e && e.toJSON && (e = e.toJSON()), _t(e) === "object" && e !== null) {
    t.push(e), o = {}, r.push(o);
    var s = [], a;
    for (a in e) Object.prototype.hasOwnProperty.call(e, a) && s.push(a);
    for (s.sort(), i = 0; i < s.length; i += 1) a = s[i], o[a] = xt(e[a], t, r, n, a);
    t.pop(), r.pop();
  } else o = e;
  return o;
}
var ze = new U();
ze.tokenize = function(e) {
  return e.slice();
};
ze.join = ze.removeEmpty = function(e) {
  return e;
};
function yr(e, t, r) {
  return ze.diff(e, t, r);
}
function Ar(e) {
  let t = e.indexOf("\r");
  return t !== -1 ? e.charAt(t + 1) === `
` ? "crlf" : "cr" : "lf";
}
function be(e) {
  switch (e) {
    case "cr":
      return "\r";
    case "crlf":
      return `\r
`;
    default:
      return `
`;
  }
}
function Nt(e, t) {
  let r;
  switch (t) {
    case `
`:
      r = /\n/gu;
      break;
    case "\r":
      r = /\r/gu;
      break;
    case `\r
`:
      r = /\r\n/gu;
      break;
    default:
      throw new Error(`Unexpected "eol" ${JSON.stringify(t)}.`);
  }
  let n = e.match(r);
  return n ? n.length : 0;
}
function vr(e) {
  return ne(false, e, /\r\n?/gu, `
`);
}
var $ = "string";
var H = "array";
var z = "cursor";
var T = "indent";
var k = "align";
var L = "trim";
var B = "group";
var N = "fill";
var w = "if-break";
var P = "indent-if-break";
var I = "line-suffix";
var R = "line-suffix-boundary";
var y = "line";
var O = "label";
var _ = "break-parent";
var Ke = /* @__PURE__ */ new Set([z, T, k, L, B, N, w, P, I, R, y, O, _]);
var Pu = (e, t, r) => {
  if (!(e && t == null)) return Array.isArray(t) || typeof t == "string" ? t[r < 0 ? t.length + r : r] : t.at(r);
};
var A = Pu;
function Iu(e) {
  if (typeof e == "string") return $;
  if (Array.isArray(e)) return H;
  if (!e) return;
  let { type: t } = e;
  if (Ke.has(t)) return t;
}
var M = Iu;
var Ru = (e) => new Intl.ListFormat("en-US", { type: "disjunction" }).format(e);
function Yu(e) {
  let t = e === null ? "null" : typeof e;
  if (t !== "string" && t !== "object") return `Unexpected doc '${t}', 
Expected it to be 'string' or 'object'.`;
  if (M(e)) throw new Error("doc is valid.");
  let r = Object.prototype.toString.call(e);
  if (r !== "[object Object]") return `Unexpected doc '${r}'.`;
  let n = Ru([...Ke].map((u) => `'${u}'`));
  return `Unexpected doc.type '${e.type}'.
Expected it to be ${n}.`;
}
var Ot = class extends Error {
  constructor(t) {
    super(Yu(t));
    __publicField(this, "name", "InvalidDocError");
    this.doc = t;
  }
};
var Q = Ot;
var Br = {};
function ju(e, t, r, n) {
  let u = [e];
  for (; u.length > 0; ) {
    let i = u.pop();
    if (i === Br) {
      r(u.pop());
      continue;
    }
    r && u.push(i, Br);
    let o = M(i);
    if (!o) throw new Q(i);
    if ((t == null ? void 0 : t(i)) !== false) switch (o) {
      case H:
      case N: {
        let s = o === H ? i : i.parts;
        for (let a = s.length, D = a - 1; D >= 0; --D) u.push(s[D]);
        break;
      }
      case w:
        u.push(i.flatContents, i.breakContents);
        break;
      case B:
        if (n && i.expandedStates) for (let s = i.expandedStates.length, a = s - 1; a >= 0; --a) u.push(i.expandedStates[a]);
        else u.push(i.contents);
        break;
      case k:
      case T:
      case P:
      case O:
      case I:
        u.push(i.contents);
        break;
      case $:
      case z:
      case L:
      case R:
      case y:
      case _:
        break;
      default:
        throw new Q(i);
    }
  }
}
var Fe = ju;
function Oe(e, t) {
  if (typeof e == "string") return t(e);
  let r = /* @__PURE__ */ new Map();
  return n(e);
  function n(i) {
    if (r.has(i)) return r.get(i);
    let o = u(i);
    return r.set(i, o), o;
  }
  function u(i) {
    switch (M(i)) {
      case H:
        return t(i.map(n));
      case N:
        return t({ ...i, parts: i.parts.map(n) });
      case w:
        return t({ ...i, breakContents: n(i.breakContents), flatContents: n(i.flatContents) });
      case B: {
        let { expandedStates: o, contents: s } = i;
        return o ? (o = o.map(n), s = o[0]) : s = n(s), t({ ...i, contents: s, expandedStates: o });
      }
      case k:
      case T:
      case P:
      case O:
      case I:
        return t({ ...i, contents: n(i.contents) });
      case $:
      case z:
      case L:
      case R:
      case y:
      case _:
        return t(i);
      default:
        throw new Q(i);
    }
  }
}
function Je(e, t, r) {
  let n = r, u = false;
  function i(o) {
    if (u) return false;
    let s = t(o);
    s !== void 0 && (u = true, n = s);
  }
  return Fe(e, i), n;
}
function Hu(e) {
  if (e.type === B && e.break || e.type === y && e.hard || e.type === _) return true;
}
function xr(e) {
  return Je(e, Hu, false);
}
function wr(e) {
  if (e.length > 0) {
    let t = A(false, e, -1);
    !t.expandedStates && !t.break && (t.break = "propagated");
  }
  return null;
}
function br(e) {
  let t = /* @__PURE__ */ new Set(), r = [];
  function n(i) {
    if (i.type === _ && wr(r), i.type === B) {
      if (r.push(i), t.has(i)) return false;
      t.add(i);
    }
  }
  function u(i) {
    i.type === B && r.pop().break && wr(r);
  }
  Fe(e, n, u, true);
}
function Wu(e) {
  return e.type === y && !e.hard ? e.soft ? "" : " " : e.type === w ? e.flatContents : e;
}
function Nr(e) {
  return Oe(e, Wu);
}
function _r(e) {
  for (e = [...e]; e.length >= 2 && A(false, e, -2).type === y && A(false, e, -1).type === _; ) e.length -= 2;
  if (e.length > 0) {
    let t = Ne(A(false, e, -1));
    e[e.length - 1] = t;
  }
  return e;
}
function Ne(e) {
  switch (M(e)) {
    case T:
    case P:
    case B:
    case I:
    case O: {
      let t = Ne(e.contents);
      return { ...e, contents: t };
    }
    case w:
      return { ...e, breakContents: Ne(e.breakContents), flatContents: Ne(e.flatContents) };
    case N:
      return { ...e, parts: _r(e.parts) };
    case H:
      return _r(e);
    case $:
      return e.replace(/[\n\r]*$/u, "");
    case k:
    case z:
    case L:
    case R:
    case y:
    case _:
      break;
    default:
      throw new Q(e);
  }
  return e;
}
function qe(e) {
  return Ne(Mu(e));
}
function $u(e) {
  switch (M(e)) {
    case N:
      if (e.parts.every((t) => t === "")) return "";
      break;
    case B:
      if (!e.contents && !e.id && !e.break && !e.expandedStates) return "";
      if (e.contents.type === B && e.contents.id === e.id && e.contents.break === e.break && e.contents.expandedStates === e.expandedStates) return e.contents;
      break;
    case k:
    case T:
    case P:
    case I:
      if (!e.contents) return "";
      break;
    case w:
      if (!e.flatContents && !e.breakContents) return "";
      break;
    case H: {
      let t = [];
      for (let r of e) {
        if (!r) continue;
        let [n, ...u] = Array.isArray(r) ? r : [r];
        typeof n == "string" && typeof A(false, t, -1) == "string" ? t[t.length - 1] += n : t.push(n), t.push(...u);
      }
      return t.length === 0 ? "" : t.length === 1 ? t[0] : t;
    }
    case $:
    case z:
    case L:
    case R:
    case y:
    case O:
    case _:
      break;
    default:
      throw new Q(e);
  }
  return e;
}
function Mu(e) {
  return Oe(e, (t) => $u(t));
}
function Or(e, t = Xe) {
  return Oe(e, (r) => typeof r == "string" ? Se(t, r.split(`
`)) : r);
}
function Vu(e) {
  if (e.type === y) return true;
}
function Sr(e) {
  return Je(e, Vu, false);
}
function me(e, t) {
  return e.type === O ? { ...e, contents: t(e.contents) } : t(e);
}
var St = () => {
};
var Tt = St;
function le(e) {
  return { type: T, contents: e };
}
function De(e, t) {
  return { type: k, contents: t, n: e };
}
function kt(e, t = {}) {
  return Tt(t.expandedStates), { type: B, id: t.id, contents: e, break: !!t.shouldBreak, expandedStates: t.expandedStates };
}
function kr(e) {
  return De(Number.NEGATIVE_INFINITY, e);
}
function Lr(e) {
  return De({ type: "root" }, e);
}
function Pr(e) {
  return De(-1, e);
}
function Ir(e, t) {
  return kt(e[0], { ...t, expandedStates: e });
}
function Rr(e) {
  return { type: N, parts: e };
}
function Yr(e, t = "", r = {}) {
  return { type: w, breakContents: e, flatContents: t, groupId: r.groupId };
}
function jr(e, t) {
  return { type: P, contents: e, groupId: t.groupId, negate: t.negate };
}
function Te(e) {
  return { type: I, contents: e };
}
var Hr = { type: R };
var he = { type: _ };
var Wr = { type: L };
var ke = { type: y, hard: true };
var Lt = { type: y, hard: true, literal: true };
var Qe = { type: y };
var $r = { type: y, soft: true };
var K = [ke, he];
var Xe = [Lt, he];
var Z = { type: z };
function Se(e, t) {
  let r = [];
  for (let n = 0; n < t.length; n++) n !== 0 && r.push(e), r.push(t[n]);
  return r;
}
function Ze(e, t, r) {
  let n = e;
  if (t > 0) {
    for (let u = 0; u < Math.floor(t / r); ++u) n = le(n);
    n = De(t % r, n), n = De(Number.NEGATIVE_INFINITY, n);
  }
  return n;
}
function Mr(e, t) {
  return e ? { type: O, label: e, contents: t } : t;
}
function ee(e) {
  var t;
  if (!e) return "";
  if (Array.isArray(e)) {
    let r = [];
    for (let n of e) if (Array.isArray(n)) r.push(...ee(n));
    else {
      let u = ee(n);
      u !== "" && r.push(u);
    }
    return r;
  }
  return e.type === w ? { ...e, breakContents: ee(e.breakContents), flatContents: ee(e.flatContents) } : e.type === B ? { ...e, contents: ee(e.contents), expandedStates: (t = e.expandedStates) == null ? void 0 : t.map(ee) } : e.type === N ? { type: "fill", parts: e.parts.map(ee) } : e.contents ? { ...e, contents: ee(e.contents) } : e;
}
function Vr(e) {
  let t = /* @__PURE__ */ Object.create(null), r = /* @__PURE__ */ new Set();
  return n(ee(e));
  function n(i, o, s) {
    var a, D;
    if (typeof i == "string") return JSON.stringify(i);
    if (Array.isArray(i)) {
      let l = i.map(n).filter(Boolean);
      return l.length === 1 ? l[0] : `[${l.join(", ")}]`;
    }
    if (i.type === y) {
      let l = ((a = s == null ? void 0 : s[o + 1]) == null ? void 0 : a.type) === _;
      return i.literal ? l ? "literalline" : "literallineWithoutBreakParent" : i.hard ? l ? "hardline" : "hardlineWithoutBreakParent" : i.soft ? "softline" : "line";
    }
    if (i.type === _) return ((D = s == null ? void 0 : s[o - 1]) == null ? void 0 : D.type) === y && s[o - 1].hard ? void 0 : "breakParent";
    if (i.type === L) return "trim";
    if (i.type === T) return "indent(" + n(i.contents) + ")";
    if (i.type === k) return i.n === Number.NEGATIVE_INFINITY ? "dedentToRoot(" + n(i.contents) + ")" : i.n < 0 ? "dedent(" + n(i.contents) + ")" : i.n.type === "root" ? "markAsRoot(" + n(i.contents) + ")" : "align(" + JSON.stringify(i.n) + ", " + n(i.contents) + ")";
    if (i.type === w) return "ifBreak(" + n(i.breakContents) + (i.flatContents ? ", " + n(i.flatContents) : "") + (i.groupId ? (i.flatContents ? "" : ', ""') + `, { groupId: ${u(i.groupId)} }` : "") + ")";
    if (i.type === P) {
      let l = [];
      i.negate && l.push("negate: true"), i.groupId && l.push(`groupId: ${u(i.groupId)}`);
      let p = l.length > 0 ? `, { ${l.join(", ")} }` : "";
      return `indentIfBreak(${n(i.contents)}${p})`;
    }
    if (i.type === B) {
      let l = [];
      i.break && i.break !== "propagated" && l.push("shouldBreak: true"), i.id && l.push(`id: ${u(i.id)}`);
      let p = l.length > 0 ? `, { ${l.join(", ")} }` : "";
      return i.expandedStates ? `conditionalGroup([${i.expandedStates.map((f) => n(f)).join(",")}]${p})` : `group(${n(i.contents)}${p})`;
    }
    if (i.type === N) return `fill([${i.parts.map((l) => n(l)).join(", ")}])`;
    if (i.type === I) return "lineSuffix(" + n(i.contents) + ")";
    if (i.type === R) return "lineSuffixBoundary";
    if (i.type === O) return `label(${JSON.stringify(i.label)}, ${n(i.contents)})`;
    throw new Error("Unknown doc type " + i.type);
  }
  function u(i) {
    if (typeof i != "symbol") return JSON.stringify(String(i));
    if (i in t) return t[i];
    let o = i.description || "symbol";
    for (let s = 0; ; s++) {
      let a = o + (s > 0 ? ` #${s}` : "");
      if (!r.has(a)) return r.add(a), t[i] = `Symbol.for(${JSON.stringify(a)})`;
    }
  }
}
var Ur = () => /[#*0-9]\uFE0F?\u20E3|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26AA\u26B0\u26B1\u26BD\u26BE\u26C4\u26C8\u26CF\u26D1\u26E9\u26F0-\u26F5\u26F7\u26F8\u26FA\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B55\u3030\u303D\u3297\u3299]\uFE0F?|[\u261D\u270C\u270D](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\u270A\u270B](?:\uD83C[\uDFFB-\uDFFF])?|[\u23E9-\u23EC\u23F0\u23F3\u25FD\u2693\u26A1\u26AB\u26C5\u26CE\u26D4\u26EA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2795-\u2797\u27B0\u27BF\u2B50]|\u26D3\uFE0F?(?:\u200D\uD83D\uDCA5)?|\u26F9(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\u2764\uFE0F?(?:\u200D(?:\uD83D\uDD25|\uD83E\uDE79))?|\uD83C(?:[\uDC04\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]\uFE0F?|[\uDF85\uDFC2\uDFC7](?:\uD83C[\uDFFB-\uDFFF])?|[\uDFC4\uDFCA](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDFCB\uDFCC](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF43\uDF45-\uDF4A\uDF4C-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uDDE6\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF]|\uDDE7\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF]|\uDDE8\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF7\uDDFA-\uDDFF]|\uDDE9\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF]|\uDDEA\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA]|\uDDEB\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7]|\uDDEC\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE]|\uDDED\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA]|\uDDEE\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9]|\uDDEF\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5]|\uDDF0\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF]|\uDDF1\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE]|\uDDF2\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF]|\uDDF3\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF]|\uDDF4\uD83C\uDDF2|\uDDF5\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE]|\uDDF6\uD83C\uDDE6|\uDDF7\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC]|\uDDF8\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF]|\uDDF9\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF]|\uDDFA\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF]|\uDDFB\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA]|\uDDFC\uD83C[\uDDEB\uDDF8]|\uDDFD\uD83C\uDDF0|\uDDFE\uD83C[\uDDEA\uDDF9]|\uDDFF\uD83C[\uDDE6\uDDF2\uDDFC]|\uDF44(?:\u200D\uD83D\uDFEB)?|\uDF4B(?:\u200D\uD83D\uDFE9)?|\uDFC3(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDFF3\uFE0F?(?:\u200D(?:\u26A7\uFE0F?|\uD83C\uDF08))?|\uDFF4(?:\u200D\u2620\uFE0F?|\uDB40\uDC67\uDB40\uDC62\uDB40(?:\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDC73\uDB40\uDC63\uDB40\uDC74|\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F)?)|\uD83D(?:[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3]\uFE0F?|[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC](?:\uD83C[\uDFFB-\uDFFF])?|[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4\uDEB5](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD74\uDD90](?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?|[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC25\uDC27-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE41\uDE43\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEDC-\uDEDF\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uDC08(?:\u200D\u2B1B)?|\uDC15(?:\u200D\uD83E\uDDBA)?|\uDC26(?:\u200D(?:\u2B1B|\uD83D\uDD25))?|\uDC3B(?:\u200D\u2744\uFE0F?)?|\uDC41\uFE0F?(?:\u200D\uD83D\uDDE8\uFE0F?)?|\uDC68(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDC68\uDC69]\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?)|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?\uDC68\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D\uDC68\uD83C[\uDFFB-\uDFFE])))?))?|\uDC69(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:\uDC8B\u200D\uD83D)?[\uDC68\uDC69]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D(?:[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?|\uDC69\u200D\uD83D(?:\uDC66(?:\u200D\uD83D\uDC66)?|\uDC67(?:\u200D\uD83D[\uDC66\uDC67])?))|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFC-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFD-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFD\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D\uD83D(?:[\uDC68\uDC69]|\uDC8B\u200D\uD83D[\uDC68\uDC69])\uD83C[\uDFFB-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83D[\uDC68\uDC69]\uD83C[\uDFFB-\uDFFE])))?))?|\uDC6F(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDD75(?:\uD83C[\uDFFB-\uDFFF]|\uFE0F)?(?:\u200D[\u2640\u2642]\uFE0F?)?|\uDE2E(?:\u200D\uD83D\uDCA8)?|\uDE35(?:\u200D\uD83D\uDCAB)?|\uDE36(?:\u200D\uD83C\uDF2B\uFE0F?)?|\uDE42(?:\u200D[\u2194\u2195]\uFE0F?)?|\uDEB6(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?)|\uD83E(?:[\uDD0C\uDD0F\uDD18-\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5\uDEC3-\uDEC5\uDEF0\uDEF2-\uDEF8](?:\uD83C[\uDFFB-\uDFFF])?|[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD\uDDCF\uDDD4\uDDD6-\uDDDD](?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDDDE\uDDDF](?:\u200D[\u2640\u2642]\uFE0F?)?|[\uDD0D\uDD0E\uDD10-\uDD17\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCC\uDDD0\uDDE0-\uDDFF\uDE70-\uDE7C\uDE80-\uDE89\uDE8F-\uDEC2\uDEC6\uDECE-\uDEDC\uDEDF-\uDEE9]|\uDD3C(?:\u200D[\u2640\u2642]\uFE0F?|\uD83C[\uDFFB-\uDFFF])?|\uDDCE(?:\uD83C[\uDFFB-\uDFFF])?(?:\u200D(?:[\u2640\u2642]\uFE0F?(?:\u200D\u27A1\uFE0F?)?|\u27A1\uFE0F?))?|\uDDD1(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1|\uDDD1\u200D\uD83E\uDDD2(?:\u200D\uD83E\uDDD2)?|\uDDD2(?:\u200D\uD83E\uDDD2)?))|\uD83C(?:\uDFFB(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFC-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFC(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFD-\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFD(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFE(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFD\uDFFF]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?|\uDFFF(?:\u200D(?:[\u2695\u2696\u2708]\uFE0F?|\u2764\uFE0F?\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1\uD83C[\uDFFB-\uDFFE]|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E(?:[\uDDAF\uDDBC\uDDBD](?:\u200D\u27A1\uFE0F?)?|[\uDDB0-\uDDB3]|\uDD1D\u200D\uD83E\uDDD1\uD83C[\uDFFB-\uDFFF])))?))?|\uDEF1(?:\uD83C(?:\uDFFB(?:\u200D\uD83E\uDEF2\uD83C[\uDFFC-\uDFFF])?|\uDFFC(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFD-\uDFFF])?|\uDFFD(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])?|\uDFFE(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFD\uDFFF])?|\uDFFF(?:\u200D\uD83E\uDEF2\uD83C[\uDFFB-\uDFFE])?))?)/g;
function zr(e) {
  return e === 12288 || e >= 65281 && e <= 65376 || e >= 65504 && e <= 65510;
}
function Gr(e) {
  return e >= 4352 && e <= 4447 || e === 8986 || e === 8987 || e === 9001 || e === 9002 || e >= 9193 && e <= 9196 || e === 9200 || e === 9203 || e === 9725 || e === 9726 || e === 9748 || e === 9749 || e >= 9776 && e <= 9783 || e >= 9800 && e <= 9811 || e === 9855 || e >= 9866 && e <= 9871 || e === 9875 || e === 9889 || e === 9898 || e === 9899 || e === 9917 || e === 9918 || e === 9924 || e === 9925 || e === 9934 || e === 9940 || e === 9962 || e === 9970 || e === 9971 || e === 9973 || e === 9978 || e === 9981 || e === 9989 || e === 9994 || e === 9995 || e === 10024 || e === 10060 || e === 10062 || e >= 10067 && e <= 10069 || e === 10071 || e >= 10133 && e <= 10135 || e === 10160 || e === 10175 || e === 11035 || e === 11036 || e === 11088 || e === 11093 || e >= 11904 && e <= 11929 || e >= 11931 && e <= 12019 || e >= 12032 && e <= 12245 || e >= 12272 && e <= 12287 || e >= 12289 && e <= 12350 || e >= 12353 && e <= 12438 || e >= 12441 && e <= 12543 || e >= 12549 && e <= 12591 || e >= 12593 && e <= 12686 || e >= 12688 && e <= 12773 || e >= 12783 && e <= 12830 || e >= 12832 && e <= 12871 || e >= 12880 && e <= 42124 || e >= 42128 && e <= 42182 || e >= 43360 && e <= 43388 || e >= 44032 && e <= 55203 || e >= 63744 && e <= 64255 || e >= 65040 && e <= 65049 || e >= 65072 && e <= 65106 || e >= 65108 && e <= 65126 || e >= 65128 && e <= 65131 || e >= 94176 && e <= 94180 || e === 94192 || e === 94193 || e >= 94208 && e <= 100343 || e >= 100352 && e <= 101589 || e >= 101631 && e <= 101640 || e >= 110576 && e <= 110579 || e >= 110581 && e <= 110587 || e === 110589 || e === 110590 || e >= 110592 && e <= 110882 || e === 110898 || e >= 110928 && e <= 110930 || e === 110933 || e >= 110948 && e <= 110951 || e >= 110960 && e <= 111355 || e >= 119552 && e <= 119638 || e >= 119648 && e <= 119670 || e === 126980 || e === 127183 || e === 127374 || e >= 127377 && e <= 127386 || e >= 127488 && e <= 127490 || e >= 127504 && e <= 127547 || e >= 127552 && e <= 127560 || e === 127568 || e === 127569 || e >= 127584 && e <= 127589 || e >= 127744 && e <= 127776 || e >= 127789 && e <= 127797 || e >= 127799 && e <= 127868 || e >= 127870 && e <= 127891 || e >= 127904 && e <= 127946 || e >= 127951 && e <= 127955 || e >= 127968 && e <= 127984 || e === 127988 || e >= 127992 && e <= 128062 || e === 128064 || e >= 128066 && e <= 128252 || e >= 128255 && e <= 128317 || e >= 128331 && e <= 128334 || e >= 128336 && e <= 128359 || e === 128378 || e === 128405 || e === 128406 || e === 128420 || e >= 128507 && e <= 128591 || e >= 128640 && e <= 128709 || e === 128716 || e >= 128720 && e <= 128722 || e >= 128725 && e <= 128727 || e >= 128732 && e <= 128735 || e === 128747 || e === 128748 || e >= 128756 && e <= 128764 || e >= 128992 && e <= 129003 || e === 129008 || e >= 129292 && e <= 129338 || e >= 129340 && e <= 129349 || e >= 129351 && e <= 129535 || e >= 129648 && e <= 129660 || e >= 129664 && e <= 129673 || e >= 129679 && e <= 129734 || e >= 129742 && e <= 129756 || e >= 129759 && e <= 129769 || e >= 129776 && e <= 129784 || e >= 131072 && e <= 196605 || e >= 196608 && e <= 262141;
}
var Kr = (e) => !(zr(e) || Gr(e));
var Uu = /[^\x20-\x7F]/u;
function zu(e) {
  if (!e) return 0;
  if (!Uu.test(e)) return e.length;
  e = e.replace(Ur(), "  ");
  let t = 0;
  for (let r of e) {
    let n = r.codePointAt(0);
    n <= 31 || n >= 127 && n <= 159 || n >= 768 && n <= 879 || (t += Kr(n) ? 1 : 2);
  }
  return t;
}
var Le = zu;
var Y = Symbol("MODE_BREAK");
var J = Symbol("MODE_FLAT");
var Ee = Symbol("cursor");
var Pt = Symbol("DOC_FILL_PRINTED_LENGTH");
function Jr() {
  return { value: "", length: 0, queue: [] };
}
function Gu(e, t) {
  return It(e, { type: "indent" }, t);
}
function Ku(e, t, r) {
  return t === Number.NEGATIVE_INFINITY ? e.root || Jr() : t < 0 ? It(e, { type: "dedent" }, r) : t ? t.type === "root" ? { ...e, root: e } : It(e, { type: typeof t == "string" ? "stringAlign" : "numberAlign", n: t }, r) : e;
}
function It(e, t, r) {
  let n = t.type === "dedent" ? e.queue.slice(0, -1) : [...e.queue, t], u = "", i = 0, o = 0, s = 0;
  for (let c of n) switch (c.type) {
    case "indent":
      l(), r.useTabs ? a(1) : D(r.tabWidth);
      break;
    case "stringAlign":
      l(), u += c.n, i += c.n.length;
      break;
    case "numberAlign":
      o += 1, s += c.n;
      break;
    default:
      throw new Error(`Unexpected type '${c.type}'`);
  }
  return f(), { ...e, value: u, length: i, queue: n };
  function a(c) {
    u += "	".repeat(c), i += r.tabWidth * c;
  }
  function D(c) {
    u += " ".repeat(c), i += c;
  }
  function l() {
    r.useTabs ? p() : f();
  }
  function p() {
    o > 0 && a(o), d();
  }
  function f() {
    s > 0 && D(s), d();
  }
  function d() {
    o = 0, s = 0;
  }
}
function Rt(e) {
  let t = 0, r = 0, n = e.length;
  e: for (; n--; ) {
    let u = e[n];
    if (u === Ee) {
      r++;
      continue;
    }
    for (let i = u.length - 1; i >= 0; i--) {
      let o = u[i];
      if (o === " " || o === "	") t++;
      else {
        e[n] = u.slice(0, i + 1);
        break e;
      }
    }
  }
  if (t > 0 || r > 0) for (e.length = n + 1; r-- > 0; ) e.push(Ee);
  return t;
}
function et(e, t, r, n, u, i) {
  if (r === Number.POSITIVE_INFINITY) return true;
  let o = t.length, s = [e], a = [];
  for (; r >= 0; ) {
    if (s.length === 0) {
      if (o === 0) return true;
      s.push(t[--o]);
      continue;
    }
    let { mode: D, doc: l } = s.pop(), p = M(l);
    switch (p) {
      case $:
        a.push(l), r -= Le(l);
        break;
      case H:
      case N: {
        let f = p === H ? l : l.parts, d = l[Pt] ?? 0;
        for (let c = f.length - 1; c >= d; c--) s.push({ mode: D, doc: f[c] });
        break;
      }
      case T:
      case k:
      case P:
      case O:
        s.push({ mode: D, doc: l.contents });
        break;
      case L:
        r += Rt(a);
        break;
      case B: {
        if (i && l.break) return false;
        let f = l.break ? Y : D, d = l.expandedStates && f === Y ? A(false, l.expandedStates, -1) : l.contents;
        s.push({ mode: f, doc: d });
        break;
      }
      case w: {
        let d = (l.groupId ? u[l.groupId] || J : D) === Y ? l.breakContents : l.flatContents;
        d && s.push({ mode: D, doc: d });
        break;
      }
      case y:
        if (D === Y || l.hard) return true;
        l.soft || (a.push(" "), r--);
        break;
      case I:
        n = true;
        break;
      case R:
        if (n) return false;
        break;
    }
  }
  return false;
}
function Ce(e, t) {
  let r = {}, n = t.printWidth, u = be(t.endOfLine), i = 0, o = [{ ind: Jr(), mode: Y, doc: e }], s = [], a = false, D = [], l = 0;
  for (br(e); o.length > 0; ) {
    let { ind: f, mode: d, doc: c } = o.pop();
    switch (M(c)) {
      case $: {
        let F = u !== `
` ? ne(false, c, `
`, u) : c;
        s.push(F), o.length > 0 && (i += Le(F));
        break;
      }
      case H:
        for (let F = c.length - 1; F >= 0; F--) o.push({ ind: f, mode: d, doc: c[F] });
        break;
      case z:
        if (l >= 2) throw new Error("There are too many 'cursor' in doc.");
        s.push(Ee), l++;
        break;
      case T:
        o.push({ ind: Gu(f, t), mode: d, doc: c.contents });
        break;
      case k:
        o.push({ ind: Ku(f, c.n, t), mode: d, doc: c.contents });
        break;
      case L:
        i -= Rt(s);
        break;
      case B:
        switch (d) {
          case J:
            if (!a) {
              o.push({ ind: f, mode: c.break ? Y : J, doc: c.contents });
              break;
            }
          case Y: {
            a = false;
            let F = { ind: f, mode: J, doc: c.contents }, m = n - i, h = D.length > 0;
            if (!c.break && et(F, o, m, h, r)) o.push(F);
            else if (c.expandedStates) {
              let C = A(false, c.expandedStates, -1);
              if (c.break) {
                o.push({ ind: f, mode: Y, doc: C });
                break;
              } else for (let v = 1; v < c.expandedStates.length + 1; v++) if (v >= c.expandedStates.length) {
                o.push({ ind: f, mode: Y, doc: C });
                break;
              } else {
                let E = c.expandedStates[v], g = { ind: f, mode: J, doc: E };
                if (et(g, o, m, h, r)) {
                  o.push(g);
                  break;
                }
              }
            } else o.push({ ind: f, mode: Y, doc: c.contents });
            break;
          }
        }
        c.id && (r[c.id] = A(false, o, -1).mode);
        break;
      case N: {
        let F = n - i, m = c[Pt] ?? 0, { parts: h } = c, C = h.length - m;
        if (C === 0) break;
        let v = h[m + 0], E = h[m + 1], g = { ind: f, mode: J, doc: v }, j = { ind: f, mode: Y, doc: v }, b = et(g, [], F, D.length > 0, r, true);
        if (C === 1) {
          b ? o.push(g) : o.push(j);
          break;
        }
        let X = { ind: f, mode: J, doc: E }, ae = { ind: f, mode: Y, doc: E };
        if (C === 2) {
          b ? o.push(X, g) : o.push(ae, j);
          break;
        }
        let $e = h[m + 2], yt = { ind: f, mode: d, doc: { ...c, [Pt]: m + 2 } };
        et({ ind: f, mode: J, doc: [v, E, $e] }, [], F, D.length > 0, r, true) ? o.push(yt, X, g) : b ? o.push(yt, ae, g) : o.push(yt, ae, j);
        break;
      }
      case w:
      case P: {
        let F = c.groupId ? r[c.groupId] : d;
        if (F === Y) {
          let m = c.type === w ? c.breakContents : c.negate ? c.contents : le(c.contents);
          m && o.push({ ind: f, mode: d, doc: m });
        }
        if (F === J) {
          let m = c.type === w ? c.flatContents : c.negate ? le(c.contents) : c.contents;
          m && o.push({ ind: f, mode: d, doc: m });
        }
        break;
      }
      case I:
        D.push({ ind: f, mode: d, doc: c.contents });
        break;
      case R:
        D.length > 0 && o.push({ ind: f, mode: d, doc: ke });
        break;
      case y:
        switch (d) {
          case J:
            if (c.hard) a = true;
            else {
              c.soft || (s.push(" "), i += 1);
              break;
            }
          case Y:
            if (D.length > 0) {
              o.push({ ind: f, mode: d, doc: c }, ...D.reverse()), D.length = 0;
              break;
            }
            c.literal ? f.root ? (s.push(u, f.root.value), i = f.root.length) : (s.push(u), i = 0) : (i -= Rt(s), s.push(u + f.value), i = f.length);
            break;
        }
        break;
      case O:
        o.push({ ind: f, mode: d, doc: c.contents });
        break;
      case _:
        break;
      default:
        throw new Q(c);
    }
    o.length === 0 && D.length > 0 && (o.push(...D.reverse()), D.length = 0);
  }
  let p = s.indexOf(Ee);
  if (p !== -1) {
    let f = s.indexOf(Ee, p + 1);
    if (f === -1) return { formatted: s.filter((m) => m !== Ee).join("") };
    let d = s.slice(0, p).join(""), c = s.slice(p + 1, f).join(""), F = s.slice(f + 1).join("");
    return { formatted: d + c + F, cursorNodeStart: d.length, cursorNodeText: c };
  }
  return { formatted: s.join("") };
}
function Ju(e, t, r = 0) {
  let n = 0;
  for (let u = r; u < e.length; ++u) e[u] === "	" ? n = n + t - n % t : n++;
  return n;
}
var ge = Ju;
var te;
var jt;
var tt;
var Yt = class {
  constructor(t) {
    Fr(this, te);
    this.stack = [t];
  }
  get key() {
    let { stack: t, siblings: r } = this;
    return A(false, t, r === null ? -2 : -4) ?? null;
  }
  get index() {
    return this.siblings === null ? null : A(false, this.stack, -2);
  }
  get node() {
    return A(false, this.stack, -1);
  }
  get parent() {
    return this.getNode(1);
  }
  get grandparent() {
    return this.getNode(2);
  }
  get isInArray() {
    return this.siblings !== null;
  }
  get siblings() {
    let { stack: t } = this, r = A(false, t, -3);
    return Array.isArray(r) ? r : null;
  }
  get next() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index + 1];
  }
  get previous() {
    let { siblings: t } = this;
    return t === null ? null : t[this.index - 1];
  }
  get isFirst() {
    return this.index === 0;
  }
  get isLast() {
    let { siblings: t, index: r } = this;
    return t !== null && r === t.length - 1;
  }
  get isRoot() {
    return this.stack.length === 1;
  }
  get root() {
    return this.stack[0];
  }
  get ancestors() {
    return [...pe(this, te, tt).call(this)];
  }
  getName() {
    let { stack: t } = this, { length: r } = t;
    return r > 1 ? A(false, t, -2) : null;
  }
  getValue() {
    return A(false, this.stack, -1);
  }
  getNode(t = 0) {
    let r = pe(this, te, jt).call(this, t);
    return r === -1 ? null : this.stack[r];
  }
  getParentNode(t = 0) {
    return this.getNode(t + 1);
  }
  call(t, ...r) {
    let { stack: n } = this, { length: u } = n, i = A(false, n, -1);
    for (let o of r) i = i[o], n.push(o, i);
    try {
      return t(this);
    } finally {
      n.length = u;
    }
  }
  callParent(t, r = 0) {
    let n = pe(this, te, jt).call(this, r + 1), u = this.stack.splice(n + 1);
    try {
      return t(this);
    } finally {
      this.stack.push(...u);
    }
  }
  each(t, ...r) {
    let { stack: n } = this, { length: u } = n, i = A(false, n, -1);
    for (let o of r) i = i[o], n.push(o, i);
    try {
      for (let o = 0; o < i.length; ++o) n.push(o, i[o]), t(this, o, i), n.length -= 2;
    } finally {
      n.length = u;
    }
  }
  map(t, ...r) {
    let n = [];
    return this.each((u, i, o) => {
      n[i] = t(u, i, o);
    }, ...r), n;
  }
  match(...t) {
    let r = this.stack.length - 1, n = null, u = this.stack[r--];
    for (let i of t) {
      if (u === void 0) return false;
      let o = null;
      if (typeof n == "number" && (o = n, n = this.stack[r--], u = this.stack[r--]), i && !i(u, n, o)) return false;
      n = this.stack[r--], u = this.stack[r--];
    }
    return true;
  }
  findAncestor(t) {
    for (let r of pe(this, te, tt).call(this)) if (t(r)) return r;
  }
  hasAncestor(t) {
    for (let r of pe(this, te, tt).call(this)) if (t(r)) return true;
    return false;
  }
};
te = /* @__PURE__ */ new WeakSet(), jt = function(t) {
  let { stack: r } = this;
  for (let n = r.length - 1; n >= 0; n -= 2) if (!Array.isArray(r[n]) && --t < 0) return n;
  return -1;
}, tt = function* () {
  let { stack: t } = this;
  for (let r = t.length - 3; r >= 0; r -= 2) {
    let n = t[r];
    Array.isArray(n) || (yield n);
  }
};
var qr = Yt;
var Xr = new Proxy(() => {
}, { get: () => Xr });
var Pe = Xr;
function qu(e) {
  return e !== null && typeof e == "object";
}
var Qr = qu;
function* ye(e, t) {
  let { getVisitorKeys: r, filter: n = () => true } = t, u = (i) => Qr(i) && n(i);
  for (let i of r(e)) {
    let o = e[i];
    if (Array.isArray(o)) for (let s of o) u(s) && (yield s);
    else u(o) && (yield o);
  }
}
function* Zr(e, t) {
  let r = [e];
  for (let n = 0; n < r.length; n++) {
    let u = r[n];
    for (let i of ye(u, t)) yield i, r.push(i);
  }
}
function en(e, t) {
  return ye(e, t).next().done;
}
function Ae(e) {
  return (t, r, n) => {
    let u = !!(n != null && n.backwards);
    if (r === false) return false;
    let { length: i } = t, o = r;
    for (; o >= 0 && o < i; ) {
      let s = t.charAt(o);
      if (e instanceof RegExp) {
        if (!e.test(s)) return o;
      } else if (!e.includes(s)) return o;
      u ? o-- : o++;
    }
    return o === -1 || o === i ? o : false;
  };
}
var tn = Ae(/\s/u);
var S = Ae(" 	");
var rt = Ae(",; 	");
var nt = Ae(/[^\n\r]/u);
function Xu(e, t, r) {
  let n = !!(r != null && r.backwards);
  if (t === false) return false;
  let u = e.charAt(t);
  if (n) {
    if (e.charAt(t - 1) === "\r" && u === `
`) return t - 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t - 1;
  } else {
    if (u === "\r" && e.charAt(t + 1) === `
`) return t + 2;
    if (u === `
` || u === "\r" || u === "\u2028" || u === "\u2029") return t + 1;
  }
  return t;
}
var W = Xu;
function Qu(e, t, r = {}) {
  let n = S(e, r.backwards ? t - 1 : t, r), u = W(e, n, r);
  return n !== u;
}
var V = Qu;
function Zu(e) {
  return Array.isArray(e) && e.length > 0;
}
var Ht = Zu;
var rn = /* @__PURE__ */ new Set(["tokens", "comments", "parent", "enclosingNode", "precedingNode", "followingNode"]);
var ei = (e) => Object.keys(e).filter((t) => !rn.has(t));
function ti(e) {
  return e ? (t) => e(t, rn) : ei;
}
var q = ti;
function ri(e) {
  let t = e.type || e.kind || "(unknown type)", r = String(e.name || e.id && (typeof e.id == "object" ? e.id.name : e.id) || e.key && (typeof e.key == "object" ? e.key.name : e.key) || e.value && (typeof e.value == "object" ? "" : String(e.value)) || e.operator || "");
  return r.length > 20 && (r = r.slice(0, 19) + "\u2026"), t + (r ? " " + r : "");
}
function Wt(e, t) {
  (e.comments ?? (e.comments = [])).push(t), t.printed = false, t.nodeDescription = ri(e);
}
function ue(e, t) {
  t.leading = true, t.trailing = false, Wt(e, t);
}
function re(e, t, r) {
  t.leading = false, t.trailing = false, r && (t.marker = r), Wt(e, t);
}
function ie(e, t) {
  t.leading = false, t.trailing = true, Wt(e, t);
}
var $t = /* @__PURE__ */ new WeakMap();
function ut(e, t) {
  if ($t.has(e)) return $t.get(e);
  let { printer: { getCommentChildNodes: r, canAttachComment: n, getVisitorKeys: u }, locStart: i, locEnd: o } = t;
  if (!n) return [];
  let s = ((r == null ? void 0 : r(e, t)) ?? [...ye(e, { getVisitorKeys: q(u) })]).flatMap((a) => n(a) ? [a] : ut(a, t));
  return s.sort((a, D) => i(a) - i(D) || o(a) - o(D)), $t.set(e, s), s;
}
function un(e, t, r, n) {
  let { locStart: u, locEnd: i } = r, o = u(t), s = i(t), a = ut(e, r), D, l, p = 0, f = a.length;
  for (; p < f; ) {
    let d = p + f >> 1, c = a[d], F = u(c), m = i(c);
    if (F <= o && s <= m) return un(c, t, r, c);
    if (m <= o) {
      D = c, p = d + 1;
      continue;
    }
    if (s <= F) {
      l = c, f = d;
      continue;
    }
    throw new Error("Comment location overlaps with node location");
  }
  if ((n == null ? void 0 : n.type) === "TemplateLiteral") {
    let { quasis: d } = n, c = Vt(d, t, r);
    D && Vt(d, D, r) !== c && (D = null), l && Vt(d, l, r) !== c && (l = null);
  }
  return { enclosingNode: n, precedingNode: D, followingNode: l };
}
var Mt = () => false;
function on(e, t) {
  let { comments: r } = e;
  if (delete e.comments, !Ht(r) || !t.printer.canAttachComment) return;
  let n = [], { locStart: u, locEnd: i, printer: { experimentalFeatures: { avoidAstMutation: o = false } = {}, handleComments: s = {} }, originalText: a } = t, { ownLine: D = Mt, endOfLine: l = Mt, remaining: p = Mt } = s, f = r.map((d, c) => ({ ...un(e, d, t), comment: d, text: a, options: t, ast: e, isLastComment: r.length - 1 === c }));
  for (let [d, c] of f.entries()) {
    let { comment: F, precedingNode: m, enclosingNode: h, followingNode: C, text: v, options: E, ast: g, isLastComment: j } = c;
    if (E.parser === "json" || E.parser === "json5" || E.parser === "jsonc" || E.parser === "__js_expression" || E.parser === "__ts_expression" || E.parser === "__vue_expression" || E.parser === "__vue_ts_expression") {
      if (u(F) - u(g) <= 0) {
        ue(g, F);
        continue;
      }
      if (i(F) - i(g) >= 0) {
        ie(g, F);
        continue;
      }
    }
    let b;
    if (o ? b = [c] : (F.enclosingNode = h, F.precedingNode = m, F.followingNode = C, b = [F, v, E, g, j]), ni(v, E, f, d)) F.placement = "ownLine", D(...b) || (C ? ue(C, F) : m ? ie(m, F) : h ? re(h, F) : re(g, F));
    else if (ui(v, E, f, d)) F.placement = "endOfLine", l(...b) || (m ? ie(m, F) : C ? ue(C, F) : h ? re(h, F) : re(g, F));
    else if (F.placement = "remaining", !p(...b)) if (m && C) {
      let X = n.length;
      X > 0 && n[X - 1].followingNode !== C && nn(n, E), n.push(c);
    } else m ? ie(m, F) : C ? ue(C, F) : h ? re(h, F) : re(g, F);
  }
  if (nn(n, t), !o) for (let d of r) delete d.precedingNode, delete d.enclosingNode, delete d.followingNode;
}
var sn = (e) => !/[\S\n\u2028\u2029]/u.test(e);
function ni(e, t, r, n) {
  let { comment: u, precedingNode: i } = r[n], { locStart: o, locEnd: s } = t, a = o(u);
  if (i) for (let D = n - 1; D >= 0; D--) {
    let { comment: l, precedingNode: p } = r[D];
    if (p !== i || !sn(e.slice(s(l), a))) break;
    a = o(l);
  }
  return V(e, a, { backwards: true });
}
function ui(e, t, r, n) {
  let { comment: u, followingNode: i } = r[n], { locStart: o, locEnd: s } = t, a = s(u);
  if (i) for (let D = n + 1; D < r.length; D++) {
    let { comment: l, followingNode: p } = r[D];
    if (p !== i || !sn(e.slice(a, o(l)))) break;
    a = s(l);
  }
  return V(e, a);
}
function nn(e, t) {
  var s, a;
  let r = e.length;
  if (r === 0) return;
  let { precedingNode: n, followingNode: u } = e[0], i = t.locStart(u), o;
  for (o = r; o > 0; --o) {
    let { comment: D, precedingNode: l, followingNode: p } = e[o - 1];
    Pe.strictEqual(l, n), Pe.strictEqual(p, u);
    let f = t.originalText.slice(t.locEnd(D), i);
    if (((a = (s = t.printer).isGap) == null ? void 0 : a.call(s, f, t)) ?? /^[\s(]*$/u.test(f)) i = t.locStart(D);
    else break;
  }
  for (let [D, { comment: l }] of e.entries()) D < o ? ie(n, l) : ue(u, l);
  for (let D of [n, u]) D.comments && D.comments.length > 1 && D.comments.sort((l, p) => t.locStart(l) - t.locStart(p));
  e.length = 0;
}
function Vt(e, t, r) {
  let n = r.locStart(t) - 1;
  for (let u = 1; u < e.length; ++u) if (n < r.locStart(e[u])) return u - 1;
  return 0;
}
function ii(e, t) {
  let r = t - 1;
  r = S(e, r, { backwards: true }), r = W(e, r, { backwards: true }), r = S(e, r, { backwards: true });
  let n = W(e, r, { backwards: true });
  return r !== n;
}
var Ie = ii;
function an(e, t) {
  let r = e.node;
  return r.printed = true, t.printer.printComment(e, t);
}
function oi(e, t) {
  var l;
  let r = e.node, n = [an(e, t)], { printer: u, originalText: i, locStart: o, locEnd: s } = t;
  if ((l = u.isBlockComment) == null ? void 0 : l.call(u, r)) {
    let p = V(i, s(r)) ? V(i, o(r), { backwards: true }) ? K : Qe : " ";
    n.push(p);
  } else n.push(K);
  let D = W(i, S(i, s(r)));
  return D !== false && V(i, D) && n.push(K), n;
}
function si(e, t, r) {
  var D;
  let n = e.node, u = an(e, t), { printer: i, originalText: o, locStart: s } = t, a = (D = i.isBlockComment) == null ? void 0 : D.call(i, n);
  if (r != null && r.hasLineSuffix && !(r != null && r.isBlock) || V(o, s(n), { backwards: true })) {
    let l = Ie(o, s(n));
    return { doc: Te([K, l ? K : "", u]), isBlock: a, hasLineSuffix: true };
  }
  return !a || r != null && r.hasLineSuffix ? { doc: [Te([" ", u]), he], isBlock: a, hasLineSuffix: true } : { doc: [" ", u], isBlock: a, hasLineSuffix: false };
}
function ai(e, t) {
  let r = e.node;
  if (!r) return {};
  let n = t[Symbol.for("printedComments")];
  if ((r.comments || []).filter((a) => !n.has(a)).length === 0) return { leading: "", trailing: "" };
  let i = [], o = [], s;
  return e.each(() => {
    let a = e.node;
    if (n != null && n.has(a)) return;
    let { leading: D, trailing: l } = a;
    D ? i.push(oi(e, t)) : l && (s = si(e, t, s), o.push(s.doc));
  }, "comments"), { leading: i, trailing: o };
}
function Dn(e, t, r) {
  let { leading: n, trailing: u } = ai(e, r);
  return !n && !u ? t : me(t, (i) => [n, i, u]);
}
function ln(e) {
  let { [Symbol.for("comments")]: t, [Symbol.for("printedComments")]: r } = e;
  for (let n of t) {
    if (!n.printed && !r.has(n)) throw new Error('Comment "' + n.value.trim() + '" was not printed. Please report this error!');
    delete n.printed;
  }
}
var Re = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "ConfigError");
  }
};
var Ye = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "name", "UndefinedParserError");
  }
};
var fn = { cursorOffset: { category: "Special", type: "int", default: -1, range: { start: -1, end: 1 / 0, step: 1 }, description: "Print (to stderr) where a cursor at the given position would move to after formatting.", cliCategory: "Editor" }, endOfLine: { category: "Global", type: "choice", default: "lf", description: "Which end of line characters to apply.", choices: [{ value: "lf", description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos" }, { value: "crlf", description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows" }, { value: "cr", description: "Carriage Return character only (\\r), used very rarely" }, { value: "auto", description: `Maintain existing
(mixed values within one file are normalised by looking at what's used after the first line)` }] }, filepath: { category: "Special", type: "path", description: "Specify the input filepath. This will be used to do parser inference.", cliName: "stdin-filepath", cliCategory: "Other", cliDescription: "Path to the file to pretend that stdin comes from." }, insertPragma: { category: "Special", type: "boolean", default: false, description: "Insert @format pragma into file's first docblock comment.", cliCategory: "Other" }, parser: { category: "Global", type: "choice", default: void 0, description: "Which parser to use.", exception: (e) => typeof e == "string" || typeof e == "function", choices: [{ value: "flow", description: "Flow" }, { value: "babel", description: "JavaScript" }, { value: "babel-flow", description: "Flow" }, { value: "babel-ts", description: "TypeScript" }, { value: "typescript", description: "TypeScript" }, { value: "acorn", description: "JavaScript" }, { value: "espree", description: "JavaScript" }, { value: "meriyah", description: "JavaScript" }, { value: "css", description: "CSS" }, { value: "less", description: "Less" }, { value: "scss", description: "SCSS" }, { value: "json", description: "JSON" }, { value: "json5", description: "JSON5" }, { value: "jsonc", description: "JSON with Comments" }, { value: "json-stringify", description: "JSON.stringify" }, { value: "graphql", description: "GraphQL" }, { value: "markdown", description: "Markdown" }, { value: "mdx", description: "MDX" }, { value: "vue", description: "Vue" }, { value: "yaml", description: "YAML" }, { value: "glimmer", description: "Ember / Handlebars" }, { value: "html", description: "HTML" }, { value: "angular", description: "Angular" }, { value: "lwc", description: "Lightning Web Components" }] }, plugins: { type: "path", array: true, default: [{ value: [] }], category: "Global", description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.", exception: (e) => typeof e == "string" || typeof e == "object", cliName: "plugin", cliCategory: "Config" }, printWidth: { category: "Global", type: "int", default: 80, description: "The line length where Prettier will try wrap.", range: { start: 0, end: 1 / 0, step: 1 } }, rangeEnd: { category: "Special", type: "int", default: 1 / 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code ending at a given character offset (exclusive).
The range will extend forwards to the end of the selected statement.`, cliCategory: "Editor" }, rangeStart: { category: "Special", type: "int", default: 0, range: { start: 0, end: 1 / 0, step: 1 }, description: `Format code starting at a given character offset.
The range will extend backwards to the start of the first line containing the selected statement.`, cliCategory: "Editor" }, requirePragma: { category: "Special", type: "boolean", default: false, description: `Require either '@prettier' or '@format' to be present in the file's first docblock comment
in order for it to be formatted.`, cliCategory: "Other" }, tabWidth: { type: "int", category: "Global", default: 2, description: "Number of spaces per indentation level.", range: { start: 0, end: 1 / 0, step: 1 } }, useTabs: { category: "Global", type: "boolean", default: false, description: "Indent with tabs instead of spaces." }, embeddedLanguageFormatting: { category: "Global", type: "choice", default: "auto", description: "Control how Prettier formats quoted code embedded in the file.", choices: [{ value: "auto", description: "Format embedded code if Prettier can automatically identify it." }, { value: "off", description: "Never automatically format embedded code." }] } };
function it({ plugins: e = [], showDeprecated: t = false } = {}) {
  let r = e.flatMap((u) => u.languages ?? []), n = [];
  for (let u of ci(Object.assign({}, ...e.map(({ options: i }) => i), fn))) !t && u.deprecated || (Array.isArray(u.choices) && (t || (u.choices = u.choices.filter((i) => !i.deprecated)), u.name === "parser" && (u.choices = [...u.choices, ...li(u.choices, r, e)])), u.pluginDefaults = Object.fromEntries(e.filter((i) => {
    var o;
    return ((o = i.defaultOptions) == null ? void 0 : o[u.name]) !== void 0;
  }).map((i) => [i.name, i.defaultOptions[u.name]])), n.push(u));
  return { languages: r, options: n };
}
function* li(e, t, r) {
  let n = new Set(e.map((u) => u.value));
  for (let u of t) if (u.parsers) {
    for (let i of u.parsers) if (!n.has(i)) {
      n.add(i);
      let o = r.find((a) => a.parsers && Object.prototype.hasOwnProperty.call(a.parsers, i)), s = u.name;
      o != null && o.name && (s += ` (plugin: ${o.name})`), yield { value: i, description: s };
    }
  }
}
function ci(e) {
  let t = [];
  for (let [r, n] of Object.entries(e)) {
    let u = { name: r, ...n };
    Array.isArray(u.default) && (u.default = A(false, u.default, -1).value), t.push(u);
  }
  return t;
}
var fi = (e) => String(e).split(/[/\\]/u).pop();
function dn(e, t) {
  if (!t) return;
  let r = fi(t).toLowerCase();
  return e.find(({ filenames: n }) => n == null ? void 0 : n.some((u) => u.toLowerCase() === r)) ?? e.find(({ extensions: n }) => n == null ? void 0 : n.some((u) => r.endsWith(u)));
}
function di(e, t) {
  if (t) return e.find(({ name: r }) => r.toLowerCase() === t) ?? e.find(({ aliases: r }) => r == null ? void 0 : r.includes(t)) ?? e.find(({ extensions: r }) => r == null ? void 0 : r.includes(`.${t}`));
}
function pi(e, t) {
  let r = e.plugins.flatMap((u) => u.languages ?? []), n = di(r, t.language) ?? dn(r, t.physicalFile) ?? dn(r, t.file) ?? (t.physicalFile, void 0);
  return n == null ? void 0 : n.parsers[0];
}
var pn = pi;
var oe = { key: (e) => /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(e) ? e : JSON.stringify(e), value(e) {
  if (e === null || typeof e != "object") return JSON.stringify(e);
  if (Array.isArray(e)) return `[${e.map((r) => oe.value(r)).join(", ")}]`;
  let t = Object.keys(e);
  return t.length === 0 ? "{}" : `{ ${t.map((r) => `${oe.key(r)}: ${oe.value(e[r])}`).join(", ")} }`;
}, pair: ({ key: e, value: t }) => oe.value({ [e]: t }) };
var Ut = Me(ot());
var hn = (e, t, { descriptor: r }) => {
  let n = [`${Ut.default.yellow(typeof e == "string" ? r.key(e) : r.pair(e))} is deprecated`];
  return t && n.push(`we now treat it as ${Ut.default.blue(typeof t == "string" ? r.key(t) : r.pair(t))}`), n.join("; ") + ".";
};
var ce = Me(ot());
var st = Symbol.for("vnopts.VALUE_NOT_EXIST");
var ve = Symbol.for("vnopts.VALUE_UNCHANGED");
var En = " ".repeat(2);
var gn = (e, t, r) => {
  let { text: n, list: u } = r.normalizeExpectedResult(r.schemas[e].expected(r)), i = [];
  return n && i.push(Cn(e, t, n, r.descriptor)), u && i.push([Cn(e, t, u.title, r.descriptor)].concat(u.values.map((o) => yn(o, r.loggerPrintWidth))).join(`
`)), An(i, r.loggerPrintWidth);
};
function Cn(e, t, r, n) {
  return [`Invalid ${ce.default.red(n.key(e))} value.`, `Expected ${ce.default.blue(r)},`, `but received ${t === st ? ce.default.gray("nothing") : ce.default.red(n.value(t))}.`].join(" ");
}
function yn({ text: e, list: t }, r) {
  let n = [];
  return e && n.push(`- ${ce.default.blue(e)}`), t && n.push([`- ${ce.default.blue(t.title)}:`].concat(t.values.map((u) => yn(u, r - En.length).replace(/^|\n/g, `$&${En}`))).join(`
`)), An(n, r);
}
function An(e, t) {
  if (e.length === 1) return e[0];
  let [r, n] = e, [u, i] = e.map((o) => o.split(`
`, 1)[0].length);
  return u > t && u > i ? n : r;
}
var Kt = Me(ot());
var zt = [];
var vn = [];
function Gt(e, t) {
  if (e === t) return 0;
  let r = e;
  e.length > t.length && (e = t, t = r);
  let n = e.length, u = t.length;
  for (; n > 0 && e.charCodeAt(~-n) === t.charCodeAt(~-u); ) n--, u--;
  let i = 0;
  for (; i < n && e.charCodeAt(i) === t.charCodeAt(i); ) i++;
  if (n -= i, u -= i, n === 0) return u;
  let o, s, a, D, l = 0, p = 0;
  for (; l < n; ) vn[l] = e.charCodeAt(i + l), zt[l] = ++l;
  for (; p < u; ) for (o = t.charCodeAt(i + p), a = p++, s = p, l = 0; l < n; l++) D = o === vn[l] ? a : a + 1, a = zt[l], s = zt[l] = a > s ? D > s ? s + 1 : D : D > a ? a + 1 : D;
  return s;
}
var at = (e, t, { descriptor: r, logger: n, schemas: u }) => {
  let i = [`Ignored unknown option ${Kt.default.yellow(r.pair({ key: e, value: t }))}.`], o = Object.keys(u).sort().find((s) => Gt(e, s) < 3);
  o && i.push(`Did you mean ${Kt.default.blue(r.key(o))}?`), n.warn(i.join(" "));
};
var Fi = ["default", "expected", "validate", "deprecated", "forward", "redirect", "overlap", "preprocess", "postprocess"];
function mi(e, t) {
  let r = new e(t), n = Object.create(r);
  for (let u of Fi) u in t && (n[u] = hi(t[u], r, x.prototype[u].length));
  return n;
}
var x = class {
  static create(t) {
    return mi(this, t);
  }
  constructor(t) {
    this.name = t.name;
  }
  default(t) {
  }
  expected(t) {
    return "nothing";
  }
  validate(t, r) {
    return false;
  }
  deprecated(t, r) {
    return false;
  }
  forward(t, r) {
  }
  redirect(t, r) {
  }
  overlap(t, r, n) {
    return t;
  }
  preprocess(t, r) {
    return t;
  }
  postprocess(t, r) {
    return ve;
  }
};
function hi(e, t, r) {
  return typeof e == "function" ? (...n) => e(...n.slice(0, r - 1), t, ...n.slice(r - 1)) : () => e;
}
var Dt = class extends x {
  constructor(t) {
    super(t), this._sourceName = t.sourceName;
  }
  expected(t) {
    return t.schemas[this._sourceName].expected(t);
  }
  validate(t, r) {
    return r.schemas[this._sourceName].validate(t, r);
  }
  redirect(t, r) {
    return this._sourceName;
  }
};
var lt = class extends x {
  expected() {
    return "anything";
  }
  validate() {
    return true;
  }
};
var ct = class extends x {
  constructor({ valueSchema: t, name: r = t.name, ...n }) {
    super({ ...n, name: r }), this._valueSchema = t;
  }
  expected(t) {
    let { text: r, list: n } = t.normalizeExpectedResult(this._valueSchema.expected(t));
    return { text: r && `an array of ${r}`, list: n && { title: "an array of the following values", values: [{ list: n }] } };
  }
  validate(t, r) {
    if (!Array.isArray(t)) return false;
    let n = [];
    for (let u of t) {
      let i = r.normalizeValidateResult(this._valueSchema.validate(u, r), u);
      i !== true && n.push(i.value);
    }
    return n.length === 0 ? true : { value: n };
  }
  deprecated(t, r) {
    let n = [];
    for (let u of t) {
      let i = r.normalizeDeprecatedResult(this._valueSchema.deprecated(u, r), u);
      i !== false && n.push(...i.map(({ value: o }) => ({ value: [o] })));
    }
    return n;
  }
  forward(t, r) {
    let n = [];
    for (let u of t) {
      let i = r.normalizeForwardResult(this._valueSchema.forward(u, r), u);
      n.push(...i.map(Bn));
    }
    return n;
  }
  redirect(t, r) {
    let n = [], u = [];
    for (let i of t) {
      let o = r.normalizeRedirectResult(this._valueSchema.redirect(i, r), i);
      "remain" in o && n.push(o.remain), u.push(...o.redirect.map(Bn));
    }
    return n.length === 0 ? { redirect: u } : { redirect: u, remain: n };
  }
  overlap(t, r) {
    return t.concat(r);
  }
};
function Bn({ from: e, to: t }) {
  return { from: [e], to: t };
}
var ft = class extends x {
  expected() {
    return "true or false";
  }
  validate(t) {
    return typeof t == "boolean";
  }
};
function _n(e, t) {
  let r = /* @__PURE__ */ Object.create(null);
  for (let n of e) {
    let u = n[t];
    if (r[u]) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
    r[u] = n;
  }
  return r;
}
function xn(e, t) {
  let r = /* @__PURE__ */ new Map();
  for (let n of e) {
    let u = n[t];
    if (r.has(u)) throw new Error(`Duplicate ${t} ${JSON.stringify(u)}`);
    r.set(u, n);
  }
  return r;
}
function bn() {
  let e = /* @__PURE__ */ Object.create(null);
  return (t) => {
    let r = JSON.stringify(t);
    return e[r] ? true : (e[r] = true, false);
  };
}
function Nn(e, t) {
  let r = [], n = [];
  for (let u of e) t(u) ? r.push(u) : n.push(u);
  return [r, n];
}
function On(e) {
  return e === Math.floor(e);
}
function Sn(e, t) {
  if (e === t) return 0;
  let r = typeof e, n = typeof t, u = ["undefined", "object", "boolean", "number", "string"];
  return r !== n ? u.indexOf(r) - u.indexOf(n) : r !== "string" ? Number(e) - Number(t) : e.localeCompare(t);
}
function Tn(e) {
  return (...t) => {
    let r = e(...t);
    return typeof r == "string" ? new Error(r) : r;
  };
}
function Jt(e) {
  return e === void 0 ? {} : e;
}
function qt(e) {
  if (typeof e == "string") return { text: e };
  let { text: t, list: r } = e;
  return Ei((t || r) !== void 0, "Unexpected `expected` result, there should be at least one field."), r ? { text: t, list: { title: r.title, values: r.values.map(qt) } } : { text: t };
}
function Xt(e, t) {
  return e === true ? true : e === false ? { value: t } : e;
}
function Qt(e, t, r = false) {
  return e === false ? false : e === true ? r ? true : [{ value: t }] : "value" in e ? [e] : e.length === 0 ? false : e;
}
function wn(e, t) {
  return typeof e == "string" || "key" in e ? { from: t, to: e } : "from" in e ? { from: e.from, to: e.to } : { from: t, to: e.to };
}
function dt(e, t) {
  return e === void 0 ? [] : Array.isArray(e) ? e.map((r) => wn(r, t)) : [wn(e, t)];
}
function Zt(e, t) {
  let r = dt(typeof e == "object" && "redirect" in e ? e.redirect : e, t);
  return r.length === 0 ? { remain: t, redirect: r } : typeof e == "object" && "remain" in e ? { remain: e.remain, redirect: r } : { redirect: r };
}
function Ei(e, t) {
  if (!e) throw new Error(t);
}
var pt = class extends x {
  constructor(t) {
    super(t), this._choices = xn(t.choices.map((r) => r && typeof r == "object" ? r : { value: r }), "value");
  }
  expected({ descriptor: t }) {
    let r = Array.from(this._choices.keys()).map((o) => this._choices.get(o)).filter(({ hidden: o }) => !o).map((o) => o.value).sort(Sn).map(t.value), n = r.slice(0, -2), u = r.slice(-2);
    return { text: n.concat(u.join(" or ")).join(", "), list: { title: "one of the following values", values: r } };
  }
  validate(t) {
    return this._choices.has(t);
  }
  deprecated(t) {
    let r = this._choices.get(t);
    return r && r.deprecated ? { value: t } : false;
  }
  forward(t) {
    let r = this._choices.get(t);
    return r ? r.forward : void 0;
  }
  redirect(t) {
    let r = this._choices.get(t);
    return r ? r.redirect : void 0;
  }
};
var Ft = class extends x {
  expected() {
    return "a number";
  }
  validate(t, r) {
    return typeof t == "number";
  }
};
var mt = class extends Ft {
  expected() {
    return "an integer";
  }
  validate(t, r) {
    return r.normalizeValidateResult(super.validate(t, r), t) === true && On(t);
  }
};
var je = class extends x {
  expected() {
    return "a string";
  }
  validate(t) {
    return typeof t == "string";
  }
};
var kn = oe;
var Ln = at;
var Pn = gn;
var In = hn;
var ht = class {
  constructor(t, r) {
    let { logger: n = console, loggerPrintWidth: u = 80, descriptor: i = kn, unknown: o = Ln, invalid: s = Pn, deprecated: a = In, missing: D = () => false, required: l = () => false, preprocess: p = (d) => d, postprocess: f = () => ve } = r || {};
    this._utils = { descriptor: i, logger: n || { warn: () => {
    } }, loggerPrintWidth: u, schemas: _n(t, "name"), normalizeDefaultResult: Jt, normalizeExpectedResult: qt, normalizeDeprecatedResult: Qt, normalizeForwardResult: dt, normalizeRedirectResult: Zt, normalizeValidateResult: Xt }, this._unknownHandler = o, this._invalidHandler = Tn(s), this._deprecatedHandler = a, this._identifyMissing = (d, c) => !(d in c) || D(d, c), this._identifyRequired = l, this._preprocess = p, this._postprocess = f, this.cleanHistory();
  }
  cleanHistory() {
    this._hasDeprecationWarned = bn();
  }
  normalize(t) {
    let r = {}, u = [this._preprocess(t, this._utils)], i = () => {
      for (; u.length !== 0; ) {
        let o = u.shift(), s = this._applyNormalization(o, r);
        u.push(...s);
      }
    };
    i();
    for (let o of Object.keys(this._utils.schemas)) {
      let s = this._utils.schemas[o];
      if (!(o in r)) {
        let a = Jt(s.default(this._utils));
        "value" in a && u.push({ [o]: a.value });
      }
    }
    i();
    for (let o of Object.keys(this._utils.schemas)) {
      if (!(o in r)) continue;
      let s = this._utils.schemas[o], a = r[o], D = s.postprocess(a, this._utils);
      D !== ve && (this._applyValidation(D, o, s), r[o] = D);
    }
    return this._applyPostprocess(r), this._applyRequiredCheck(r), r;
  }
  _applyNormalization(t, r) {
    let n = [], { knownKeys: u, unknownKeys: i } = this._partitionOptionKeys(t);
    for (let o of u) {
      let s = this._utils.schemas[o], a = s.preprocess(t[o], this._utils);
      this._applyValidation(a, o, s);
      let D = ({ from: d, to: c }) => {
        n.push(typeof c == "string" ? { [c]: d } : { [c.key]: c.value });
      }, l = ({ value: d, redirectTo: c }) => {
        let F = Qt(s.deprecated(d, this._utils), a, true);
        if (F !== false) if (F === true) this._hasDeprecationWarned(o) || this._utils.logger.warn(this._deprecatedHandler(o, c, this._utils));
        else for (let { value: m } of F) {
          let h = { key: o, value: m };
          if (!this._hasDeprecationWarned(h)) {
            let C = typeof c == "string" ? { key: c, value: m } : c;
            this._utils.logger.warn(this._deprecatedHandler(h, C, this._utils));
          }
        }
      };
      dt(s.forward(a, this._utils), a).forEach(D);
      let f = Zt(s.redirect(a, this._utils), a);
      if (f.redirect.forEach(D), "remain" in f) {
        let d = f.remain;
        r[o] = o in r ? s.overlap(r[o], d, this._utils) : d, l({ value: d });
      }
      for (let { from: d, to: c } of f.redirect) l({ value: d, redirectTo: c });
    }
    for (let o of i) {
      let s = t[o];
      this._applyUnknownHandler(o, s, r, (a, D) => {
        n.push({ [a]: D });
      });
    }
    return n;
  }
  _applyRequiredCheck(t) {
    for (let r of Object.keys(this._utils.schemas)) if (this._identifyMissing(r, t) && this._identifyRequired(r)) throw this._invalidHandler(r, st, this._utils);
  }
  _partitionOptionKeys(t) {
    let [r, n] = Nn(Object.keys(t).filter((u) => !this._identifyMissing(u, t)), (u) => u in this._utils.schemas);
    return { knownKeys: r, unknownKeys: n };
  }
  _applyValidation(t, r, n) {
    let u = Xt(n.validate(t, this._utils), t);
    if (u !== true) throw this._invalidHandler(r, u.value, this._utils);
  }
  _applyUnknownHandler(t, r, n, u) {
    let i = this._unknownHandler(t, r, this._utils);
    if (i) for (let o of Object.keys(i)) {
      if (this._identifyMissing(o, i)) continue;
      let s = i[o];
      o in this._utils.schemas ? u(o, s) : n[o] = s;
    }
  }
  _applyPostprocess(t) {
    let r = this._postprocess(t, this._utils);
    if (r !== ve) {
      if (r.delete) for (let n of r.delete) delete t[n];
      if (r.override) {
        let { knownKeys: n, unknownKeys: u } = this._partitionOptionKeys(r.override);
        for (let i of n) {
          let o = r.override[i];
          this._applyValidation(o, i, this._utils.schemas[i]), t[i] = o;
        }
        for (let i of u) {
          let o = r.override[i];
          this._applyUnknownHandler(i, o, t, (s, a) => {
            let D = this._utils.schemas[s];
            this._applyValidation(a, s, D), t[s] = a;
          });
        }
      }
    }
  }
};
var er;
function gi(e, t, { logger: r = false, isCLI: n = false, passThrough: u = false, FlagSchema: i, descriptor: o } = {}) {
  if (n) {
    if (!i) throw new Error("'FlagSchema' option is required.");
    if (!o) throw new Error("'descriptor' option is required.");
  } else o = oe;
  let s = u ? Array.isArray(u) ? (f, d) => u.includes(f) ? { [f]: d } : void 0 : (f, d) => ({ [f]: d }) : (f, d, c) => {
    let { _: F, ...m } = c.schemas;
    return at(f, d, { ...c, schemas: m });
  }, a = yi(t, { isCLI: n, FlagSchema: i }), D = new ht(a, { logger: r, unknown: s, descriptor: o }), l = r !== false;
  l && er && (D._hasDeprecationWarned = er);
  let p = D.normalize(e);
  return l && (er = D._hasDeprecationWarned), p;
}
function yi(e, { isCLI: t, FlagSchema: r }) {
  let n = [];
  t && n.push(lt.create({ name: "_" }));
  for (let u of e) n.push(Ai(u, { isCLI: t, optionInfos: e, FlagSchema: r })), u.alias && t && n.push(Dt.create({ name: u.alias, sourceName: u.name }));
  return n;
}
function Ai(e, { isCLI: t, optionInfos: r, FlagSchema: n }) {
  let { name: u } = e, i = { name: u }, o, s = {};
  switch (e.type) {
    case "int":
      o = mt, t && (i.preprocess = Number);
      break;
    case "string":
      o = je;
      break;
    case "choice":
      o = pt, i.choices = e.choices.map((a) => a != null && a.redirect ? { ...a, redirect: { to: { key: e.name, value: a.redirect } } } : a);
      break;
    case "boolean":
      o = ft;
      break;
    case "flag":
      o = n, i.flags = r.flatMap((a) => [a.alias, a.description && a.name, a.oppositeDescription && `no-${a.name}`].filter(Boolean));
      break;
    case "path":
      o = je;
      break;
    default:
      throw new Error(`Unexpected type ${e.type}`);
  }
  if (e.exception ? i.validate = (a, D, l) => e.exception(a) || D.validate(a, l) : i.validate = (a, D, l) => a === void 0 || D.validate(a, l), e.redirect && (s.redirect = (a) => a ? { to: typeof e.redirect == "string" ? e.redirect : { key: e.redirect.option, value: e.redirect.value } } : void 0), e.deprecated && (s.deprecated = true), t && !e.array) {
    let a = i.preprocess || ((D) => D);
    i.preprocess = (D, l, p) => l.preprocess(a(Array.isArray(D) ? A(false, D, -1) : D), p);
  }
  return e.array ? ct.create({ ...t ? { preprocess: (a) => Array.isArray(a) ? a : [a] } : {}, ...s, valueSchema: o.create(i) }) : o.create({ ...i, ...s });
}
var Rn = gi;
var vi = (e, t, r) => {
  if (!(e && t == null)) {
    if (t.findLast) return t.findLast(r);
    for (let n = t.length - 1; n >= 0; n--) {
      let u = t[n];
      if (r(u, n, t)) return u;
    }
  }
};
var tr = vi;
function rr(e, t) {
  if (!t) throw new Error("parserName is required.");
  let r = tr(false, e, (u) => u.parsers && Object.prototype.hasOwnProperty.call(u.parsers, t));
  if (r) return r;
  let n = `Couldn't resolve parser "${t}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new Re(n);
}
function Yn(e, t) {
  if (!t) throw new Error("astFormat is required.");
  let r = tr(false, e, (u) => u.printers && Object.prototype.hasOwnProperty.call(u.printers, t));
  if (r) return r;
  let n = `Couldn't find plugin for AST format "${t}".`;
  throw n += " Plugins must be explicitly added to the standalone bundle.", new Re(n);
}
function Et({ plugins: e, parser: t }) {
  let r = rr(e, t);
  return nr(r, t);
}
function nr(e, t) {
  let r = e.parsers[t];
  return typeof r == "function" ? r() : r;
}
function jn(e, t) {
  let r = e.printers[t];
  return typeof r == "function" ? r() : r;
}
var Hn = { astFormat: "estree", printer: {}, originalText: void 0, locStart: null, locEnd: null };
async function Bi(e, t = {}) {
  var p;
  let r = { ...e };
  if (!r.parser) if (r.filepath) {
    if (r.parser = pn(r, { physicalFile: r.filepath }), !r.parser) throw new Ye(`No parser could be inferred for file "${r.filepath}".`);
  } else throw new Ye("No parser and no file path given, couldn't infer a parser.");
  let n = it({ plugins: e.plugins, showDeprecated: true }).options, u = { ...Hn, ...Object.fromEntries(n.filter((f) => f.default !== void 0).map((f) => [f.name, f.default])) }, i = rr(r.plugins, r.parser), o = await nr(i, r.parser);
  r.astFormat = o.astFormat, r.locEnd = o.locEnd, r.locStart = o.locStart;
  let s = (p = i.printers) != null && p[o.astFormat] ? i : Yn(r.plugins, o.astFormat), a = await jn(s, o.astFormat);
  r.printer = a;
  let D = s.defaultOptions ? Object.fromEntries(Object.entries(s.defaultOptions).filter(([, f]) => f !== void 0)) : {}, l = { ...u, ...D };
  for (let [f, d] of Object.entries(l)) (r[f] === null || r[f] === void 0) && (r[f] = d);
  return r.parser === "json" && (r.trailingComma = "none"), Rn(r, n, { passThrough: Object.keys(Hn), ...t });
}
var se = Bi;
var Mn = Me($n());
async function bi(e, t) {
  let r = await Et(t), n = r.preprocess ? r.preprocess(e, t) : e;
  t.originalText = n;
  let u;
  try {
    u = await r.parse(n, t, t);
  } catch (i) {
    Ni(i, e);
  }
  return { text: n, ast: u };
}
function Ni(e, t) {
  let { loc: r } = e;
  if (r) {
    let n = (0, Mn.codeFrameColumns)(t, r, { highlightCode: true });
    throw e.message += `
` + n, e.codeFrame = n, e;
  }
  throw e;
}
var fe = bi;
async function Vn(e, t, r, n, u) {
  let { embeddedLanguageFormatting: i, printer: { embed: o, hasPrettierIgnore: s = () => false, getVisitorKeys: a } } = r;
  if (!o || i !== "auto") return;
  if (o.length > 2) throw new Error("printer.embed has too many parameters. The API changed in Prettier v3. Please update your plugin. See https://prettier.io/docs/plugins#optional-embed");
  let D = q(o.getVisitorKeys ?? a), l = [];
  d();
  let p = e.stack;
  for (let { print: c, node: F, pathStack: m } of l) try {
    e.stack = m;
    let h = await c(f, t, e, r);
    h && u.set(F, h);
  } catch (h) {
    if (globalThis.PRETTIER_DEBUG) throw h;
  }
  e.stack = p;
  function f(c, F) {
    return Oi(c, F, r, n);
  }
  function d() {
    let { node: c } = e;
    if (c === null || typeof c != "object" || s(e)) return;
    for (let m of D(c)) Array.isArray(c[m]) ? e.each(d, m) : e.call(d, m);
    let F = o(e, r);
    if (F) {
      if (typeof F == "function") {
        l.push({ print: F, node: c, pathStack: [...e.stack] });
        return;
      }
      u.set(c, F);
    }
  }
}
async function Oi(e, t, r, n) {
  let u = await se({ ...r, ...t, parentParser: r.parser, originalText: e }, { passThrough: true }), { ast: i } = await fe(e, u), o = await n(i, u);
  return qe(o);
}
function Si(e, t) {
  let { originalText: r, [Symbol.for("comments")]: n, locStart: u, locEnd: i, [Symbol.for("printedComments")]: o } = t, { node: s } = e, a = u(s), D = i(s);
  for (let l of n) u(l) >= a && i(l) <= D && o.add(l);
  return r.slice(a, D);
}
var Un = Si;
async function He(e, t) {
  ({ ast: e } = await ir(e, t));
  let r = /* @__PURE__ */ new Map(), n = new qr(e), i = /* @__PURE__ */ new Map();
  await Vn(n, s, t, He, i);
  let o = await zn(n, t, s, void 0, i);
  if (ln(t), t.nodeAfterCursor && !t.nodeBeforeCursor) return [Z, o];
  if (t.nodeBeforeCursor && !t.nodeAfterCursor) return [o, Z];
  return o;
  function s(D, l) {
    return D === void 0 || D === n ? a(l) : Array.isArray(D) ? n.call(() => a(l), ...D) : n.call(() => a(l), D);
  }
  function a(D) {
    let l = n.node;
    if (l == null) return "";
    let p = l && typeof l == "object" && D === void 0;
    if (p && r.has(l)) return r.get(l);
    let f = zn(n, t, s, D, i);
    return p && r.set(l, f), f;
  }
}
function zn(e, t, r, n, u) {
  var a;
  let { node: i } = e, { printer: o } = t, s;
  switch ((a = o.hasPrettierIgnore) != null && a.call(o, e) ? s = Un(e, t) : u.has(i) ? s = u.get(i) : s = o.print(e, t, r, n), i) {
    case t.cursorNode:
      s = me(s, (D) => [Z, D, Z]);
      break;
    case t.nodeBeforeCursor:
      s = me(s, (D) => [D, Z]);
      break;
    case t.nodeAfterCursor:
      s = me(s, (D) => [Z, D]);
      break;
  }
  return o.printComment && (!o.willPrintOwnComments || !o.willPrintOwnComments(e, t)) && (s = Dn(e, s, t)), s;
}
async function ir(e, t) {
  let r = e.comments ?? [];
  t[Symbol.for("comments")] = r, t[Symbol.for("tokens")] = e.tokens ?? [], t[Symbol.for("printedComments")] = /* @__PURE__ */ new Set(), on(e, t);
  let { printer: { preprocess: n } } = t;
  return e = n ? await n(e, t) : e, { ast: e, comments: r };
}
function Ti(e, t) {
  let { cursorOffset: r, locStart: n, locEnd: u } = t, i = q(t.printer.getVisitorKeys), o = (d) => n(d) <= r && u(d) >= r, s = e, a = [e];
  for (let d of Zr(e, { getVisitorKeys: i, filter: o })) a.push(d), s = d;
  if (en(s, { getVisitorKeys: i })) return { cursorNode: s };
  let D, l, p = -1, f = Number.POSITIVE_INFINITY;
  for (; a.length > 0 && (D === void 0 || l === void 0); ) {
    s = a.pop();
    let d = D !== void 0, c = l !== void 0;
    for (let F of ye(s, { getVisitorKeys: i })) {
      if (!d) {
        let m = u(F);
        m <= r && m > p && (D = F, p = m);
      }
      if (!c) {
        let m = n(F);
        m >= r && m < f && (l = F, f = m);
      }
    }
  }
  return { nodeBeforeCursor: D, nodeAfterCursor: l };
}
var Gn = Ti;
function ki(e, t) {
  let { printer: { massageAstNode: r, getVisitorKeys: n } } = t;
  if (!r) return e;
  let u = q(n), i = r.ignoredProperties ?? /* @__PURE__ */ new Set();
  return o(e);
  function o(s, a) {
    if (!(s !== null && typeof s == "object")) return s;
    if (Array.isArray(s)) return s.map((f) => o(f, a)).filter(Boolean);
    let D = {}, l = new Set(u(s));
    for (let f in s) !Object.prototype.hasOwnProperty.call(s, f) || i.has(f) || (l.has(f) ? D[f] = o(s[f], s) : D[f] = s[f]);
    let p = r(s, D, a);
    if (p !== null) return p ?? D;
  }
}
var Kn = ki;
var Li = (e, t, r) => {
  if (!(e && t == null)) {
    if (t.findLastIndex) return t.findLastIndex(r);
    for (let n = t.length - 1; n >= 0; n--) {
      let u = t[n];
      if (r(u, n, t)) return n;
    }
    return -1;
  }
};
var Jn = Li;
var Pi = ({ parser: e }) => e === "json" || e === "json5" || e === "jsonc" || e === "json-stringify";
function Ii(e, t) {
  let r = [e.node, ...e.parentNodes], n = /* @__PURE__ */ new Set([t.node, ...t.parentNodes]);
  return r.find((u) => Qn.has(u.type) && n.has(u));
}
function qn(e) {
  let t = Jn(false, e, (r) => r.type !== "Program" && r.type !== "File");
  return t === -1 ? e : e.slice(0, t + 1);
}
function Ri(e, t, { locStart: r, locEnd: n }) {
  let u = e.node, i = t.node;
  if (u === i) return { startNode: u, endNode: i };
  let o = r(e.node);
  for (let a of qn(t.parentNodes)) if (r(a) >= o) i = a;
  else break;
  let s = n(t.node);
  for (let a of qn(e.parentNodes)) {
    if (n(a) <= s) u = a;
    else break;
    if (u === i) break;
  }
  return { startNode: u, endNode: i };
}
function or(e, t, r, n, u = [], i) {
  let { locStart: o, locEnd: s } = r, a = o(e), D = s(e);
  if (!(t > D || t < a || i === "rangeEnd" && t === a || i === "rangeStart" && t === D)) {
    for (let l of ut(e, r)) {
      let p = or(l, t, r, n, [e, ...u], i);
      if (p) return p;
    }
    if (!n || n(e, u[0])) return { node: e, parentNodes: u };
  }
}
function Yi(e, t) {
  return t !== "DeclareExportDeclaration" && e !== "TypeParameterDeclaration" && (e === "Directive" || e === "TypeAlias" || e === "TSExportAssignment" || e.startsWith("Declare") || e.startsWith("TSDeclare") || e.endsWith("Statement") || e.endsWith("Declaration"));
}
var Qn = /* @__PURE__ */ new Set(["JsonRoot", "ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral", "UnaryExpression", "TemplateLiteral"]);
var ji = /* @__PURE__ */ new Set(["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"]);
function Xn(e, t, r) {
  if (!t) return false;
  switch (e.parser) {
    case "flow":
    case "babel":
    case "babel-flow":
    case "babel-ts":
    case "typescript":
    case "acorn":
    case "espree":
    case "meriyah":
    case "__babel_estree":
      return Yi(t.type, r == null ? void 0 : r.type);
    case "json":
    case "json5":
    case "jsonc":
    case "json-stringify":
      return Qn.has(t.type);
    case "graphql":
      return ji.has(t.kind);
    case "vue":
      return t.tag !== "root";
  }
  return false;
}
function Zn(e, t, r) {
  let { rangeStart: n, rangeEnd: u, locStart: i, locEnd: o } = t;
  Pe.ok(u > n);
  let s = e.slice(n, u).search(/\S/u), a = s === -1;
  if (!a) for (n += s; u > n && !/\S/u.test(e[u - 1]); --u) ;
  let D = or(r, n, t, (d, c) => Xn(t, d, c), [], "rangeStart"), l = a ? D : or(r, u, t, (d) => Xn(t, d), [], "rangeEnd");
  if (!D || !l) return { rangeStart: 0, rangeEnd: 0 };
  let p, f;
  if (Pi(t)) {
    let d = Ii(D, l);
    p = d, f = d;
  } else ({ startNode: p, endNode: f } = Ri(D, l, t));
  return { rangeStart: Math.min(i(p), i(f)), rangeEnd: Math.max(o(p), o(f)) };
}
var nu = "\uFEFF";
var eu = Symbol("cursor");
async function uu(e, t, r = 0) {
  if (!e || e.trim().length === 0) return { formatted: "", cursorOffset: -1, comments: [] };
  let { ast: n, text: u } = await fe(e, t);
  t.cursorOffset >= 0 && (t = { ...t, ...Gn(n, t) });
  let i = await He(n, t);
  r > 0 && (i = Ze([K, i], r, t.tabWidth));
  let o = Ce(i, t);
  if (r > 0) {
    let a = o.formatted.trim();
    o.cursorNodeStart !== void 0 && (o.cursorNodeStart -= o.formatted.indexOf(a), o.cursorNodeStart < 0 && (o.cursorNodeStart = 0, o.cursorNodeText = o.cursorNodeText.trimStart()), o.cursorNodeStart + o.cursorNodeText.length > a.length && (o.cursorNodeText = o.cursorNodeText.trimEnd())), o.formatted = a + be(t.endOfLine);
  }
  let s = t[Symbol.for("comments")];
  if (t.cursorOffset >= 0) {
    let a, D, l, p;
    if ((t.cursorNode || t.nodeBeforeCursor || t.nodeAfterCursor) && o.cursorNodeText) if (l = o.cursorNodeStart, p = o.cursorNodeText, t.cursorNode) a = t.locStart(t.cursorNode), D = u.slice(a, t.locEnd(t.cursorNode));
    else {
      if (!t.nodeBeforeCursor && !t.nodeAfterCursor) throw new Error("Cursor location must contain at least one of cursorNode, nodeBeforeCursor, nodeAfterCursor");
      a = t.nodeBeforeCursor ? t.locEnd(t.nodeBeforeCursor) : 0;
      let h = t.nodeAfterCursor ? t.locStart(t.nodeAfterCursor) : u.length;
      D = u.slice(a, h);
    }
    else a = 0, D = u, l = 0, p = o.formatted;
    let f = t.cursorOffset - a;
    if (D === p) return { formatted: o.formatted, cursorOffset: l + f, comments: s };
    let d = D.split("");
    d.splice(f, 0, eu);
    let c = p.split(""), F = yr(d, c), m = l;
    for (let h of F) if (h.removed) {
      if (h.value.includes(eu)) break;
    } else m += h.count;
    return { formatted: o.formatted, cursorOffset: m, comments: s };
  }
  return { formatted: o.formatted, cursorOffset: -1, comments: s };
}
async function Hi(e, t) {
  let { ast: r, text: n } = await fe(e, t), { rangeStart: u, rangeEnd: i } = Zn(n, t, r), o = n.slice(u, i), s = Math.min(u, n.lastIndexOf(`
`, u) + 1), a = n.slice(s, u).match(/^\s*/u)[0], D = ge(a, t.tabWidth), l = await uu(o, { ...t, rangeStart: 0, rangeEnd: Number.POSITIVE_INFINITY, cursorOffset: t.cursorOffset > u && t.cursorOffset <= i ? t.cursorOffset - u : -1, endOfLine: "lf" }, D), p = l.formatted.trimEnd(), { cursorOffset: f } = t;
  f > i ? f += p.length - o.length : l.cursorOffset >= 0 && (f = l.cursorOffset + u);
  let d = n.slice(0, u) + p + n.slice(i);
  if (t.endOfLine !== "lf") {
    let c = be(t.endOfLine);
    f >= 0 && c === `\r
` && (f += Nt(d.slice(0, f), `
`)), d = ne(false, d, `
`, c);
  }
  return { formatted: d, cursorOffset: f, comments: l.comments };
}
function sr(e, t, r) {
  return typeof t != "number" || Number.isNaN(t) || t < 0 || t > e.length ? r : t;
}
function tu(e, t) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u } = t;
  return r = sr(e, r, -1), n = sr(e, n, 0), u = sr(e, u, e.length), { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u };
}
function iu(e, t) {
  let { cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i } = tu(e, t), o = e.charAt(0) === nu;
  if (o && (e = e.slice(1), r--, n--, u--), i === "auto" && (i = Ar(e)), e.includes("\r")) {
    let s = (a) => Nt(e.slice(0, Math.max(a, 0)), `\r
`);
    r -= s(r), n -= s(n), u -= s(u), e = vr(e);
  }
  return { hasBOM: o, text: e, options: tu(e, { ...t, cursorOffset: r, rangeStart: n, rangeEnd: u, endOfLine: i }) };
}
async function ru(e, t) {
  let r = await Et(t);
  return !r.hasPragma || r.hasPragma(e);
}
async function ar(e, t) {
  let { hasBOM: r, text: n, options: u } = iu(e, await se(t));
  if (u.rangeStart >= u.rangeEnd && n !== "" || u.requirePragma && !await ru(n, u)) return { formatted: e, cursorOffset: t.cursorOffset, comments: [] };
  let i;
  return u.rangeStart > 0 || u.rangeEnd < n.length ? i = await Hi(n, u) : (!u.requirePragma && u.insertPragma && u.printer.insertPragma && !await ru(n, u) && (n = u.printer.insertPragma(n)), i = await uu(n, u)), r && (i.formatted = nu + i.formatted, i.cursorOffset >= 0 && i.cursorOffset++), i;
}
async function ou(e, t, r) {
  let { text: n, options: u } = iu(e, await se(t)), i = await fe(n, u);
  return r && (r.preprocessForPrint && (i.ast = await ir(i.ast, u)), r.massage && (i.ast = Kn(i.ast, u))), i;
}
async function su(e, t) {
  t = await se(t);
  let r = await He(e, t);
  return Ce(r, t);
}
async function au(e, t) {
  let r = Vr(e), { formatted: n } = await ar(r, { ...t, parser: "__js_expression" });
  return n;
}
async function Du(e, t) {
  t = await se(t);
  let { ast: r } = await fe(e, t);
  return He(r, t);
}
async function lu(e, t) {
  return Ce(e, await se(t));
}
var Dr = {};
vt(Dr, { builders: () => $i, printer: () => Mi, utils: () => Vi });
var $i = { join: Se, line: Qe, softline: $r, hardline: K, literalline: Xe, group: kt, conditionalGroup: Ir, fill: Rr, lineSuffix: Te, lineSuffixBoundary: Hr, cursor: Z, breakParent: he, ifBreak: Yr, trim: Wr, indent: le, indentIfBreak: jr, align: De, addAlignmentToDoc: Ze, markAsRoot: Lr, dedentToRoot: kr, dedent: Pr, hardlineWithoutBreakParent: ke, literallineWithoutBreakParent: Lt, label: Mr, concat: (e) => e };
var Mi = { printDocToString: Ce };
var Vi = { willBreak: xr, traverseDoc: Fe, findInDoc: Je, mapDoc: Oe, removeLines: Nr, stripTrailingHardline: qe, replaceEndOfLine: Or, canBreak: Sr };
var cu = "3.5.3";
var cr = {};
vt(cr, { addDanglingComment: () => re, addLeadingComment: () => ue, addTrailingComment: () => ie, getAlignmentSize: () => ge, getIndentSize: () => fu, getMaxContinuousCount: () => du, getNextNonSpaceNonCommentCharacter: () => pu, getNextNonSpaceNonCommentCharacterIndex: () => no, getPreferredQuote: () => mu, getStringWidth: () => Le, hasNewline: () => V, hasNewlineInRange: () => hu, hasSpaces: () => Eu, isNextLineEmpty: () => so, isNextLineEmptyAfterIndex: () => Ct, isPreviousLineEmpty: () => io, makeString: () => Cu, skip: () => Ae, skipEverythingButNewLine: () => nt, skipInlineComment: () => Be, skipNewline: () => W, skipSpaces: () => S, skipToLineEnd: () => rt, skipTrailingComment: () => we, skipWhitespace: () => tn });
function Ui(e, t) {
  if (t === false) return false;
  if (e.charAt(t) === "/" && e.charAt(t + 1) === "*") {
    for (let r = t + 2; r < e.length; ++r) if (e.charAt(r) === "*" && e.charAt(r + 1) === "/") return r + 2;
  }
  return t;
}
var Be = Ui;
function zi(e, t) {
  return t === false ? false : e.charAt(t) === "/" && e.charAt(t + 1) === "/" ? nt(e, t) : t;
}
var we = zi;
function Gi(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = S(e, n), n = Be(e, n), n = we(e, n), n = W(e, n);
  return n;
}
var We = Gi;
function Ki(e, t) {
  let r = null, n = t;
  for (; n !== r; ) r = n, n = rt(e, n), n = Be(e, n), n = S(e, n);
  return n = we(e, n), n = W(e, n), n !== false && V(e, n);
}
var Ct = Ki;
function Ji(e, t) {
  let r = e.lastIndexOf(`
`);
  return r === -1 ? 0 : ge(e.slice(r + 1).match(/^[\t ]*/u)[0], t);
}
var fu = Ji;
function lr(e) {
  if (typeof e != "string") throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function qi(e, t) {
  let r = e.match(new RegExp(`(${lr(t)})+`, "gu"));
  return r === null ? 0 : r.reduce((n, u) => Math.max(n, u.length / t.length), 0);
}
var du = qi;
function Xi(e, t) {
  let r = We(e, t);
  return r === false ? "" : e.charAt(r);
}
var pu = Xi;
var gt = "'";
var Fu = '"';
function Qi(e, t) {
  let r = t === true || t === gt ? gt : Fu, n = r === gt ? Fu : gt, u = 0, i = 0;
  for (let o of e) o === r ? u++ : o === n && i++;
  return u > i ? n : r;
}
var mu = Qi;
function Zi(e, t, r) {
  for (let n = t; n < r; ++n) if (e.charAt(n) === `
`) return true;
  return false;
}
var hu = Zi;
function eo(e, t, r = {}) {
  return S(e, r.backwards ? t - 1 : t, r) !== t;
}
var Eu = eo;
function to(e, t, r) {
  let n = t === '"' ? "'" : '"', i = ne(false, e, /\\(.)|(["'])/gsu, (o, s, a) => s === n ? s : a === t ? "\\" + a : a || (r && /^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/u.test(s) ? s : "\\" + s));
  return t + i + t;
}
var Cu = to;
function ro(e, t, r) {
  return We(e, r(t));
}
function no(e, t) {
  return arguments.length === 2 || typeof t == "number" ? We(e, t) : ro(...arguments);
}
function uo(e, t, r) {
  return Ie(e, r(t));
}
function io(e, t) {
  return arguments.length === 2 || typeof t == "number" ? Ie(e, t) : uo(...arguments);
}
function oo(e, t, r) {
  return Ct(e, r(t));
}
function so(e, t) {
  return arguments.length === 2 || typeof t == "number" ? Ct(e, t) : oo(...arguments);
}
function de(e, t = 1) {
  return async (...r) => {
    let n = r[t] ?? {}, u = n.plugins ?? [];
    return r[t] = { ...n, plugins: Array.isArray(u) ? u : Object.values(u) }, e(...r);
  };
}
var gu = de(ar);
async function yu(e, t) {
  let { formatted: r } = await gu(e, { ...t, cursorOffset: -1 });
  return r;
}
async function ao(e, t) {
  return await yu(e, t) === e;
}
var Do = de(it, 0);
var lo = { parse: de(ou), formatAST: de(su), formatDoc: de(au), printToDoc: de(Du), printDocToString: de(lu) };

// node_modules/@bgd-labs/toolbox/dist/index.mjs
__toESM(require_standalone2(), 1);
var ChainId = {
  celo: celo.id,
  mainnet: mainnet.id,
  polygon: polygon.id,
  polygon_amoy: polygonAmoy.id,
  avalanche: avalanche.id,
  avalanche_fuji: avalancheFuji.id,
  arbitrum: arbitrum.id,
  arbitrum_sepolia: arbitrumSepolia.id,
  fantom: fantom.id,
  fantom_testnet: fantomTestnet.id,
  optimism: optimism.id,
  optimism_sepolia: optimismSepolia.id,
  harmony: harmonyOne.id,
  sepolia: sepolia.id,
  scroll: scroll.id,
  scroll_sepolia: scrollSepolia.id,
  sonic: sonic.id,
  mantle: mantle.id,
  metis: metis.id,
  base: base.id,
  base_sepolia: baseSepolia.id,
  bnb: bsc.id,
  gnosis: gnosis.id,
  zkEVM: polygonZkEvm.id,
  zksync: zksync.id,
  linea: linea.id
};
var alechmyNetworkMap = {
  1: "eth-mainnet",
  10: "opt-mainnet",
  30: "rootstock-mainnet",
  31: "rootstock-testnet",
  56: "bnb-mainnet",
  97: "bnb-testnet",
  100: "gnosis-mainnet",
  130: "unichain-mainnet",
  137: "polygon-mainnet",
  146: "sonic-mainnet",
  204: "opbnb-mainnet",
  250: "fantom-mainnet",
  252: "frax-mainnet",
  300: "zksync-sepolia",
  324: "zksync-mainnet",
  360: "shape-mainnet",
  480: "worldchain-mainnet",
  545: "flow-testnet",
  592: "astar-mainnet",
  747: "flow-mainnet",
  1088: "metis-mainnet",
  1101: "polygonzkevm-mainnet",
  1301: "unichain-sepolia",
  1328: "sei-testnet",
  1329: "sei-mainnet",
  1868: "soneium-mainnet",
  1946: "soneium-minato",
  2020: "ronin-mainnet",
  2021: "ronin-saigon",
  2442: "polygonzkevm-cardona",
  2522: "frax-sepolia",
  2741: "abstract-mainnet",
  4002: "fantom-testnet",
  4157: "crossfi-testnet",
  4158: "crossfi-mainnet",
  4801: "worldchain-sepolia",
  5e3: "mantle-mainnet",
  5003: "mantle-sepolia",
  5373: "settlus-septestnet",
  5611: "opbnb-testnet",
  7e3: "zetachain-mainnet",
  7001: "zetachain-testnet",
  8008: "polynomial-mainnet",
  8009: "polynomial-sepolia",
  8453: "base-mainnet",
  10143: "monad-testnet",
  10200: "gnosis-chiado",
  11011: "shape-sepolia",
  11124: "abstract-testnet",
  17e3: "eth-holesky",
  33111: "apechain-curtis",
  33139: "apechain-mainnet",
  37111: "lens-sepolia",
  42161: "arb-mainnet",
  42170: "arbnova-mainnet",
  43113: "avax-fuji",
  43114: "avax-mainnet",
  57054: "sonic-blaze",
  57073: "ink-mainnet",
  59141: "linea-sepolia",
  59144: "linea-mainnet",
  63157: "geist-mainnet",
  80002: "polygon-amoy",
  80094: "berachain-mainnet",
  81457: "blast-mainnet",
  84532: "base-sepolia",
  421614: "arb-sepolia",
  534351: "scroll-sepolia",
  534352: "scroll-mainnet",
  631571: "geist-polter",
  763373: "ink-sepolia",
  7777777: "zora-mainnet",
  11155111: "eth-sepolia",
  11155420: "opt-sepolia",
  168587773: "blast-sepolia",
  241320161: "xmtp-testnet",
  666666666: "degen-mainnet",
  994873017: "lumia-prism",
  999999999: "zora-sepolia",
  1952959480: "lumia-testnet"
};
var quicknodeNetworkMap = {
  1: "mainnet",
  10: "optimism",
  14: "flare-mainnet",
  56: "bsc",
  81: "joc-mainnet",
  97: "bsc-testnet",
  100: "xdai",
  114: "flare-coston2",
  130: "unichain-mainnet",
  137: "matic",
  164: "omni-omega",
  166: "omni-mainnet",
  250: "fantom",
  252: "fraxtal-mainnet",
  295: "hedera-mainnet",
  296: "hedera-testnet",
  300: "zksync-sepolia",
  324: "zksync-mainnet",
  480: "worldchain-mainnet",
  545: "flow-testnet",
  690: "redstone-mainnet",
  747: "flow-mainnet",
  1001: "kaia-kairos",
  1101: "zkevm-mainnet",
  1135: "lisk-mainnet",
  1301: "unichain-sepolia",
  1315: "story-aeneid",
  1328: "sei-atlantic",
  1329: "sei-pacific",
  1480: "vana-mainnet",
  1513: "story-testnet",
  1516: "story-odyssey",
  1993: "b3-sepolia",
  2442: "zkevm-cardona",
  2741: "abstract-mainnet",
  2810: "morph-holesky",
  2818: "morph-mainnet",
  3338: "peaq-mainnet",
  4801: "worldchain-sepolia",
  5e3: "mantle-mainnet",
  5003: "mantle-sepolia",
  6805: "race-mainnet",
  6806: "race-sepolia",
  7560: "cyber-mainnet",
  8217: "kaia-mainnet",
  8333: "b3-mainnet",
  8453: "base-mainnet",
  11124: "abstract-testnet",
  13371: "imx-mainnet",
  13473: "imx-testnet",
  14800: "vana-moksha",
  16600: "0g-newton",
  17e3: "ethereum-holesky",
  34443: "mode-mainnet",
  42161: "arbitrum-mainnet",
  42170: "nova-mainnet",
  42220: "celo-mainnet",
  43113: "avalanche-testnet",
  43114: "avalanche-mainnet",
  59144: "linea-mainnet",
  80002: "matic-amoy",
  80084: "bera-bartio",
  80085: "bera-artio",
  80094: "bera-mainnet",
  81457: "blast-mainnet",
  84532: "base-sepolia",
  421613: "arbitrum-goerli",
  421614: "arbitrum-sepolia",
  534351: "scroll-testnet",
  534352: "scroll-mainnet",
  660279: "xai-mainnet",
  763373: "ink-sepolia",
  7777777: "zora-mainnet",
  11155111: "ethereum-sepolia",
  11155420: "optimism-sepolia",
  111557560: "cyber-sepolia",
  168587773: "blast-sepolia",
  37714555429: "xai-testnet"
};
var publicRPCs = {
  [ChainId.mainnet]: "https://eth.llamarpc.com",
  [ChainId.polygon]: "https://polygon.llamarpc.com",
  [ChainId.arbitrum]: "https://polygon.llamarpc.com",
  [ChainId.base]: "https://base.llamarpc.com",
  [ChainId.bnb]: "https://binance.llamarpc.com",
  [ChainId.metis]: "https://andromeda.metis.io/?owner=1088",
  [ChainId.gnosis]: "https://rpc.ankr.com/gnosis",
  [ChainId.scroll]: "https://rpc.scroll.io",
  [ChainId.zksync]: "https://mainnet.era.zksync.io",
  [ChainId.fantom]: "https://rpc.ftm.tools",
  [ChainId.avalanche]: "https://api.avax.network/ext/bc/C/rpc",
  [ChainId.linea]: "https://rpc.linea.build"
};
Object.values(ChainId).filter(
  (id) => alechmyNetworkMap[id]
);
var getNetworkEnv = (chainId) => {
  const symbol = Object.entries(ChainId).find(
    ([, value]) => value === chainId
  )?.[0];
  if (!symbol) {
    throw new Error(
      `Didn't find a viem symbol for chainId: ${chainId}. Wire it up in 'src/chainIds.ts'!`
    );
  }
  const env = `RPC_${symbol.toUpperCase()}`;
  return env;
};
function getExplicitRPC(chainId) {
  const env = getNetworkEnv(chainId);
  if (process.env[env]) {
    return process.env[env];
  }
  throw new Error(`Env '${env}' is not set. Please set it manually.`);
}
function getAlchemyRPC(chainId, alchemyKey2) {
  const alchemyId = alechmyNetworkMap[chainId];
  if (!alchemyId) {
    throw new Error(`ChainId '${chainId}' is not supported by Alchemy.`);
  }
  if (!alchemyKey2) {
    throw new Error(
      `ChainId '${chainId}' is supported by Alchemy, but no 'alchemyKey' was provided.`
    );
  }
  return `https://${alchemyId}.g.alchemy.com/v2/${alchemyKey2}`;
}
function getPublicRpc(chainId) {
  const publicRpc = publicRPCs[chainId];
  if (!publicRpc)
    throw new Error(`No default public rpc for '${chainId}' configured.`);
  return publicRpc;
}
function getQuickNodeRpc(chainId, options) {
  const quickNodeSlug = quicknodeNetworkMap[chainId];
  if (!quickNodeSlug) {
    throw new Error(`ChainId '${chainId}' is not supported by Quicknode.`);
  }
  if (!options.quicknodeEndpointName) {
    throw new Error(
      `ChainId '${chainId}' is supported by Quicknode, but no 'quicknodeEndpointName' was provided.`
    );
  }
  if (!options.quicknodeToken) {
    throw new Error(
      `ChainId '${chainId}' is supported by Quicknode, but no 'quicknodeToken' was provided.`
    );
  }
  if (chainId === ChainId.mainnet) {
    return `https://${options.quicknodeEndpointName}.quiknode.pro/${options.quicknodeToken}`;
  }
  return `https://${options.quicknodeEndpointName}.${quickNodeSlug}.quiknode.pro/${options.quicknodeToken}`;
}
var getRPCUrl = (chainId, options) => {
  if (!Object.values(ChainId).includes(chainId)) {
    throw new Error(
      `ChainId '${chainId}' is not supported by this library. Feel free to open an issue.`
    );
  }
  try {
    return getExplicitRPC(chainId);
  } catch (e) {
  }
  if (options?.alchemyKey) {
    try {
      return getAlchemyRPC(chainId, options?.alchemyKey);
    } catch (e) {
    }
  }
  if (options?.quicknodeEndpointName && options.quicknodeToken) {
    try {
      return getQuickNodeRpc(chainId, {
        quicknodeToken: options.quicknodeToken,
        quicknodeEndpointName: options.quicknodeEndpointName
      });
    } catch (e) {
    }
  }
  try {
    return getPublicRpc(chainId);
  } catch (e) {
  }
};

// src/action.ts
var alchemyKey = (0, import_core.getInput)("ALCHEMY_API_KEY") !== "" ? (0, import_core.getInput)("ALCHEMY_API_KEY") : void 0;
var quicknodeToken = (0, import_core.getInput)("QUICKNODE_TOKEN") !== "" ? (0, import_core.getInput)("QUICKNODE_TOKEN") : "5196b99cdae04535ecd62906c3b618876686618a";
var quicknodeEndpointName = (0, import_core.getInput)("QUICKNODE_ENDPOINT_NAME") !== "" ? (0, import_core.getInput)("QUICKNODE_ENDPOINT_NAME") : "quaint-still-liquid";
for (const chainId of Object.values(ChainId)) {
  const envVarName = getNetworkEnv(chainId);
  (0, import_core.debug)(`Setting ${envVarName}`);
  (0, import_core.exportVariable)(
    envVarName,
    getRPCUrl(chainId, { alchemyKey, quicknodeToken, quicknodeEndpointName })
  );
}
/*! Bundled license information:

undici/lib/fetch/body.js:
  (*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> *)

undici/lib/websocket/frame.js:
  (*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
